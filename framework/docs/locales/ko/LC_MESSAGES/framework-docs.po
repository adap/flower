# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024 Flower Labs GmbH
# This file is distributed under the same license as the Flower package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: Flower main\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-21 00:08+0000\n"
"PO-Revision-Date: 2024-08-23 13:09+0000\n"
"Last-Translator: Seulki Yun <icstuckyi@gmail.com>\n"
"Language: ko\n"
"Language-Team: Korean <https://hosted.weblate.org/projects/flower-"
"docs/framework/ko/>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/build.rst:-1
msgid ""
"Learn how to build Flower apps with step-by-step guides on installation, "
"configuration, strategy implementation, model checkpoints, and more."
msgstr ""

#: ../../source/build.rst:7
#, fuzzy
msgid "Build Flower apps"
msgstr "Flower 서버."

#: ../../source/build.rst:11 ../../source/contribute.rst:27
#: ../../source/deploy.rst:11 ../../source/simulate.rst:11
msgid "How-to guides"
msgstr "사용 방법 가이드"

#: ../../source/build.rst:13 ../../source/contribute.rst:29
#: ../../source/deploy.rst:13 ../../source/index.rst:76
#: ../../source/simulate.rst:13
msgid ""
"Problem-oriented how-to guides show step-by-step how to achieve a "
"specific goal."
msgstr "문제 중심의 방법 가이드는 특정 목표를 달성하는 방법을 단계별로 보여줍니다."

#: ../../source/contribute.rst:18
msgid "Contributor tutorials"
msgstr "기여자 튜토리얼"

#: ../../source/contribute.rst:49
msgid "Contributor explanations"
msgstr "기여자 설명"

#: ../../source/contribute.rst:61
msgid "Contributor references"
msgstr "기여자 참조"

#: ../../source/contribute.rst:-1
msgid ""
"Join the Flower community! Explore tutorials and guides to contribute "
"code, documentation, translations, and more to advance federated learning"
" with Flower."
msgstr ""

#: ../../source/contribute.rst:7 ../../source/index.rst:112
#: ../../source/index.rst:117
#, fuzzy
msgid "Contribute"
msgstr "속성"

#: ../../source/contribute.rst:9 ../../source/index.rst:114
msgid ""
"The Flower community welcomes contributions. The following docs are "
"intended to help along the way."
msgstr "Flower 커뮤니티는 여러분의 기여를 환영합니다. 다음 문서는 그 과정에서 도움을 드리기 위한 문서입니다."

#: ../../source/contribute.rst:14 ../../source/index.rst:33
msgid "Tutorials"
msgstr "튜토리얼"

#: ../../source/contribute.rst:16
#, fuzzy
msgid "A learning-oriented series of tutorials, the best place to start."
msgstr "학습 중심의 연합 학습 튜토리얼 시리즈로, 시작하기에 가장 좋은 곳입니다."

#: ../../source/contribute.rst:44 ../../source/index.rst:87
#: ../../source/index.rst:92
msgid "Explanations"
msgstr "설명"

#: ../../source/contribute.rst:46 ../../source/index.rst:89
msgid ""
"Understanding-oriented concept guides explain and discuss key topics and "
"underlying ideas behind Flower and collaborative AI."
msgstr "이해 중심의 개념 가이드에서는 Flower와 협업 AI의 주요 주제와 기본 아이디어를 설명하고 토론합니다."

#: ../../source/contribute.rst:57
#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:365
#: ../../source/index.rst:102 ../../source/index.rst:104
#: ../../source/reference.rst:7
msgid "References"
msgstr "참조"

#: ../../source/contribute.rst:59 ../../source/reference.rst:9
msgid "Information-oriented API reference and other reference material."
msgstr "정보 지향 API 참조 및 기타 참고 자료."

#: ../../source/contributor-explanation-public-and-private-apis.rst:3
msgid "Public and private APIs"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:5
msgid ""
"In Python, everything is public. To enable developers to understand which"
" components can be relied upon, Flower declares a public API. Components "
"that are part of the public API can be relied upon. Changes to the public"
" API are announced in the release notes and are subject to deprecation "
"policies."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:10
msgid ""
"Everything that is not part of the public API is part of the private API."
" Even though Python allows accessing them, user code should never use "
"those components. Private APIs can change at any time, even in patch "
"releases."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:14
msgid ""
"How can you determine whether a component is part of the public API or "
"not? Easy:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:16
msgid "`Use the Flower API reference documentation <ref-api/flwr.html>`_"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:17
msgid "`Use the Flower CLI reference documentation <ref-api-cli.html>`_"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:19
msgid ""
"Everything listed in the reference documentation is part of the public "
"API. This document explains how Flower maintainers define the public API "
"and how you can determine whether a component is part of the public API "
"or not by reading the Flower source code."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:25
#, fuzzy
msgid "Flower public API"
msgstr "Flower ClientApp."

#: ../../source/contributor-explanation-public-and-private-apis.rst:27
msgid "Flower has a well-defined public API. Let's look at this in more detail."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:31
msgid ""
"Every component that is reachable by recursively following "
"``__init__.__all__`` starting from the root package (``flwr``) is part of"
" the public API."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:34
msgid ""
"If you want to determine whether a component "
"(class/function/generator/...) is part of the public API or not, you need"
" to start at the root of the ``flwr`` package. Let's use ``tree -L 1 -d "
"src/py/flwr`` to look at the Python sub-packages contained ``flwr``:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:48
msgid ""
"Contrast this with the definition of ``__all__`` in the root "
"``src/py/flwr/__init__.py``:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:61
msgid ""
"You can see that ``flwr`` has six subpackages (``cli``, ``client``, "
"``common``, ``proto``, ``server``, ``simulation``), but only four of them"
" are \"exported\" via ``__all__`` (``client``, ``common``, ``server``, "
"``simulation``)."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:65
msgid ""
"What does this mean? It means that ``client``, ``common``, ``server`` and"
" ``simulation`` are part of the public API, but ``cli`` and ``proto`` are"
" not. The ``flwr`` subpackages ``cli`` and ``proto`` are private APIs. A "
"private API can change completely from one release to the next (even in "
"patch releases). It can change in a breaking way, it can be renamed (for "
"example, ``flwr.cli`` could be renamed to ``flwr.command``) and it can "
"even be removed completely."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:72
msgid "Therefore, as a Flower user:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:74
msgid "``from flwr import client`` ✅ Ok, you're importing a public API."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:75
msgid ""
"``from flwr import proto`` ❌ Not recommended, you're importing a private "
"API."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:77
msgid ""
"What about components that are nested deeper in the hierarchy? Let's look"
" at Flower strategies to see another typical pattern. Flower strategies "
"like ``FedAvg`` are often imported using ``from flwr.server.strategy "
"import FedAvg``. Let's look at "
"``src/py/flwr/server/strategy/__init__.py``:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:93
msgid ""
"What's notable here is that all strategies are implemented in dedicated "
"modules (e.g., ``fedavg.py``). In ``__init__.py``, we *import* the "
"components we want to make part of the public API and then *export* them "
"via ``__all__``. Note that we export the component itself (for example, "
"the ``FedAvg`` class), but not the module it is defined in (for example, "
"``fedavg.py``). This allows us to move the definition of ``FedAvg`` into "
"a different module (or even a module in a subpackage) without breaking "
"the public API (as long as we update the import path in ``__init__.py``)."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:101
msgid "Therefore:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:103
msgid ""
"``from flwr.server.strategy import FedAvg`` ✅ Ok, you're importing a "
"class that is part of the public API."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:105
msgid ""
"``from flwr.server.strategy import fedavg`` ❌ Not recommended, you're "
"importing a private module."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:108
msgid ""
"This approach is also implemented in the tooling that automatically "
"builds API reference docs."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:113
msgid "Flower public API of private packages"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:115
msgid ""
"We also use this to define the public API of private subpackages. Public,"
" in this context, means the API that other ``flwr`` subpackages should "
"use. For example, ``flwr.server.grid`` is a private subpackage (it's not "
"exported via ``src/py/flwr/server/__init__.py``'s ``__all__``)."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:120
msgid ""
"Still, the private sub-package ``flwr.server.grid`` defines a \"public\" "
"API using ``__all__`` in ``src/py/flwr/server/grid/__init__.py``:"
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:136
msgid ""
"The interesting part is that both ``GrpcGrid`` and ``InMemoryGrid`` are "
"never used by Flower framework users, only by other parts of the Flower "
"framework codebase. Those other parts of the codebase import, for "
"example, ``InMemoryGrid`` using ``from flwr.server.driver import "
"InMemoryGrid`` (i.e., the ``InMemoryGrid`` exported via ``__all__``), not"
" ``from flwr.server.driver.in_memory_driver import InMemoryGrid`` "
"(``in_memory_driver.py`` is the module containing the actual "
"``InMemoryGrid`` class definition)."
msgstr ""

#: ../../source/contributor-explanation-public-and-private-apis.rst:144
msgid ""
"This is because ``flwr.server.driver`` defines a public interface for "
"other ``flwr`` subpackages. This allows codeowners of "
"``flwr.server.driver`` to refactor the package without breaking other "
"``flwr``-internal users."
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:3
#, fuzzy
msgid "How to Build Docker Flower Images Locally"
msgstr "Docker Flower 이미지를 Locally 구축하는 방법"

#: ../../source/contributor-how-to-build-docker-images.rst:5
msgid ""
"Flower provides pre-made docker images on `Docker Hub "
"<https://hub.docker.com/u/flwr>`_ that include all necessary dependencies"
" for running the SuperLink, SuperNode or ServerApp. You can also build "
"your own custom docker images from scratch with a different version of "
"Python or Linux distribution (Ubuntu/Alpine) if that is what you need. In"
" this guide, we will explain what images exist and how to build them "
"locally."
msgstr ""
"Flower는 'Docker Hub <https://hub.docker.com/u/flwr>'_에서 미리 만들어진 Docker "
"이미지들을 제공합니다. 해당 이미지들은 SuperLink, ServerNode 또는 ServerApp을 실행하는 데 필요한 모든 "
"dependencies를 포함합니다. 필요한 경우 다른 버전의 Python이나 Linux 배포판(Ubuntu/Alpine)을 사용해"
" 처음부터 사용자 정의 Docker 이미지를 빌드할 수도 있습니다. 이 가이드에서는 존재하는 이미지들과 이들을 로컬에서 빌드하는 "
"방법에 대해 설명하겠습니다."

#: ../../source/contributor-how-to-build-docker-images.rst:11
msgid ""
"Before we can start, we need to meet a few prerequisites in our local "
"development environment."
msgstr "시작하기 전에, 로컬 개발 환경에서 몇 가지 전제 조건을 충족해야 합니다."

#: ../../source/contributor-how-to-build-docker-images.rst:14
#, fuzzy
msgid "Clone the ``flower`` repository."
msgstr "플라워 레포지토리를 클론합니다."

#: ../../source/contributor-how-to-build-docker-images.rst:20
msgid "Verify the Docker daemon is running."
msgstr "Docker 데몬이 실행 중인지 확인하십시오."

#: ../../source/contributor-how-to-build-docker-images.rst:22
#, fuzzy
msgid ""
"The build instructions that assemble the images are located in the "
"respective Dockerfiles. You can find them in the subdirectories of "
"``framework/docker``."
msgstr ""
"이미지들을 조합하는 빌드 명령어들은 해당 Dockerfile에 있습니다. \"src/docker\" 의 하위 디렉토리에서 찾을 수 "
"있습니다."

#: ../../source/contributor-how-to-build-docker-images.rst:25
msgid ""
"Flower Docker images are configured via build arguments. Through build "
"arguments, we can make the creation of images more flexible. For example,"
" in the base image, we can specify the version of Python to install using"
" the ``PYTHON_VERSION`` build argument. Some of the build arguments have "
"default values, others must be specified when building the image. All "
"available build arguments for each image are listed in one of the tables "
"below."
msgstr ""
"Flower Docker는 빌드 전달인자를 통해 구성됩니다. 빌드 argument들을 통해, 이미지를 보다 유연하게 생성할 수 "
"있습니다. 예를 들어, base 이미지에서 \"PYTHON_VERSION\" 빌드 전달인자를 사용하여 Python 버전을 지정할 수"
" 있습니다. 일부 빌드 전달인자들은 기본값이며, 이미지를 빌드할 때 지정해야 합니다. 각 이미지에 사용할 수 있는 모든 빌드 "
"전달인자는 아래 표 중에 있습니다."

#: ../../source/contributor-how-to-build-docker-images.rst:34
#, fuzzy
msgid "Building the Base Image"
msgstr "기본 이미지 빌드"

#: ../../source/contributor-how-to-build-docker-images.rst:40
#: ../../source/contributor-how-to-build-docker-images.rst:107
msgid "Build argument"
msgstr "빌드 전달인자"

#: ../../source/contributor-how-to-build-docker-images.rst:41
#: ../../source/contributor-how-to-build-docker-images.rst:108
#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#: ../../source/how-to-configure-audit-logging.rst:58
#: ../../source/ref-exit-codes/0.rst:7 ../../source/ref-exit-codes/1.rst:7
#: ../../source/ref-exit-codes/100.rst:7 ../../source/ref-exit-codes/101.rst:7
#: ../../source/ref-exit-codes/102.rst:7 ../../source/ref-exit-codes/103.rst:7
#: ../../source/ref-exit-codes/104.rst:7 ../../source/ref-exit-codes/2.rst:7
#: ../../source/ref-exit-codes/200.rst:23 ../../source/ref-exit-codes/201.rst:7
#: ../../source/ref-exit-codes/202.rst:7 ../../source/ref-exit-codes/3.rst:7
#: ../../source/ref-exit-codes/300.rst:7 ../../source/ref-exit-codes/302.rst:7
#: ../../source/ref-exit-codes/303.rst:7 ../../source/ref-exit-codes/304.rst:7
#: ../../source/ref-exit-codes/400.rst:7 ../../source/ref-exit-codes/500.rst:7
#: ../../source/ref-exit-codes/600.rst:7 ../../source/ref-exit-codes/601.rst:7
#: ../../source/ref-exit-codes/602.rst:7
msgid "Description"
msgstr "설명"

#: ../../source/contributor-how-to-build-docker-images.rst:42
#: ../../source/contributor-how-to-build-docker-images.rst:109
msgid "Required"
msgstr "필수"

#: ../../source/contributor-how-to-build-docker-images.rst:43
#: ../../source/contributor-how-to-build-docker-images.rst:110
#: ../../source/docker/persist-superlink-state.rst:26
#: ../../source/docker/pin-version.rst:18
#: ../../source/docker/set-environment-variables.rst:14
msgid "Example"
msgstr "예시"

#: ../../source/contributor-how-to-build-docker-images.rst:44
msgid "``DISTRO``"
msgstr "``DISTRO``"

#: ../../source/contributor-how-to-build-docker-images.rst:45
msgid "The Linux distribution to use as the base image."
msgstr "기본 이미지 사용을 위한 Linux 배포판."

#: ../../source/contributor-how-to-build-docker-images.rst:46
#: ../../source/contributor-how-to-build-docker-images.rst:50
#: ../../source/contributor-how-to-build-docker-images.rst:54
#: ../../source/contributor-how-to-build-docker-images.rst:70
#: ../../source/contributor-how-to-build-docker-images.rst:77
#: ../../source/contributor-how-to-build-docker-images.rst:113
msgid "No"
msgstr "아니오"

#: ../../source/contributor-how-to-build-docker-images.rst:47
msgid "``ubuntu``"
msgstr "``ubuntu``"

#: ../../source/contributor-how-to-build-docker-images.rst:48
msgid "``DISTRO_VERSION``"
msgstr "``DISTRO_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:49
msgid "Version of the Linux distribution."
msgstr "Linux 배포판 버전."

#: ../../source/contributor-how-to-build-docker-images.rst:51
msgid ":substitution-code:`|ubuntu_version|`"
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:52
msgid "``PYTHON_VERSION``"
msgstr "``PYTHON_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:53
msgid "Version of ``python`` to be installed."
msgstr "설치 된 ``python`` 버전."

#: ../../source/contributor-how-to-build-docker-images.rst:55
msgid "``3.11`` or ``3.11.1``"
msgstr "``3.11`` 또는 ``3.11.1``"

#: ../../source/contributor-how-to-build-docker-images.rst:56
msgid "``PIP_VERSION``"
msgstr "``PIP_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:57
msgid "Version of ``pip`` to be installed."
msgstr "설치 된 ``pip`` 버전."

#: ../../source/contributor-how-to-build-docker-images.rst:58
#: ../../source/contributor-how-to-build-docker-images.rst:62
#: ../../source/contributor-how-to-build-docker-images.rst:66
#: ../../source/contributor-how-to-build-docker-images.rst:117
msgid "Yes"
msgstr "예"

#: ../../source/contributor-how-to-build-docker-images.rst:59
msgid ":substitution-code:`|pip_version|`"
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:60
msgid "``SETUPTOOLS_VERSION``"
msgstr "``SETUPTOOLS_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:61
msgid "Version of ``setuptools`` to be installed."
msgstr "설치 된 ``setuptools`` 버전."

#: ../../source/contributor-how-to-build-docker-images.rst:63
#, fuzzy
msgid ":substitution-code:`|setuptools_version|`"
msgstr "``SETUPTOOLS_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:64
msgid "``FLWR_VERSION``"
msgstr "``FLWR_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:65
msgid "Version of Flower to be installed."
msgstr "설치 된 Flower 버전."

#: ../../source/contributor-how-to-build-docker-images.rst:67
msgid ":substitution-code:`|stable_flwr_version|`"
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:68
msgid "``FLWR_PACKAGE``"
msgstr "``FLWR_PACKAGE``"

#: ../../source/contributor-how-to-build-docker-images.rst:69
msgid "The Flower package to be installed."
msgstr "설치 할 Flower 패키지."

#: ../../source/contributor-how-to-build-docker-images.rst:71
msgid "``flwr`` or ``flwr-nightly``"
msgstr "``flwr`` 또는 ``flwr-nightly``"

#: ../../source/contributor-how-to-build-docker-images.rst:72
#, fuzzy
msgid "``FLWR_VERSION_REF``"
msgstr "``FLWR_VERSION``"

#: ../../source/contributor-how-to-build-docker-images.rst:73
msgid ""
"A `direct reference "
"<https://packaging.python.org/en/latest/specifications/version-specifiers"
"/#direct-references>`_ without the ``@`` specifier. If both "
"``FLWR_VERSION`` and ``FLWR_VERSION_REF`` are specified, the "
"``FLWR_VERSION_REF`` has precedence."
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:78
#, fuzzy
msgid "`Direct Reference Examples`_"
msgstr "예시 요청"

#: ../../source/contributor-how-to-build-docker-images.rst:80
#, fuzzy
msgid ""
"The following example creates a base Ubuntu/Alpine image with Python "
"``3.11.0``, pip :substitution-code:`|pip_version|`, setuptools "
":substitution-code:`|setuptools_version|` and Flower :substitution-"
"code:`|stable_flwr_version|`:"
msgstr ""
"다음 예시에서는 Python 3.11.0, pip 23.0.1, setuptools 및 Flower 1.8.0으로 기본 "
"Ubuntu/Alpine 이미지를 만듭니다:"

#: ../../source/contributor-how-to-build-docker-images.rst:95
#, fuzzy
msgid ""
"In this example, we specify our image name as ``flwr_base`` and the tag "
"as ``0.1.0``. Remember that the build arguments as well as the name and "
"tag can be adapted to your needs. These values serve as examples only."
msgstr ""
"이미지의 이름은 ``flwr_base``이고 태그는 ``0.1.0``입니다. 필요에 따라 빌드 전달인자들 뿐만 아니라 이름과 태그도"
" 정할 수 있습니다. 이 값들은 예시일 뿐입니다."

#: ../../source/contributor-how-to-build-docker-images.rst:101
#, fuzzy
msgid "Building a Flower Binary Image"
msgstr "기본 이미지 빌드"

#: ../../source/contributor-how-to-build-docker-images.rst:111
msgid "``BASE_REPOSITORY``"
msgstr "``BASE_REPOSITORY``"

#: ../../source/contributor-how-to-build-docker-images.rst:112
msgid "The repository name of the base image."
msgstr "기본 이미지의 레포지토리 이름."

#: ../../source/contributor-how-to-build-docker-images.rst:114
msgid "``flwr/base``"
msgstr "``flwr/base``"

#: ../../source/contributor-how-to-build-docker-images.rst:115
msgid "``BASE_IMAGE``"
msgstr "``BASE_IMAGE``"

#: ../../source/contributor-how-to-build-docker-images.rst:116
msgid "The Tag of the Flower base image."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/contributor-how-to-build-docker-images.rst:118
msgid ":substitution-code:`|stable_flwr_version|-py3.11-ubuntu|ubuntu_version|`"
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:120
msgid ""
"For example, to build a SuperLink image with the latest Flower version, "
"Python 3.11 and Ubuntu 22.04, run the following:"
msgstr ""

#: ../../source/contributor-how-to-build-docker-images.rst:131
#, fuzzy
msgid ""
"If you want to use your own base image instead of the official Flower "
"base image, all you need to do is set the ``BASE_REPOSITORY`` build "
"argument to ``flwr_base`` (as we've specified above)."
msgstr ""
"공식 Flower 기본 이미지 대신 자체 기본 이미지를 사용 하길 원한다면, ``BASE_REPOSITORY`` 빌드 전달인자들을 "
"설정해야 합니다."

#: ../../source/contributor-how-to-build-docker-images.rst:143
msgid "After creating the image, we can test whether the image is working:"
msgstr "이미지 생성 후에, 이미지가 작동하는지 테스트할 수 있습니다:"

#: ../../source/contributor-how-to-build-docker-images.rst:151
#, fuzzy
msgid "Direct Reference Examples"
msgstr "예시 요청"

#: ../../source/contributor-how-to-contribute-translations.rst:3
msgid "Contribute translations"
msgstr "번역 기여"

#: ../../source/contributor-how-to-contribute-translations.rst:5
msgid ""
"Since `Flower 1.5 <https://flower.ai/docs/framework/ref-"
"changelog.html#v1-5-0-2023-08-31>`_ we have introduced translations to "
"our doc pages, but, as you might have noticed, the translations are often"
" imperfect. If you speak languages other than English, you might be able "
"to help us in our effort to make Federated Learning accessible to as many"
" people as possible by contributing to those translations! This might "
"also be a great opportunity for those wanting to become open source "
"contributors with little prerequisites."
msgstr ""
"`Flower 1.5 <https://flower.ai/docs/framework/ref "
"changelog.html#v1-5-0-2023-08-31>`_ 부터 문서 페이지에 번역을 도입했지만, 아시다시피 번역이 불안전한 "
"경우가 많습니다. 만일 영어 이외의 언어를 사용한다면, 많은 사람들이 연합 학습에 접근할 수 있도록 번역 작업에 기여함으로써 저희의"
" 노력에 도움을 주실 수 있습니다! 이는 전제 조건이 거의 없는 오픈 소스 기여자가 되고자 하는 사람들에게 좋은 기회가 될 수도 "
"있습니다."

#: ../../source/contributor-how-to-contribute-translations.rst:14
msgid ""
"Our translation project is publicly available over on `Weblate "
"<https://hosted.weblate.org/projects/flower-docs/framework/>`_, this "
"where most of the work will happen."
msgstr ""
"번역 프로젝트는 `Weblate <https://hosted.weblate.org/projects/flower-"
"docs/framework/>`_에서 공개적으로 진행되며, 대부분의 작업이 이곳에서 이루어집니다."

#: ../../source/contributor-how-to-contribute-translations.rst:20
msgid "Contribute to existing languages"
msgstr "기존 언어에 기여하기"

#: ../../source/contributor-how-to-contribute-translations.rst:25
msgid ""
"The first thing you will need to do in order to contribute is to create a"
" free Weblate account on this `page "
"<https://hosted.weblate.org/accounts/register/>`_. More information about"
" profile settings can be found `here "
"<https://docs.weblate.org/en/latest/user/profile.html>`_."
msgstr ""
"기여를 하기 위해 가장 먼저 해야 할 일은 해당 `page "
"<https://hosted.weblate.org/accounts/register/>`_에서 무료 Weblate 계정을 만드는 "
"것입니다. 프로필 설정에 대한 자세한 정보는 `here "
"<https://docs.weblate.org/en/latest/user/profile.html>`_를 참조하세요."

#: ../../source/contributor-how-to-contribute-translations.rst:30
msgid ""
"Once you are signed in to Weblate, you can navigate to the `Flower "
"Framework project <https://hosted.weblate.org/projects/flower-"
"docs/framework/>`_. Here, you should see the different existing languages"
" that can be found on the website."
msgstr ""
"Weblate에 로그인한 후, `Flower Framework project "
"<https://hosted.weblate.org/projects/flower-docs/framework/>`_로 이동할 수 "
"있습니다. 여기에서 웹사이트에 있는 다양한 기존 언어들을 확인할 수 있습니다."

#: ../../source/contributor-how-to-contribute-translations.rst:34
msgid ""
"Once you have selected the language you want to contribute to, you should"
" see a similar interface to this:"
msgstr "기여하고자 하는 언어를 선택하면, 다음과 같은 인터페이스가 나타납니다:"

#: ../../source/contributor-how-to-contribute-translations.rst:39
msgid ""
"The most straight forward option here is to click on the ``Translate`` "
"button on the top right (in the ``Translation status`` section). This "
"will automatically bring you to the translation interface for "
"untranslated strings."
msgstr ""
"여기서 가장 간단한 옵션은 오른쪽 상단(``Translation status`` 부분)에 있는 ``Translate`` 버튼을 "
"클릭하는 것 입니다. 번역되지 않은 문장에 대한 번역 인터페이스로 자동으로 이동합니다."

#: ../../source/contributor-how-to-contribute-translations.rst:43
msgid "This is what the interface looks like:"
msgstr "인터페이스는 다음과 같습니다:"

#: ../../source/contributor-how-to-contribute-translations.rst:47
msgid ""
"You input your translation in the text box at the top and then, once you "
"are happy with it, you either press ``Save and continue`` (to save the "
"translation and go to the next untranslated string), ``Save and stay`` "
"(to save the translation and stay on the same page), ``Suggest`` (to add "
"your translation to suggestions for other users to view), or ``Skip`` (to"
" go to the next untranslated string without saving anything)."
msgstr ""
"번역문을 상단의 텍스트 상자에 입력한 후, 번역이 만족스러우면 ``Save and continue``(번역을 저장하고 다음 미번역 "
"문장으로 이동), ``Save and stay``(번역을 저장하고 해당 페이지에 머무르기), ``Suggest`` (다른 사용자가 "
"볼 수 있도록 번역을 제안 항목에 추가), ``Skip``(아무것도 저장하지 않고 다음 미번역 문장으로 이동) 중 하나를 선택하면 "
"됩니다."

#: ../../source/contributor-how-to-contribute-translations.rst:53
msgid ""
"In order to help with the translations, you can see on the bottom the "
"``Nearby strings``, the ``Comments`` (from other contributors), the "
"``Automatic suggestions`` (from machine translation engines), the "
"translations in ``Other languages``, and the ``History`` of translations "
"for this string."
msgstr ""
"번역에 도움을 주기위해 하단에서 `주변 문자열``, ``의견``(다른 기여자의), ``자동 제안``(기계 번역의), ``다른 "
"언어``의 번역 및 해당 문장의 번역``히스토리``를 볼 수 있습니다."

#: ../../source/contributor-how-to-contribute-translations.rst:58
msgid ""
"On the right, under the ``String information`` section, you can also "
"click the link under ``Source string location`` in order to view the "
"source of the doc file containing the string."
msgstr "오른쪽의 ``문자열 정보``에서 ``원본 문자열 위치``를 클릭하여 해당 문장이 포함된 문서의 파일 소스를 볼 수도 있습니다."

#: ../../source/contributor-how-to-contribute-translations.rst:62
msgid ""
"For more information about translating using Weblate, you can check out "
"this `in-depth guide "
"<https://docs.weblate.org/en/latest/user/translating.html>`_."
msgstr ""
"Weblate를 통한 번역에 대한 자세한 정보는 `in-depth guide "
"<https://docs.weblate.org/en/latest/user/translating.html>`_를 확인하세요."

#: ../../source/contributor-how-to-contribute-translations.rst:67
msgid "Add new languages"
msgstr "새 언어 추가"

#: ../../source/contributor-how-to-contribute-translations.rst:69
msgid ""
"If you want to add a new language, you will first have to contact us, "
"either on `Slack <https://flower.ai/join-slack>`_, or by opening an issue"
" on our `GitHub repo <https://github.com/adap/flower>`_."
msgstr ""
"새 언어를 추가하려면, `Slack <https://flower.ai/join-slack>`에 문의하거나 `GitHub repo "
"<https://github.com/adap/flower>`_에서 issue에 들어가 문의 해야 합니다."

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:3
msgid "Develop in VSCode Dev Containers"
msgstr "VSCode Dev Container에서 개발"

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:5
msgid ""
"When working on the Flower framework we want to ensure that all "
"contributors use the same developer environment to format code or run "
"tests. For this purpose we are using the VSCode Remote Containers "
"extension. What is it? Read the following quote:"
msgstr ""
"Flower 프레임워크 작업시, 모든 기여자들이 코드 포맷팅이나 테스트 실행을 위해 동일한 개발 환경을 사용하길 원합니다. 이를 "
"위해 VSCode Remote Containers 확장을 사용하고 있습니다. 그것이 무엇인지 알아보기 위해 다음 인용문을 "
"읽어보세요:"

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:9
#, fuzzy
msgid ""
"The Visual Studio Code Remote - Containers extension lets you use a "
"Docker container as a fully-featured development environment. It allows "
"you to open any folder inside (or mounted into) a container and take "
"advantage of Visual Studio Code's full feature set. A "
"``devcontainer.json`` file in your project tells VS Code how to access "
"(or create) a development container with a well-defined tool and runtime "
"stack. This container can be used to run an application or to separate "
"tools, libraries, or runtimes needed for working with a codebase."
msgstr ""
"Visual Studio Code Remote - 컨테이너 확장을 사용하면 Docker 컨테이너를 모든 기능을 갖춘 개발 환경으로 "
"사용할 수 있습니다. 이 확장 기능을 사용하면 컨테이너 내부(또는 컨테이너에 마운트된)의 모든 폴더를 열고 Visual Studio"
" Code의 모든 기능을 활용할 수 있습니다. 프로젝트에 있는 :code:`devcontainer.json` 파일은 잘 정의된 "
"도구와 런타임 스택을 사용하여 개발 컨테이너에 액세스(또는 생성)하는 방법을 VS Code에 알려줍니다. 이 컨테이너는 "
"애플리케이션을 실행하거나 코드베이스 작업에 필요한 도구, 라이브러리 또는 런타임을 분리하는 데 사용할 수 있습니다."

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:17
msgid ""
"Workspace files are mounted from the local file system or copied or "
"cloned into the container. Extensions are installed and run inside the "
"container, where they have full access to the tools, platform, and file "
"system. This means that you can seamlessly switch your entire development"
" environment just by connecting to a different container."
msgstr ""
"작업 공간 파일은 로컬 파일 시스템에서 마운트되거나 컨테이너에 복사 또는 클론됩니다. 확장 프로그램은 컨테이너 내부에 설치되고 "
"실행되며, 도구, 플랫폼 및 파일 시스템에 완전한 접근 권한을 갖습니다. 이는 다른 컨테이너에 연결하는 것만으로 전체 개발 환경을 "
"원활하게 전환할 수 있음을 의미합니다."

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:23
msgid ""
"Source: `Official VSCode documentation "
"<https://code.visualstudio.com/docs/devcontainers/containers>`_"
msgstr "출처 : 공식 VSCode 문서"

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:28
msgid "Getting started"
msgstr "시작하기"

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:30
#, fuzzy
msgid ""
"Configuring and setting up the ``Dockerfile`` as well the configuration "
"for the devcontainer can be a bit more involved. The good thing is you "
"don't have to do it. Usually it should be enough to install `Docker "
"<https://docs.docker.com/engine/install/>`_ on your system and ensure its"
" available on your command line. Additionally, install the `VSCode "
"Containers Extension <vscode:extension/ms-vscode-remote.remote-"
"containers>`_."
msgstr ""
"`Dockerfile`을 설정하고 구성하는 것과 개발 컨테이너 구성은 약간 복잡할 수 있습니다. 다행히도, 이를 직접 할 필요는 "
"없습니다. 일반적으로 시스템에 `Docker <https://docs.docker.com/engine/install/>`_를 "
"설치하고 커맨드 라인에서 사용할 수 있는지 확인하는 것으로 충분합니다. 추가로 `VSCode Containers Extension "
"<vscode:extension/ms-vscode-remote.remote-containers>`_을 설치하세요."

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:37
msgid ""
"Now you should be good to go. When starting VSCode, it will ask you to "
"run in the container environment and - if you confirm - automatically "
"build the container and use it. To manually instruct VSCode to use the "
"devcontainer, you can, after installing the extension, click the green "
"area in the bottom left corner of your VSCode window and select the "
"option *(Re)Open Folder in Container*."
msgstr ""
"이제 준비가 완료되었습니다. VSCode를 시작하면 컨테이너 환경에서 실행할지를 묻고, 확인하면 자동으로 컨테이너를 빌드하고 사용할"
" 것입니다. VSCode에 수동으로 개발 컨테이너를 사용하도록 지시하려면, 확장을 설치한 후, VSCode 창의 왼쪽 하단에 있는 "
"초록색 부을 클릭하고 *(Re)Open Folder in Container* 옵션을 선택하세요."

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:43
msgid ""
"In some cases your setup might be more involved. For those cases consult "
"the following sources:"
msgstr "경우에 따라 설정이 더 복잡할 수도 있습니다. 이러한 경우에는 다음 소스를 참조하세요:"

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:46
msgid ""
"`Developing inside a Container "
"<https://code.visualstudio.com/docs/devcontainers/containers#_system-"
"requirements>`_"
msgstr ""
"`컨테이너 내부 개발<https://code.visualstudio.com/docs/devcontainers/containers"
"#_system-requirements>`_"

#: ../../source/contributor-how-to-develop-in-vscode-dev-containers.rst:48
msgid ""
"`Remote development in Containers "
"<https://code.visualstudio.com/docs/devcontainers/tutorial>`_"
msgstr "`컨테이너 원격 개발<https://code.visualstudio.com/docs/devcontainers/tutorial>`_"

#: ../../source/contributor-how-to-install-development-versions.rst:3
msgid "Install development versions"
msgstr "개발 버전 설치하기"

#: ../../source/contributor-how-to-install-development-versions.rst:7
msgid "Install development versions of Flower"
msgstr "Flower 개발 버전 설치하기"

#: ../../source/contributor-how-to-install-development-versions.rst:10
msgid "Using Poetry (recommended)"
msgstr "Poetry 사용하기(권장)"

#: ../../source/contributor-how-to-install-development-versions.rst:12
msgid ""
"Install a ``flwr`` pre-release from PyPI: update the ``flwr`` dependency "
"in ``pyproject.toml`` and then reinstall (don't forget to delete "
"``poetry.lock`` (``rm poetry.lock``) before running ``poetry install``)."
msgstr ""
"PyPI에서 ``flwr`` 사전 릴리스 설치하기: ``pyproject.toml``에서 ``flwr``의 의존성을 업데이트한 "
"다음, 재설치하세요(``poetry 설치``이전에 ``poetry.lock`` (``rm poetry.lock``)를 제거하는 것을"
" 잊지 마세요)."

#: ../../source/contributor-how-to-install-development-versions.rst:16
#, python-brace-format
msgid ""
"``flwr = { version = \"1.0.0a0\", allow-prereleases = true }`` (without "
"extras)"
msgstr "``flwr = { version = \"1.0.0a0\", allow-prereleases = true }`` (extras 제외)"

#: ../../source/contributor-how-to-install-development-versions.rst:17
#, python-brace-format
msgid ""
"``flwr = { version = \"1.0.0a0\", allow-prereleases = true, extras = "
"[\"simulation\"] }`` (with extras)"
msgstr ""
"``flwr = { version = \"1.0.0a0\", allow-prereleases = true, extras = "
"[\"simulation\"] }`` (extras 포함)"

#: ../../source/contributor-how-to-install-development-versions.rst:20
msgid ""
"Install ``flwr`` from a local copy of the Flower source code via "
"``pyproject.toml``:"
msgstr "``pyproject.toml``을 통해 Flower 소스 코드의 로컬 복사본에서 ``flwr``을 설치하세요:"

#: ../../source/contributor-how-to-install-development-versions.rst:22
#, python-brace-format
msgid "``flwr = { path = \"../../\", develop = true }`` (without extras)"
msgstr "``flwr = { path = \"../../\", develop = true }`` (extras 제외)"

#: ../../source/contributor-how-to-install-development-versions.rst:23
#, python-brace-format
msgid ""
"``flwr = { path = \"../../\", develop = true, extras = [\"simulation\"] "
"}`` (with extras)"
msgstr ""
"``flwr = { path = \"../../\", develop = true, extras = [\"simulation\"] "
"}`` (extras 포함)"

#: ../../source/contributor-how-to-install-development-versions.rst:25
msgid "Install ``flwr`` from a local wheel file via ``pyproject.toml``:"
msgstr "``pyproject.toml``을 통해 로컬 wheel file에서 ``flwr``을 설치하세요:"

#: ../../source/contributor-how-to-install-development-versions.rst:27
#, python-brace-format
msgid ""
"``flwr = { path = \"../../dist/flwr-1.8.0-py3-none-any.whl\" }`` (without"
" extras)"
msgstr ""
"``flwr = { path = \"../../dist/flwr-1.8.0-py3-none-any.whl\" }`` (extras "
"제외)"

#: ../../source/contributor-how-to-install-development-versions.rst:28
#, python-brace-format
msgid ""
"``flwr = { path = \"../../dist/flwr-1.8.0-py3-none-any.whl\", extras = "
"[\"simulation\"] }`` (with extras)"
msgstr ""
"``flwr = { path = \"../../dist/flwr-1.8.0-py3-none-any.whl\", extras = "
"[\"simulation\"] }`` (extras 포함)"

#: ../../source/contributor-how-to-install-development-versions.rst:31
msgid ""
"Please refer to the Poetry documentation for further details: `Poetry "
"Dependency Specification <https://python-poetry.org/docs/dependency-"
"specification/>`_"
msgstr ""
"자세한 내용은 Poetry 문서를 참고하세요: `Poetry Dependency Specification <https"
"://python-poetry.org/docs/dependency-specification/>`_"

#: ../../source/contributor-how-to-install-development-versions.rst:35
msgid "Using pip (recommended on Colab)"
msgstr "pip 사용하기(Colab에서 권장)"

#: ../../source/contributor-how-to-install-development-versions.rst:37
msgid "Install a ``flwr`` pre-release from PyPI:"
msgstr "PyPI에서 ``flwr`` 사전 릴리즈를 설치하기:"

#: ../../source/contributor-how-to-install-development-versions.rst:39
msgid "``pip install -U --pre flwr`` (without extras)"
msgstr "``pip install -U --pre flwr`` (extras 제외)"

#: ../../source/contributor-how-to-install-development-versions.rst:40
msgid "``pip install -U --pre 'flwr[simulation]'`` (with extras)"
msgstr "``pip install -U --pre 'flwr[simulation]'`` (extras 포함)"

#: ../../source/contributor-how-to-install-development-versions.rst:42
msgid ""
"Python packages can be installed from git repositories. Use one of the "
"following commands to install the Flower directly from GitHub."
msgstr ""
"Python 패키지는 git 저장소에서 설치할 수 있습니다. 다음 명령어 중 하나를 사용하여 GitHub에서 직접 Flower를 "
"설치하세요."

#: ../../source/contributor-how-to-install-development-versions.rst:45
msgid "Install ``flwr`` from the default GitHub branch (``main``):"
msgstr "기본 GitHub branch (``main``)에서 ``flwr`` 를 설치하기:"

#: ../../source/contributor-how-to-install-development-versions.rst:47
#, fuzzy
msgid ""
"``pip install "
"flwr@git+https://github.com/adap/flower.git#subdirectory=framework`` "
"(without extras)"
msgstr ""
"``pip install flwr@git+https://github.com/adap/flower.git@branch-name`` "
"(extras 제외)"

#: ../../source/contributor-how-to-install-development-versions.rst:49
#, fuzzy
msgid ""
"``pip install "
"'flwr[simulation]@git+https://github.com/adap/flower.git#subdirectory=framework'``"
" (with extras)"
msgstr ""
"``pip install 'flwr[simulation]@git+https://github.com/adap/flower.git"
"@branch-name'`` (extras 포함)"

#: ../../source/contributor-how-to-install-development-versions.rst:53
msgid "Install ``flwr`` from a specific GitHub branch (``branch-name``):"
msgstr "특정 GitHub branch (``branch-name``)에서 ``flwr`` 설치하기:"

#: ../../source/contributor-how-to-install-development-versions.rst:55
#, fuzzy
msgid ""
"``pip install flwr@git+https://github.com/adap/flower.git@branch-"
"name#subdirectory=framework`` (without extras)"
msgstr ""
"``pip install flwr@git+https://github.com/adap/flower.git@branch-name`` "
"(extras 제외)"

#: ../../source/contributor-how-to-install-development-versions.rst:58
#, fuzzy
msgid ""
"``pip install 'flwr[simulation]@git+https://github.com/adap/flower.git"
"@branch-name#subdirectory=framework'`` (with extras)"
msgstr ""
"``pip install 'flwr[simulation]@git+https://github.com/adap/flower.git"
"@branch-name'`` (extras 포함)"

#: ../../source/contributor-how-to-install-development-versions.rst:64
msgid "Open Jupyter Notebooks on Google Colab"
msgstr "Google Colab에서 Jupyter Notebooks 열기"

#: ../../source/contributor-how-to-install-development-versions.rst:66
msgid ""
"Open the notebook ``framework/docs/source/tutorial-series-get-started-"
"with-flower-pytorch.ipynb``:"
msgstr ""
"``framework/docs/source/tutorial-series-get-started-with-flower-"
"pytorch.ipynb``notebook을 엽니다:"

#: ../../source/contributor-how-to-install-development-versions.rst:69
msgid ""
"https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
"/tutorial-series-get-started-with-flower-pytorch.ipynb"
msgstr ""
"https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
"/tutorial-series-get-started-with-flower-pytorch.ipynb"

#: ../../source/contributor-how-to-install-development-versions.rst:71
msgid ""
"Open a development version of the same notebook from branch `branch-name`"
" by changing ``main`` to ``branch-name`` (right after ``blob``):"
msgstr ""
"``main``을 ``branch-name``(``blob`` 바로 뒤)으로 변경하여 동일한 notebook의 개발 버전을 브랜치 "
"`branch-name`에서 엽니다 :"

#: ../../source/contributor-how-to-install-development-versions.rst:74
msgid ""
"https://colab.research.google.com/github/adap/flower/blob/branch-"
"name/framework/docs/source/tutorial-series-get-started-with-flower-"
"pytorch.ipynb"
msgstr ""
"https://colab.research.google.com/github/adap/flower/blob/branch-"
"name/framework/docs/source/tutorial-series-get-started-with-flower-"
"pytorch.ipynb"

#: ../../source/contributor-how-to-install-development-versions.rst:76
msgid "Install a `whl` on Google Colab:"
msgstr "Google Colab에서 `whl` 설치하기:"

#: ../../source/contributor-how-to-install-development-versions.rst:78
msgid ""
"In the vertical icon grid on the left hand side, select ``Files`` > "
"``Upload to session storage``"
msgstr "왼쪽의 수직 아이콘 그리드에서 ``Files`` > ``Upload to session storage``를 선택하세요"

#: ../../source/contributor-how-to-install-development-versions.rst:80
msgid "Upload the whl (e.g., ``flwr-1.8.0-py3-none-any.whl``)"
msgstr "whl (예:``flwr-1.8.0-py3-none-any.whl``)을 업로드하세요"

#: ../../source/contributor-how-to-install-development-versions.rst:81
msgid ""
"Change ``!pip install -q 'flwr[simulation]' torch torchvision "
"matplotlib`` to ``!pip install -q 'flwr-1.8.0-py3-none-"
"any.whl[simulation]' torch torchvision matplotlib``"
msgstr ""
"``!pip install -q 'flwr[simulation]' torch torchvision matplotlib``를 "
"``!pip install -q 'flwr-1.8.0-py3-none-any.whl[simulation]' torch "
"torchvision matplotlib``로 바꾸세요"

#: ../../source/contributor-how-to-release-flower.rst:3
msgid "Release Flower"
msgstr "Flower 릴리즈 하기"

#: ../../source/contributor-how-to-release-flower.rst:5
msgid ""
"This document describes the current release process. It may or may not "
"change in the future."
msgstr "이 문서는 현재 릴리즈 과정을 설명합니다. 이는 앞으로 변경될 수도 있습니다."

#: ../../source/contributor-how-to-release-flower.rst:10
msgid "During the release"
msgstr "릴리즈 동안에"

#: ../../source/contributor-how-to-release-flower.rst:12
#, fuzzy
msgid ""
"The version number of a release is stated in "
"``./framework/pyproject.toml``. To release a new version of Flower, the "
"following things need to happen (in that order):"
msgstr ""
"릴리즈의 버전 번호는 ``pyproject.toml``에 명시되어 있습니다. Flower의 새 버전을 릴리즈하려면 다음 작업이 "
"순서대로 수행되어야 합니다:"

#: ../../source/contributor-how-to-release-flower.rst:15
msgid ""
"Run ``python3 ./framework/dev/update_changelog.py <YOUR_GH_TOKEN>`` to "
"add all new changes to the changelog. You can make manual edits to the "
"changelog afterward to improve its formatting or wording. This script "
"will also replace the ``## Unreleased`` header with the new version "
"number and current date, and add a thank-you message for contributors. "
"Open a pull request with these changes."
msgstr ""

#: ../../source/contributor-how-to-release-flower.rst:20
#, fuzzy
msgid ""
"Once the pull request is merged, tag the release commit with the version "
"number: ``git tag v<NEW_VERSION>`` (notice the ``v`` added before the "
"version number), then ``git push --tags``. This will create a draft "
"release on GitHub containing the correct artifacts and the relevant part "
"of the changelog."
msgstr ""
"pull request가 병합되면, PR이 병합되는 즉시 버전 번호로 릴리즈 커밋에 태그를 지정합니다:``git tag "
"v<NEW_VERSION>`` (버전 번호 앞에 ``v``가 추가된 것을 확인), 그 다음 ``git push --tags``. "
"이렇게 하면 올바른 아티팩트와 변경 로그의 관련 부분이 포함된 초안 릴리즈가 GitHub에 생성됩니다."

#: ../../source/contributor-how-to-release-flower.rst:24
msgid "Check the draft release on GitHub, and if everything is good, publish it."
msgstr "GitHub에서 릴리즈 초안을 확인하고, 모든 것이 양호하면 게시하세요."

#: ../../source/contributor-how-to-release-flower.rst:28
msgid "After the release"
msgstr "릴리즈 후에"

#: ../../source/contributor-how-to-release-flower.rst:30
msgid "Create a pull request which contains the following changes:"
msgstr "다음 변경 사항이 포함된 pull request를 만듭니다:"

#: ../../source/contributor-how-to-release-flower.rst:32
msgid ""
"Increase the minor version in ``pyproject.toml`` by one and update all "
"files which contain the current version number (if necessary) by running "
"``./framework/dev/update_version.py``."
msgstr ""

#: ../../source/contributor-how-to-release-flower.rst:35
msgid ""
"Add a new ``## Unreleased`` section at the top of "
"``./framework/docs/source/ref-changelog.md`` to prepare for future "
"changes."
msgstr ""

#: ../../source/contributor-how-to-release-flower.rst:38
msgid ""
"Merge the pull request on the same day (i.e., before a new nightly "
"release gets published to PyPI)."
msgstr "pull request를 같은 날(즉, 새로운 nightly 릴리즈가 PyPI에 게시되기 전에) 병합하세요."

#: ../../source/contributor-how-to-release-flower.rst:43
msgid "Publishing a pre-release"
msgstr "사전 릴리즈 게시"

#: ../../source/contributor-how-to-release-flower.rst:46
msgid "Pre-release naming"
msgstr "사전 릴리즈 이름"

#: ../../source/contributor-how-to-release-flower.rst:48
msgid ""
"PyPI supports pre-releases (alpha, beta, release candidate). Pre-releases"
" MUST use one of the following naming patterns:"
msgstr "PyPI는 사전 릴리즈(알파, 베타, 릴리스 후보)를 지원합니다. 사전 릴리즈는 반드시 다음 명명 패턴 중 하나를 사용해야 합니다:"

#: ../../source/contributor-how-to-release-flower.rst:51
msgid "Alpha: ``MAJOR.MINOR.PATCHaN``"
msgstr "Alpha: ``MAJOR.MINOR.PATCHaN``"

#: ../../source/contributor-how-to-release-flower.rst:52
msgid "Beta: ``MAJOR.MINOR.PATCHbN``"
msgstr "Beta: ``MAJOR.MINOR.PATCHbN``"

#: ../../source/contributor-how-to-release-flower.rst:53
msgid "Release candidate (RC): ``MAJOR.MINOR.PATCHrcN``"
msgstr "Release candidate (RC): ``MAJOR.MINOR.PATCHrcN``"

#: ../../source/contributor-how-to-release-flower.rst:55
msgid "Examples include:"
msgstr "예시:"

#: ../../source/contributor-how-to-release-flower.rst:57
msgid "``1.0.0a0``"
msgstr "``1.0.0a0``"

#: ../../source/contributor-how-to-release-flower.rst:58
msgid "``1.0.0b0``"
msgstr "``1.0.0b0``"

#: ../../source/contributor-how-to-release-flower.rst:59
msgid "``1.0.0rc0``"
msgstr "``1.0.0rc0``"

#: ../../source/contributor-how-to-release-flower.rst:60
msgid "``1.0.0rc1``"
msgstr "``1.0.0rc1``"

#: ../../source/contributor-how-to-release-flower.rst:62
msgid ""
"This is in line with PEP-440 and the recommendations from the Python "
"Packaging Authority (PyPA):"
msgstr "이는 PEP-440 및 Python Packaging Authority (PyPA)의 권장 사항과 일치합니다:"

#: ../../source/contributor-how-to-release-flower.rst:65
msgid "`PEP-440 <https://peps.python.org/pep-0440/>`_"
msgstr "`PEP-440 <https://peps.python.org/pep-0440/>`_"

#: ../../source/contributor-how-to-release-flower.rst:66
msgid ""
"`PyPA Choosing a versioning scheme "
"<https://packaging.python.org/en/latest/guides/distributing-packages-"
"using-setuptools/#choosing-a-versioning-scheme>`_"
msgstr ""
"`PyPA 버전 관리 체계 선택하기 <https://packaging.python.org/en/latest/guides"
"/distributing-packages-using-setuptools/#choosing-a-versioning-scheme>`_"

#: ../../source/contributor-how-to-release-flower.rst:69
msgid ""
"Note that the approach defined by PyPA is not compatible with SemVer "
"2.0.0 spec, for details consult the `Semantic Versioning Specification "
"<https://semver.org/spec/v2.0.0.html#spec-item-11>`_ (specifically item "
"11 on precedence)."
msgstr ""
"PyPA에서 정의한 접근 방식은 SemVer 2.0.0 사양과 호환되지 않으며, 자세한 내용은`Semantic Versioning "
"관리 사양 <https://semver.org/spec/v2.0.0.html#spec-item-11>`_ (특히 항목 11이 "
"우선순위)을 참조하세요."

#: ../../source/contributor-how-to-release-flower.rst:75
msgid "Pre-release classification"
msgstr "사전 릴리즈 분류"

#: ../../source/contributor-how-to-release-flower.rst:77
msgid "Should the next pre-release be called alpha, beta, or release candidate?"
msgstr "다음 사전 릴리즈를 알파, 베타 또는 릴리스 후보라고 불러야 하나요?"

#: ../../source/contributor-how-to-release-flower.rst:79
msgid ""
"RC: feature complete, no known issues (apart from issues that are "
"classified as \"won't fix\" for the next stable release) - if no issues "
"surface this will become the next stable release"
msgstr ""
"RC: 기능 완료, 알려진 문제 없음(다음 stable 릴리즈에서 \"수정되지 않음\"으로 분류된 문제 제외) - 문제가 나타나지 "
"않으면 다음 stable 릴리즈가 됩니다"

#: ../../source/contributor-how-to-release-flower.rst:82
msgid "Beta: feature complete, allowed to have known issues"
msgstr "베타: 기능 완료, 알려진 문제 발생 가능"

#: ../../source/contributor-how-to-release-flower.rst:83
msgid "Alpha: not feature complete, allowed to have known issues"
msgstr "알파: 기능 미완성, 알려진 문제가 있을 수 있음"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:3
msgid "Set up a virtual env"
msgstr "가상 환경 설정"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:5
msgid ""
"It is recommended to run your Python setup within a virtual environment. "
"This guide shows three different examples how to create a virtual "
"environment with pyenv virtualenv, poetry, or Anaconda. You can follow "
"the instructions or choose your preferred setup."
msgstr ""
"가상 환경 내에서 파이썬 설정을 실행하는 것이 좋습니다. 이 가이드에서는 pyenv virtualenv, poetry 또는 "
"Anaconda를 사용하여 가상 환경을 만드는 세 가지 예제를 보여줍니다. 안내를 따르거나 원하는 설정을 선택할 수 있습니다."

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:12
msgid "Python Version"
msgstr "Python 버전"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:14
#: ../../source/how-to-install-flower.rst:13
msgid "Flower requires at least `Python 3.10 <https://docs.python.org/3.10/>`_."
msgstr "Flower는 `Python 3.10 <https://docs.python.org/3.10/>`_이상이 필요하지만."

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:18
msgid ""
"Due to a known incompatibility with `ray "
"<https://docs.ray.io/en/latest/>`_, we currently recommend utilizing at "
"most `Python 3.11 <https://docs.python.org/3.11/>`_ for running Flower "
"simulations."
msgstr ""
"`Ray <https://docs.ray.io/en/latest/>`__와 호환되지 않는 것으로 알려져 있으므로, 현재 Flower"
" 시뮬레이션을 실행할 때는 최대 `Python 3.11 <https://docs.python.org/3.11/>`_을 사용하는 것이"
" 좋습니다."

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:24
msgid "Virtualenv with Pyenv/Virtualenv"
msgstr "Pyenv/Virtualenv를 사용한 가상 환경"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:26
msgid ""
"One of the recommended virtual environment is `pyenv "
"<https://github.com/pyenv/pyenv>`_/`virtualenv <https://github.com/pyenv"
"/pyenv-virtualenv>`_. Please see `Flower examples "
"<https://github.com/adap/flower/tree/main/examples/>`_ for details."
msgstr ""
"권장 가상 환경 중 하나는 `pyenv <https://github.com/pyenv/pyenv>`_/`virtualenv "
"<https://github.com/pyenv/pyenv-virtualenv>`_입니다. 자세한 내용은 `Flower "
"examples <https://github.com/adap/flower/tree/main/examples/>`_를 참조하세요."

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:31
msgid ""
"Once Pyenv is set up, you can use it to install `Python Version 3.10 "
"<https://docs.python.org/3.10/>`_ or above:"
msgstr ""
"Pyenv가 설정되면 이를 사용하여 'Python 버전 3.10 <https://docs.python.org/3.10/>`_ "
"이상'을 설치할 수 있습니다:"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:38
msgid "Create the virtualenv with:"
msgstr "가상 환경을 만듭니다:"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:44
msgid "Activate the virtualenv by running the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:52
msgid "Virtualenv with Poetry"
msgstr "Poetry를 사용한 가상 환경"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:54
msgid ""
"The Flower examples are based on `Poetry <https://python-"
"poetry.org/docs/>`_ to manage dependencies. After installing Poetry you "
"simply create a virtual environment with:"
msgstr ""
"Flower examples은 의존성을 관리하기 위해 `Poetry <https://python-"
"poetry.org/docs/>`_를 기반으로 합니다. Poetry를 설치한 후 가상 환경을 생성하기만 하면 됩니다:"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:61
msgid ""
"If you open a new terminal you can activate the previously created "
"virtual environment with the following command:"
msgstr "새 터미널을 열면 다음 명령을 사용하여 이전에 생성한 가상 환경을 활성화할 수 있습니다:"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:70
msgid "Virtualenv with Anaconda"
msgstr "Anaconda를 사용한 가상 환경"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:72
#, fuzzy
msgid ""
"If you prefer to use Anaconda for your virtual environment then install "
"and setup the `conda <https://docs.conda.io/projects/conda/en/latest"
"/user-guide/install/index.html>`_ package. After setting it up you can "
"create a virtual environment with:"
msgstr ""
"가상 환경에서 Anaconda를 사용하려면 `conda "
"<https://docs.conda.io/projects/conda/en/latest/user-"
"guide/install/index.html>`_ 패키지를 설치 및 설정하세요. 설정 후 다음을 사용하여 가상 환경을 만들 수 "
"있습니다:"

#: ../../source/contributor-how-to-set-up-a-virtual-env.rst:80
msgid "and activate the virtual environment with:"
msgstr "그 후 가상 환경을 활성화합니다:"

#: ../../source/contributor-how-to-write-documentation.rst:3
msgid "Write documentation"
msgstr "문서 작성"

#: ../../source/contributor-how-to-write-documentation.rst:7
msgid "Project layout"
msgstr "프로젝트 레이아웃"

#: ../../source/contributor-how-to-write-documentation.rst:9
msgid ""
"The Flower documentation lives in the ``doc`` directory. The Sphinx-based"
" documentation system supports both reStructuredText (``.rst`` files) and"
" Markdown (``.md`` files)."
msgstr ""
"Flower 문서는 ``doc`` 디렉토리에 있습니다. Sphinx 기반 문서 시스템은 reStructuredText "
"텍스트(``.rst`` 파일)와 Markdown(``.md`` 파일)을 모두 지원합니다."

#: ../../source/contributor-how-to-write-documentation.rst:12
msgid ""
"Note that, in order to build the documentation locally (with ``poetry run"
" make html``, like described below), `Pandoc "
"<https://pandoc.org/installing.html>`_ needs to be installed on the "
"system."
msgstr ""
"로컬에서 문서를 작성하려면(아래 설명과 같이 ``poetry run make html``로) `Pandoc "
"<https://pandoc.org/installing.html>`_이 시스템에 설치되어 있어야 합니다."

#: ../../source/contributor-how-to-write-documentation.rst:18
msgid "Edit an existing page"
msgstr "기존 페이지 편집"

#: ../../source/contributor-how-to-write-documentation.rst:20
msgid ""
"Edit an existing ``.rst`` (or ``.md``) file under "
"``framework/docs/source/``"
msgstr "framework/docs/source/``에서 기존 ``.rst``(또는 ``.md``) 파일을 편집합니다"

#: ../../source/contributor-how-to-write-documentation.rst:21
#: ../../source/contributor-how-to-write-documentation.rst:31
#, fuzzy
msgid "Compile the docs: ``cd framework/docs``, then ``poetry run make html``"
msgstr "문서를 컴파일합니다: ``cd doc``, ``poetry run make html`` 순으로 컴파일합니다"

#: ../../source/contributor-how-to-write-documentation.rst:22
#: ../../source/contributor-how-to-write-documentation.rst:32
#, fuzzy
msgid ""
"Open ``framework/docs/build/html/index.html`` in the browser to check the"
" result"
msgstr "브라우저에서 ``doc/build/html/index.html``을 열어 결과를 확인합니다"

#: ../../source/contributor-how-to-write-documentation.rst:26
msgid "Create a new page"
msgstr "새 페이지 만들기"

#: ../../source/contributor-how-to-write-documentation.rst:28
msgid "Add new ``.rst`` file under ``framework/docs/source/``"
msgstr "``framework/docs/source/`에 새 ``.rst`` 을 추가합니다"

#: ../../source/contributor-how-to-write-documentation.rst:29
msgid "Add content to the new ``.rst`` file"
msgstr "새 '.rst' 파일에 내용을 추가합니다"

#: ../../source/contributor-how-to-write-documentation.rst:30
msgid "Link to the new rst from ``index.rst``"
msgstr "``index.rst``에서 새 rst로 연결합니다"

#: ../../source/contributor-ref-good-first-contributions.rst:3
msgid "Good first contributions"
msgstr "훌륭한 첫 번째 기여"

#: ../../source/contributor-ref-good-first-contributions.rst:5
msgid ""
"We welcome contributions to Flower! However, it is not always easy to "
"know where to start. We therefore put together a few recommendations on "
"where to start to increase your chances of getting your PR accepted into "
"the Flower codebase."
msgstr ""
"Flower에 대한 기여를 환영합니다! 하지만 어디서부터 시작해야 할지 알기란 쉽지 않습니다. 그래서 저희는 여러분의 PR이 "
"Flower 코드베이스에 채택될 가능성을 높이기 위해 어디서부터 시작해야 하는지 몇 가지 권장 사항을 정리해 보았습니다."

#: ../../source/contributor-ref-good-first-contributions.rst:11
msgid "Where to start"
msgstr "시작 위치"

#: ../../source/contributor-ref-good-first-contributions.rst:13
#, fuzzy
msgid ""
"In general, it is easier to get PR's accepted if they only touch non-core"
" areas of the codebase. Good candidates to get started are:"
msgstr ""
"Flower 코어 라이브러리가 완성될 때까지는 코드베이스의 비핵심 영역만 건드리는 것이 PR을 승인받기가 더 쉬울 것입니다. "
"시작하기에 좋은 후보자는 다음과 같습니다:"

#: ../../source/contributor-ref-good-first-contributions.rst:16
msgid "Documentation: What's missing? What could be expressed more clearly?"
msgstr "문서: 무엇이 누락되었나요? 무엇을 더 명확하게 표현할 수 있을까요?"

#: ../../source/contributor-ref-good-first-contributions.rst:17
#, python-format
msgid ""
"Open issues: Issues with the tag `good first issue "
"<https://github.com/adap/flower/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22>`_."
msgstr ""

#: ../../source/contributor-ref-good-first-contributions.rst:19
msgid "Baselines: See below."
msgstr "Baselines: 아래를 참조하세요."

#: ../../source/contributor-ref-good-first-contributions.rst:20
msgid "Examples: See below."
msgstr "예시: 아래를 참조하세요."

#: ../../source/contributor-ref-good-first-contributions.rst:24
#, fuzzy
msgid "Flower Baselines"
msgstr "Flower Baselines 요청"

#: ../../source/contributor-ref-good-first-contributions.rst:26
#, fuzzy
msgid ""
"If you are not familiar with Flower Baselines, please check our "
"`contributing guide for baselines <https://flower.ai/docs/baselines/how-"
"to-contribute-baselines.html>`_."
msgstr ""
"Flower Baseline에 익숙하지 않다면 ' Baseline 기여 가이드 "
"<https://flower.ai/docs/baselines/how-to-contribute-baselines.html>`_를 "
"확인해보세요."

#: ../../source/contributor-ref-good-first-contributions.rst:29
#, fuzzy
msgid ""
"Then take a look at the open `issues "
"<https://github.com/adap/flower/issues?q=is%3Aopen+is%3Aissue+label%3A%22new+baseline%22>`_"
" for baseline requests. If you find a baseline that you'd like to work "
"on, and it has no assignees, feel free to assign it to yourself and get "
"started!"
msgstr ""
"그런 다음 오픈 된 `issues "
"<https://github.com/adap/flower/issues?q=is%3Aopen+is%3Aissue+label%3A%22new+baseline%22>`_에서"
" baseline 요청을 확인해야 합니다. 작업하고 싶은 기준선을 찾았지만 담당자가 없는 경우, 자유롭게 자신에게 할당하고 작업을 "
"시작하세요!"

#: ../../source/contributor-ref-good-first-contributions.rst:34
#, fuzzy
msgid ""
"If you don't find the baseline you'd like to work on, be sure to open a "
"new issue with the baseline request template!"
msgstr "그렇지 않으면 작업하고 싶은 baseline을 찾지 못하면 baseline 요청 템플릿으로 새 이슈를 열어야 합니다!"

#: ../../source/contributor-ref-good-first-contributions.rst:39
#, fuzzy
msgid "Usage examples"
msgstr "예시"

#: ../../source/contributor-ref-good-first-contributions.rst:41
#, fuzzy
msgid ""
"We wish we had more time to write usage examples because they help users "
"to get started with building what they want. If you notice any missing "
"examples that could help others, feel free to contribute!"
msgstr ""
"사용 예시는 사용자가 원하는 것을 구축하는 데 도움이 된다고 생각하기 때문에 더 많은 시간을 할애하여 작성할 수 있었으면 합니다. "
"다음은 저희가 기꺼이 PR을 수락할 수 있는 몇 가지 아이디어입니다:"

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:3
msgid "Secure Aggregation Protocols"
msgstr "Secure Aggregation 프로토콜"

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:7
msgid ""
"While this term might be used in other places, here it refers to a series"
" of protocols, including ``SecAgg``, ``SecAgg+``, ``LightSecAgg``, "
"``FastSecAgg``, etc. This concept was first proposed by Bonawitz et al. "
"in `Practical Secure Aggregation for Federated Learning on User-Held Data"
" <https://arxiv.org/abs/1611.04482>`_."
msgstr ""

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:12
msgid ""
"Secure Aggregation protocols are used to securely aggregate model updates"
" from multiple clients while keeping the updates private. This is done by"
" encrypting the model updates before sending them to the server. The "
"server can decrypt only the aggregated model update without being able to"
" inspect individual updates."
msgstr ""

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:17
msgid ""
"Flower now provides the ``SecAgg`` and ``SecAgg+`` protocols. While we "
"plan to implement more protocols in the future, one may also implement "
"their own custom secure aggregation protocol via low-level APIs."
msgstr ""

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:23
msgid "The ``SecAgg+`` protocol in Flower"
msgstr ""

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:25
msgid ""
"The ``SecAgg+`` protocol is implemented using the ``SecAggPlusWorkflow`` "
"in the ``ServerApp`` and the ``secaggplus_mod`` in the ``ClientApp``. The"
" ``SecAgg`` protocol is a special case of the ``SecAgg+`` protocol, and "
"one may use ``SecAggWorkflow`` and ``secagg_mod`` for that."
msgstr ""

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:30
msgid ""
"You may find a detailed example in the `Secure Aggregation Example "
"<https://flower.ai/docs/examples/flower-secure-aggregation.html>`_. The "
"documentation for the ``SecAgg+`` protocol configuration is available at "
"`SecAggPlusWorkflow <https://flower.ai/docs/framework/ref-"
"api/flwr.server.workflow.SecAggPlusWorkflow.html>`_."
msgstr ""

#: ../../source/contributor-ref-secure-aggregation-protocols.rst:35
msgid ""
"The logic of the ``SecAgg+`` protocol is illustrated in the following "
"sequence diagram: the dashed lines represent communication over the "
"network, and the solid lines represent communication within the same "
"process. The ``ServerApp`` is connected to ``SuperLink``, and the "
"``ClientApp`` is connected to the ``SuperNode``; thus, the communication "
"between the ``ServerApp`` and the ``ClientApp`` is done via the "
"``SuperLink`` and the ``SuperNode``."
msgstr ""

#: ../../source/contributor-tutorial-contribute-on-github.rst:3
msgid "Contribute on GitHub"
msgstr "GitHub에서 기여하기"

#: ../../source/contributor-tutorial-contribute-on-github.rst:5
msgid ""
"This guide is for people who want to get involved with Flower, but who "
"are not used to contributing to GitHub projects."
msgstr "이 가이드는 Flower에 참여하고 싶지만 GitHub 프로젝트에 기여하는 데 익숙하지 않은 분들을 위한 것입니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:8
msgid ""
"If you're familiar with how contributing on GitHub works, you can "
"directly checkout our :doc:`getting started guide for contributors "
"<contributor-tutorial-get-started-as-a-contributor>`."
msgstr ""
"깃허브에서 기여하는 방식에 익숙하다면 :doc:`기여자를 위한 시작 가이드<contributor-tutorial-get-"
"started-as-a-contributor>`를 직접 확인하세요."

#: ../../source/contributor-tutorial-contribute-on-github.rst:14
msgid "Setting up the repository"
msgstr "레포지토리 설정하기"

#: ../../source/contributor-tutorial-contribute-on-github.rst:16
msgid "**Create a GitHub account and setup Git**"
msgstr "**GitHub 계정을 만들고 Git을 설정합니다**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:17
msgid ""
"Git is a distributed version control tool. This allows for an entire "
"codebase's history to be stored and every developer's machine. It is a "
"software that will need to be installed on your local machine, you can "
"follow this `guide <https://docs.github.com/en/get-started/getting-"
"started-with-git/set-up-git>`_ to set it up."
msgstr ""
"Git은 분산 버전 관리 도구입니다. 이를 통해 전체 코드베이스의 히스토리와 모든 개발자의 컴퓨터를 저장할 수 있습니다. 로컬 "
"컴퓨터에 설치해야 하는 소프트웨어로, 이 `가이드 <https://docs.github.com/en/get-started"
"/getting-started-with-git/set-up-git>`_를 따라 설정할 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:23
msgid ""
"GitHub, itself, is a code hosting platform for version control and "
"collaboration. It allows for everyone to collaborate and work from "
"anywhere on remote repositories."
msgstr ""
"GitHub는 그 자체로 버전 관리 및 협업을 위한 코드 호스팅 플랫폼입니다. 누구나 원격 레포지토리에서 어디서든 협업하고 작업할 "
"수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:27
msgid ""
"If you haven't already, you will need to create an account on `GitHub "
"<https://github.com/signup>`_."
msgstr "아직 계정을 만들지 않았다면 `GitHub <https://github.com/signup>`_에서 계정을 만들어야 합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:30
msgid ""
"The idea behind the generic Git and GitHub workflow boils down to this: "
"you download code from a remote repository on GitHub, make changes "
"locally and keep track of them using Git and then you upload your new "
"history back to GitHub."
msgstr ""
"일반적인 Git 및 GitHub 워크플로우의 기본 개념은 다음과 같이 요약됩니다. GitHub의 원격 레포지토리에서 코드를 "
"다운로드하고 로컬에서 변경한 후 Git을 사용하여 추적한 다음 새 기록을 다시 GitHub에 업로드하는 것입니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:33
msgid "**Forking the Flower repository**"
msgstr "**Flower 레포지토리 포크하기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:34
#, fuzzy
msgid ""
"A fork is a personal copy of a GitHub repository. To create one for "
"Flower, you must navigate to https://github.com/adap/flower (while "
"connected to your GitHub account) and click the ``Fork`` button situated "
"on the top right of the page."
msgstr ""
"포크는 GitHub 리포지토리의 개인 복사본입니다. Flower용 포크를 만들려면 "
"`<https://github.com/adap/flower>`_로 이동하여(GitHub 계정에 연결된 상태에서) 페이지 오른쪽 "
"상단에 있는 ``포크`` 버튼을 클릭해야 합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:40
msgid ""
"You can change the name if you want, but this is not necessary as this "
"version of Flower will be yours and will sit inside your own account "
"(i.e., in your own list of repositories). Once created, you should see on"
" the top left corner that you are looking at your own version of Flower."
msgstr ""
"원하는 경우 이름을 변경할 수 있지만, 이 버전의 Flower는 자신의 계정(즉, 자신의 리포지토리 목록)에 위치하게 되므로 변경할"
" 필요는 없습니다. 만들기가 완료되면 왼쪽 상단에Flower 버전이 표시되는 것을 볼 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:46
msgid "**Cloning your forked repository**"
msgstr "**포크된 레포지토리 클론하기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:47
msgid ""
"The next step is to download the forked repository on your machine to be "
"able to make changes to it. On your forked repository page, you should "
"first click on the ``Code`` button on the right, this will give you the "
"ability to copy the HTTPS link of the repository."
msgstr ""
"다음 단계는 컴퓨터에서 포크된 레포지토리를 변경할 수 있도록 다운로드하는 것입니다. 포크된 포지토리 페이지에서 먼저 오른쪽의 "
"``Code`` 버튼을 클릭하면 레포지토리의 HTTPS 링크를 복사할 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:54
msgid ""
"Once you copied the \\<URL\\>, you can open a terminal on your machine, "
"navigate to the place you want to download the repository to and type:"
msgstr "\\<URL\\>를 복사한 후에는 컴퓨터에서 터미널을 열고 레포지토리를 다운로드할 위치로 이동하여 입력하면 됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:61
msgid ""
"This will create a ``flower/`` (or the name of your fork if you renamed "
"it) folder in the current working directory."
msgstr "현재 작업 디렉터리에``flower/``(또는 포크 이름을 변경한 경우 포크 이름) 폴더가 생성됩니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:63
msgid "**Add origin**"
msgstr "**origin 추가**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:64
msgid "You can then go into the repository folder:"
msgstr "그런 다음 레포지토리 폴더로 이동할 수 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:70
msgid ""
"And here we will need to add an origin to our repository. The origin is "
"the \\<URL\\> of the remote fork repository. To obtain it, we can do as "
"previously mentioned by going to our fork repository on our GitHub "
"account and copying the link."
msgstr ""
"여기에 레포지토리에 origin을 추가해야 합니다. origin은 원격 포크 레포지토리의 \\<URL\\>입니다. origin을 "
"얻으려면 앞서 설명한 대로 GitHub 계정의 포크 레포지토리로 이동하여 링크를 복사하면 됩니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:77
msgid ""
"Once the \\<URL\\> is copied, we can type the following command in our "
"terminal:"
msgstr "\\<URL\\> 이 복사되면 터미널에 다음 명령을 입력하면 됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:82
msgid "**Add upstream**"
msgstr "**Upstream 추가하기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:83
msgid ""
"Now we will add an upstream address to our repository. Still in the same "
"directory, we must run the following command:"
msgstr "이제 레포지토리에 upstream 주소를 추가하겠습니다. 여전히 같은 디렉터리에서 다음 명령을 실행해야 합니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:90
msgid "The following diagram visually explains what we did in the previous steps:"
msgstr "다음 다이어그램은 이전 단계에서 수행한 작업을 시각적으로 설명합니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:94
msgid ""
"The upstream is the GitHub remote address of the parent repository (in "
"this case Flower), i.e. the one we eventually want to contribute to and "
"therefore need an up-to-date history of. The origin is just the GitHub "
"remote address of the forked repository we created, i.e. the copy (fork) "
"in our own account."
msgstr ""
"upstream은 부모 레포지토리(이 경우 Flower)의 GitHub 원격 주소, 즉 우리가 최종적으로 기여하고 싶고 따라서 최신"
" 기록이 필요한 레포지토리입니다. origin은 우리가 만든 포크된 레포지토리의 GitHub 원격 주소, 즉 우리 계정에 있는 "
"사본(포크)입니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:99
msgid ""
"To make sure our local version of the fork is up-to-date with the latest "
"changes from the Flower repository, we can execute the following command:"
msgstr "로컬 버전의 포크가 Flower 레포지토리의 최신 변경 사항으로 최신 상태인지 확인하려면 다음 명령을 실행하면 됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:108
msgid "Setting up the coding environment"
msgstr "코딩 환경 설정"

#: ../../source/contributor-tutorial-contribute-on-github.rst:110
msgid ""
"This can be achieved by following this :doc:`getting started guide for "
"contributors <contributor-tutorial-get-started-as-a-contributor>` (note "
"that you won't need to clone the repository). Once you are able to write "
"code and test it, you can finally start making changes!"
msgstr ""
":doc:'기여자를 위한 시작 가이드 <contributor-tutorial-get-started-"
"as-a-contributor>'를 참조하세요(레포지토리를 복제할 필요는 없습니다). 코드를 작성하고 테스트할 수 있게 되면 드디어"
" 변경을 시작할 수 있습니다!"

#: ../../source/contributor-tutorial-contribute-on-github.rst:117
msgid "Making changes"
msgstr "변경하기"

#: ../../source/contributor-tutorial-contribute-on-github.rst:119
msgid ""
"Before making any changes make sure you are up-to-date with your "
"repository:"
msgstr "변경하기 전에 레포지토리를 최신 상태로 유지하세요:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:125
msgid "And with Flower's repository:"
msgstr "Flower의 레포지토리도 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:131
msgid "**Create a new branch**"
msgstr "**새 브랜치 만들기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:132
msgid ""
"To make the history cleaner and easier to work with, it is good practice "
"to create a new branch for each feature/project that needs to be "
"implemented."
msgstr "히스토리를 더 깔끔하고 작업하기 쉽게 만들려면 구현해야 하는 각 기능/프로젝트에 대해 새 브랜치를 만드는 것이 좋습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:135
msgid ""
"To do so, just run the following command inside the repository's "
"directory:"
msgstr "이렇게 하려면 레포지토리 디렉토리에서 다음 명령을 실행하면 됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:140
msgid "**Make changes**"
msgstr "**변경하기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:141
msgid "Write great code and create wonderful changes using your favorite editor!"
msgstr "선호하는 편집기를 사용하여 멋진 코드를 작성하고 훌륭한 변화를 만들어 보세요!"

#: ../../source/contributor-tutorial-contribute-on-github.rst:142
msgid "**Test and format your code**"
msgstr "**코드 테스트 및 서식 지정**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:143
msgid ""
"Don't forget to test and format your code! Otherwise your code won't be "
"able to be merged into the Flower repository. This is done so the "
"codebase stays consistent and easy to understand."
msgstr ""
"코드를 테스트하고 서식을 지정하는 것을 잊지 마세요! 그렇지 않으면 코드를 Flower 레포지토리에 병합할 수 없습니다. 이는 "
"코드베이스가 일관성을 유지하고 이해하기 쉽도록 하기 위한 것입니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:147
msgid "To do so, we have written a few scripts that you can execute:"
msgstr "이를 위해 실행할 수 있는 몇 가지 스크립트를 작성했습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:153
msgid "**Stage changes**"
msgstr "**변경사항 스테이징**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:154
msgid ""
"Before creating a commit that will update your history, you must specify "
"to Git which files it needs to take into account."
msgstr "기록을 업데이트할 커밋을 만들기 전에 어떤 파일을 고려해야 하는지 Git에 지정해야 합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:157
msgid "This can be done with:"
msgstr "이 작업을 수행할 수 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:163
#, fuzzy
msgid ""
"To check which files have been modified compared to the last version "
"(last commit) and to see which files are staged for commit, you can use "
"the ``git status`` command."
msgstr ""
"마지막 버전(마지막 커밋)과 비교하여 수정된 파일을 확인하고 커밋을 위해 스테이징된 파일을 확인하려면 :code:`git "
"status` 명령을 사용하면 됩니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:166
msgid "**Commit changes**"
msgstr "**변경사항 커밋**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:167
#, fuzzy
msgid ""
"Once you have added all the files you wanted to commit using ``git add``,"
" you can finally create your commit using this command:"
msgstr ":code:`git add`를 사용하여 커밋하려는 모든 파일을 추가한 후, 마지막으로 이 명령을 사용하여 커밋을 생성할 수 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:174
#, fuzzy
msgid ""
"The \\<commit_message\\> is there to explain to others what the commit "
"does. It should be written in an imperative style and be concise. An "
"example would be ``git commit -m \"Add images to README\"``."
msgstr ""
"커밋의 내용을 다른 사람에게 설명하기 위해 \\<commit_message\\>가 있습니다. 명령형 스타일로 작성해야 하며 간결해야"
" 합니다. 예를 들면 :code:`git commit -m \"Add images to README\"`."

#: ../../source/contributor-tutorial-contribute-on-github.rst:177
msgid "**Push the changes to the fork**"
msgstr "**변경 사항을 포크에 푸시**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:178
msgid ""
"Once we have committed our changes, we have effectively updated our local"
" history, but GitHub has no way of knowing this unless we push our "
"changes to our origin's remote address:"
msgstr ""
"변경 사항을 커밋하면 로컬 히스토리를 효과적으로 업데이트한 것이지만, 변경 사항을 원본의 원격 주소로 푸시하지 않는 한 "
"GitHub는 이를 알 방법이 없습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:186
msgid ""
"Once this is done, you will see on the GitHub that your forked repo was "
"updated with the changes you have made."
msgstr "이 작업이 완료되면 변경한 내용으로 포크된 레포지토리가 업데이트된 것을 GitHub에서 확인할 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:191
msgid "Creating and merging a pull request (PR)"
msgstr "pull request(PR) 만들기 및 병합하기"

#: ../../source/contributor-tutorial-contribute-on-github.rst:193
msgid "**Create the PR**"
msgstr "**PR 만들기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:194
msgid ""
"Once you have pushed changes, on the GitHub webpage of your repository "
"you should see the following message:"
msgstr "변경 사항을 푸시하고 나면 레포지토리의 GitHub 웹페이지에 다음 메시지가 표시됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:199
msgid "Otherwise you can always find this option in the ``Branches`` page."
msgstr "그렇지 않으면 언제든지 ``Branches`` 페이지에서 이 옵션을 찾을 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:201
msgid ""
"Once you click the ``Compare & pull request`` button, you should see "
"something similar to this:"
msgstr "``Compare & pull request`` 버튼을 클릭하면 이와 비슷한 화면이 표시됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:206
msgid "At the top you have an explanation of which branch will be merged where:"
msgstr "상단에는 어느 지점이 어디에 병합될 것인지에 대한 설명이 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:210
msgid ""
"In this example you can see that the request is to merge the branch "
"``doc-fixes`` from my forked repository to branch ``main`` from the "
"Flower repository."
msgstr ""
"이 예제에서는 내 포크된 레포지토리의 ``doc-fixes`` 브랜치를 Flower 레포지토리의 ``main`` 브랜치에 병합하라는"
" 요청을 볼 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:213
msgid ""
"The title should be changed to adhere to the :ref:`pr_title_format` "
"guidelines, otherwise it won't be possible to merge the PR. So in this "
"case, a correct title might be ``docs(framework:skip) Fix typos``."
msgstr ""
"제목은 :ref:`pr_title_format` 가이드라인을 준수하도록 변경해야 하며, 그렇지 않으면 PR을 병합할 수 없습니다. "
"따라서 이 경우 올바른 제목은 ``docs(framework:skip) Fix typos``이 될 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:217
msgid ""
"The input box in the middle is there for you to describe what your PR "
"does and to link it to existing issues. We have placed comments (that "
"won't be rendered once the PR is opened) to guide you through the "
"process."
msgstr ""
"가운데에 있는 입력 상자는 PR의 기능을 설명하고 기존 이슈에 연결할 수 있는 곳입니다. 프로세스를 안내하기 위해 코멘트(PR이 "
"열리면 렌더링되지 않음)를 배치했습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:221
msgid "It is important to follow the instructions described in comments."
msgstr "코멘트에 설명된 지침을 따르는 것이 중요합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:223
msgid ""
"At the bottom you will find the button to open the PR. This will notify "
"reviewers that a new PR has been opened and that they should look over it"
" to merge or to request changes."
msgstr ""
"하단에는 PR을 여는 버튼이 있습니다. 이렇게 하면 검토자에게 새 PR이 열렸으며 병합하거나 변경을 요청하기 위해 검토해야 함을 "
"알립니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:227
msgid ""
"If your PR is not yet ready for review, and you don't want to notify "
"anyone, you have the option to create a draft pull request:"
msgstr "PR이 아직 검토할 준비가 되지 않았고 다른 사람에게 알리고 싶지 않은 경우 pull request 초안을 만드는 옵션이 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:231
msgid "**Making new changes**"
msgstr "**new changes 만들기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:232
msgid ""
"Once the PR has been opened (as draft or not), you can still push new "
"commits to it the same way we did before, by making changes to the branch"
" associated with the PR."
msgstr "PR이 초안으로 열렸든 아니든, PR과 연결된 브랜치를 변경하여 이전과 같은 방식으로 새 커밋을 푸시할 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:235
msgid "**Review the PR**"
msgstr "**PR 검토하기**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:236
msgid ""
"Once the PR has been opened or once the draft PR has been marked as "
"ready, a review from code owners will be automatically requested:"
msgstr "PR이 열리거나 초안 PR이 준비됨으로 표시되면 코드 소유자의 검토가 자동으로 요청됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:241
msgid ""
"Code owners will then look into the code, ask questions, request changes "
"or validate the PR."
msgstr "그러면 코드 소유자는 코드를 살펴보고, 질문하고, 변경을 요청하거나 PR의 유효성을 검사합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:244
msgid "Merging will be blocked if there are ongoing requested changes."
msgstr "진행 중인 변경 요청이 있는 경우 병합이 차단됩니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:248
msgid ""
"To resolve them, just push the necessary changes to the branch associated"
" with the PR:"
msgstr "이를 해결하려면 PR과 연결된 브랜치에 필요한 변경 사항을 푸시하면 됩니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:253
msgid "And resolve the conversation:"
msgstr "그리고 소통을 통해 해결하세요:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:257
msgid ""
"Once all the conversations have been resolved, you can re-request a "
"review."
msgstr "모든 대화가 해결되면 검토를 다시 요청할 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:258
msgid "**Once the PR is merged**"
msgstr "**PR이 병합되면**"

#: ../../source/contributor-tutorial-contribute-on-github.rst:259
msgid ""
"If all the automatic tests have passed and reviewers have no more changes"
" to request, they can approve the PR and merge it."
msgstr "모든 자동 테스트가 통과되고 검토자가 더 이상 요청할 변경 사항이 없는 경우 PR을 승인하고 병합할 수 있습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:264
msgid ""
"Once it is merged, you can delete the branch on GitHub (a button should "
"appear to do so) and also delete it locally by doing:"
msgstr "병합이 완료되면 GitHub에서 브랜치를 삭제할 수 있으며(삭제 버튼이 표시되어야 함), 로컬에서도 삭제할 수 있습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:272
msgid "Then you should update your forked repository by doing:"
msgstr "그런 다음 다음을 수행하여 포크된 레포지토리를 업데이트해야 합니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:281
msgid "Example of first contribution"
msgstr "첫 번째 기여의 예"

#: ../../source/contributor-tutorial-contribute-on-github.rst:284
msgid "Problem"
msgstr "문제"

#: ../../source/contributor-tutorial-contribute-on-github.rst:286
msgid ""
"For our documentation, we've started to use the `Diàtaxis framework "
"<https://diataxis.fr/>`_."
msgstr "저희 문서에는 'Diàtaxis 프레임워크 <https://diataxis.fr/>`_'를 사용하기 시작했습니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:289
msgid ""
"Our \"How to\" guides should have titles that continue the sentence \"How"
" to …\", for example, \"How to upgrade to Flower 1.0\"."
msgstr ""
"'How to' 가이드의 제목은 \"How to …\"라는 문장을 이어가는 제목이어야 합니다(예: \"How to upgrade "
"to Flower 1.0\")."

#: ../../source/contributor-tutorial-contribute-on-github.rst:292
msgid ""
"Most of our guides do not follow this new format yet, and changing their "
"title is (unfortunately) more involved than one might think."
msgstr "대부분의 가이드는 아직 이 새로운 형식을 따르지 않으며, 안타깝게도 제목을 변경하는 작업은 생각보다 복잡합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:295
msgid ""
"This issue is about changing the title of a doc from present continuous "
"to present simple."
msgstr "이번 이슈는 문서 제목을 현재 연속형에서 현재 단순형으로 변경하는 것에 관한 것입니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:298
msgid ""
"Let's take the example of \"Saving Progress\" which we changed to \"Save "
"Progress\". Does this pass our check?"
msgstr ""
"\"How to saving progress\"을 \"How to save progress\"으로 변경한 예를 들어 보겠습니다. "
"이것이 우리의 점검을 통과했나요?"

#: ../../source/contributor-tutorial-contribute-on-github.rst:301
msgid "Before: \"How to saving progress\" ❌"
msgstr "Before: \"How to saving progress\" ❌"

#: ../../source/contributor-tutorial-contribute-on-github.rst:303
msgid "After: \"How to save progress\" ✅"
msgstr "After: \"How to save progress\" ✅"

#: ../../source/contributor-tutorial-contribute-on-github.rst:306
msgid "Solution"
msgstr "해결법"

#: ../../source/contributor-tutorial-contribute-on-github.rst:308
msgid ""
"This is a tiny change, but it'll allow us to test your end-to-end setup. "
"After cloning and setting up the Flower repo, here's what you should do:"
msgstr ""
"이것은 사소한 변경이지만 end-to-end 설정을 테스트할 수 있습니다. Flower 레포지토리를 복제하고 설정한 후에는 다음과 "
"같이 하세요:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:311
msgid "Find the source file in ``framework/docs/source``"
msgstr "``framework/docs/source``에서 소스 파일을 찾습니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:312
msgid ""
"Make the change in the ``.rst`` file (beware, the dashes under the title "
"should be the same length as the title itself)"
msgstr "``.rst`` 파일에서 변경합니다(제목 아래의 대시는 제목 자체의 길이와 같아야 합니다)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:314
msgid ""
"Build the docs and `check the result <contributor-how-to-write-"
"documentation.html#edit-an-existing-page>`_"
msgstr ""
"문서를 빌드하고 '결과 확인 <contributor-how-to-write-documentation.html#edit-an-"
"existing-page>`_'합니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:318
msgid "Rename file"
msgstr "파일 이름 바꾸기"

#: ../../source/contributor-tutorial-contribute-on-github.rst:320
msgid ""
"You might have noticed that the file name still reflects the old wording."
" If we just change the file, then we break all existing links to it - it "
"is **very important** to avoid that, breaking links can harm our search "
"engine ranking."
msgstr ""
"파일 이름에 여전히 이전 문구가 반영되어 있는 것을 보셨을 것입니다. 파일만 변경하면 파일에 대한 기존 링크가 모두 끊어지는데, "
"링크를 끊으면 검색 엔진 순위에 영향을 줄 수 있으므로 이를 방지하는 것이 **매우 중요**합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:324
msgid "Here's how to change the file name:"
msgstr "파일 이름을 변경하는 방법은 다음과 같습니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:326
msgid "Change the file name to ``save-progress.rst``"
msgstr "파일 이름을 ``save-progress.rst``로 변경합니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:327
msgid "Add a redirect rule to ``framework/docs/source/conf.py``"
msgstr "'framework/docs/source/conf.py'에 리디렉션 규칙을 추가합니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:329
msgid ""
"This will cause a redirect from ``saving-progress.html`` to ``save-"
"progress.html``, old links will continue to work."
msgstr ""
"이렇게 하면 ``saving-progress.html``에서 ``save-progress.html``로 리디렉션되며, 이전 링크는 "
"계속 작동합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:333
msgid "Apply changes in the index file"
msgstr "인덱스 파일에 변경 사항 적용"

#: ../../source/contributor-tutorial-contribute-on-github.rst:335
msgid ""
"For the lateral navigation bar to work properly, it is very important to "
"update the ``index.rst`` file as well. This is where we define the whole "
"arborescence of the navbar."
msgstr ""
"횡방향 내비게이션 바가 제대로 작동하려면 ``index.rst`` 파일도 업데이트하는 것이 매우 중요합니다. 이 파일은 탐색 모음의"
" 전체 배열을 정의하는 곳입니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:339
msgid "Find and modify the file name in ``index.rst``"
msgstr "``index.rst``에서 파일 이름을 찾아 수정합니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:342
msgid "Open PR"
msgstr "PR 열기"

#: ../../source/contributor-tutorial-contribute-on-github.rst:344
msgid ""
"Commit the changes (commit messages are always imperative: \"Do "
"something\", in this case \"Change …\")"
msgstr "변경 사항을 커밋합니다(커밋 메시지는 항상 필수 메시지입니다:\"Do something\"(이 경우 는 \"Change …\" )"

#: ../../source/contributor-tutorial-contribute-on-github.rst:346
msgid "Push the changes to your fork"
msgstr "변경 사항을 포크에 푸시합니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:347
msgid ""
"Open a PR (as shown above) with title ``docs(framework) Update how-to "
"guide title``"
msgstr "``docs(framework) Update how-to guide title`` 제목으로 PR(위와 같이)을 엽니다"

#: ../../source/contributor-tutorial-contribute-on-github.rst:348
msgid "Wait for it to be approved!"
msgstr "승인될 때까지 기다리세요!"

#: ../../source/contributor-tutorial-contribute-on-github.rst:349
msgid "Congrats! 🥳 You're now officially a Flower contributor!"
msgstr "축하합니다! 이제 공식적으로 Flower 기여자가 되셨습니다!"

#: ../../source/contributor-tutorial-contribute-on-github.rst:353
#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:401
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:337
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:700
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:441
#: ../../source/tutorial-series-what-is-federated-learning.rst:367
msgid "Next steps"
msgstr "다음 단계"

#: ../../source/contributor-tutorial-contribute-on-github.rst:355
msgid ""
"Once you have made your first PR, and want to contribute more, be sure to"
" check out the following :"
msgstr "첫 번째 PR을 작성하고 더 많은 기여를 하고 싶다면 다음을 확인하세요:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:358
#, fuzzy
msgid ""
":doc:`Good first contributions <contributor-ref-good-first-"
"contributions>`, where you should particularly look into the "
"``baselines`` contributions."
msgstr ""
":doc:`훌륭한 첫 번째 기여 <contributor-ref-good-first-contributions>`, 특히 "
":code:`baselines` 기여를 살펴봐야 합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:363
msgid "Appendix"
msgstr "부록"

#: ../../source/contributor-tutorial-contribute-on-github.rst:368
msgid "PR title format"
msgstr "PR 제목 형식"

#: ../../source/contributor-tutorial-contribute-on-github.rst:370
msgid "We enforce the following PR title format:"
msgstr "다음과 같은 PR 제목 형식을 적용합니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:376
msgid ""
"(or ``<type>(<project>:skip) <subject>`` to ignore the PR in the "
"changelog)"
msgstr "(또는 ``<type>(<project>:skip) <subject>``를 사용하면 변경 로그에서 PR을 무시합니다.)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:378
#, python-brace-format
msgid ""
"Where ``<type>`` needs to be in ``{ci, fix, feat, docs, refactor, "
"break}``, ``<project>`` should be in ``{framework, baselines, datasets, "
"examples, or '*' when modifying multiple projects which requires the "
"':skip' flag to be used}``, and ``<subject>`` starts with a capitalised "
"verb in the imperative mood."
msgstr ""
"여기서 ``<type>``은 ``{ci, fix, feat, docs, refactor, break}``, "
"``<project>``는 ``{framework, baselines, datasets, examples, or '*' "
"':skip' 플래그를 사용해야 하는 여러 프로젝트를 수정하는 경우}``로 입력해야 하며, ``<subject>``는 대문자로 "
"시작해야 합니다."

#: ../../source/contributor-tutorial-contribute-on-github.rst:383
msgid "Valid examples:"
msgstr "유효한 예시입니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:385
msgid "``feat(framework) Add flwr build CLI command``"
msgstr "``feat(framework) Add flwr build CLI command``"

#: ../../source/contributor-tutorial-contribute-on-github.rst:386
msgid "``refactor(examples:skip) Improve quickstart-pytorch logging``"
msgstr "``refactor(examples:skip) Improve quickstart-pytorch logging``"

#: ../../source/contributor-tutorial-contribute-on-github.rst:387
msgid "``ci(*:skip) Enforce PR title format``"
msgstr "``ci(*:skip) Enforce PR title format``"

#: ../../source/contributor-tutorial-contribute-on-github.rst:389
msgid "Invalid examples:"
msgstr "잘못된 예시입니다:"

#: ../../source/contributor-tutorial-contribute-on-github.rst:391
msgid "``feat(framework): Add flwr build CLI command`` (extra ``:``)"
msgstr "``feat(framework): Add flwr build CLI command`` ( ``:``제외)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:392
msgid ""
"``feat(*) Add flwr build CLI command`` (missing ``skip`` flag along with "
"``*``)"
msgstr "``feat(*) Add flwr build CLI command`` (``skip`` flag와 함께 ``*``누락)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:393
msgid "``feat(skip) Add flwr build CLI command`` (missing ``<project>``)"
msgstr "``feat(skip) Add flwr build CLI command`` (``<project>``누락)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:394
msgid "``feat(framework) add flwr build CLI command`` (non capitalised verb)"
msgstr "``feat(framework) add flwr build CLI command`` (대문자로 표기되지 않은 동사)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:395
msgid "``feat(framework) Add flwr build CLI command.`` (dot at the end)"
msgstr "``feat(framework) Add flwr build CLI command.`` (끝에 마침표)"

#: ../../source/contributor-tutorial-contribute-on-github.rst:396
msgid "``Add flwr build CLI command.`` (missing ``<type>(<project>)``)"
msgstr "``Add flwr build CLI command.`` ( ``<type>(<project>)``누락)"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:3
msgid "Get started as a contributor"
msgstr "기여자로 시작하기"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:7
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:22
#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:24
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:19
#: ../../source/docker/tutorial-quickstart-docker.rst:17
#: ../../source/how-to-authenticate-accounts.rst:28
#: ../../source/how-to-configure-audit-logging.rst:80
#: ../../source/how-to-run-flower-with-deployment-engine.rst:24
msgid "Prerequisites"
msgstr "전제 조건"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:9
msgid "`Python 3.10 <https://docs.python.org/3.10/>`_ or above"
msgstr "Python 3.10 <https://docs.python.org/3.10/>`_ 이상"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:10
msgid "`Poetry 1.3 <https://python-poetry.org/>`_ or above"
msgstr "`Poetry 1.3 <https://python-poetry.org/>`_ _ 이상"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:11
msgid "(Optional) `pyenv <https://github.com/pyenv/pyenv>`_"
msgstr "(선택 사항) `pyenv <https://github.com/pyenv/pyenv>`_"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:12
msgid "(Optional) `pyenv-virtualenv <https://github.com/pyenv/pyenv-virtualenv>`_"
msgstr "(선택 사항) `pyenv-virtualenv <https://github.com/pyenv/pyenv-virtualenv>`_"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:14
#, fuzzy
msgid ""
"Flower uses ``pyproject.toml`` to manage dependencies and configure "
"development tools (the ones which support it). Poetry is a build tool "
"which supports `PEP 517 <https://peps.python.org/pep-0517/>`_."
msgstr ""
"Flower는 dependencies을 관리하고 개발 도구(이를 지원하는 도구)를 구성하기 위해 "
":code:`pyproject.toml`을 사용합니다. Poetry는 `PEP 517 "
"<https://peps.python.org/pep-0517/>`_을 지원하는 빌드 도구입니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:20
msgid "Developer Machine Setup"
msgstr "개발자 머신 설정"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:23
#, fuzzy
msgid "Preliminaries"
msgstr "사전 준비"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:25
msgid "Some system-wide dependencies are needed."
msgstr "일부 시스템 전체에 대한 의존성이 필요합니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:28
msgid "For macOS"
msgstr "macOS의 경우"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:30
msgid ""
"Install `homebrew <https://brew.sh/>`_. Don't forget the post-"
"installation actions to add `brew` to your PATH."
msgstr "`homebrew <https://brew.sh/>`_를 설치합니다. 설치 후 `brew`를 PATH에 추가하는 작업을 잊지 마세요."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:32
#, fuzzy
msgid ""
"Install `xz` (to install different Python versions) and `pandoc` to build"
" the docs:"
msgstr "xz`(다른 Python 버전을 설치하려면)와 `pandoc`을 설치하여 문서를 빌드합니다::"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:39
msgid "For Ubuntu"
msgstr "Ubuntu의 경우"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:41
#, fuzzy
msgid ""
"Ensure you system (Ubuntu 22.04+) is up-to-date, and you have all "
"necessary packages:"
msgstr "시스템(우분투 22.04 이상)이 최신 상태이고 필요한 패키지가 모두 설치되어 있는지 확인하세요:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:50
msgid "Create Flower Dev Environment"
msgstr "Flower 개발 환경 만들기"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:52
#, fuzzy
msgid ""
"Clone the `Flower repository <https://github.com/adap/flower>`_ from "
"GitHub:"
msgstr "1. GitHub: 에서 ``Flower 레포지토리 <https://github.com/adap/flower>`_를 복제합니다::"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:59
msgid ""
"Create and activate a Python virtual environment for development. See "
"`Set up a virtual env <contributor-how-to-set-up-a-virtual-env.rst>`_ for"
" detailed instructions."
msgstr ""

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:63
msgid ""
"One way to do this is by using `pyenv <https://github.com/pyenv/pyenv>`_ "
"and `pyenv-virtualenv <https://github.com/pyenv/pyenv-virtualenv>`_. You "
"can also optionally install a specific Python version using pyenv if you "
"haven't already installed your desired version:"
msgstr ""

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:74
msgid ""
"Install Poetry, which is used to manage dependencies and development "
"workflows:"
msgstr ""

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:80
msgid ""
"Navigate to the ``framework`` directory and install the Flower project in"
" development mode, including all optional dependencies:"
msgstr ""

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:90
msgid "Convenience Scripts"
msgstr "편의 스크립트"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:92
#, fuzzy
msgid ""
"The Flower repository contains a number of convenience scripts to make "
"recurring development tasks easier and less error-prone. See the ``/dev``"
" subdirectory for a full list. The following scripts are amongst the most"
" important ones:"
msgstr ""
"Flower 레포지토리에는 반복적인 개발 작업을 더 쉽고 오류를 줄이기 위한 여러 가지 편의 스크립트가 포함되어 있습니다. 전체 "
"목록은 :code:`/dev` 하위 디렉터리를 참조하세요. 다음 스크립트는 가장 중요한 스크립트 중 하나입니다:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:97
msgid "Compile ProtoBuf Definitions"
msgstr "ProtoBuf 정의 컴파일"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:104
msgid "Auto-Format Code"
msgstr "자동 포맷 코드"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:111
msgid "Run Linters and Tests"
msgstr "린터 및 테스트 실행"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:118
msgid "Add a pre-commit hook"
msgstr "사전 커밋 훅 추가"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:120
#, fuzzy
msgid ""
"Developers may integrate a pre-commit hook into their workflow utilizing "
"the `pre-commit <https://pre-commit.com/#install>`_ library. The pre-"
"commit hook is configured to execute two primary operations: "
"``./framework/dev/format.sh`` and ``./framework/dev/test.sh`` scripts."
msgstr ""
"개발자는 `pre-commit <https://pre-commit.com/#install>`_ 라이브러리를 사용하여 사전 커밋 훅을"
" 워크플로에 통합할 수 있습니다. 사전 커밋 훅은 두 가지 기본 작업을 실행하도록 구성됩니다:``./dev/format.sh`` 및"
" ``./dev/test.sh`` 스크립트."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:125
msgid "There are multiple ways developers can use this:"
msgstr "개발자가 이것을 사용할 수 있는 여러가지 방법이 있습니다:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:127
msgid "Install the pre-commit hook to your local git directory by simply running:"
msgstr "간단하게 실행하여 로컬 git 디렉터리에 사전 커밋 훅을 설치하세요:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:133
msgid ""
"Each ``git commit`` will trigger the execution of formatting and "
"linting/test scripts."
msgstr "각 ``git 커밋``은 포맷 및 린팅/테스트 스크립트의 실행을 트리거합니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:135
#, fuzzy
msgid ""
"If in a hurry, bypass the hook using ``--no-verify`` with the ``git "
"commit`` command."
msgstr "급한 경우 ``git commit`` 명령과 함께 `--no-verify``를 사용하여 훅을 넘기세요:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:142
msgid ""
"For developers who prefer not to install the hook permanently, it is "
"possible to execute a one-time check prior to committing changes by using"
" the following command:"
msgstr "훅을 영구적으로 설치하지 않으려는 개발자의 경우 다음 명령을 사용하여 변경 사항을 커밋하기 전에 일회성 검사를 실행할 수 있습니다:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:149
msgid ""
"This executes the formatting and linting checks/tests on all the files "
"without modifying the default behavior of ``git commit``."
msgstr "이렇게 하면 ``git commit``의 기본 동작을 수정하지 않고 모든 파일에 대해 포맷 및 린팅 검사/테스트를 실행합니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:153
msgid "Run Github Actions (CI) locally"
msgstr "로컬에서 Github Action(CI) 실행하기"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:155
#, fuzzy
msgid ""
"Developers could run the full set of Github Actions workflows under their"
" local environment by using `Act <https://github.com/nektos/act>`_. "
"Please refer to the installation instructions under the linked repository"
" and run the next command under Flower main cloned repository folder:"
msgstr ""
"개발자는 `Act <https://github.com/nektos/act>`_를 사용하여 로컬 환경에서 전체 Github "
"Actions 워크플로우 세트를 실행할 수 있습니다. 링크된 레포지토리 아래의 설치 지침을 참조하여 Flower 메인 클론 "
"레포지토리 폴더 아래에서 다음 명령을 실행하세요::"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:164
msgid ""
"The Flower default workflow would run by setting up the required Docker "
"machines underneath."
msgstr "Flower 기본 워크플로우는 아래에 필요한 Docker 머신을 설정하여 실행합니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:169
msgid "Build Release"
msgstr "릴리즈 빌드"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:171
#, fuzzy
msgid ""
"Flower uses Poetry to build releases. The necessary command is wrapped in"
" a simple script:"
msgstr "Flower는 Poetry를 사용하여 릴리즈를 빌드합니다. 필요한 명령은 간단한 스크립트로 래핑됩니다::"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:178
#, fuzzy
msgid ""
"The resulting ``.whl`` and ``.tar.gz`` releases will be stored in the "
"``./framework/dist`` subdirectory."
msgstr "결과물인 :code:`.whl` 및 :code:`.tar.gz` 릴리즈는 :code:`/dist` 하위 디렉터리에 저장됩니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:183
msgid "Build Documentation"
msgstr "문서 빌드"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:185
#, fuzzy
msgid ""
"Flower's documentation uses `Sphinx <https://www.sphinx-doc.org/>`_. To "
"build the documentation locally, run the following script:"
msgstr ""
"Flower의 문서는 `Sphinx <https://www.sphinx-doc.org/>`_를 사용합니다. 아직 문서를 다시 작성할"
" 수 있는 편리한 스크립트는 없지만 다음과 같이 쉽게 작성할 수 있습니다:"

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:192
#, fuzzy
msgid "This will generate HTML documentation in ``./framework/doc/build/html``."
msgstr "그러면 ``doc/build/html``에 HTML 문서가 생성됩니다."

#: ../../source/contributor-tutorial-get-started-as-a-contributor.rst:194
#, fuzzy
msgid ""
"Note that, in order to build the documentation locally, `Pandoc "
"<https://pandoc.org/installing.html>`_ needs to be installed on the "
"system."
msgstr ""
"로컬에서 문서를 작성하려면(아래 설명과 같이 ``poetry run make html``로) `Pandoc "
"<https://pandoc.org/installing.html>`_이 시스템에 설치되어 있어야 합니다."

#: ../../source/deploy.rst:-1
msgid ""
"Deploy with the Flower Deployment Runtime using step-by-step guides on "
"TLS, authentication, logging, Docker, Azure, and more for secure, "
"scalable solutions."
msgstr ""

#: ../../source/deploy.rst:7
msgid "Deploy using the Flower Deployment Runtime"
msgstr ""

#: ../../source/docker/enable-tls.rst:-1
msgid ""
"Enable TLS in Flower for secure communication with encrypted data "
"transmission using PEM-encoded certificates and private keys."
msgstr ""

#: ../../source/docker/enable-tls.rst:7
#, fuzzy
msgid "Enable TLS for Secure Connections"
msgstr "보안 연결을 위한 SSL 사용 설정"

#: ../../source/docker/enable-tls.rst:9
msgid ""
"When operating in a production environment, it is strongly recommended to"
" enable Transport Layer Security (TLS) for each Flower component to "
"ensure secure communication."
msgstr ""

#: ../../source/docker/enable-tls.rst:14
msgid ""
"For testing purposes, you can generate your own self-signed certificates."
" The `Enable SSL connections <https://flower.ai/docs/framework/how-to-"
"enable-ssl-connections.html#certificates>`__ page contains a section that"
" will guide you through the process."
msgstr ""
"테스트 목적으로 자체 서명된 인증서를 생성할 수 있습니다. 'SSL 연결 사용 "
"<https://flower.ai/docs/framework/how-to-enable-ssl-"
"connections.html#certificates>`__ 페이지에 프로세스를 안내하는 섹션이 있습니다."

#: ../../source/docker/enable-tls.rst:21
msgid ""
"When working with Docker on Linux, you may need to change the ownership "
"of the directory containing the certificates to ensure proper access and "
"permissions."
msgstr ""

#: ../../source/docker/enable-tls.rst:24
#, fuzzy
msgid ""
"By default, Flower containers run with a non-root user ``app``. The "
"mounted files and directories must have the proper permissions for the "
"user ID ``49999``."
msgstr ""
"기본적으로 Flower 컨테이너는 루트가 아닌 사용자 ``app``로 실행되므로 마운트된 파일과 디렉터리에 사용자 ID "
"``49999``에 대한 적절한 권한이 있어야 합니다. 예를 들어, ``certificates/`` 디렉터리에 있는 모든 파일의 "
"사용자 ID를 변경하려면 ``sudo chown -R 49999:49999 certificates/*``를 실행하면 됩니다."

#: ../../source/docker/enable-tls.rst:27
#, fuzzy
msgid ""
"For example, to change the user ID of all files in the ``certificates/`` "
"directory, you can run ``sudo chown -R 49999:49999 certificates/*``."
msgstr ""
"기본적으로 Flower 컨테이너는 루트가 아닌 사용자 ``app``로 실행되므로 마운트된 파일과 디렉터리에 사용자 ID "
"``49999``에 대한 적절한 권한이 있어야 합니다. 예를 들어, ``certificates/`` 디렉터리에 있는 모든 파일의 "
"사용자 ID를 변경하려면 ``sudo chown -R 49999:49999 certificates/*``를 실행하면 됩니다."

#: ../../source/docker/enable-tls.rst:30
msgid ""
"If you later want to delete the directory, you can change the user ID "
"back to the current user ID by running ``sudo chown -R $USER:$(id -gn) "
"certificates``."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "Isolation Mode ``subprocess``"
msgstr ""

#: ../../source/docker/enable-tls.rst:37
msgid ""
"By default, the ServerApp is executed as a subprocess within the "
"SuperLink Docker container, and the ClientApp is run as a subprocess "
"within the SuperNode Docker container. You can learn more about the "
"different process modes here: :doc:`run-as-subprocess`."
msgstr ""

#: ../../source/docker/enable-tls.rst:42 ../../source/docker/enable-tls.rst:127
#, fuzzy
msgid ""
"To enable TLS between the SuperLink and SuperNode, as well as between the"
" SuperLink and the ``flwr`` CLI, you will need a PEM-encoded root "
"certificate, private key, and certificate chain."
msgstr "SSL을 사용하려면 PEM으로 인코딩된 루트 인증서, PEM으로 인코딩된 개인 키 및 PEM으로 인코딩된 인증서 체인이 필요합니다."

#: ../../source/docker/enable-tls.rst:45
#, fuzzy
msgid "**SuperLink**"
msgstr "flower 초연결"

#: ../../source/docker/enable-tls.rst:47
#, fuzzy
msgid ""
"Assuming all files we need are in the local ``superlink-certificates`` "
"directory, we can use the flag ``--volume`` to mount the local "
"directories into the SuperLink container:"
msgstr ""
"인증서가 이미 로컬에 존재한다고 가정하면, ``--volume`` 플래그를 사용하여 로컬 인증서를 컨테이너의 ``/app/`` "
"디렉터리에 마운트할 수 있습니다. 이렇게 하면 SuperNode가 컨테이너 내의 인증서에 액세스할 수 있습니다. 컨테이너를 시작할 "
"때 ``--root-certificates`` 플래그를 사용하세요."

#: ../../source/docker/enable-tls.rst
msgid "Understanding the command"
msgstr ""

#: ../../source/docker/enable-tls.rst:62 ../../source/docker/enable-tls.rst:104
#: ../../source/docker/enable-tls.rst:148
#: ../../source/docker/enable-tls.rst:187
#: ../../source/docker/enable-tls.rst:214
#: ../../source/docker/enable-tls.rst:239
#: ../../source/docker/tutorial-quickstart-docker.rst:81
#: ../../source/docker/tutorial-quickstart-docker.rst:123
#: ../../source/docker/tutorial-quickstart-docker.rst:239
#: ../../source/docker/tutorial-quickstart-docker.rst:277
#, fuzzy
msgid "``docker run``: This tells Docker to run a container from an image."
msgstr "``docker run``: 새 Docker 컨테이너를 실행하는 명령입니다."

#: ../../source/docker/enable-tls.rst:63 ../../source/docker/enable-tls.rst:105
#: ../../source/docker/enable-tls.rst:149
#: ../../source/docker/enable-tls.rst:188
#: ../../source/docker/enable-tls.rst:215
#: ../../source/docker/enable-tls.rst:240
#: ../../source/docker/tutorial-quickstart-docker.rst:82
#: ../../source/docker/tutorial-quickstart-docker.rst:124
#: ../../source/docker/tutorial-quickstart-docker.rst:240
#: ../../source/docker/tutorial-quickstart-docker.rst:278
msgid "``--rm``: Remove the container once it is stopped or the command exits."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--volume ./superlink-certificates/:/app/certificates/:ro``: Mount the "
"``superlink-certificates``"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"directory in the current working directory of the host machine as a read-"
"only volume"
msgstr ""

#: ../../source/docker/enable-tls.rst
#, fuzzy
msgid "at the ``/app/certificates`` directory inside the container."
msgstr "VSCode Dev Container에서 개발"

#: ../../source/docker/enable-tls.rst
msgid ""
"This allows the container to access the TLS certificates that are stored "
"in the certificates"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "directory."
msgstr ""

#: ../../source/docker/enable-tls.rst:70
msgid "``<superlink-image>``: The name of your SuperLink image to be run."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--ssl-ca-certfile certificates/ca.crt``: Specify the location of the CA"
" certificate file"
msgstr ""

#: ../../source/docker/enable-tls.rst
#, fuzzy
msgid "inside the container."
msgstr "VSCode Dev Container에서 개발"

#: ../../source/docker/enable-tls.rst
msgid ""
"The ``certificates/ca.crt`` file is a certificate that is used to verify "
"the identity of the"
msgstr ""

#: ../../source/docker/enable-tls.rst
#, fuzzy
msgid "SuperLink."
msgstr "flower 초연결"

#: ../../source/docker/enable-tls.rst
msgid ""
"``--ssl-certfile certificates/server.pem``: Specify the location of the "
"SuperLink's"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "TLS certificate file inside the container."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"The ``certificates/server.pem`` file is used to identify the SuperLink "
"and to encrypt the"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "data that is transmitted over the network."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--ssl-keyfile certificates/server.key``: Specify the location of the "
"SuperLink's"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "TLS private key file inside the container."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"The ``certificates/server.key`` file is used to decrypt the data that is "
"transmitted over"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "the network."
msgstr ""

#: ../../source/docker/enable-tls.rst:87
#, fuzzy
msgid "**SuperNode**"
msgstr "run\\_supernode"

#: ../../source/docker/enable-tls.rst:91 ../../source/docker/enable-tls.rst:197
msgid ""
"If you're generating self-signed certificates and the ``ca.crt`` "
"certificate doesn't exist on the SuperNode, you can copy it over after "
"the generation step."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--volume ./superlink-certificates/ca.crt:/app/ca.crt/:ro``: Mount the "
"``ca.crt``"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"file from the ``superlink-certificates`` directory of the host machine as"
" a read-only"
msgstr ""

#: ../../source/docker/enable-tls.rst
#, fuzzy
msgid "volume at the ``/app/ca.crt`` directory inside the container."
msgstr "VSCode Dev Container에서 개발"

#: ../../source/docker/enable-tls.rst:109
msgid "``<supernode-image>``: The name of your SuperNode image to be run."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--root-certificates ca.crt``: This specifies the location of the CA "
"certificate file"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "The ``ca.crt`` file is used to verify the identity of the SuperLink."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "Isolation Mode ``process``"
msgstr ""

#: ../../source/docker/enable-tls.rst:117
msgid ""
"In isolation mode ``process``, the ServerApp and ClientApp run in their "
"own processes. Unlike in isolation mode ``subprocess``, the SuperLink or "
"SuperNode does not attempt to create the respective processes; instead, "
"they must be created externally."
msgstr ""

#: ../../source/docker/enable-tls.rst:121
msgid ""
"It is possible to run only the SuperLink in isolation mode ``subprocess``"
" and the SuperNode in isolation mode ``process``, or vice versa, or even "
"both with isolation mode ``process``."
msgstr ""

#: ../../source/docker/enable-tls.rst:125
msgid "**SuperLink and ServerApp**"
msgstr ""

#: ../../source/docker/enable-tls.rst:130
#, fuzzy
msgid ""
"Assuming all files we need are in the local ``superlink-certificates`` "
"directory, we can use the flag ``--volume`` to mount the local directory "
"into the SuperLink container:"
msgstr ""
"인증서가 이미 로컬에 존재한다고 가정하면, ``--volume`` 플래그를 사용하여 로컬 인증서를 컨테이너의 ``/app/`` "
"디렉터리에 마운트할 수 있습니다. 이렇게 하면 SuperNode가 컨테이너 내의 인증서에 액세스할 수 있습니다. 컨테이너를 시작할 "
"때 ``--root-certificates`` 플래그를 사용하세요."

#: ../../source/docker/enable-tls.rst
msgid "``--volume ./superlink-certificates/:/app/certificates/:ro``: Mount the"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``superlink-certificates`` directory in the current working directory of "
"the host"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"machine as a read-only volume at the ``/app/certificates`` directory "
"inside the container."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
":substitution-code:`flwr/superlink:|stable_flwr_version|`: The name of "
"the image to be run and the specific"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"tag of the image. The tag :substitution-code:`|stable_flwr_version|` "
"represents a specific version of the image."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--isolation process``: Tells the SuperLink that the ServerApp is "
"created by separate"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "independent process. The SuperLink does not attempt to create it."
msgstr ""

#: ../../source/docker/enable-tls.rst:176
#, fuzzy
msgid "Start the ServerApp container:"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/docker/enable-tls.rst
#: ../../source/docker/tutorial-quickstart-docker-compose.rst
#: ../../source/docker/tutorial-quickstart-docker.rst
#: ../../source/how-to-authenticate-supernodes.rst
#: ../../source/how-to-enable-tls-connections.rst
#: ../../source/how-to-run-flower-with-deployment-engine.rst
msgid "Understand the command"
msgstr ""

#: ../../source/docker/enable-tls.rst:189
msgid "``<serverapp-image>``: The name of your ServerApp image to be run."
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--insecure``:  This flag tells the container to operate in an insecure "
"mode, allowing"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"unencrypted communication. Secure connections will be added in future "
"releases."
msgstr ""

#: ../../source/docker/enable-tls.rst:193
msgid "**SuperNode and ClientApp**"
msgstr ""

#: ../../source/docker/enable-tls.rst:200
#, fuzzy
msgid "Start the SuperNode container:"
msgstr "이미 *서버*를 시작할 수 있습니다:"

#: ../../source/docker/enable-tls.rst
msgid ""
"``--volume ./superlink-certificates/ca.crt:/app/ca.crt/:ro``: Mount the "
"``ca.crt`` file from the"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``superlink-certificates`` directory of the host machine as a read-only "
"volume at the ``/app/ca.crt``"
msgstr ""

#: ../../source/docker/enable-tls.rst
#, fuzzy
msgid "directory inside the container."
msgstr "VSCode Dev Container에서 개발"

#: ../../source/docker/enable-tls.rst
msgid ""
":substitution-code:`flwr/supernode:|stable_flwr_version|`: The name of "
"the image to be run and the specific"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid ""
"``--isolation process``: Tells the SuperNode that the ClientApp is "
"created by separate"
msgstr ""

#: ../../source/docker/enable-tls.rst
msgid "independent process. The SuperNode does not attempt to create it."
msgstr ""

#: ../../source/docker/enable-tls.rst:228
#, fuzzy
msgid "Start the ClientApp container:"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/docker/enable-tls.rst:241
msgid "``<clientapp-image>``: The name of your ClientApp image to be run."
msgstr ""

#: ../../source/docker/enable-tls.rst:245
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:61
#, fuzzy
msgid ""
"Append the following lines to the end of the ``pyproject.toml`` file and "
"save it:"
msgstr "``pyproject.toml``에 다음 버전 제약 조건을 설정했는지 확인하세요:"

#: ../../source/docker/enable-tls.rst:247
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:63
#: ../../source/docker/tutorial-quickstart-docker.rst:310
#: ../../source/how-to-enable-tls-connections.rst:127
#: ../../source/how-to-manage-flower-federations.rst:69
#: ../../source/how-to-run-flower-with-deployment-engine.rst:179
#: ../../source/how-to-upgrade-to-message-api.rst:132
#, fuzzy
msgid "pyproject.toml"
msgstr "또는 ``pyproject.toml``:"

#: ../../source/docker/enable-tls.rst:254
#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:163
msgid ""
"The path of the ``root-certificates`` should be relative to the location "
"of the ``pyproject.toml`` file."
msgstr ""

#: ../../source/docker/enable-tls.rst:259
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:72
#: ../../source/how-to-run-flower-with-deployment-engine.rst:188
msgid ""
"You can customize the string that follows ``tool.flwr.federations.`` to "
"fit your needs. However, please note that the string cannot contain a dot"
" (``.``)."
msgstr ""

#: ../../source/docker/enable-tls.rst:262
msgid ""
"In this example, ``local-deployment-tls`` has been used. Just remember to"
" replace ``local-deployment-tls`` with your chosen name in both the "
"``tool.flwr.federations.`` string and the corresponding ``flwr run .`` "
"command."
msgstr ""

#: ../../source/docker/index.rst:-1
msgid ""
"Learn how to run Flower for federated learning using Docker with pre-made"
" images, including advanced options and Docker Compose for seamless "
"deployment."
msgstr ""

#: ../../source/docker/index.rst:7
msgid "Run Flower using Docker"
msgstr "Docker를 사용하여 Flower 실행"

#: ../../source/docker/index.rst:9
msgid ""
"Start your Flower journey with our pre-made Docker images on Docker Hub, "
"supporting ``amd64`` and ``arm64v8`` architectures."
msgstr ""

#: ../../source/docker/index.rst:12
msgid ""
"Our Quickstart guide walks you through containerizing a Flower project "
"and running it end to end using Docker."
msgstr ""

#: ../../source/docker/index.rst:17
#, fuzzy
msgid "Getting Started"
msgstr "시작하기"

#: ../../source/docker/index.rst:26 ../../source/helm/index.rst:39
msgid "Running in Production"
msgstr ""

#: ../../source/docker/index.rst:36
#, fuzzy
msgid "Advanced Options"
msgstr "고급 Docker 옵션"

#: ../../source/docker/index.rst:49
#, fuzzy
msgid "Run Flower using Docker Compose"
msgstr "Docker를 사용하여 Flower 실행"

#: ../../source/docker/persist-superlink-state.rst:-1
msgid ""
"Persist SuperLink state in Flower by saving it to a local directory, "
"ensuring data retention across Docker container restarts."
msgstr ""

#: ../../source/docker/persist-superlink-state.rst:7
msgid "Persist the State of the SuperLink"
msgstr ""

#: ../../source/docker/persist-superlink-state.rst:9
#, fuzzy
msgid ""
"By default, the Flower SuperLink keeps its state in-memory. When using "
"the Docker flag ``--rm``, the state is not persisted between container "
"starts."
msgstr ""
"기본적으로 Flower SuperLink는 상태를 in-memory에 유지합니다. Docker 플래그 `--rm``을 사용하는 경우"
" 컨테이너 시작 사이에 상태가 유지되지 않습니다. 아래에서 호스트 시스템의 파일에 상태를 저장하는 방법을 보여드리겠습니다."

#: ../../source/docker/persist-superlink-state.rst:12
msgid ""
"If you want to persist the state of the SuperLink on your host system, "
"all you need to do is specify a directory where you want to save the file"
" on your host system and a name for the database file."
msgstr ""

#: ../../source/docker/persist-superlink-state.rst:16
msgid ""
"By default, the SuperLink container runs with a non-root user called "
"``app`` with the user ID ``49999``. When working with Docker on Linux, it"
" is recommended to create a new directory and set the user ID to "
"``49999`` to ensure the mounted directory has the proper permissions."
msgstr ""

#: ../../source/docker/persist-superlink-state.rst:21
msgid ""
"If you later want to delete the directory, you can change the user ID "
"back to the current user ID by running ``sudo chown -R $USER:$(id -gn) "
"state``."
msgstr ""

#: ../../source/docker/persist-superlink-state.rst:28
#, fuzzy
msgid ""
"In the example below, we create a new directory called ``state``, change "
"the user ID and tell Docker via the flag ``--volume`` to mount the local "
"``state`` directory into the ``/app/state`` directory of the container. "
"Lastly, we use the flag ``--database`` to specify the name of the "
"database file."
msgstr ""
"아래 예에서는 새 디렉터리를 생성하고, 사용자 ID를 변경하고, 플래그 ``--volume``을 통해 Docker에게 로컬 "
"``state`` 디렉터리를 컨테이너의 ``/app/state`` 디렉터리에 마운트하도록 지시합니다. 또한 "
"``--database`` 플래그를 사용하여 데이터베이스 파일의 이름을 지정합니다."

#: ../../source/docker/persist-superlink-state.rst:43
#, fuzzy
msgid ""
"As soon as the SuperLink starts, the file ``state.db`` is created in the "
"``state`` directory on your host system. If the file already exists, the "
"SuperLink tries to restore the state from the file. To start the "
"SuperLink with an empty database, ensure that there is no database called"
" ``state.db`` in the ``state`` directory (``rm state.db``) before you "
"execute the ``docker run`` command above."
msgstr ""
"SuperLink가 시작되자마자 호스트 시스템의 ``state`` 디렉터리에 ``state.db`` 파일이 생성됩니다. 파일이 이미"
" 존재하는 경우 SuperLink는 파일에서 상태를 복원하려고 시도합니다. 빈 데이터베이스로 SuperLink를 시작하려면 "
"``state.db`` 파일을 제거하면 됩니다."

#: ../../source/docker/pin-version.rst:-1
msgid ""
"Pin Flower Docker images to specific versions using image digests, "
"ensuring consistent deployments while receiving essential security "
"updates."
msgstr ""

#: ../../source/docker/pin-version.rst:7
#, fuzzy
msgid "Pin a Docker Image to a Specific Version"
msgstr "특정 버전에 Docker 이미지 고정하기"

#: ../../source/docker/pin-version.rst:9
#, fuzzy
msgid ""
"It may happen that we update the images behind the tags. Such updates "
"usually include security updates of system dependencies that should not "
"change the functionality of Flower. However, if you want to ensure that "
"you use a fixed version of the Docker image in your deployments, you can "
"`specify the digest "
"<https://docs.docker.com/reference/cli/docker/image/pull/#pull-an-image-"
"by-digest-immutable-identifier>`_ of the image instead of the tag."
msgstr ""
"태그 뒤에 있는 이미지가 업데이트될 수 있습니다. 이러한 업데이트에는 일반적으로 Flower의 기능을 변경해서는 안 되는 시스템 "
"의존성에 대한 보안 업데이트가 포함됩니다. 그러나 항상 동일한 이미지를 사용하려면 태그 대신 이미지의 해시를 지정할 수 있습니다."

#: ../../source/docker/pin-version.rst:20
#, fuzzy
msgid ""
"The following command returns the current image digest referenced by the "
":substitution-code:`superlink:|stable_flwr_version|` tag:"
msgstr "다음 명령은 ``superlink:1.8.0`` 태그가 참조하는 현재 이미지 해시를 반환합니다:"

#: ../../source/docker/pin-version.rst:29
msgid "This will output"
msgstr ""

#: ../../source/docker/pin-version.rst:36
#, fuzzy
msgid "Next, we can pin the digest when running a new SuperLink container:"
msgstr "다음으로, 새 SuperLink 컨테이너를 실행할 때 해시를 고정할 수 있습니다:"

#: ../../source/docker/run-as-root-user.rst:-1
msgid ""
"Run Flower Docker containers with root privileges for specific build "
"tasks, adhering to security best practices for production environments."
msgstr ""

#: ../../source/docker/run-as-root-user.rst:7
#, fuzzy
msgid "Run with Root User Privileges"
msgstr "루트 사용자 권한으로 실행"

#: ../../source/docker/run-as-root-user.rst:9
#, fuzzy
msgid ""
"Flower Docker images, by default, run with a non-root user "
"(username/groupname: ``app``, UID/GID: ``49999``). Using root user is "
"**not recommended** unless it is necessary for specific tasks during the "
"build process."
msgstr ""
"기본적으로 Flower Docker 이미지는 루트 사용자가 아닌 사용자(사용자명/그룹명:``app``, UID/GID: "
"``49999``)로 실행됩니다. 빌드 프로세스 중 특정 작업에 필요한 경우가 아니라면 루트 사용자를 사용하지 않는 것이 좋습니다."
" 보안 모범 사례를 유지하려면 항상 프로덕션 환경에서 루트 사용자가 아닌 사용자로 컨테이너를 실행해야 합니다."

#: ../../source/docker/run-as-root-user.rst:13
msgid ""
"Always make sure to run the container as a non-root user in production to"
" maintain security best practices."
msgstr ""

#: ../../source/docker/run-as-root-user.rst:18
#, fuzzy
msgid "Run a Container with Root User Privileges"
msgstr "**루트 사용자 권한으로 컨테이너 실행하기**"

#: ../../source/docker/run-as-root-user.rst:20
msgid ""
"Run the Docker image with the ``-u`` flag and specify ``root`` as the "
"username:"
msgstr "``-u`` 플래그를 사용하여 Docker 이미지를 실행하고 사용자 이름으로 ``root``를 지정합니다:"

#: ../../source/docker/run-as-root-user.rst:27
msgid "This command will run the Docker container with root user privileges."
msgstr "이 명령은 루트 사용자 권한으로 Docker 컨테이너를 실행합니다."

#: ../../source/docker/run-as-root-user.rst:31
#, fuzzy
msgid "Run the Build Process with Root User Privileges"
msgstr "**루트 사용자 권한으로 빌드 프로세스를 실행합니다**"

#: ../../source/docker/run-as-root-user.rst:33
msgid ""
"If you want to switch to the root user during the build process of the "
"Docker image to install missing system dependencies, you can use the "
"``USER root`` directive within your Dockerfile."
msgstr ""
"Docker 이미지 빌드 과정에서 루트 사용자로 전환하여 누락된 시스템 의존성을 설치하려면 Dockerfile 내에서 ``USER "
"root`` 지시어를 사용할 수 있습니다."

#: ../../source/docker/run-as-root-user.rst:37
#, fuzzy
msgid "SuperNode Dockerfile"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/docker/run-as-subprocess.rst:-1
msgid ""
"Execute Flower ServerApp and ClientApp as subprocesses within SuperLink "
"and SuperNode Docker containers to optimize resource usage, isolation, "
"and security."
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:7
#, fuzzy
msgid "Run ServerApp or ClientApp as a Subprocess"
msgstr "린터 및 테스트 실행"

#: ../../source/docker/run-as-subprocess.rst:9
msgid ""
"The SuperLink and SuperNode components support two distinct isolation "
"modes, allowing for flexible deployment and control:"
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:12
msgid ""
"Subprocess Mode: In this configuration (default), the SuperLink and "
"SuperNode take responsibility for launching the ServerApp and ClientApp "
"processes internally. This differs from the ``process`` isolation-mode "
"which uses separate containers, as demonstrated in the :doc:`tutorial-"
"quickstart-docker` guide."
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:17
msgid ""
"Using the ``subprocess`` approach reduces the number of running "
"containers, which can be beneficial for environments with limited "
"resources. However, it also means that the applications are not isolated "
"from their parent containers, which may introduce additional security "
"concerns."
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:22
msgid ""
"Process Mode: In this mode, the ServerApp and ClientApps run in "
"completely separate processes. Unlike the alternative Subprocess mode, "
"the SuperLink or SuperNode does not attempt to create or manage these "
"processes. Instead, they must be started externally."
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:27
msgid ""
"Both modes can be mixed for added flexibility. For instance, you can run "
"the SuperLink in ``subprocess`` mode while keeping the SuperNode in "
"``process`` mode, or vice versa."
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:30
msgid ""
"To run the SuperLink and SuperNode in isolation mode ``process``, refer "
"to the :doc:`tutorial-quickstart-docker` guide. To run them in "
"``subprocess`` mode, follow the instructions below."
msgstr ""

#: ../../source/docker/run-as-subprocess.rst
#: ../../source/ref-api/flwr.serverapp.ServerApp.rst:2
msgid "ServerApp"
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:38
#: ../../source/docker/run-as-subprocess.rst:79
#, fuzzy
msgid "**Prerequisites**"
msgstr "전제 조건"

#: ../../source/docker/run-as-subprocess.rst:40
msgid ""
"1. Before running the ServerApp as a subprocess, ensure that the FAB "
"dependencies have been installed in the SuperLink images. This can be "
"done by extending the SuperLink image:"
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:43
#, fuzzy
msgid "superlink.Dockerfile"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/docker/run-as-subprocess.rst:57
#, fuzzy
msgid ""
"2. Next, build the SuperLink Docker image by running the following "
"command in the directory where Dockerfile is located:"
msgstr ""
"다음으로, Dockerfile 및 ClientApp 코드가 있는 디렉터리에서 다음 명령을 실행하여 SuperNode Docker "
"이미지를 빌드합니다."

#: ../../source/docker/run-as-subprocess.rst:64
#, fuzzy
msgid "**Run the ServerApp as a Subprocess**"
msgstr "린터 및 테스트 실행"

#: ../../source/docker/run-as-subprocess.rst:66
msgid ""
"Start the SuperLink and run the ServerApp as a subprocess (note that the "
"subprocess mode is the default, so you do not have to explicitly set the "
"``--isolation`` flag):"
msgstr ""

#: ../../source/docker/run-as-subprocess.rst
#: ../../source/ref-api/flwr.clientapp.ClientApp.rst:2
msgid "ClientApp"
msgstr "클라이언트앱"

#: ../../source/docker/run-as-subprocess.rst:81
msgid ""
"1. Before running the ClientApp as a subprocess, ensure that the FAB "
"dependencies have been installed in the SuperNode images. This can be "
"done by extending the SuperNode image:"
msgstr ""

#: ../../source/docker/run-as-subprocess.rst:85
#, fuzzy
msgid "supernode.Dockerfile"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/docker/run-as-subprocess.rst:99
#, fuzzy
msgid ""
"2. Next, build the SuperNode Docker image by running the following "
"command in the directory where Dockerfile is located:"
msgstr ""
"다음으로, Dockerfile 및 ClientApp 코드가 있는 디렉터리에서 다음 명령을 실행하여 SuperNode Docker "
"이미지를 빌드합니다."

#: ../../source/docker/run-as-subprocess.rst:106
#, fuzzy
msgid "**Run the ClientApp as a Subprocess**"
msgstr "린터 및 테스트 실행"

#: ../../source/docker/run-as-subprocess.rst:108
msgid ""
"Start the SuperNode and run the ClientApp as a subprocess (note that the "
"subprocess mode is the default, so you do not have to explicitly set the "
"``--isolation`` flag):"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:-1
msgid ""
"Beginner’s guide to running Flower quickstart examples with the "
"Deployment Engine using Docker Compose, showcasing its powerful federated"
" learning capabilities."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:7
#, fuzzy
msgid "Run Flower Quickstart Examples with Docker Compose"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:9
msgid ""
"Flower provides a set of `quickstart examples "
"<https://github.com/adap/flower/tree/main/examples>`_ to help you get "
"started with the framework. These examples are designed to demonstrate "
"the capabilities of Flower and by default run using the Simulation "
"Engine. This guide demonstrates how to run them using Flower's Deployment"
" Engine via Docker Compose."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:17
msgid ""
"Some quickstart examples may have limitations or requirements that "
"prevent them from running on every environment. For more information, "
"please see Limitations_."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:24
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:21
#: ../../source/docker/tutorial-quickstart-docker.rst:19
#: ../../source/how-to-run-flower-with-deployment-engine.rst:26
#, fuzzy
msgid "Before you start, make sure that:"
msgstr "시작하기 전에 Docker daemon이 실행 중인지 확인하세요:"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:26
#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:28
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:23
#: ../../source/docker/tutorial-quickstart-docker.rst:21
msgid "The ``flwr`` CLI is :doc:`installed <../how-to-install-flower>` locally."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:27
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:24
#: ../../source/docker/tutorial-quickstart-docker.rst:22
#, fuzzy
msgid "The Docker daemon is running."
msgstr "Docker 데몬이 실행 중인지 확인하십시오."

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:28
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:25
msgid ""
"Docker Compose V2 is `installed "
"<https://docs.docker.com/compose/install/>`_."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:32
#, fuzzy
msgid "Run the Quickstart Example"
msgstr "예시 요청"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:34
msgid ""
"Clone the quickstart example you like to run. For example, ``quickstart-"
"pytorch``:"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:42
msgid ""
"Download the `compose.yml "
"<https://github.com/adap/flower/blob/main/framework/docker/complete/compose.yml>`_"
" file into the example directory:"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:52
#, fuzzy
msgid ""
"Export the version of Flower that your environment uses. Then, build and "
"start the services using the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:75
#: ../../source/how-to-run-flower-with-deployment-engine.rst:191
msgid ""
"In this example, ``local-deployment`` has been used. Just remember to "
"replace ``local-deployment`` with your chosen name in both the "
"``tool.flwr.federations.`` string and the corresponding ``flwr run .`` "
"command."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:79
msgid "Run the example and follow the logs of the ``ServerApp`` :"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:85
msgid ""
"That is all it takes! You can monitor the progress of the run through the"
" logs of the ``ServerApp``."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:90
msgid "Run a Different Quickstart Example"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:92
msgid ""
"To run a different quickstart example, such as ``quickstart-tensorflow``,"
" first, shut down the Docker Compose services of the current example:"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:99
msgid "After that, you can repeat the steps above."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:103
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:109
#, fuzzy
msgid "Limitations"
msgstr "동기"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:108
#, fuzzy
msgid "Quickstart Example"
msgstr "빠른 시작"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:110
#, fuzzy
msgid "quickstart-fastai"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:111
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:113
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:115
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:122
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:124
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:128
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:130
#: ../../source/docker/run-quickstart-examples-docker-compose.rst:132
#: ../../source/ref-changelog.md:978 ../../source/ref-changelog.md:1344
#: ../../source/ref-changelog.md:1619 ../../source/ref-changelog.md:1683
#: ../../source/ref-changelog.md:1741 ../../source/ref-changelog.md:1810
#: ../../source/ref-changelog.md:1872
msgid "None"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:112
#, fuzzy
msgid "quickstart-huggingface"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:114
#, fuzzy
msgid "quickstart-jax"
msgstr "빠른 시작"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:116
#, fuzzy
msgid "quickstart-mlcube"
msgstr "빠른 시작"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:117
msgid ""
"The example has not yet been updated to work with the latest ``flwr`` "
"version."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:118
#, fuzzy
msgid "quickstart-mlx"
msgstr "빠른 시작"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:119
msgid ""
"`Requires to run on macOS with Apple Silicon <https://ml-"
"explore.github.io/mlx/build/html/install.html#python-installation>`_."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:121
#, fuzzy
msgid "quickstart-monai"
msgstr "빠른 시작"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:123
#, fuzzy
msgid "quickstart-pandas"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:125
msgid "quickstart-pytorch-lightning"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:126
msgid ""
"Requires an older pip version that is not supported by the Flower Docker "
"images."
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:127
#, fuzzy
msgid "quickstart-pytorch"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:129
msgid "quickstart-sklearn-tabular"
msgstr ""

#: ../../source/docker/run-quickstart-examples-docker-compose.rst:131
#, fuzzy
msgid "quickstart-tensorflow"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/set-environment-variables.rst:-1
msgid ""
"Use the -e flag to configure environment variables in Flower Docker "
"containers, customizing telemetry, logging, and other settings for "
"federated learning."
msgstr ""

#: ../../source/docker/set-environment-variables.rst:7
#, fuzzy
msgid "Set Environment Variables"
msgstr "환경 변수 설정"

#: ../../source/docker/set-environment-variables.rst:9
#, fuzzy
msgid ""
"To set a variable inside a Docker container, you can use the ``-e "
"<name>=<value>`` flag. Multiple ``-e`` flags can be used to set multiple "
"environment variables for a container."
msgstr "Docker 컨테이너 내에서 변수를 설정하려면 ``-e <name>=<value>`` 플래그를 사용하면 됩니다."

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:-1
msgid ""
"Deploy a Flower project on multiple machines using Docker Compose to "
"configure server and client components with TLS encryption and persistent"
" SuperLink state."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:7
#, fuzzy
msgid "Deploy Flower on Multiple Machines with Docker Compose"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:9
msgid ""
"This guide will help you set up a Flower project on multiple machines "
"using Docker Compose."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:12
msgid ""
"You will learn how to run the Flower client and server components on two "
"separate machines, with Flower configured to use TLS encryption and "
"persist SuperLink state across restarts. A server consists of a SuperLink"
" and a ``ServerApp``. For more details about the Flower architecture, "
"refer to the :doc:`../explanation-flower-architecture` explainer page."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:18
msgid ""
"This guide assumes you have completed the :doc:`tutorial-quickstart-"
"docker-compose` tutorial. It is highly recommended that you follow and "
"understand the contents of that tutorial before proceeding with this "
"guide."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:26
msgid "Before you begin, make sure you have the following prerequisites:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:29
msgid "The Docker daemon is running on your local machine and the remote machine."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:30
msgid ""
"Docker Compose V2 is installed on both your local machine and the remote "
"machine."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:31
msgid "You can connect to the remote machine from your local machine."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:32
msgid "Ports ``9091`` and ``9093`` are accessible on the remote machine."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:36
msgid ""
"The guide uses the |quickstart_sklearn_tabular|_ example as an example "
"project."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:38
msgid ""
"If your project has a different name or location, please remember to "
"adjust the commands/paths accordingly."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:43
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:29
#: ../../source/docker/tutorial-quickstart-docker.rst:26
msgid "Step 1: Set Up"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:45
msgid "Clone the Flower repository and change to the ``distributed`` directory:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:53
msgid "Get the IP address from the remote machine and save it for later."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:54
msgid ""
"Use the ``certs.yml`` Compose file to generate your own self-signed "
"certificates. If you have certificates, you can continue with Step 2."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:59
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:224
msgid "These certificates should be used only for development purposes."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:61
msgid ""
"For production environments, you may have to use dedicated services to "
"obtain your certificates."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:64
msgid ""
"First, set the environment variable ``SUPERLINK_IP`` with the IP address "
"from the remote machine. For example, if the IP is ``192.168.2.33``, "
"execute:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:71
msgid "Next, generate the self-signed certificates:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:79
msgid "Step 2: Copy the Server Compose Files"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:81
msgid ""
"Use the method that works best for you to copy the ``server`` directory, "
"the certificates, and the ``pyproject.toml`` file of your Flower project "
"to the remote machine."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:85
msgid "For example, you can use ``scp`` to copy the directories:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:95
msgid "Step 3: Start the Flower Server Components"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:97
msgid ""
"Log into the remote machine using ``ssh`` and run the following command "
"to start the SuperLink and ``ServerApp`` services:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:111
msgid ""
"The path to the ``PROJECT_DIR`` containing the ``pyproject.toml`` file "
"should be relative to the location of the server ``compose.yml`` file."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:116
msgid ""
"When working with Docker Compose on Linux, you may need to create the "
"``state`` directory first and change its ownership to ensure proper "
"access and permissions. After exporting the ``PROJECT_DIR`` (after line "
"4), run the following commands:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:125
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:176
msgid ""
"For more information, consult the following page: :doc:`persist-"
"superlink-state`."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:127
msgid "Go back to your terminal on your local machine."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:131
#, fuzzy
msgid "Step 4: Start the Flower Client Components"
msgstr "서버(SuperLink)"

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:133
msgid ""
"On your local machine, run the following command to start the client "
"components:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:143
msgid ""
"The path to the ``PROJECT_DIR`` containing the ``pyproject.toml`` file "
"should be relative to the location of the client ``compose.yml`` file."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:148
#, fuzzy
msgid "Step 5: Run Your Flower Project"
msgstr "Flower SuperNode를 실행합니다."

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:150
msgid ""
"Specify the remote SuperLink IP addresses and the path to the root "
"certificate in the ``[tool.flwr.federations.remote-deployment]`` table in"
" the ``pyproject.toml`` file. Here, we have named our remote federation "
"``remote-deployment``:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:154
msgid "examples/quickstart-sklearn-tabular/pyproject.toml"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:166
msgid "Run the project and follow the ``ServerApp`` logs:"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:172
msgid ""
"That's it! With these steps, you've set up Flower on two separate "
"machines and are ready to start using it."
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:177
msgid "Step 6: Clean Up"
msgstr ""

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:179
#, fuzzy
msgid "Shut down the Flower client components:"
msgstr "Flower 클라이언트 앱을 실행합니다."

#: ../../source/docker/tutorial-deploy-on-multiple-machines.rst:186
msgid "Shut down the Flower server components and delete the SuperLink state:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:-1
msgid ""
"Containerize a Flower federated learning project and run it end-to-end "
"with this guide, including SuperLink, SuperNode, ServerApp, and ClientApp"
" setup."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:7
#, fuzzy
msgid "Quickstart with Docker"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/tutorial-quickstart-docker.rst:9
msgid ""
"This quickstart aims to guide you through the process of containerizing a"
" Flower project and running it end to end using Docker on your local "
"machine."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:12
msgid ""
"This tutorial does not use production-ready settings, so you can focus on"
" understanding the basic workflow that uses the minimum configurations."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:40
#: ../../source/docker/tutorial-quickstart-docker.rst:28
msgid "Create a new Flower project (PyTorch):"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:50
msgid "Create a new Docker bridge network called ``flwr-network``:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:56
msgid ""
"User-defined networks, such as ``flwr-network``, enable IP resolution of "
"container names, a feature absent in the default bridge network. This "
"simplifies quickstart example by avoiding the need to determine host IP "
"first."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:62
#, fuzzy
msgid "Step 2: Start the SuperLink"
msgstr "서버(SuperLink)"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:72
#: ../../source/docker/tutorial-quickstart-docker.rst:64
msgid "Open your terminal and run:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:83
msgid ""
"``-p 9091:9091 -p 9092:9092 -p 9093:9093``: Map port ``9091``, ``9092`` "
"and ``9093`` of the container to the same port of the host machine, "
"allowing other services to access the ServerAppIO API on "
"``http://localhost:9091``, the Fleet API on ``http://localhost:9092`` and"
" the Control API on ``http://localhost:9093``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:87
#: ../../source/docker/tutorial-quickstart-docker.rst:128
#: ../../source/docker/tutorial-quickstart-docker.rst:241
#: ../../source/docker/tutorial-quickstart-docker.rst:279
msgid ""
"``--network flwr-network``: Make the container join the network named "
"``flwr-network``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:88
msgid "``--name superlink``: Assign the name ``superlink`` to the container."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:89
#: ../../source/docker/tutorial-quickstart-docker.rst:130
#: ../../source/docker/tutorial-quickstart-docker.rst:243
#: ../../source/docker/tutorial-quickstart-docker.rst:281
msgid ""
"``--detach``: Run the container in the background, freeing up the "
"terminal."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:90
msgid ""
":substitution-code:`flwr/superlink:|stable_flwr_version|`: The name of "
"the image to be run and the specific tag of the image. The tag "
":substitution-code:`|stable_flwr_version|` represents a :doc:`specific "
"version <pin-version>` of the image."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:92
#: ../../source/docker/tutorial-quickstart-docker.rst:133
msgid ""
"``--insecure``: This flag tells the container to operate in an insecure "
"mode, allowing unencrypted communication."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:94
msgid ""
"``--isolation process``: Tells the SuperLink that the ServerApp is "
"executed by separate independent process. The SuperLink does not attempt "
"to execute it. You can learn more about the different process modes here:"
" :doc:`run-as-subprocess`."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:100
#, fuzzy
msgid "Step 3: Start the SuperNodes"
msgstr "서버(SuperLink)"

#: ../../source/docker/tutorial-quickstart-docker.rst:102
msgid "Start two SuperNode containers."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:104
msgid "Start the first container:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:125
msgid ""
"``-p 9094:9094``: Map port ``9094`` of the container to the same port of "
"the host machine, allowing other services to access the SuperNode API on "
"``http://localhost:9094``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:129
msgid "``--name supernode-1``: Assign the name ``supernode-1`` to the container."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:131
#, fuzzy
msgid ""
":substitution-code:`flwr/supernode:|stable_flwr_version|`: This is the "
"name of the image to be run and the specific tag of the image."
msgstr "``flwr_supernode:0.0.1``: 사용할 Docker 이미지의 태그 이름입니다."

#: ../../source/docker/tutorial-quickstart-docker.rst:135
msgid ""
"``--superlink superlink:9092``: Connect to the SuperLink's Fleet API at "
"the address ``superlink:9092``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:137
msgid ""
"``--node-config \"partition-id=0 num-partitions=2\"``: Set the partition "
"ID to ``0`` and the number of partitions to ``2`` for the SuperNode "
"configuration."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:139
msgid ""
"``--clientappio-api-address 0.0.0.0:9094``: Set the address and port "
"number that the SuperNode is listening on to communicate with the "
"ClientApp process. If multiple SuperNodes are started on the same "
"machine, use a different port number for each SuperNode. (E.g. In the "
"next step, we set the second SuperNode container to listen on port 9095)"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:143
msgid ""
"``--isolation process``: Tells the SuperNode that the ClientApp is "
"executed by a separate independent process. The SuperNode does not "
"attempt to execute it."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:146
msgid "Start the second container:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:165
#, fuzzy
msgid "Step 4: Start the SuperExec to execute ServerApps"
msgstr "서버(SuperLink)"

#: ../../source/docker/tutorial-quickstart-docker.rst:167
msgid ""
"The **SuperExec** Docker image comes with a pre-installed version of "
"Flower and serves as a base for building your own image. Use a **single**"
" image and select the desired behavior (ServerApps vs ClientApps) at "
"runtime via the ``--plugin-type`` flag. SuperExec spawns the "
"corresponding processes on demand."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:172
msgid ""
"When using SuperExec with the *serverapp* plugin, pass ``--appio-api-"
"address`` pointing to the SuperLink's **ServerAppIO API** endpoint."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:175
msgid ""
"Create a Dockerfile called ``superexec.Dockerfile`` and paste the "
"following:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:177
#: ../../source/how-to-run-flower-on-gcp.rst
#, fuzzy
msgid "superexec.Dockerfile"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/docker/tutorial-quickstart-docker.rst
#, fuzzy
msgid "Understand the Dockerfile"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/docker/tutorial-quickstart-docker.rst:193
#, fuzzy
msgid ""
":substitution-code:`FROM flwr/superexec:|stable_flwr_version|`: This line"
" specifies that the Docker image to be built from is the "
"``flwr/superexec`` image, version :substitution-"
"code:`|stable_flwr_version|`."
msgstr "다음 명령은 ``superlink:1.8.0`` 태그가 참조하는 현재 이미지 해시를 반환합니다:"

#: ../../source/docker/tutorial-quickstart-docker.rst:195
msgid ""
"``WORKDIR /app``: Set the working directory for the container to "
"``/app``. Any subsequent commands that reference a directory will be "
"relative to this directory."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:197
msgid ""
"``COPY pyproject.toml .``: Copy the ``pyproject.toml`` file. from the "
"current working directory into the container's ``/app`` directory."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:199
msgid ""
"``RUN sed -i 's/.*flwr\\[simulation\\].*//' pyproject.toml``: Remove the "
"``flwr`` dependency from the ``pyproject.toml``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:201
msgid ""
"``python -m pip install -U --no-cache-dir .``: Run the ``pip`` install "
"command to install the dependencies defined in the ``pyproject.toml`` "
"file."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:204
msgid ""
"The ``-U`` flag indicates that any existing packages should be upgraded, "
"and ``--no-cache-dir`` prevents pip from using the cache to speed up the "
"installation."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:206
msgid ""
"``ENTRYPOINT [\"flower-superexec\"]``: Set the command ``flower-"
"superexec`` to be the default command run when the container is started."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:211
msgid ""
"Note that `flwr <https://pypi.org/project/flwr/>`__ is already installed "
"in the ``flwr/superexec`` base image, so only other package dependencies "
"such as ``flwr-datasets``, ``torch``, etc., need to be installed. As a "
"result, the ``flwr`` dependency is removed from the ``pyproject.toml`` "
"after it has been copied into the Docker image (see line 5)."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:217
msgid ""
"Afterward, in the directory that holds the Dockerfile, execute this "
"Docker command to build the SuperExec image:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:224
#, fuzzy
msgid "Start the **SuperExec for ServerApps** container:"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/docker/tutorial-quickstart-docker.rst:242
msgid "``--name superexec-serverapp``: Give the container a descriptive name."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:244
#: ../../source/docker/tutorial-quickstart-docker.rst:282
#, fuzzy
msgid ""
"``flwr_superexec:0.0.1``: This is the name of the image to be run and the"
" specific tag of the image."
msgstr "``flwr_supernode:0.0.1``: 사용할 Docker 이미지의 태그 이름입니다."

#: ../../source/docker/tutorial-quickstart-docker.rst:246
#: ../../source/docker/tutorial-quickstart-docker.rst:284
msgid ""
"``--insecure``: This flag tells the container to operate in an insecure "
"mode, allowing unencrypted communication. Secure connections will be "
"added in future releases."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:248
msgid ""
"``--plugin-type serverapp``: Load the *serverapp* plugin. SuperExec will "
"spawn ServerApp processes as needed."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:250
msgid ""
"``--appio-api-address superlink:9091``: Connect to the SuperLink's "
"ServerAppIO API at the address ``superlink:9091``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:255
#, fuzzy
msgid "Step 5: Start the SuperExec to execute ClientApps"
msgstr "서버(SuperLink)"

#: ../../source/docker/tutorial-quickstart-docker.rst:257
msgid ""
"For ClientApps, reuse the **same** image and change the plugin and API "
"address. When using the *clientapp* plugin, pass ``--appio-api-address`` "
"pointing to the SuperNode's **ClientAppIO API** endpoint."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:261
msgid "(No new Dockerfile is needed; reuse ``flwr_superexec:0.0.1``.)"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:262
#, fuzzy
msgid "Start the first **SuperExec for ClientApps** container:"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/docker/tutorial-quickstart-docker.rst:280
msgid "``--name superexec-clientapp-1``: Give the container a descriptive name."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:286
msgid ""
"``--plugin-type clientapp``: Load the *clientapp* plugin. SuperExec will "
"spawn ClientApp processes as needed."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:288
msgid ""
"``--appio-api-address supernode-1:9094``: Connect to the SuperNode's "
"ClientAppIO API at the address ``supernode-1:9094``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:291
#, fuzzy
msgid "Start the second **SuperExec for ClientApps** container:"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/docker/tutorial-quickstart-docker.rst:306
msgid "Step 6: Run the Quickstart Project"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:308
#, fuzzy
msgid "Add the following lines to the ``pyproject.toml``:"
msgstr "``pyproject.toml``에 다음 버전 제약 조건을 설정했는지 확인하세요:"

#: ../../source/docker/tutorial-quickstart-docker.rst:317
msgid ""
"Run the ``quickstart-docker`` project and follow the ServerApp logs to "
"track the execution of the run:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:326
msgid "Step 7: Update the Application"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:328
msgid ""
"Change the application code. For example, change the ``seed`` in "
"``quickstart_docker/task.py`` to ``43`` and save it:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:331
msgid "quickstart_docker/task.py"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:338
#, fuzzy
msgid "Stop the running containers:"
msgstr "이미 *서버*를 시작할 수 있습니다:"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:135
#: ../../source/docker/tutorial-quickstart-docker.rst:342
msgid ""
"If you have modified the dependencies listed in your ``pyproject.toml`` "
"file, it is essential to rebuild images."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:345
msgid "If you haven't made any changes, you can skip steps 2 through 4."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:351
#, fuzzy
msgid "Rebuild the SuperExec image:"
msgstr "기본 이미지 빌드"

#: ../../source/docker/tutorial-quickstart-docker.rst:357
msgid ""
"Launch **one SuperExec container** for the new ServerApp and **two "
"SuperExec containers** for the new ClientApps:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:387
msgid "Run the updated project:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:395
msgid "Step 8: Clean Up"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:397
msgid "Remove the containers and the bridge network:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:419
#: ../../source/docker/tutorial-quickstart-docker.rst:409
#, fuzzy
msgid "Where to Go Next"
msgstr "시작 위치"

#: ../../source/docker/tutorial-quickstart-docker.rst:411
msgid ":doc:`enable-tls`"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:412
msgid ":doc:`persist-superlink-state`"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker.rst:413
msgid ":doc:`tutorial-quickstart-docker-compose`"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:-1
msgid ""
"Learn how to quickly set up Flower using Docker Compose, enable TLS, and "
"persist application state for federated learning with minimal "
"configuration effort."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:7
#, fuzzy
msgid "Quickstart with Docker Compose"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:9
msgid ""
"This quickstart shows you how to set up Flower using Docker Compose in a "
"single command, allowing you to focus on developing your application "
"without worrying about the underlying infrastructure."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:13
msgid ""
"You will also learn how to easily enable TLS encryption and persist "
"application state locally, giving you the freedom to choose the "
"configuration that best suits your project's needs."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:31
msgid "Clone the Docker Compose ``complete`` directory:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:46
msgid ""
"Export the path of the newly created project. The path should be relative"
" to the location of the Docker Compose files:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:53
msgid ""
"Setting the ``PROJECT_DIR`` helps Docker Compose locate the "
"``pyproject.toml`` file, allowing it to install dependencies in the "
"``ServerApp`` and ``ClientApp`` images correctly."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:59
#, fuzzy
msgid "Step 2: Run Flower in Insecure Mode"
msgstr "Flower SuperNode를 실행합니다."

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:61
msgid ""
"To begin, start Flower with the most basic configuration. In this setup, "
"Flower will run without TLS and without persisting the state."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:66
msgid ""
"Without TLS, the data sent between the services remains **unencrypted**. "
"Use it only for development purposes."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:69
msgid ""
"For production-oriented use cases, :ref:`enable TLS <TLS>` for secure "
"data transmission."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:80
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:186
#, fuzzy
msgid "``docker compose``: The Docker command to run the Docker Compose tool."
msgstr "``docker run``: 새 Docker 컨테이너를 실행하는 명령입니다."

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:81
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:192
msgid ""
"``--build``: Rebuild the images for each service if they don't already "
"exist."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:82
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:193
msgid ""
"``-d``: Detach the containers from the terminal and run them in the "
"background."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:86
msgid "Step 3: Run the Quickstart Project"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:88
msgid ""
"Now that the Flower services have been started via Docker Compose, it is "
"time to run the quickstart example."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:91
msgid ""
"To ensure the ``flwr`` CLI connects to the SuperLink, you need to specify"
" the SuperLink addresses in the ``pyproject.toml`` file."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:94
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:235
msgid "Add the following lines to the ``quickstart-compose/pyproject.toml``:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:96
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:237
msgid "quickstart-compose/pyproject.toml"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:103
msgid ""
"Run the quickstart example, monitor the ``ServerApp`` logs and wait for "
"the summary to appear:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:112
msgid "Step 4: Update the Application"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:114
msgid "In the next step, change the application code."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:116
msgid ""
"For example, go to the ``task.py`` file in the ``quickstart-"
"compose/quickstart_compose/`` directory and add a ``print`` call in the "
"``get_weights`` function:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:120
msgid "quickstart-compose/quickstart_compose/task.py"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:131
#, fuzzy
msgid "Rebuild and restart the services."
msgstr "이미 *서버*를 시작할 수 있습니다:"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:138
msgid "If you haven't made any changes, you can skip this step."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:140
msgid "Run the following command to rebuild and restart the services:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:146
msgid "Run the updated quickstart example:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:152
msgid "In the ``ServerApp`` logs, you should find the ``Get weights`` line:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:166
msgid "Step 5: Persisting the SuperLink State"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:168
msgid ""
"In this step, Flower services are configured to persist the state of the "
"SuperLink service, ensuring that it maintains its state even after a "
"restart."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:173
msgid ""
"When working with Docker Compose on Linux, you may need to create the "
"``state`` directory first and change its ownership to ensure proper "
"access and permissions."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:178
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:229
msgid "Run the command:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:187
msgid ""
"``-f compose.yml``: Specify the YAML file that contains the basic Flower "
"service definitions."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst
msgid ""
"``-f with-state.yml``: Specifies the path to an additional Docker Compose"
" file that"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst
msgid "contains the configuration for persisting the SuperLink state."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst
msgid ""
"Docker merges Compose files according to `merging rules "
"<https://docs.docker.com/compose/multiple-compose-files/merge/#merging-"
"rules>`_."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:195
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:250
#: ../../source/docker/tutorial-quickstart-docker-compose.rst:385
msgid "Rerun the ``quickstart-compose`` project:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:201
msgid "Check the content of the ``state`` directory:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:208
msgid ""
"You should see a ``state.db`` file in the ``state`` directory. If you "
"restart the service, the state file will be used to restore the state "
"from the previously saved data. This ensures that the data persists even "
"if the containers are stopped and started again."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:217
msgid "Step 6: Run Flower with TLS"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:219
msgid ""
"To demonstrate how to enable TLS, generate self-signed certificates using"
" the ``certs.yml`` Compose file."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:226
msgid ""
"For production environments, use a service like `Let's Encrypt "
"<https://letsencrypt.org/>`_ to obtain your certificates."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:244
msgid "Restart the services with TLS enabled:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:258
#, fuzzy
msgid "Step 7: Add another SuperNode and ClientApp"
msgstr "서버(SuperLink)"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:260
msgid ""
"You can add more SuperNodes and ClientApps by uncommenting their "
"definitions in the ``compose.yml`` file:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:263
msgid "compose.yml"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:317
msgid ""
"If you also want to enable TLS for the new SuperNode, uncomment the "
"definition in the ``with-tls.yml`` file:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:320
msgid "with-tls.yml"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:341
#, fuzzy
msgid "Restart the services with:"
msgstr "이미 *서버*를 시작할 수 있습니다:"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:351
msgid "Step 8: Persisting the SuperLink State and Enabling TLS"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:353
msgid ""
"To run Flower with persisted SuperLink state and enabled TLS, a slight "
"change in the ``with-state.yml`` file is required:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:356
msgid "Comment out the lines 2-6 and uncomment the lines 7-13:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:358
msgid "with-state.yml"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:379
#, fuzzy
msgid "Restart the services:"
msgstr "이미 *서버*를 시작할 수 있습니다:"

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:393
msgid "Step 9: Merge Multiple Compose Files"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:395
msgid ""
"You can merge multiple Compose files into a single file. For instance, if"
" you wish to combine the basic configuration with the TLS configuration, "
"execute the following command:"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:404
msgid ""
"This will merge the contents of ``compose.yml`` and ``with-tls.yml`` into"
" a new file called ``my_compose.yml``."
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:409
msgid "Step 10: Clean Up"
msgstr ""

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:411
#, fuzzy
msgid "Remove all services and volumes:"
msgstr "R에서 모든 항목을 제거합니다."

#: ../../source/docker/tutorial-quickstart-docker-compose.rst:421
#, fuzzy
msgid ":doc:`run-quickstart-examples-docker-compose`"
msgstr "빠른 시작 튜토리얼"

#: ../../source/docker/use-a-different-version.rst:-1
msgid ""
"Learn how to switch to a different version of Flower, including nightly "
"builds, by changing Docker image tags for consistent federated learning "
"environments."
msgstr ""

#: ../../source/docker/use-a-different-version.rst:7
#, fuzzy
msgid "Use a Different Flower Version"
msgstr "다른 Flower 버전 사용"

#: ../../source/docker/use-a-different-version.rst:9
msgid ""
"If you want to use a different version of Flower, for example Flower "
"nightly, you can do so by changing the tag. All available versions are on"
" `Docker Hub <https://hub.docker.com/u/flwr>`__."
msgstr ""
"다른 버전의 Flower를 사용하려면 태그를 변경하여 사용할 수 있습니다(예: Flower nightly). 사용 가능한 모든 "
"버전은 `Docker Hub <https://hub.docker.com/u/flwr>`__에 있습니다."

#: ../../source/docker/use-a-different-version.rst:15
#, fuzzy
msgid ""
"When using Flower nightly, the SuperLink nightly image must be paired "
"with the corresponding SuperNode and ServerApp nightly images released on"
" the same day. To ensure the versions are in sync, using the concrete "
"tag, e.g., ``1.10.0.dev20240610`` instead of ``nightly`` is recommended."
msgstr ""
"SuperNode Docker 이미지는 현재 1.9.0 야간 릴리스에서만 작동합니다. 안정 버전은 Flower 1.9.0(안정)이 "
"출시되면 사용할 수 있습니다(예상 출시일: 5월). SuperNode 야간 이미지는 같은 날 릴리스된 해당 SuperLink 및 "
"서버앱 야간 이미지와 페어링되어야 합니다. 버전이 동기화되도록 하려면 ``nightly`` 대신 "
"``1.9.0.dev20240501``과 같은 구체적인 태그를 사용하는 것이 좋습니다."

#: ../../source/explanation-differential-privacy.rst:-1
msgid ""
"In this Flower explainer, learn how differential privacy ensures data "
"security in federated learning, with central & local approaches to "
"prevent leakage of sensitive information during model training."
msgstr ""

#: ../../source/explanation-differential-privacy.rst:7
#: ../../source/explanation-differential-privacy.rst:20
#: ../../source/tutorial-series-what-is-federated-learning.rst:325
msgid "Differential Privacy"
msgstr "차등 프라이버시"

#: ../../source/explanation-differential-privacy.rst:9
msgid ""
"The information in datasets like healthcare, financial transactions, user"
" preferences, etc., is valuable and has the potential for scientific "
"breakthroughs and provides important business insights. However, such "
"data is also sensitive and there is a risk of compromising individual "
"privacy."
msgstr ""
"의료, 금융 거래, 사용자 선호도 등과 같은 데이터 세트의 정보는 가치 있고 과학적 혁신의 잠재력을 지니고 있으며 중요한 비즈니스 "
"인사이트를 제공합니다. 그러나 이러한 데이터는 또한 민감한 정보이며 개인의 프라이버시를 침해할 위험이 있습니다."

#: ../../source/explanation-differential-privacy.rst:14
msgid ""
"Traditional methods like anonymization alone would not work because of "
"attacks like Re-identification and Data Linkage. That's where "
"differential privacy comes in. It provides the possibility of analyzing "
"data while ensuring the privacy of individuals."
msgstr ""
"익명화와 같은 기존 방법만으로는 재식별 및 데이터 연결과 같은 공격으로 인해 효과가 없습니다. 그래서 차등 프라이버시가 "
"등장했습니다. 차등 프라이버시는 개인의 개인 정보 보호를 보장하면서 데이터를 분석할 수 있는 가능성을 제공합니다."

#: ../../source/explanation-differential-privacy.rst:22
msgid ""
"Imagine two datasets that are identical except for a single record (for "
"instance, Alice's data). Differential Privacy (DP) guarantees that any "
"analysis (M), like calculating the average income, will produce nearly "
"identical results for both datasets (O and O' would be similar). This "
"preserves group patterns while obscuring individual details, ensuring the"
" individual's information remains hidden in the crowd."
msgstr ""
"하나의 레코드(예: 앨리스의 데이터)를 제외하고는 동일한 두 개의 데이터 세트가 있다고 상상해 보세요. 차등 프라이버시(DP)는 "
"평균 소득 계산과 같은 모든 분석(M)이 두 데이터 세트에 대해 거의 동일한 결과를 산출하도록 보장합니다(O와 O' 는 비슷할 "
"것입니다). 이렇게 하면 그룹 패턴은 보존하면서 개별 세부 정보는 가려져 개인의 정보가 군중 속에 숨겨집니다."

#: ../../source/explanation-differential-privacy.rst:28
msgid "DP Intro"
msgstr "DP 소개"

#: ../../source/explanation-differential-privacy.rst:33
msgid ""
"One of the most commonly used mechanisms to achieve DP is adding enough "
"noise to the output of the analysis to mask the contribution of each "
"individual in the data while preserving the overall accuracy of the "
"analysis."
msgstr ""
"DP를 달성하기 위해 가장 일반적으로 사용되는 메커니즘 중 하나는 분석의 전반적인 정확도를 유지하면서 데이터에서 각 개인의 기여도를"
" 가릴 수 있도록 분석 결과에 충분한 노이즈를 추가하는 것입니다."

#: ../../source/explanation-differential-privacy.rst:38
msgid "Formal Definition"
msgstr "공식 정의"

#: ../../source/explanation-differential-privacy.rst:40
msgid ""
"Differential Privacy (DP) provides statistical guarantees against the "
"information an adversary can infer through the output of a randomized "
"algorithm. It provides an unconditional upper bound on the influence of a"
" single individual on the output of the algorithm by adding noise [1]. A "
"randomized mechanism M provides (:math:`\\epsilon`, "
":math:`\\delta`)-differential privacy if for any two neighboring "
"databases, D :sub:`1` and D :sub:`2`, that differ in only a single "
"record, and for all possible outputs S ⊆ Range(A):"
msgstr ""
"차등 프라이버시(DP)는 공격자가 무작위 알고리즘의 출력을 통해 유추할 수 있는 정보에 대해 통계적 보장을 제공합니다. 이는 "
"노이즈를 추가하여 알고리즘의 출력에 대한 한 개인의 영향력에 대한 무조건적인 상한선을 제공합니다[1]. 무작위 메커니즘 M은 하나의"
" 레코드만 다른 두 개의 인접 데이터베이스인 D:sub:`1`과 D:sub:`2`의 경우, 가능한 모든 출력 S ⊆ "
"Range(A)에 대해 (:math:`\\epsilon`, :math:`\\delta`)-차등 프라이버시를 제공합니다:"

#: ../../source/explanation-differential-privacy.rst:48
#, fuzzy, python-brace-format
msgid ""
"\\small\n"
"P[M(D_{1} \\in A)] \\leq e^{\\epsilon} P[M(D_{2} \\in A)] + \\delta"
msgstr ""
"\\small\n"
"P[M(D_{1} \\in A)] \\leq e^{\\delta} P[M(D_{2} \\in A)] + \\delta"

#: ../../source/explanation-differential-privacy.rst:53
msgid ""
"The :math:`\\epsilon` parameter, also known as the privacy budget, is a "
"metric of privacy loss. It also controls the privacy-utility trade-off; "
"lower :math:`\\epsilon` values indicate higher levels of privacy but are "
"likely to reduce utility as well. The :math:`\\delta` parameter accounts "
"for a small probability on which the upper bound :math:`\\epsilon` does "
"not hold. The amount of noise needed to achieve differential privacy is "
"proportional to the sensitivity of the output, which measures the maximum"
" change in the output due to the inclusion or removal of a single record."
msgstr ""
"프라이버시 예산이라고도 하는 :math:`\\epsilon` 매개변수는 프라이버시 손실을 측정하는 지표입니다. 이 매개변수는 "
"프라이버시와 효용의 균형을 제어하며, :math:`\\epsilon` 값이 낮을수록 프라이버시 수준이 높지만 효용도 감소할 가능성이"
" 높습니다. math:`\\delta` 매개변수는 상한값인 :math:`\\epsilon`이 적용되지 않는 작은 확률을 설명합니다."
" 차등 프라이버시를 달성하는 데 필요한 노이즈의 양은 출력의 감도에 비례하며, 이는 단일 레코드의 포함 또는 제거로 인한 출력의 "
"최대 변화를 측정합니다."

#: ../../source/explanation-differential-privacy.rst:63
msgid "Differential Privacy in Machine Learning"
msgstr "머신 러닝의 차등 프라이버시"

#: ../../source/explanation-differential-privacy.rst:65
msgid ""
"DP can be utilized in machine learning to preserve the privacy of the "
"training data. Differentially private machine learning algorithms are "
"designed in a way to prevent the algorithm to learn any specific "
"information about any individual data points and subsequently prevent the"
" model from revealing sensitive information. Depending on the stage at "
"which noise is introduced, various methods exist for applying DP to "
"machine learning algorithms. One approach involves adding noise to the "
"training data (either to the features or labels), while another method "
"entails injecting noise into the gradients of the loss function during "
"model training. Additionally, such noise can be incorporated into the "
"model's output."
msgstr ""
"머신 러닝에서 DP를 활용하여 학습 데이터의 개인정보를 보호할 수 있습니다. 차등 비공개 머신 러닝 알고리즘은 알고리즘이 개별 "
"데이터 포인트에 대한 특정 정보를 학습하지 못하도록 하여 모델이 민감한 정보를 노출하지 않도록 하는 방식으로 설계되었습니다. "
"노이즈가 도입되는 단계에 따라 머신 러닝 알고리즘에 DP를 적용하는 다양한 방법이 존재합니다. 한 가지 방법은 학습 데이터(특징 "
"또는 레이블)에 노이즈를 추가하는 것이고, 다른 방법은 모델 학습 중에 손실 함수의 기울기에 노이즈를 주입하는 것입니다. 또한 "
"이러한 노이즈를 모델의 출력에 통합할 수도 있습니다."

#: ../../source/explanation-differential-privacy.rst:77
msgid "Differential Privacy in Federated Learning"
msgstr "연합 학습의 차등 프라이버시"

#: ../../source/explanation-differential-privacy.rst:79
msgid ""
"Federated learning is a data minimization approach that allows multiple "
"parties to collaboratively train a model without sharing their raw data. "
"However, federated learning also introduces new privacy challenges. The "
"model updates between parties and the central server can leak information"
" about the local data. These leaks can be exploited by attacks such as "
"membership inference and property inference attacks, or model inversion "
"attacks."
msgstr ""
"연합 학습은 여러 당사자가 원시 데이터를 공유하지 않고도 공동으로 모델을 학습할 수 있는 데이터 최소화 접근 방식입니다. 그러나 "
"연합 학습은 새로운 개인정보 보호 문제를 야기하기도 합니다. 당사자와 중앙 서버 간의 모델 업데이트는 로컬 데이터에 대한 정보를 "
"유출할 수 있습니다. 이러한 유출은 멤버십 추론 및 속성 추론 공격이나 모델 반전 공격과 같은 공격에 악용될 수 있습니다."

#: ../../source/explanation-differential-privacy.rst:86
msgid ""
"DP can play a crucial role in federated learning to provide privacy for "
"the clients' data."
msgstr "DP는 연합 학습에서 클라이언트의 데이터에 대한 개인 정보 보호를 제공하는 데 중요한 역할을 할 수 있습니다."

#: ../../source/explanation-differential-privacy.rst:89
msgid ""
"Depending on the granularity of privacy provision or the location of "
"noise addition, different forms of DP exist in federated learning. In "
"this explainer, we focus on two approaches of DP utilization in federated"
" learning based on where the noise is added: at the server (also known as"
" the center) or at the client (also known as the local)."
msgstr ""
"개인 정보 제공의 세분성 또는 노이즈 추가 위치에 따라 연합 학습에는 다양한 형태의 DP가 존재합니다. 이 설명에서는 노이즈가 "
"추가되는 위치에 따라 서버(중앙이라고도 함) 또는 클라이언트(로컬이라고도 함)에서의 연합 학습에서 DP를 활용하는 두 가지 접근 "
"방식에 중점을 둡니다."

#: ../../source/explanation-differential-privacy.rst:94
msgid ""
"**Central Differential Privacy**: DP is applied by the server and the "
"goal is to prevent the aggregated model from leaking information about "
"each client's data."
msgstr ""
"**중앙 차등 프라이버시**: DP는 서버에서 적용되며 집계된 모델이 각 클라이언트의 데이터에 대한 정보를 유출하는 것을 방지하는 "
"것이 목표입니다."

#: ../../source/explanation-differential-privacy.rst:96
msgid ""
"**Local Differential Privacy**: DP is applied on the client side before "
"sending any information to the server and the goal is to prevent the "
"updates that are sent to the server from leaking any information about "
"the client's data."
msgstr ""
"**로컬 차등 프라이버시**: DP는 정보를 서버로 보내기 전에 클라이언트 측에서 적용되며, 서버로 전송되는 업데이트가 클라이언트 "
"데이터에 대한 정보를 유출하는 것을 방지하는 것이 목표입니다."

#: ../../source/explanation-differential-privacy.rst:101
#: ../../source/explanation-differential-privacy.rst:107
#: ../../source/how-to-use-differential-privacy.rst:53
msgid "Central Differential Privacy"
msgstr "중앙 차등 프라이버시"

#: ../../source/explanation-differential-privacy.rst:103
msgid ""
"In this approach, which is also known as user-level DP, the central "
"server is responsible for adding noise to the globally aggregated "
"parameters. It should be noted that trust in the server is required."
msgstr ""
"사용자 수준 DP라고도 하는 이 접근 방식에서는 중앙 서버가 전역적으로 집계된 매개변수에 노이즈를 추가하는 역할을 담당합니다. "
"서버에 대한 신뢰가 필요하다는 점에 유의해야 합니다."

#: ../../source/explanation-differential-privacy.rst:112
msgid ""
"While there are various ways to implement central DP in federated "
"learning, we concentrate on the algorithms proposed by [2] and [3]. The "
"overall approach is to clip the model updates sent by the clients and add"
" some amount of noise to the aggregated model. In each iteration, a "
"random set of clients is chosen with a specific probability for training."
" Each client performs local training on its own data. The update of each "
"client is then clipped by some value `S` (sensitivity `S`). This would "
"limit the impact of any individual client which is crucial for privacy "
"and often beneficial for robustness. A common approach to achieve this is"
" by restricting the `L2` norm of the clients' model updates, ensuring "
"that larger updates are scaled down to fit within the norm `S`."
msgstr ""
"연합 학습에서 중앙 DP를 구현하는 방법은 여러 가지가 있지만, 여기서는 [2]와 [3]에서 제안한 알고리즘에 집중합니다. 전반적인"
" 접근 방식은 클라이언트가 전송한 모델 업데이트를 잘라내고 집계된 모델에 약간의 노이즈를 추가하는 것입니다. 각 반복에서 특정 "
"확률로 훈련할 무작위 클라이언트 세트가 선택됩니다. 각 클라이언트는 자체 데이터에 대해 로컬 학습을 수행합니다. 그런 다음 각 "
"클라이언트의 업데이트는 특정 값 `S`(민감도 `S`)에 의해 잘립니다. 이렇게 하면 개별 클라이언트의 영향을 제한할 수 있어 "
"개인정보 보호에 중요하고 견고성에 도움이 되는 경우가 많습니다. 이를 달성하기 위한 일반적인 접근 방식은 클라이언트 모델 업데이트의"
" `L2` 규범을 제한하여 더 큰 업데이트가 규범 `S`에 맞도록 축소되도록 하는 것입니다."

#: ../../source/explanation-differential-privacy.rst:123
msgid "clipping"
msgstr "클리핑"

#: ../../source/explanation-differential-privacy.rst:128
msgid ""
"Afterwards, the Gaussian mechanism is used to add noise in order to "
"distort the sum of all clients' updates. The amount of noise is scaled to"
" the sensitivity value to obtain a privacy guarantee. The Gaussian "
"mechanism is used with a noise sampled from `N (0, σ²)` where `σ = ( "
"noise_scale * S ) / (number of sampled clients)`."
msgstr ""
"그 후 가우시안 메커니즘을 사용하여 모든 클라이언트의 업데이트 합계를 왜곡하기 위해 노이즈를 추가합니다. 노이즈의 양은 감도 값에 "
"따라 조정되어 프라이버시 보장을 얻습니다. 가우시안 메커니즘은 `N (0, σ²)`에서 샘플링된 노이즈와 함께 사용됩니다. 여기서 "
"`σ = (noise_scale * S) / (샘플링된 클라이언트 수)`입니다."

#: ../../source/explanation-differential-privacy.rst:134
msgid "Clipping"
msgstr "클리핑"

#: ../../source/explanation-differential-privacy.rst:136
msgid ""
"There are two forms of clipping commonly used in Central DP: Fixed "
"Clipping and Adaptive Clipping."
msgstr "중앙 DP에서 일반적으로 사용되는 클리핑에는 고정 클리핑과 조정 클리핑의 두 가지 형태가 있습니다."

#: ../../source/explanation-differential-privacy.rst:139
msgid ""
"**Fixed Clipping** : A predefined fix threshold is set for the magnitude "
"of clients' updates. Any update exceeding this threshold is clipped back "
"to the threshold value."
msgstr ""
"**고정 클리핑** : 클라이언트의 업데이트 크기에 대해 미리 정의된 고정 임계값이 설정됩니다. 이 임계값을 초과하는 모든 "
"업데이트는 임계값으로 다시 클리핑됩니다."

#: ../../source/explanation-differential-privacy.rst:141
msgid ""
"**Adaptive Clipping** : The clipping threshold dynamically adjusts based "
"on the observed update distribution [4]. It means that the clipping value"
" is tuned during the rounds with respect to the quantile of the update "
"norm distribution."
msgstr ""
"**조정 클리핑** : 클리핑 임계값은 관찰된 업데이트 분포에 따라 동적으로 조정됩니다[4]. 즉, 클리핑 값은 업데이트 표준 "
"분포의 사분위수에 따라 라운드가 진행되는 동안 조정됩니다."

#: ../../source/explanation-differential-privacy.rst:145
msgid ""
"The choice between fixed and adaptive clipping depends on various factors"
" such as privacy requirements, data distribution, model complexity, and "
"others."
msgstr "고정 클리핑과 조정 클리핑 중 선택은 개인정보 보호 요구 사항, 데이터 배포, 모델 복잡성 등 다양한 요인에 따라 달라집니다."

#: ../../source/explanation-differential-privacy.rst:149
#: ../../source/explanation-differential-privacy.rst:155
#: ../../source/how-to-use-differential-privacy.rst:147
msgid "Local Differential Privacy"
msgstr "로컬 차등 프라이버시"

#: ../../source/explanation-differential-privacy.rst:151
msgid ""
"In this approach, each client is responsible for performing DP. Local DP "
"avoids the need for a fully trusted aggregator, but it should be noted "
"that local DP leads to a decrease in accuracy but better privacy in "
"comparison to central DP."
msgstr ""
"이 접근 방식에서는 각 클라이언트가 DP를 수행할 책임이 있습니다. 로컬 DP는 완전히 신뢰할 수 있는 애그리게이터가 필요하지 "
"않지만, 로컬 DP는 중앙 DP에 비해 정확도는 떨어져도 개인 정보 보호는 더 우수하다는 점에 유의해야 합니다."

#: ../../source/explanation-differential-privacy.rst:160
msgid "In this explainer, we focus on two forms of achieving Local DP:"
msgstr "이 설명에서는 로컬 DP를 달성하는 두 가지 형태에 중점을 둡니다:"

#: ../../source/explanation-differential-privacy.rst:162
msgid ""
"Each client adds noise to the local updates before sending them to the "
"server. To achieve (:math:`\\epsilon`, :math:`\\delta`)-DP, considering "
"the sensitivity of the local model to be ∆, Gaussian noise is applied "
"with a noise scale of σ where:"
msgstr ""
"각 클라이언트는 로컬 업데이트를 서버로 보내기 전에 로컬 업데이트에 노이즈를 추가합니다. 로컬 모델의 감도를 ∆로 간주하여 가우시안"
" 노이즈가 σ의 노이즈 스케일로 적용되어 (:math:`\\epsilon`, :math:`\\delta`)-DP를 달성하기 위해, "
"여기서 σ는 노이즈 스케일입니다:"

#: ../../source/explanation-differential-privacy.rst:166
#, fuzzy
msgid ""
"\\small\n"
"\\frac{∆ \\times \\sqrt{2 \\times "
"\\log\\left(\\frac{1.25}{\\delta}\\right)}}{\\epsilon}"
msgstr ""
"\\small\n"
"\\frac{∆ \\times \\sqrt{2 \\times "
"\\log\\left(\\frac{1.25}{\\delta}\\right)}}{\\epsilon}\n"
"\n"

#: ../../source/explanation-differential-privacy.rst:171
msgid ""
"Each client adds noise to the gradients of the model during the local "
"training (DP-SGD). More specifically, in this approach, gradients are "
"clipped and an amount of calibrated noise is injected into the gradients."
msgstr ""
"각 클라이언트는 로컬 트레이닝(DP-SGD) 중에 모델의 gradient에 노이즈를 추가합니다. 보다 구체적으로, 이 접근 "
"방식에서는 gradient이 클리핑되고 보정된 노이즈가 gradient에 주입됩니다."

#: ../../source/explanation-differential-privacy.rst:175
msgid ""
"Please note that these two approaches are providing privacy at different "
"levels."
msgstr "이 두 가지 접근 방식은 서로 다른 수준의 개인정보 보호 기능을 제공한다는 점에 유의하세요."

#: ../../source/explanation-differential-privacy.rst:177
msgid "**References:**"
msgstr "**참고:**"

#: ../../source/explanation-differential-privacy.rst:179
msgid "[1] Dwork et al. The Algorithmic Foundations of Differential Privacy."
msgstr "[1] Dwork 외. 차등 프라이버시의 알고리즘적 기초."

#: ../../source/explanation-differential-privacy.rst:181
msgid ""
"[2] McMahan et al. Learning Differentially Private Recurrent Language "
"Models."
msgstr "[2] McMahan 외. 차등적 개인 반복 언어 모델 학습."

#: ../../source/explanation-differential-privacy.rst:183
msgid ""
"[3] Geyer et al. Differentially Private Federated Learning: A Client "
"Level Perspective."
msgstr "[3] Geyer 외. 차등적 개인 연합 학습: 고객 수준의 관점."

#: ../../source/explanation-differential-privacy.rst:185
msgid "[4] Galen et al. Differentially Private Learning with Adaptive Clipping."
msgstr "[4] Galen 외. 조정형 클리핑을 통한 차등적 개인 학습."

#: ../../source/explanation-federated-evaluation.rst:-1
#, fuzzy
msgid ""
"Learn the two main approaches to evaluating models in Flower: centralized"
" (server-side) evaluation and federated (client-side) evaluation, with "
"built-in strategies and configuration options."
msgstr ""
"연합 학습 시스템에서 모델을 평가하는 데는 중앙 집중식(또는 서버 측) 평가와 연합(또는 클라이언트 측) 평가라는 두 가지 주요 "
"접근 방식이 있습니다."

#: ../../source/explanation-federated-evaluation.rst:7
msgid "Federated evaluation"
msgstr "연합 평가"

#: ../../source/explanation-federated-evaluation.rst:9
msgid ""
"There are two main approaches to evaluating models in federated learning "
"systems: centralized (or server-side) evaluation and federated (or "
"client-side) evaluation."
msgstr ""
"연합 학습 시스템에서 모델을 평가하는 데는 중앙 집중식(또는 서버 측) 평가와 연합(또는 클라이언트 측) 평가라는 두 가지 주요 "
"접근 방식이 있습니다."

#: ../../source/explanation-federated-evaluation.rst:14
msgid "Centralized Evaluation"
msgstr "중앙 집중식 평가"

#: ../../source/explanation-federated-evaluation.rst:17
msgid "Built-In Strategies"
msgstr "기본 제공 전략"

#: ../../source/explanation-federated-evaluation.rst:19
msgid ""
"All built-in strategies support centralized evaluation by providing an "
"evaluation function during initialization. An evaluation function is any "
"function that can take the current global model parameters as input and "
"return evaluation results:"
msgstr ""
"모든 기본 제공 전략은 초기화 중에 평가 함수를 제공하여 중앙 집중식 평가를 지원합니다. 평가 함수는 현재 글로벌 모델 파라미터를 "
"입력으로 받아 평가 결과를 반환할 수 있는 모든 함수입니다:"

#: ../../source/explanation-federated-evaluation.rst:78
msgid "Custom Strategies"
msgstr "사용자 정의 전략"

#: ../../source/explanation-federated-evaluation.rst:80
#, fuzzy
msgid ""
"The ``Strategy`` abstraction provides a method called ``evaluate`` that "
"can directly be used to evaluate the current global model parameters. The"
" current server implementation calls ``evaluate`` after parameter "
"aggregation and before federated evaluation (see next paragraph)."
msgstr ""
"코드:`전략` 추상화는 현재 전역 모델 파라미터를 평가하는 데 직접 사용할 수 있는 :코드:`평가`라는 메서드를 제공합니다. 현재 "
"서버 구현에서는 매개변수 집계 후와 연합 평가 전에 :code:`evaluate`를 호출합니다(다음 단락 참조)."

#: ../../source/explanation-federated-evaluation.rst:87
#: ../../source/tutorial-series-what-is-federated-learning.rst:306
msgid "Federated Evaluation"
msgstr "연합 평가"

#: ../../source/explanation-federated-evaluation.rst:90
msgid "Implementing Federated Evaluation"
msgstr "연합 평가 구현"

#: ../../source/explanation-federated-evaluation.rst:92
#, fuzzy
msgid ""
"Client-side evaluation happens in the ``Client.evaluate`` method and can "
"be configured from the server side."
msgstr "클라이언트 측 평가는 :code:`Client.evaluate` 메서드에서 이루어지며 서버 측에서 구성할 수 있습니다."

#: ../../source/explanation-federated-evaluation.rst:125
msgid "Configuring Federated Evaluation"
msgstr "연합 평가 구성"

#: ../../source/explanation-federated-evaluation.rst:127
msgid ""
"Federated evaluation can be configured from the server side. Built-in "
"strategies support the following arguments:"
msgstr "연합 평가는 서버 측에서 구성할 수 있습니다. 기본 제공 전략은 다음 인수를 지원합니다:"

#: ../../source/explanation-federated-evaluation.rst:130
#, fuzzy
msgid ""
"``fraction_evaluate``: a ``float`` defining the fraction of clients that "
"will be selected for evaluation. If ``fraction_evaluate`` is set to "
"``0.1`` and ``100`` clients are connected to the server, then ``10`` will"
" be randomly selected for evaluation. If ``fraction_evaluate`` is set to "
"``0.0``, federated evaluation will be disabled."
msgstr ""
":code:`fraction_evaluate`: 평가를 위해 선택될 클라이언트의 비율을 정의하는 :code:`float`입니다. "
"코드:`fraction_evaluate`가 :code:`0.1`로 설정되어 있고 :code:`100` 클라이언트가 서버에 연결되어 "
"있는 경우 :code:`10`이 평가를 위해 무작위로 선택됩니다. code:`fraction_evaluate`가 "
":code:`0.0`으로 설정된 경우 연합 평가가 비활성화됩니다."

#: ../../source/explanation-federated-evaluation.rst:135
#, fuzzy
msgid ""
"``min_evaluate_clients``: an ``int``: the minimum number of clients to be"
" selected for evaluation. If ``fraction_evaluate`` is set to ``0.1``, "
"``min_evaluate_clients`` is set to 20, and ``100`` clients are connected "
"to the server, then ``20`` clients will be selected for evaluation."
msgstr ""
":code:`min_evaluate_clients`: 평가를 위해 선택할 최소 클라이언트 수. :code:`int`. "
"코드:`fraction_evaluate`가 :code:`0.1`로 설정되어 있고 :code:`fraction_evaluate`가 "
"20으로 설정되어 있으며 :code:`100` 클라이언트가 서버에 연결되어 있는 경우 :code:`20` 클라이언트가 평가를 위해 "
"선택됩니다."

#: ../../source/explanation-federated-evaluation.rst:139
#, fuzzy
msgid ""
"``min_available_clients``: an ``int`` that defines the minimum number of "
"clients which need to be connected to the server before a round of "
"federated evaluation can start. If fewer than ``min_available_clients`` "
"are connected to the server, the server will wait until more clients are "
"connected before it continues to sample clients for evaluation."
msgstr ""
":code:`min_available_clients`: federated 평가 단계를 시작하기 전에 서버에 연결해야 하는 최소 "
"클라이언트 수를 정의하는 :code:`int`입니다. 서버에 연결된 클라이언트가 "
":code:`min_available_clients`보다 적으면 서버는 더 많은 클라이언트가 연결될 때까지 기다렸다가 평가를 위한 "
"클라이언트 샘플링을 계속합니다."

#: ../../source/explanation-federated-evaluation.rst:144
#, fuzzy
msgid ""
"``on_evaluate_config_fn``: a function that returns a configuration "
"dictionary which will be sent to the selected clients. The function will "
"be called during each round and provides a convenient way to customize "
"client-side evaluation from the server side, for example, to configure "
"the number of validation steps performed."
msgstr ""
"code:`on_evaluate_config_fn`: 선택한 클라이언트로 전송할 구성 사전을 반환하는 함수입니다. 이 함수는 각 "
"단계 중에 호출되며, 서버 측에서 클라이언트 측 평가를 사용자 지정하는 편리한 방법을 제공합니다(예: 수행되는 유효성 검사 단계 수"
" 구성)."

#: ../../source/explanation-federated-evaluation.rst:187
msgid "Evaluating Local Model Updates During Training"
msgstr "훈련 중 로컬 모델 업데이트 평가"

#: ../../source/explanation-federated-evaluation.rst:189
#, fuzzy
msgid ""
"Model parameters can also be evaluated during training. ``Client.fit`` "
"can return arbitrary evaluation results as a dictionary:"
msgstr ""
"모델 파라미터는 훈련 중에도 평가할 수 있습니다. :code:`Client.fit`은 임의의 평가 결과를 dictionary로 "
"반환할 수 있습니다:"

#: ../../source/explanation-federated-evaluation.rst:231
msgid "Full Code Example"
msgstr "전체 코드 예제"

#: ../../source/explanation-federated-evaluation.rst:233
#, fuzzy
msgid ""
"For a full code example that uses both centralized and federated "
"evaluation, see the `Advanced TensorFlow Example "
"<https://github.com/adap/flower/tree/main/examples/advanced-tensorflow>`_"
" (the same approach can be applied to workloads implemented in any other "
"framework)."
msgstr ""
"연합 평가와 중앙 집중식 평가를 모두 사용하는 전체 코드 예제는 *고급 텐서플로우 예제*(다른 프레임워크에서 구현된 워크로드에도 "
"동일한 접근 방식을 적용할 수 있음)를 참조하세요: "
"https://github.com/adap/flower/tree/main/examples/advanced-tensorflow"

#: ../../source/explanation-flower-architecture.rst:-1
msgid ""
"Learn about the architecture of a deployed Flower federated learning "
"system, including SuperLink, SuperNodes, multi-tenancy, and the role of "
"SuperExec for managing concurrent training runs."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:7
msgid "Flower Architecture"
msgstr "Flower 아키텍처"

#: ../../source/explanation-flower-architecture.rst:9
msgid ""
"This page explains the architecture of deployed Flower federated learning"
" system."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:11
msgid ""
"In federated learning (FL), there is typically one server and a number of"
" clients that are connected to the server. This is often called a "
"federation."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:14
msgid ""
"The role of the server is to coordinate the training process. The role of"
" each client is to receive tasks from the server, execute those tasks and"
" return the results back to the server."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:18
msgid "This is sometimes called a hub-and-spoke topology:"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:20
#, fuzzy
msgid "Hub-and-spoke topology in federated learning"
msgstr "연합 학습이란 무엇입니까?"

#: ../../source/explanation-flower-architecture.rst:25
#, fuzzy
msgid "Hub-and-spoke topology in federated learning (dark theme)"
msgstr "연합 학습이란 무엇입니까?"

#: ../../source/explanation-flower-architecture.rst:30
msgid ""
"Hub-and-spoke topology in federated learning (one server, multiple "
"clients)."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:32
msgid ""
"In a real-world deployment, we typically want to run different projects "
"on such a federation. Each project could use different hyperparameters, "
"different model architectures, different aggregation strategies, or even "
"different machine learning frameworks like PyTorch and TensorFlow."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:37
msgid ""
"This is why, in Flower, both the server side and the client side are "
"split into two parts. One part is long-lived and responsible for "
"communicating across the network, the other part is short-lived and "
"executes task-specific code."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:41
msgid ""
"A Flower *server* is composed of **SuperLink**, **SuperExec**, and "
"``ServerApp``:"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:43
msgid ""
"**SuperLink**: A long-running process that forwards task instructions to "
"clients (SuperNodes) and receives task results back."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:45
msgid ""
"**SuperExec**: A long-running process that schedules, launches, and "
"manages multiple app processes (e.g., ``ServerApp``) on demand by "
"communicating with the SuperLink. By default, it is started automatically"
" by the SuperLink."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:48
msgid ""
"``ServerApp``: A short-lived app process containing project-specific code"
" that customizes all server-side aspects of federated learning systems "
"(client selection, client configuration, result aggregation). This is the"
" component AI researchers and engineers implement when building Flower "
"apps."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:53
msgid ""
"A Flower *client* is composed of **SuperNode**, **SuperExec**, and "
"``ClientApp``:"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:55
msgid ""
"**SuperNode**: A long-running process that connects to the SuperLink, "
"requests tasks, executes them (for example, \"train this model on your "
"local data\"), and returns the results to the SuperLink."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:58
msgid ""
"**SuperExec**: A long-running process that schedules, launches, and "
"manages multiple application processes (e.g., ``ClientApp``) on demand by"
" communicating with the SuperNode. By default, it is started "
"automatically by the SuperNode."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:61
msgid ""
"``ClientApp``: A short-lived app process containing project-specific code"
" that customizes all client-side aspects of federated learning systems "
"(local model training, evaluation, pre- and post-processing). This is the"
" component AI researchers and engineers implement when building Flower "
"apps."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:66
msgid ""
"Why SuperNode and SuperLink? Well, in federated learning, the clients are"
" the actual stars of the show. They hold the training data and they run "
"the actual training. This is why Flower decided to name them "
"**SuperNode**. The **SuperLink** is then responsible for acting as the "
"*missing link* among all those SuperNodes."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:71
#, fuzzy
msgid "Basic Flower architecture"
msgstr "Flower 아키텍처"

#: ../../source/explanation-flower-architecture.rst:76
#, fuzzy
msgid "Basic Flower architecture (dark theme)"
msgstr "Flower 아키텍처"

#: ../../source/explanation-flower-architecture.rst:81
msgid "The basic Flower architecture for federated learning."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:83
msgid ""
"In a Flower app project, users will typically develop the ``ServerApp`` "
"and the ``ClientApp``. All the network communication between *server* and"
" *clients* is taken care of by the SuperLink and SuperNodes."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:89
msgid ""
"For more details, please refer to the |serverapp_link|_ and "
"|clientapp_link|_ documentation."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:92
msgid ""
"With *multi-run*, multiple ``ServerApp``\\s and ``ClientApp``\\s can run "
"within the same federation, which consists of a single long-running "
"SuperLink and multiple long-running SuperNodes. This capability is "
"sometimes referred to as *multi-tenancy* or *multi-job*."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:96
msgid ""
"As shown in the figure below, two Flower App projects, each consisting of"
" a ``ServerApp`` and a ``ClientApp``, could share the same SuperLink and "
"SuperNodes."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:99
#, fuzzy
msgid "Multi-run federated learning architecture"
msgstr "연합 학습"

#: ../../source/explanation-flower-architecture.rst:104
#, fuzzy
msgid "Multi-run federated learning architecture (dark theme)"
msgstr "연합 학습"

#: ../../source/explanation-flower-architecture.rst:109
#, fuzzy
msgid "Multi-run federated learning architecture with Flower"
msgstr "연합 학습"

#: ../../source/explanation-flower-architecture.rst:111
msgid ""
"To illustrate how multi-run works, consider one federated learning "
"training run where a ``ServerApp`` and a ``ClientApp`` are participating "
"in ``[run 1]``. Note that a SuperNode will only run a ``ClientApp`` if it"
" is selected to participate in the training run."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:116
msgid ""
"In ``[run 1]`` below, all the SuperNodes are selected and therefore run "
"their corresponding ``ClientApp``\\s:"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:119
msgid "Multi-tenancy federated learning architecture - Run 1"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:124
#, fuzzy
msgid "Multi-tenancy federated learning architecture - Run 1 (dark theme)"
msgstr "연합 학습"

#: ../../source/explanation-flower-architecture.rst:129
msgid ""
"Run 1 in a multi-run federated learning architecture with Flower. All "
"SuperNodes participate in the training round."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:132
msgid ""
"However, in ``[run 2]``, only the first and second SuperNodes are "
"selected to participate in the training:"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:135
msgid "Multi-tenancy federated learning architecture - Run 2"
msgstr ""

#: ../../source/explanation-flower-architecture.rst:140
#, fuzzy
msgid "Multi-tenancy federated learning architecture - Run 2 (dark theme)"
msgstr "연합 학습"

#: ../../source/explanation-flower-architecture.rst:145
msgid ""
"Run 2 in a multi-run federated learning architecture with Flower. Only "
"the first and second SuperNodes are selected to participate in the "
"training round."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:148
msgid ""
"Therefore, with Flower multi-run, different Flower App projects can run "
"on different sets of clients."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:153
msgid ""
"This explanation covers the Flower Deployment Runtime. An explanation "
"covering the Flower Simulation Runtime will follow."
msgstr ""

#: ../../source/explanation-flower-architecture.rst:158
#, fuzzy
msgid ""
"As we continue to enhance Flower at a rapid pace, we'll periodically "
"update this explainer document. Feel free to share any feedback with us."
msgstr ""
"Flower Next는 빠른 속도로 지속적으로 개선되고 있으므로 이 가이드는 주기적으로 업데이트될 예정입니다. 피드백이 있으면 "
"언제든지 공유해 주세요!"

#: ../../source/explanation-flower-strategy-abstraction.rst:-1
msgid ""
"Create custom federated learning strategies in Flower by modifying client"
" sampling, training, aggregation, and evaluation for enhanced flexibility"
" and control."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:15
#, fuzzy
msgid "Flower Strategy Abstraction"
msgstr ":code:`Strategy` 추상화"

#: ../../source/explanation-flower-strategy-abstraction.rst:17
msgid ""
"The strategy abstraction enables the implementation of fully custom "
"federated learning strategies. In Flower, a *strategy* is essentially the"
" federated learning algorithm that runs inside the ``ServerApp``. "
"Strategies define how to:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:21
#, fuzzy
msgid "Sample clients"
msgstr "Flower 클라이언트."

#: ../../source/explanation-flower-strategy-abstraction.rst:22
#, fuzzy
msgid "Configure instructions for training and evaluation"
msgstr "고객을 위한 맞춤 지침."

#: ../../source/explanation-flower-strategy-abstraction.rst:23
msgid "Aggregate updates and metrics"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:24
#, fuzzy
msgid "Evaluate models"
msgstr "EvaluateRes"

#: ../../source/explanation-flower-strategy-abstraction.rst:26
msgid ""
"Flower ships with a number of built-in strategies, all following the same"
" API described below. You can also implement your own strategies with "
"full access to the same capabilities."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:32
#, fuzzy
msgid "The ``Strategy`` abstraction"
msgstr ":code:`Strategy` 추상화"

#: ../../source/explanation-flower-strategy-abstraction.rst:34
#, fuzzy
msgid ""
"All strategy implementations must derive from the abstract base class "
"|strategy_link|_. This includes both built-in strategies and third-"
"party/custom strategies. By extending this base class, user-defined "
"strategies gain the exact same power and flexibility as the built-in "
"ones."
msgstr ""
"모든 전략 구현은 기본 제공 구현과 타사 구현 모두 추상 기본 클래스인 "
":code:`flwr.server.strategy.Strategy`에서 파생됩니다. 즉, 사용자 정의 전략 구현은 기본 제공 구현과"
" 완전히 동일한 기능을 사용할 수 있습니다."

#: ../../source/explanation-flower-strategy-abstraction.rst:39
msgid ""
"The ``Strategy`` base class defines a ``start`` method and requires "
"subclasses to implement several abstract methods:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:97
#, fuzzy
msgid "Creating a new strategy"
msgstr "새 페이지 만들기"

#: ../../source/explanation-flower-strategy-abstraction.rst:99
msgid ""
"You can customize an existing strategy (e.g., |fedavg_link|_) by "
"overriding one or several of its methods. For full flexibility, you can "
"also implement a strategy from scratch. To implement a brand new "
"strategy, simply define a class that derives from ``Strategy`` and "
"implement the abstract methods:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:127
msgid ""
"The ``start`` method is already implemented in the base class and "
"typically does not need to be overridden. It orchestrates the federated "
"learning process by invoking the abstract methods in sequence."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:133
#, fuzzy
msgid "Understand ``start`` method"
msgstr ":code:`evaluate` 메서드"

#: ../../source/explanation-flower-strategy-abstraction.rst:135
msgid "The ``start`` method of the ``Strategy`` base class follows this workflow:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:137
msgid ""
"Call ``evaluate_fn`` (if provided) to evaluate the initial model on the "
"ServerApp side."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:139
msgid "Call ``configure_train`` to generate training messages for ClientApps."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:140
#, fuzzy
msgid "Send training messages to ClientApps."
msgstr "클라이언트앱"

#: ../../source/explanation-flower-strategy-abstraction.rst:141
msgid ""
"ClientApps run their ``@app.train()`` function and return training "
"replies."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:142
msgid "Call ``aggregate_train`` to aggregate the training replies."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:143
msgid ""
"Call ``configure_evaluate`` to generate evaluation messages for "
"ClientApps."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:144
#, fuzzy
msgid "Send evaluation messages to ClientApps."
msgstr "클라이언트앱"

#: ../../source/explanation-flower-strategy-abstraction.rst:145
msgid ""
"ClientApps run their ``@app.evaluate()`` function and return evaluation "
"replies."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:146
msgid "Call ``aggregate_evaluate`` to aggregate the evaluation replies."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:147
msgid ""
"Call ``evaluate_fn`` (if provided) to evaluate the aggregated model on "
"the ServerApp side."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:149
msgid "Repeat steps 2-10 for the specified number of rounds."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:150
msgid ""
"Return the final ``Result``, which contains the final model and metrics "
"history."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:152
msgid "The following diagram illustrates the flow."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:156
msgid ""
"The sequence diagram below shows the interaction between ``ServerApp``, "
"``Strategy`` (inside ``ServerApp``), and ``ClientApp``. In reality, they "
"do **not** communicate directly over the network—Flower infrastructure "
"(``SuperLink`` and ``SuperNode``) transparently manages all "
"communication. You can read more about it in the :doc:`Flower Network "
"Communication <ref-flower-network-communication>` guide."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:201
#, fuzzy
msgid "The ``configure_train`` method"
msgstr ":code:`configure_fit` 메서드"

#: ../../source/explanation-flower-strategy-abstraction.rst:203
#, fuzzy
msgid ""
"The ``configure_train`` method is responsible for preparing the next "
"round of training. But what does *configure* mean in this context? It "
"means selecting which clients should participate in the round and "
"deciding what instructions they should receive."
msgstr ""
":code:`configure_fit`은 다가오는 학 라운드를 구성하는 역할을 합니다. 이 문맥에서 *구성*은 무엇을 의미하나요? "
"라운드를 구성한다는 것은 클라이언트를 선택하고 이 클라이언트에게 어떤 지침을 보낼지 결정하는 것을 의미합니다. "
"code:`configure_fit`의 시그니처를 보면 이를 명확히 알 수 있습니다:"

#: ../../source/explanation-flower-strategy-abstraction.rst:207
#: ../../source/explanation-flower-strategy-abstraction.rst:249
#: ../../source/explanation-flower-strategy-abstraction.rst:287
#: ../../source/explanation-flower-strategy-abstraction.rst:330
msgid "Here is the method signature:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:217
#: ../../source/explanation-flower-strategy-abstraction.rst:297
msgid "This method takes four arguments:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:219
#: ../../source/explanation-flower-strategy-abstraction.rst:263
#: ../../source/explanation-flower-strategy-abstraction.rst:299
#: ../../source/explanation-flower-strategy-abstraction.rst:344
msgid "``server_round``: The current round number"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:220
#, fuzzy
msgid "``arrays``: The current global model parameters"
msgstr "현재(전역) 모델 매개변수입니다."

#: ../../source/explanation-flower-strategy-abstraction.rst:221
msgid "``config``: A configuration dictionary for the round"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:222
msgid "``grid``: The object responsible for managing communication with clients"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:224
#, fuzzy
msgid ""
"The return value is an iterable of ``Message`` objects, where each "
"message contains the instructions to be sent to a specific client. A "
"typical implementation of ``configure_train`` will:"
msgstr ""
"반환 값은 튜플 목록으로, 각 튜플은 특정 클라이언트로 전송될 명령어를 나타냅니다. 전략 구현은 일반적으로 "
":code:`configure_fit`에서 다음 단계를 수행합니다:"

#: ../../source/explanation-flower-strategy-abstraction.rst:228
msgid ""
"Use the ``grid`` to randomly sample a subset (or all) of the available "
"clients"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:229
msgid ""
"Create one ``Message`` per selected client, containing the global model "
"parameters and configuration values"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:232
msgid ""
"More advanced strategies can implement custom client selection logic by "
"using the capabilities of ``grid``. A client only participates in a round"
" if ``configure_train`` generates a message for its node ID."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:238
msgid ""
"Because the return value is defined per client, strategies can easily "
"implement heterogeneous configurations. For example, different clients "
"can receive different models or hyperparameters, enabling highly "
"customized training behaviors."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:244
#, fuzzy
msgid "The ``aggregate_train`` method"
msgstr ":code:`aggregate_fit` 메서드"

#: ../../source/explanation-flower-strategy-abstraction.rst:246
#, fuzzy
msgid ""
"The ``aggregate_train`` method is responsible for aggregating the "
"training results received from the clients selected in "
"``configure_train``."
msgstr ""
"code:`aggregate_fit`은 :code:`configure_fit`에서 훈련하도록 선택되고 요청된 클라이언트가 반환한 "
"결과를 집계하는 역할을 담당합니다."

#: ../../source/explanation-flower-strategy-abstraction.rst:261
#: ../../source/explanation-flower-strategy-abstraction.rst:342
msgid "This method takes two arguments:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:264
msgid ""
"``replies``: An iterable of ``Message`` objects from the participating "
"clients"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:266
msgid "It returns a tuple consisting of:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:268
#, fuzzy
msgid "``ArrayRecord``: The updated global model parameters"
msgstr "현재 로컬 모델 파라미터를 반환합니다."

#: ../../source/explanation-flower-strategy-abstraction.rst:269
msgid "``MetricRecord``: Aggregated training metrics (such as loss or accuracy)"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:271
msgid ""
"If aggregation cannot be performed (e.g., if too many clients failed "
"during the round), the method may decide to return ``(None, None)`` "
"instead."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:276
msgid ""
"You can use ``Message.has_error()`` to check if a reply contains an error"
" and decide how to handle it during aggregation."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:281
#, fuzzy
msgid "The ``configure_evaluate`` method"
msgstr ":code:`configure_evaluate` 메서드"

#: ../../source/explanation-flower-strategy-abstraction.rst:283
#, fuzzy
msgid ""
"The ``configure_evaluate`` method is responsible for preparing the next "
"round of evaluation. Similar to ``configure_train``, this involves "
"selecting which clients should participate and deciding what instructions"
" they should receive for evaluation."
msgstr ""
":code:`configure_evaluate`는 다가오는 평가 라운드를 구성하는 역할을 합니다. 이 문맥에서 *구성*은 무엇을 "
"의미하나요? 라운드를 구성한다는 것은 클라이언트를 선택하고 이러한 클라이언트에 전송할 지침을 결정하는 것을 의미합니다. "
":code:`configure_evaluate`의 시그니처를 보면 이를 명확히 알 수 있습니다:"

#: ../../source/explanation-flower-strategy-abstraction.rst:300
#, fuzzy
msgid "``arrays``: The current global model parameters to be evaluated"
msgstr "현재(전역) 모델 매개변수입니다."

#: ../../source/explanation-flower-strategy-abstraction.rst:301
msgid "``config``: A configuration dictionary for evaluation"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:302
msgid "``grid``: The object that manages communication with clients"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:304
msgid ""
"The return value is an iterable of ``Message`` objects, one for each "
"selected client. Each message typically contains the current global model"
" parameters and any evaluation configuration."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:308
msgid "A typical implementation of ``configure_evaluate`` will:"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:310
msgid "Use ``grid`` to select a subset (or all) of the available clients"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:311
msgid ""
"Create one ``Message`` per selected client containing the global model "
"and evaluation configuration"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:314
msgid ""
"As with training, more advanced strategies may apply custom client "
"selection logic or send different evaluation configurations to different "
"clients."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:319
msgid ""
"Because each client receives its own message, strategies can implement "
"heterogeneous evaluation setups. For example, some clients might evaluate"
" on larger test sets, while others might use specialized metrics."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:325
#, fuzzy
msgid "The ``aggregate_evaluate`` method"
msgstr ":code:`aggregate_evaluate` 메서드"

#: ../../source/explanation-flower-strategy-abstraction.rst:327
#, fuzzy
msgid ""
"The ``aggregate_evaluate`` method is responsible for aggregating the "
"evaluation results received from the clients selected in "
"``configure_evaluate``."
msgstr ""
"code:`aggregate_evaluate`는 :code:`configure_evaluate`에서 선택되어 평가를 요청한 "
"클라이언트가 반환한 결과를 집계하는 역할을 담당합니다."

#: ../../source/explanation-flower-strategy-abstraction.rst:345
msgid ""
"``replies``: An iterable of ``Message`` objects returned by the clients "
"after they executed evaluation"
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:348
msgid ""
"It returns a single ``MetricRecord`` that represents the aggregated "
"evaluation metrics across all participating clients. If aggregation "
"cannot be performed (for example, due to excessive client failures or "
"missing metrics), the method may return ``None``."
msgstr ""

#: ../../source/explanation-flower-strategy-abstraction.rst:354
msgid ""
"As with training, ``Message.has_error()`` can be used to detect and "
"handle client errors during aggregation."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md
msgid ""
"Deploy Flower's SuperLink Helm chart to set up federated learning "
"servers. Default config mirrors official releases, enabling seamless "
"deployment, evaluation."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:12
msgid "Deploy SuperLink using Helm"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:15
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:15
msgid ""
"Flower Helm charts are a Flower Enterprise feature. See [Flower "
"Enterprise](https://flower.ai/enterprise) for details."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:18
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:18
msgid ""
"The Flower Framework offers a unified approach to federated learning, "
"analytics, and evaluation, allowing you to federate any workload, machine"
" learning framework, or programming language."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:21
msgid ""
"This Helm chart installs the server-side components of the Flower "
"Framework, specifically setting up the SuperLink."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:24
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:24
msgid ""
"The default installation configuration aims to replicate the "
"functionality and setup of the provided Flower Framework releases."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:27
#, fuzzy
msgid "Disable the SuperLink component"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:35
#, fuzzy
msgid "Enable the SuperExec component"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:42
#, fuzzy
msgid "Run simulations in Kubernetes using the Simulation Plugin"
msgstr "멀티 노드 Flower 시뮬레이션"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:44
msgid ""
"For more details, visit: [Run simulations](../how-to-run-simulations.rst"
"#run-simulations) guide."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:53
msgid "Change Log Verbosity Level"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:55
msgid ""
"The log verbosity level in Flower can be adjusted using the "
"`FLWR_LOG_LEVEL` environment variable. This helps control the level of "
"detail included in logs, making debugging and monitoring easier."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:58
#, fuzzy
msgid "Setting Global Log Level"
msgstr "글로벌 모델 전송"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:60
msgid ""
"To enable detailed logging (e.g., `DEBUG` level) for all services, add "
"`FLWR_LOG_LEVEL` to the `env` parameter under the `global` section in "
"your `values.yml` file:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:70
msgid "Setting Log Level for a Specific Service"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:72
msgid ""
"If you want to enable logging only for a specific service (e.g., "
"`superlink`), you can specify it under the respective service section:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:82
msgid ""
"For more details on logging configuration, visit: [Flower Logging "
"Documentation](../how-to-configure-logging.rst)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:85
#: ../../source/how-to-configure-audit-logging.rst:7
#, fuzzy
msgid "Configure Audit Logging"
msgstr "클라이언트 구성"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:87
msgid ""
"Audit logging provides JSON-formatted log output for Flower, allowing you"
" to capture and store events that occur in the SuperLink. This feature is"
" useful for monitoring, debugging, or maintaining a historical record of "
"important actions."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:91
msgid ""
"To enable audit logging, add the following flag to the SuperLink "
"configuration:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:100
msgid ""
"For more details on audit logging configuration, visit: [Flower Audit "
"Logging Documentation](../how-to-configure-audit-logging.rst)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:103
msgid "License Key"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:105
msgid ""
"Starting from `1.20.0`, the SuperLink service must be started with a "
"valid license key."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:108
msgid ""
"You can configure the license key in the `global.license` section of your"
" `values.yml` file in one of two ways:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:111
msgid "Directly — by setting `global.license.key` to your license key."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:112
msgid ""
"From an existing Kubernetes Secret — by setting "
"`global.license.existingSecret` to the name of a secret that contains "
"your key."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:116
msgid ""
"The SuperLink must be able to connect to `https://api.flower.ai` in order"
" to validate the license."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:119
msgid "Example: Setting the License Key Directly"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:129
msgid ""
"In this configuration, the Helm chart will automatically create a "
"Kubernetes Secret and mount it into the SuperLink container."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:132
#, fuzzy
msgid "Example: Using an Existing Secret"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:142
msgid ""
"If both `key` and `existingSecret` are set, `existingSecret` takes "
"precedence and the `key` value will be ignored."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:146
msgid ""
"By default, the `existingSecret` resource must contain a key named "
"`FLWR_LICENSE_KEY`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:155
#, fuzzy
msgid "Example: Setting a Custom Secret Key"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:157
msgid ""
"If you prefer to use a different key name instead of the default "
"`FLWR_LICENSE_KEY`, you can override it by setting `secretKey` to your "
"desired name:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:175
#, fuzzy
msgid "Enable Account Authentication"
msgstr "설치 확인"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:177
msgid ""
"Account authentication can be enabled if you're using the Flower "
"Enterprise Edition (EE) Docker images. This is configured in the "
"`global.userAuth` section of your `values.yml` file."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:180
#, fuzzy
msgid "Example: Enabling OpenID Connect (OIDC) Authentication"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:196
#, fuzzy
msgid "Explanation of Parameters:"
msgstr "모델 매개변수."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:198
msgid "`authn_type`: The authentication mechanism being used (e.g., oidc)."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:199
msgid ""
"`auth_url`: The OpenID Connect authentication endpoint where users "
"authenticate."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:200
msgid "`token_url`: The URL for retrieving access tokens."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:201
msgid "`validate_url`: The endpoint for validating account authentication."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:202
msgid "`oidc_client_id`: The client ID issued by the authentication provider."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:203
msgid "`oidc_client_secret`: The secret key associated with the client ID."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:205
#, fuzzy
msgid "Use an Existing Secret"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:207
msgid ""
"To use an existing secret that contains the account authentication "
"configuration, set `existingSecret` to the name of the existing secret:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:218
msgid ""
"Note that the existing secret must contain the key `account-auth-"
"config.yml`:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:233
#, fuzzy
msgid "Configuring OpenFGA"
msgstr "구성"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:235
msgid ""
"The flower-server chat component supports OpenFGA as a fine-grained "
"authorization service, but it is disabled by default."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:238
msgid "To enable OpenFGA change the following value in your `values.yml` file:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:245
msgid ""
"By default, OpenFGA will run with an in-memory store, which is non-"
"persistent and suitable only for testing or development."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:248
msgid "OpenFGA supports persistent storage using PostgreSQL or MySQL:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:250
msgid ""
"To deploy OpenFGA with a new PostgreSQL/MySQL instance, enable the "
"bundled chart configuration."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:251
msgid ""
"To connect to an existing database, provide the appropriate connection "
"details via Helm values (e.g., `openfga.datastore.uri`)."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:254
msgid ""
"For more information visit the official [OpenFGA Helm Chart "
"Documentation](https://artifacthub.io/packages/helm/openfga/openfga/0.2.30)."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:256
msgid ""
"The following commands set up a store, authorization model, and inserts "
"users (using tuples) into OpenFGA. Run these once the OpenFGA instance is"
" deployed."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:258
msgid "Setup the authorization model and tuples:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md
msgid "Authorization model file `model.fga`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md
msgid "User permissions file `tuples.fga`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:292
#, fuzzy
msgid "Create store:"
msgstr "새 페이지 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:302
msgid ""
"The response will include an `id` field, which is the OpenFGA store ID "
"associated with the `OPENFGA_STORE_NAME` that was created."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:304
msgid "Get store ID (alternative way):"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:311
msgid "Set OpenFGA store ID from previous step and write model:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:321
msgid "Set OpenFGA model ID from previous step and write tuples:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:332
msgid ""
"Add a new `authorization` section under your existing `global.userAuth` "
"configuration or directly within your existing secret, depending on your "
"setup. Set the `OPENFGA_STORE_ID` and `OPENFGA_MODEL_ID` from the "
"previous steps in the file:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:344
#, fuzzy
msgid "Change Isolation Mode"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:346
msgid ""
"The isolation mode determines how the SuperLink manages the SuperExec "
"process execution. This setting can be adjusted using the "
"`superlink.isolationMode` parameter:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:349
msgid "**Example: Changing Isolation Mode**"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:361
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:85
#, fuzzy
msgid "Deploy Flower Framework with TLS"
msgstr "Flower 프레임워크"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:363
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:87
msgid ""
"By default, the Flower Framework is deployed with TLS enabled. This means"
" `tls.enabled` is set to `true`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:366
msgid ""
"If `cert-manager` is installed in your Kubernetes cluster, this chart can"
" be used to set up TLS in several ways. By default, it creates both a "
"self-signed `Issuer` and a `Certificate`, but you can also choose to "
"create only an `Issuer` or create a `Certificate` from an existing "
"`Issuer`/`ClusterIssuer`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:371
msgid ""
"Regardless of the option you choose, TLS is only enabled when you set "
"`tls.enabled: true`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:373
msgid "Default Behavior (self-signed Issuer + Certificate)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:387
msgid ""
"When deployed with these values, the chart creates a self-signed `Issuer`"
" and then uses it to issue a TLS certificate. The generated `Certificate`"
" is valid for five years, is renewed fifteen days before expiry, and is "
"stored in a Kubernetes `Secret`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:391
msgid ""
"If you leave `secretName` empty, the secret name defaults to `<chart-name"
">-server-tls`. The certificate includes `global.domain` as its common "
"name, along with service DNS entries and any `additionalHosts` you "
"provide."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:395
msgid ""
"This setup is best suited for testing and validating the Helm charts in a"
" non-production environment."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:398
msgid ""
"You can switch from self-signed to another issuer type by providing a "
"`spec` block for the `Issuer`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:401
msgid "Create a Certificate using an Existing Issuer / ClusterIssuer"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:403
msgid ""
"Use this if you already have an `Issuer` or `ClusterIssuer` (e.g., Let’s "
"Encrypt or a corporate CA) and you want the chart to create the "
"`Certificate`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:420
msgid ""
"With this configuration, the chart does not create a new `Issuer`. "
"Instead, it references the specified `ClusterIssuer` named `letsencrypt-"
"clusterissuer` and requests a `Certificate` from it. It is stored in a "
"Kubernetes `Secret` that, by default, is named `<chart-name>-server-tls`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:424
msgid ""
"To change the secret name, set `tls.certificate.secretName` to the "
"desired name:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:432
msgid "Create only an Issuer"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:434
msgid ""
"In this mode, the chart creates an `Issuer` but does not create a "
"`Certificate`. This is useful if you want `cert-manager` to automatically"
" generate certificates based on `Ingress` annotations."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:448
msgid ""
"See the [Ingress Configuration](###generate-a-certificate-via-ingress-"
"annotations) section for more information."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:450
#, fuzzy
msgid "Use an Existing TLS Certificate"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:452
msgid ""
"If you already have a TLS certificate available as a Kubernetes `Secret`,"
" you can configure the chart to use it directly instead of creating a new"
" `Certificate` with `cert-manager`. To do this, disable certificate "
"creation and set `tls.existingSecret` to the name of your `Secret`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:456
msgid ""
"The `Secret` must be of type `kubernetes.io/tls` and contain the standard"
" `tls.crt`, `tls.key` fields, with `ca.crt` being optional. If `ca.crt` "
"is not provided, `tls.crt` will also be used as the CA certificate."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:460
msgid ""
"If both `tls.existingSecret` and `tls.certificate.enabled` are set, the "
"`tls.existingSecret` value will be ignored and a new `Certificate` will "
"be issued."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:472
#, fuzzy
msgid "Override Certificate Paths"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:474
msgid ""
"By default, the TLS-related flags use the following paths when TLS is "
"enabled:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:476
msgid ""
"`--ssl-ca-certfile`: `/app/cert/ca.crt`, `--ssl-certfile`: "
"`/app/cert/tls.crt`, `--ssl-keyfile`: `/app/cert/tls.key`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:480
msgid ""
"These paths can be overridden by specifying the flags in the `extraArgs`,"
" as shown below:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:496
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:146
#, fuzzy
msgid "Deploy Flower Framework without TLS"
msgstr "플라워 프레임워크 문서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:498
msgid ""
"You might want to disable TLS for testing or internal use. In this mode, "
"the chart does not create any `cert-manager` `Issuer` or `Certificate` "
"resources, and any TLS-related configuration on the `Ingress` resource is"
" ignored."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:507
#, fuzzy
msgid "Ingress Configuration"
msgstr "구성 값"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:509
#, fuzzy
msgid "Generate a Certificate via Ingress Annotations"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:511
msgid ""
"If you prefer to let `cert-manager` generate a `Certificate` through "
"`Ingress` annotations, you can disable the chart’s built-in certificate "
"management. To do this, set `tls.certificate.enabled` to `false` and "
"leave `tls.existingSecret` empty. Also ensure `tls.enabled` is set to "
"`true`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:516
msgid ""
"The annotations you specify under `superlink.ingress.annotations` will be"
" passed directly to the `Ingress` resource. For supported annotation "
"keys, refer to the `cert-manager` [documentation](https://cert-"
"manager.io/docs/usage/ingress/)."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:544
msgid ""
"The chart creates an `Ingress` for SuperLink with the provided "
"annotations. `cert-manager` generates a `Certificate`, and stores it in a"
" Kubernetes `Secret`. That `Secret` is then mounted into the SuperLink "
"container so it can use the TLS keypair for its endpoints. The same "
"`Secret` is also referenced by the `Ingress` resource, which means the "
"generated certificate is shared between the `Ingress` and the SuperLink "
"service."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:550
msgid ""
"By default, the Ingress-generated certificate is stored in a `Secret` "
"named `<chart-name>-server-tls`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:553
msgid "You can override this by setting `superlink.ingress.tls.secretName`:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:564
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:114
#, fuzzy
msgid "**Important:**"
msgstr "중요"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:566
msgid ""
"If `tls.certificate.enabled` is set to `true` or if `tls.existingSecret` "
"is specified, the `secretName` of the `Ingress` resource is ignored. In "
"that case, the chart will rely on the `Certificate` created through its "
"own mechanism."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:569
msgid ""
"Always ensure that when you use `Ingress` annotations, no certificate is "
"generated or referenced by this chart. Otherwise, you may end up with "
"conflicting secrets."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:572
msgid "TLS Certificate with Additional Hosts"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:574
msgid ""
"By default, when `cert-manager` issues a `Certificate` it only includes "
"the DNS name specified in `commonName`, which is derived from "
"`global.domain`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:577
msgid ""
"In some deployments, the server and client charts may run inside the same"
" Kubernetes cluster, while the Control API is exposed publicly over the "
"internet. In this scenario, the SuperNodes need to connect to the "
"SuperLink using its internal service URL (e.g., "
"`<superlink>.<namespace>.svc.cluster.local`)."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:582
msgid ""
"To support this, you can extend the certificate with additional hosts by "
"using `superlink.ingress.extraHosts`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:585
msgid ""
"The example below shows how to configure the `Ingress` so that the "
"generated `Certificate` covers both the external hostname and the "
"internal service name:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:617
msgid "SSL-Passthrough"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:619
msgid ""
"In some scenarios, you may want to let the SuperLink service terminate "
"TLS directly rather than having the Ingress controller handle TLS "
"termination. This is useful if you need to use protocols such as gRPC "
"over TLS end-to-end, where the Ingress should simply forward the "
"encrypted traffic without decrypting it."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:624
msgid ""
"To enable this mode with the NGINX Ingress Controller, you can configure "
"SSL passthrough by setting the `nginx.ingress.kubernetes.io/ssl-"
"passthrough` annotation to `\"true\"`. In this configuration, the Ingress"
" forwards TLS traffic directly to the SuperLink container, which then "
"handles certificate validation and encryption."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:662
#, fuzzy
msgid "Enable Node Authentication"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:676
msgid "Public keys can include comments at the end of the key data:"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:685
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:240
#: flwr.app.error.Error flwr.app.metadata.Metadata
#: flwr.clientapp.client_app.ClientApp.evaluate
#: flwr.clientapp.client_app.ClientApp.query
#: flwr.clientapp.client_app.ClientApp.train
#: flwr.clientapp.mod.localdp_mod.LocalDpMod flwr.common.context.Context
#: flwr.common.message.Message flwr.common.message.Message.create_error_reply
#: flwr.common.message.Message.create_reply flwr.common.message.Message.inflate
#: flwr.common.record.array.Array flwr.common.record.array.Array.inflate
#: flwr.common.record.arrayrecord.ArrayRecord
#: flwr.common.record.arrayrecord.ArrayRecord.inflate
#: flwr.common.record.configrecord.ConfigRecord
#: flwr.common.record.configrecord.ConfigRecord.inflate
#: flwr.common.record.metricrecord.MetricRecord
#: flwr.common.record.metricrecord.MetricRecord.inflate
#: flwr.common.record.recorddict.RecordDict
#: flwr.common.record.recorddict.RecordDict.inflate
#: flwr.server.grid.grid.Grid.create_message
#: flwr.server.grid.grid.Grid.pull_messages
#: flwr.server.grid.grid.Grid.push_messages
#: flwr.server.grid.grid.Grid.send_and_receive
#: flwr.server.grid.grid.Grid.set_run flwr.serverapp.strategy.bulyan.Bulyan
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad
#: flwr.serverapp.strategy.fedadam.FedAdam
#: flwr.serverapp.strategy.fedavg.FedAvg
#: flwr.serverapp.strategy.fedavgm.FedAvgM
#: flwr.serverapp.strategy.fedmedian.FedMedian
#: flwr.serverapp.strategy.fedprox.FedProx
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic
#: flwr.serverapp.strategy.fedyogi.FedYogi flwr.serverapp.strategy.krum.Krum
#: flwr.serverapp.strategy.multikrum.MultiKrum
#: flwr.serverapp.strategy.qfedavg.QFedAvg
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train
#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate
#: flwr.serverapp.strategy.strategy.Strategy.configure_train
#: flwr.serverapp.strategy.strategy.Strategy.start of
msgid "Parameters"
msgstr "파라미터"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:687
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:242
#, fuzzy
msgid "Helm parameters"
msgstr "모델 매개변수."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Name"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Value"
msgstr "EvaluateRes"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`nameOverride`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Override Replaces the name of the chart in the Chart.yaml"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`flower-server`"
msgstr "Flower 서버."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`fullnameOverride`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Override Completely replaces the generated name."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`\"\"`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:694
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:249
#, fuzzy
msgid "Global parameters"
msgstr "모델 매개변수."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.annotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Default Annotations"
msgstr "설명"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, python-brace-format
msgid "`{}`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.labels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default Labels"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.podLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default PodLabels"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.domain`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Default Domain"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`example.com`"
msgstr "예시"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.ingressClassName`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Default IngressClass"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.nodeSelector`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default node selector for all components"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.tolerations`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Default tolerations for all components"
msgstr "고객을 위한 맞춤 지침."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`[]`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.affinity.podAntiAffinity`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default affinity preset for all components"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`soft`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default pod anti-affinity rules. Either: `none`, `soft` or `hard`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.affinity.nodeAffinity.type`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default node affinity rules. Either: `none`, `soft` or `hard`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`hard`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.affinity.nodeAffinity.matchExpressions`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default match expressions for node affinity"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.nodeAuth.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enables or Disables Node-Authentication SuperLink \\<-> SuperNode"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`false`"
msgstr "``flwr/base``"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.nodeAuth.authListPublicKeys`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "A list of ecdsa-sha2-nistp384 SuperNode keys"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.userAuth.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Enables or disables the user authentication plugin."
msgstr "설치 확인"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`global.userAuth.config`"
msgstr ":code:`evaluate`"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Set the user authentication configuration."
msgstr "구성 값"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`global.userAuth.existingSecret`"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Existing secret with user authentication configuration."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.license.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enables or disables the configuration of the EE license."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`true`"
msgstr "``DISTRO``"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.license.key`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "The EE license key."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`global.license.secretKey`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "The name of the key inside the Kubernetes Secret"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`FLWR_LICENSE_KEY`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`global.license.existingSecret`"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Name of an existing Kubernetes Secret"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.securityContext.runAsUser`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context runAsUser"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`49999`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.securityContext.runAsGroup`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context runAsGroup"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.securityContext.fsGroup`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context fsGroup"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.podSecurityContext.runAsNonRoot`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context runAsNonRoot"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.podSecurityContext.readOnlyRootFilesystem`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context readOnlyRootFilesystem"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.podSecurityContext.allowPrivilegeEscalation`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context allowPrivilegeEscalation"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.podSecurityContext.seccompProfile.type`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context seccompProfile"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`RuntimeDefault`"
msgstr "``flwr/base``"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.podSecurityContext.capabilities.drop`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Set Security Context capabilities"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`[\"ALL\"]`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.env`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Default environment variables"
msgstr "환경 변수 설정"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.image.pullPolicy`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Default image pullPolicy"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`IfNotPresent`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:729
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:276
#, fuzzy
msgid "TLS Configuration"
msgstr "구성 값"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`tls.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enable TLS configuration for the Flower Framework."
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.issuer.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable automatic creation of a cert-manager Issuer."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.issuer.name`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Name of the Issuer resource to use."
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.issuer.spec`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "The contents of the `.spec` block for the cert-manager Issuer."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.enabled`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable automatic creation of a cert-manager Certificate."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.annotations`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Certificate CRD annotations."
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.secretName`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Name of the Kubernetes Secret to store the TLS key and certificate."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.issuerGroup`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "API group for the issuer. Defaults to `cert-manager.io`."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`cert-manager.io`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.existingIssuer`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Name of an existing Issuer or ClusterIssuer to use."
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.existingIssuerKind`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Kind of the existing issuer (`Issuer` or `ClusterIssuer`)."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.duration`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "The requested ‘duration’ (i.e. lifetime) of the Certificate."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`43800h`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.renewBefore`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "How long before the currently issued certificate’s expiry"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`360h`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.privateKey`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Private key options. These include the key algorithm and"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.usages`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Requested key usages and extended key usages."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.certificate.additionalHosts`"
msgstr "인증서"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Additional hosts you want to put into the SAN's"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`tls.existingSecret`"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:750
#, fuzzy
msgid "Component SuperLink"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.name`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Name of the SuperLink"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Enable or Disable SuperLink"
msgstr ":code:`SuperLink`에서 노드 인증 활성화"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.resources`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Set container requests and limits for different resources like CPU or "
"memory (essential for production workloads)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.volumes`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Specify a list of volumes for the SuperLink pod(s)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.volumeMounts`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Allows to specify additional VolumeMounts"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.simulation.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Launch the SimulationIo API server in place of the"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.isolationMode`"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "The isolation mode of the SuperLink"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`subprocess`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.automountServiceAccountToken`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Automount SA-Token into the pod."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.serviceAccount.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enabled a service account for the application controller"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.serviceAccount.annotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Annotations applied to enabled service account"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.serviceAccount.labels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Labels applied to enabled service account"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.serviceAccount.automountServiceAccountToken`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Automount SA-Token"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.type`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Valid are ClusterIP, NodePort or Loadbalancer"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`ClusterIP`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.servicePortControlName`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Prefix of the SuperLink Control API port"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`control`"
msgstr "클라이언트앱"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.servicePortControl`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Port to expose for the SuperLink Control API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`9093`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.nodePortControl`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Node port for SuperLink Control API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.servicePortServerAppIoName`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Prefix of the SuperLink ServerAppIo API port"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`serverappio`"
msgstr "flower 서버 프로그램"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.servicePortServerAppIo`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Port to expose for the SuperLink ServerAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`9091`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.service.nodePortServerAppIo`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Node port for SuperLink ServerAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.service.servicePortFleetName`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Prefix of the SuperLink Fleet API port"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`fleet`"
msgstr "``flwr/base``"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.service.servicePortFleet`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Port to expose for the SuperLink Fleet API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`9092`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.service.nodePortFleet`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Node port for SuperLink Fleet API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.service.servicePortSimulationIoName`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Prefix of the SuperLink SimulationIo API port"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`simulationio`"
msgstr "CLI 시뮬레이션"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.service.servicePortSimulationIo`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Port to expose for the SuperLink SimulationIo API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`9096`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.service.nodePortSimulationIo`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Node port for SuperLink SimulationIo API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.containerPorts.control`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Container port for SuperLink Control API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.containerPorts.serverAppIo`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Container port for SuperLink ServerAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.containerPorts.fleet`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Container port for SuperLink Fleet API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.containerPorts.simulationIo`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Container port for SuperLink SimulationIo API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.containerPorts.health`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Container port for SuperLink Health API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`8081`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.replicaCount`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "The number of SuperLink pods to run"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`1`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.labels`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Extra labels for SuperLink pods"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.extraArgs`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Add extra arguments to the default arguments for the SuperLink"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.nodeSelector`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Node labels for SuperLink pods which merges with global.nodeSelector"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.tolerations`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Node tolerations for SuperLink pods which merges with global.tolerations"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.updateStrategy.type`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink deployment strategy type"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`RollingUpdate`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.updateStrategy.rollingUpdate`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink deployment rolling update configuration parameters"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.affinity`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Node affinity for SuperLink pods which merges with global.affinity"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.env`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid ""
"Array with extra environment variables to add to SuperLink nodes which "
"merges with global.env"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.podSecurityContext`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Security settings that for the SuperLink Pods"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.securityContext`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Security settings that for the SuperLink"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.livenessProbe.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable livenessProbe on SuperLink containers"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.livenessProbe.initialDelaySeconds`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Initial delay seconds for livenessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`0`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.livenessProbe.periodSeconds`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Period seconds for livenessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`10`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.livenessProbe.timeoutSeconds`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Timeout seconds for livenessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.livenessProbe.failureThreshold`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Failure threshold for livenessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`3`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.livenessProbe.successThreshold`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Success threshold for livenessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.readinessProbe.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Enable readinessProbe on SuperLink containers"
msgstr ":code:`SuperLink`에서 노드 인증 활성화"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.readinessProbe.initialDelaySeconds`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Initial delay seconds for readinessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.readinessProbe.periodSeconds`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Period seconds for readinessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.readinessProbe.timeoutSeconds`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Timeout seconds for readinessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.readinessProbe.failureThreshold`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Failure threshold for readinessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.readinessProbe.successThreshold`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Success threshold for readinessProbe"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable the ingress resource"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.annotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Additional annotations for the ingress"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.ingressClassName`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Defines which ingress controller which implement the resource"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.tls.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable TLS termination at the Ingress level."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.tls.secretName`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Name of the Kubernetes Secret that will contain the"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.control.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable an ingress resource for SuperLink API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.control.hostname`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Ingress hostname for the SuperLink API ingress"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`control.example.com`"
msgstr "예시"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.control.path`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink API ingress path"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`/`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.control.pathType`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Ingress path type. One of Exact, Prefix or ImplementationSpecific"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`ImplementationSpecific`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.fleet.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable an ingress resource for SuperLink Fleet API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.fleet.hostname`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Ingress hostname for the SuperLink Fleet API ingress"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`fleet.example.com`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.fleet.path`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink Fleet API ingress path"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.fleet.pathType`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.serverAppIo.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Enable an ingress resource for SuperLink ServerAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.serverAppIo.hostname`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Ingress hostname for the SuperLink ServerAppIo API ingress"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`serverappio.example.com`"
msgstr "시뮬레이션 예제"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.serverAppIo.path`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink ServerAppIo API ingress path"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.ingress.serverAppIo.pathType`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.simulationIo.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable an ingress resource for SuperLink SimulationIo API"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.simulationIo.hostname`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Ingress hostname for the SuperLink SimulationIo API ingress"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`simulation.example.com`"
msgstr "시뮬레이션 예제"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.simulationIo.path`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink SimulationIo API ingress path"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.simulationIo.pathType`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.extraHosts`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "An array with additional hostname(s) to be covered with the ingress record"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.extraTls`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid ""
"TLS configuration for additional hostname(s) to be covered with this "
"ingress record"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.ingress.extraRules`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Additional rules to be covered with this ingress record"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.lifecycle`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink container(s) to automate configuration before or after startup"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.annotations`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Additional custom annotations for SuperLink"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.selectorLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Extra selectorLabels for SuperLink pods"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.podAnnotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Annotations for SuperLink pods"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.podLabels`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Extra podLabels for SuperLink pods"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.imagePullSecrets`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink image pull secrets which overrides global.imagePullSecrets"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.image.registry`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink image registry"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`registry.hub.docker.com`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.image.repository`"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "SuperLink image repository"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`flwr/superlink-ee`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superlink.image.tag`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "SuperLink image tag"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`1.21.0-ubuntu`"
msgstr "``ubuntu``"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.image.digest`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink image digest"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.image.pullPolicy`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "SuperLink image pullPolicy which Components image pullPolicy"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Specifies whether a NetworkPolicy should be created"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.allowExternal`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Allow external ingress traffic"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.allowExternalEgress`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Allow unrestricted egress traffic"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.extraIngress`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Add extra ingress rules to the NetworkPolicy"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.extraEgress`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Add extra ingress rules to the NetworkPolicy (ignored if "
"allowExternalEgress=true)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.serverAppIo.ingressPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid ""
"Labels to match to allow traffic from other pods. Ignored if "
"`superlink.networkPolicy.allowExternal` is true."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.serverAppIo.ingressNSMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid ""
"Labels to match to allow traffic from other namespaces. Ignored if "
"`superlink.networkPolicy.allowExternal` is true."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.serverAppIo.ingressNSPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid ""
"Pod labels to match to allow traffic from other namespaces. Ignored if "
"`superlink.networkPolicy.allowExternal` is true."
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.fleet.ingressPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.fleet.ingressNSMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.fleet.ingressNSPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.control.ingressPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.control.ingressNSMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.control.ingressNSPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.simulationIo.ingressPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.simulationIo.ingressNSMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`superlink.networkPolicy.simulationIo.ingressNSPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:860
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:352
#, fuzzy
msgid "Component SuperExec"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.name`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Name of the SuperExec"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superexec-serverapp`"
msgstr "flower 서버 프로그램"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "Enable or disable SuperExec"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#, fuzzy
msgid "`superexec.superlink`"
msgstr "|serverapp_link|_"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Address of the SuperLink the SuperExec should connect to"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.resources`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.volumes`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Optionally specify list of volumes for the SuperExec pod(s)"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.volumeMounts`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.automountServiceAccountToken`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.serviceAccount.enabled`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enable a service account for this component"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.serviceAccount.annotations`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.serviceAccount.labels`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.serviceAccount.automountServiceAccountToken`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.containerPorts.health`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Container port for SuperExec Health API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.podSecurityContext`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Security settings that for the SuperExec Pods"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.livenessProbe.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Enable livenessProbe on SuperExec containers"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.livenessProbe.initialDelaySeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.livenessProbe.periodSeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.livenessProbe.timeoutSeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.livenessProbe.failureThreshold`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.livenessProbe.successThreshold`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.readinessProbe.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Enable readinessProbe on SuperExec containers"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.readinessProbe.initialDelaySeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.readinessProbe.periodSeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.readinessProbe.timeoutSeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.readinessProbe.failureThreshold`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.readinessProbe.successThreshold`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.replicas`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "The number of SuperExec pods to run"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.labels`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Extra labels for SuperExec pods"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.extraArgs`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Add extra arguments to the default arguments for the SuperExec"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.nodeSelector`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Node labels for SuperExec pods which merges with global.nodeSelector"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.tolerations`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Node tolerations for SuperExec pods which merges with global.tolerations"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.updateStrategy.type`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "SuperExec deployment strategy type"
msgstr "배포"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.updateStrategy.rollingUpdate`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperExec deployment rolling update configuration parameters"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.affinity`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Node affinity for SuperExec pods which merges with global.affinity"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.env`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Array with extra environment variables to add to SuperExec nodes which "
"merges with global.env"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.lifecycle`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperExec container(s) to automate configuration before or after startup"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.annotations`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Additional custom annotations for SuperExec"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.selectorLabels`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Extra selectorLabels for SuperExec pods"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.podAnnotations`"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Annotations for SuperExec pods"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.podLabels`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Extra podLabels for SuperExec pods"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.imagePullSecrets`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperExec image pull secrets which overrides global.imagePullSecrets"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.image.registry`"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "SuperExec image registry"
msgstr "Flower 서버앱"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.image.repository`"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "SuperExec image repository"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`flwr/superexec`"
msgstr "Flower SuperNode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.image.tag`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Image tag of SuperExec"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`1.21.0-py3.11-ubuntu24.04`"
msgstr "``ubuntu``"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.image.digest`"
msgstr "Flower 서버앱"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Image digest of SuperExec"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.image.pullPolicy`"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Components image pullPolicy"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`Always`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.networkPolicy.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.networkPolicy.allowExternalEgress`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`superexec.networkPolicy.extraEgress`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:913
#, fuzzy
msgid "Component OpenFGA"
msgstr "공통"

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "`openfga.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-superlink-using-helm.md:279
msgid "Enable the openfga subchart and deploy OpenFGA"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md
msgid ""
"Deploy Flower's SuperNode Helm chart to install client federated learning"
" components. Default config mirrors official releases for seamless "
"integration."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:12
msgid "Deploy SuperNode using Helm"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:21
msgid ""
"This Helm chart installs the client-side components of the Flower "
"Framework, specifically setting up the SuperNode."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:27
msgid "Multi Project Setup"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:29
msgid ""
"To install multiple types of SuperNodes, such as a federation for running"
" PyTorch and another for TensorFlow, you need to install the Helm Chart "
"multiple times with different names. This allows each deployment to have "
"its own configurations and dependencies."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:33
msgid ""
"For instance, you can install the Chart for the PyTorch setup by "
"adjusting the values.yaml file as shown below:"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:51
#: ../../source/helm/how-to-deploy-supernode-using-helm.md:77
#, fuzzy
msgid "Install this configuration using the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:57
msgid ""
"This will deploy 10 SuperNodes named `pytorch-flower-client-"
"supernode-<random>`."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:59
msgid "For a TensorFlow setup, modify the `values.yaml` file as follows:"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:83
msgid ""
"This will deploy 3 SuperNodes named `tensorflow-flower-client-"
"supernode-<random>`."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:90
msgid ""
"When using private CAs, the SuperNode must trust the CA certificate in "
"order to connect securely to the SuperLink."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:93
msgid ""
"To provide the CA certificate, set `tls.enabled` to `true` and create a "
"`Secret` of type `kubernetes.io/tls` named `flower-client-tls`:"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:101
msgid ""
"If you want to use a different `Secret` name, override the default by "
"setting `supernode.superlink.certificate.existingSecret`:"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:116
msgid ""
"The recommended practice is to mount different `Secret`s for the "
"SuperLink and the SuperNodes `existingSecret` parameter. Keeping these "
"`Secrets` separate ensures that if the `Secret` containing the server’s "
"private key and certificate is ever tampered with, the client will fail "
"to connect rather than trusting a compromised server."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:122
msgid ""
"For further details, refer to the [`cert-manager` documentation](https"
"://cert-manager.io/docs/trust/)."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:124
msgid ""
"If the SuperLink certificate (of type `kubernetes.io/tls`) is deployed in"
" the same cluster and namespace as the SuperNode, you can enable "
"`supernode.superlink.certificate.copyFromExistingSecret`. This instructs "
"the chart to create a new `Secret` containing the CA certificate. It "
"copies `ca.crt` from the SuperLink `Secret`, or falls back to `tls.crt` "
"if `ca.crt` is not present."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:130
msgid ""
"By default, the copied `Secret` is named `flower-client-tls`. You can "
"customize this name with "
"`supernode.superlink.certificate.copyFromExistingSecret.secretName`:"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:148
msgid ""
"You might want to deploy the Flower framework without TLS for testing or "
"internal use. Be cautious as this exposes your deployment to potential "
"security risks."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:156
#, fuzzy
msgid "Node Authentication"
msgstr "설치 확인"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:158
msgid ""
"To enable Node Authentication, you need to specify a private key in "
"either PKCS8 or OpenSSH (PEM-like) format. This example assumes that the "
"SuperLink is also configured for Node Authentication and recognizes the "
"`ecdsa-sha2-nistp384 [...]` public key of this SuperNode."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:188
msgid "Isolated Setup"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:190
#, fuzzy
msgid "Isolation All-in-One"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:192
msgid ""
"To install SuperNode in isolation mode using the \"process\" "
"configuration, both the SuperExec and SuperNode need to be enabled. By "
"default, the SuperExec connects to the SuperNode internally within the "
"cluster, so there is no need to set `supernode.address` and "
"`supernode.port` unless the connection is external. This setup assumes "
"that both components are running within the same cluster."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:206
#, fuzzy
msgid "Isolation Distributed"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:208
msgid ""
"You can also deploy the SuperNode and SuperExec separately. To do this, "
"you need to deploy the chart twice: once with `supernode.enabled=true` "
"and once with `superexec.enabled=true`."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:222
#, fuzzy
msgid "Node Configuration"
msgstr "구성 값"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:224
msgid ""
"You can add a node configuration to configure a SuperNode. The YAML "
"datatype is preserved when passing it in the Python application:"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Replaces the name of the chart in the Chart.yaml"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`flower-client`"
msgstr "Flower 클라이언트."

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Completely replaces the generated name."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.nodeAuth.authSupernodePrivateKey`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Specifies the ecdsa-sha2-nistp384 private key"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`global.nodeAuth.authSupernodePublicKey`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Specifies the ecdsa-sha2-nistp384 public key"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:282
#, fuzzy
msgid "Component SuperNode"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.name`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Name of the SuperNode"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enable or disable SuperNode"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.resources`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.node.config`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.isolationMode`"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "The isolation mode of the SuperNode"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.superlink.address`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Address of the SuperLink the SuperNodes should connect to"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`my-superlink.example.com`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.superlink.port`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Port of the SuperLink the SuperNodes should connect to"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.superlink.certificate.existingSecret`"
msgstr "기존 전략 사용"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.superlink.certificate.copyFromExistingSecret.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.superlink.certificate.copyFromExistingSecret.secretName`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.volumes`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Specify a list of volumes for the SuperNode pod(s)"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.volumeMounts`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.automountServiceAccountToken`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.serviceAccount.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.serviceAccount.annotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.serviceAccount.labels`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.serviceAccount.automountServiceAccountToken`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.service.type`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.service.servicePortClientAppIoName`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Prefix of the SuperNode ClientAppIo API port"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`clientappio`"
msgstr "클라이언트앱"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.service.servicePortClientAppIo`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Port to expose for the SuperNode ClientAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`9094`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.service.nodePortClientAppIo`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Node port for SuperNode ClientAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.containerPorts.clientAppIo`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Container port for SuperNode ClientAppIo API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.containerPorts.health`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Container port for SuperNode Health API"
msgstr "flower 초연결"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.podSecurityContext`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.replicas`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "The number of SuperNode pods to run"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.labels`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Extra labels for SuperNode pods"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.extraArgs`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Add extra arguments to the default arguments for the SuperNode"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.nodeSelector`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Node labels for SuperNode pods which merges with global.nodeSelector"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.tolerations`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Node tolerations for SuperNode pods which merges with global.tolerations"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.updateStrategy.type`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "SuperNode deployment strategy type"
msgstr "배포"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.updateStrategy.rollingUpdate`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperNode deployment rolling update configuration parameters"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.affinity`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Node affinity for SuperNode pods which merges with global.affinity"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.env`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Array with extra environment variables to add to SuperNode nodes which "
"merges with global.env"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.livenessProbe.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enable livenessProbe on SuperNode containers"
msgstr "이미 *서버*를 시작할 수 있습니다:"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.livenessProbe.initialDelaySeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.livenessProbe.periodSeconds`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.livenessProbe.timeoutSeconds`"
msgstr "해결법"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.livenessProbe.failureThreshold`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.livenessProbe.successThreshold`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.readinessProbe.enabled`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enable readinessProbe on SuperNode containers"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.readinessProbe.initialDelaySeconds`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.readinessProbe.periodSeconds`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.readinessProbe.timeoutSeconds`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.readinessProbe.failureThreshold`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.readinessProbe.successThreshold`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.lifecycle`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperNode container(s) to automate configuration before or after startup"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.annotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Additional custom annotations for SuperNode"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.selectorLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Extra selectorLabels for SuperNode pods"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.podAnnotations`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Annotations for SuperNode pods"
msgstr "서버(SuperLink)"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.podLabels`"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Extra podLabels for SuperNode pods"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.imagePullSecrets`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperNode image pull secrets which overrides global.imagePullSecrets"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.image.registry`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "SuperNode image registry"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.image.repository`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "SuperNode image repository"
msgstr "레포지토리 설정하기"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`flwr/supernode-ee`"
msgstr "Flower SuperNode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`supernode.image.tag`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Image tag of SuperNode"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.image.digest`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Image digest of SuperNode"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.image.pullPolicy`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.enabled`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.allowExternal`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.allowExternalEgress`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.extraIngress`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.extraEgress`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.ingressPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Labels to match to allow traffic from other pods. Ignored if "
"`supernode.networkPolicy.allowExternal` is true."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.ingressNSMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Labels to match to allow traffic from other namespaces. Ignored if "
"`supernode.networkPolicy.allowExternal` is true."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "`supernode.networkPolicy.ingressNSPodMatchLabels`"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid ""
"Pod labels to match to allow traffic from other namespaces. Ignored if "
"`supernode.networkPolicy.allowExternal` is true."
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec-clientapp`"
msgstr "클라이언트앱"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "Enable or disable SuperExec component"
msgstr "현재 클라이언트 속성입니다."

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
#, fuzzy
msgid "`superexec.supernode`"
msgstr "run\\_supernode"

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Address of the supernode the SuperExec should connect to"
msgstr ""

#: ../../source/helm/how-to-deploy-supernode-using-helm.md:14
msgid "Specify a list of volumes for the SuperExec pod(s)"
msgstr ""

#: ../../source/helm/index.rst:41
#, fuzzy
msgid "Deploy SuperLink"
msgstr "flower 초연결"

#: ../../source/helm/index.rst:41
#, fuzzy
msgid "Deploy SuperNode"
msgstr "run\\_supernode"

#: ../../source/helm/index.rst:-1
msgid "Learn how to run Flower for federated learning using Helm charts."
msgstr ""

#: ../../source/helm/index.rst:7
#, fuzzy
msgid "Run Flower using Helm"
msgstr "Docker를 사용하여 Flower 실행"

#: ../../source/helm/index.rst:11
msgid ""
"Flower Helm charts are a Flower Enterprise feature. See `Flower "
"Enterprise <https://flower.ai/enterprise>`_ for details."
msgstr ""

#: ../../source/helm/index.rst:14
msgid ""
"This guide provides the step-by-step instructions to deploy Flower using "
"Helm, which simplifies the deployment and management of the Flower "
"framework on Kubernetes. For instance, to deploy SuperLink and SuperNode "
"services via command line, simply run the |helm_install_link|_ command "
"like so:"
msgstr ""

#: ../../source/helm/index.rst:27
msgid "Then to tear down the deployment, run the |helm_uninstall_link|_ command:"
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:-1
msgid ""
"Aggregate custom evaluation results from federated clients in Flower "
"using a callable function that applies weighted averaging for metrics "
"like accuracy."
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:23
msgid "Aggregate evaluation results"
msgstr "종합 평가 결과"

#: ../../source/how-to-aggregate-evaluation-results.rst:25
msgid ""
"Flower strategies (e.g. |fedavg_link|_ and all that derive from it) "
"automatically aggregate the metrics in the |metricrecord_link|_ in the "
"``Messages`` replied by the ``ClientApps``. By default, a weighted "
"aggregation is performed for all metrics using as weight the value "
"assigned to the ``weighted_by_key`` attribute of a strategy."
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:30
msgid ""
"When constructing your strategy, you can set both the key used to perform"
" weighted aggregation but also the callback function used to aggregate "
"metrics."
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:35
msgid ""
"By default, Flower strategies use as ``weighted_by_key=\"num-"
"examples\"``. If you are interested, see the full implementation of how "
"the default weighted aggregation callback works `here "
"<https://github.com/adap/flower/blob/b174b2e02bb34cae9ba9f2a124c610a844cee870/framework/py/flwr/serverapp/strategy/strategy_utils.py#L109>`_."
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:51
msgid ""
"Let's see how we can define a custom aggregation function for "
"``MetricRecord`` objects received in the reply of an evaluation round."
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:56
msgid ""
"Note that Flower strategies also have a ``train_metrics_aggr_fn`` "
"attribute that allows you to define a custom aggregation function for "
"received ``MetricRecord`` objects in reply messages of a training round. "
"By default, it performs weighted averaging using the value assigned to "
"the ``weighted_by_key`` exactly as the ``evaluate_metrics_aggr_fn`` "
"presented earlier."
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:64
msgid "Using a custom metrics aggregation function"
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:66
msgid ""
"The ``evaluate_metrics_aggr_fn`` can be customized to support any "
"evaluation results aggregation logic you need. Its definition is:"
msgstr ""

#: ../../source/how-to-aggregate-evaluation-results.rst:73
msgid ""
"It takes a list of |recorddict_link|_ and a weighting key as inputs and "
"returns a |metricrecord_link|_. For example, the function below extracts "
"and returns the minimum value for each metric key across all "
"|message_link|_:"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:-1
msgid ""
"Configure SuperLink for account authentication and authorization. "
"Private-by-default runs securely with OpenID Connect and OpenFGA."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:7
#, fuzzy
msgid "Authenticate Accounts via OpenID Connect"
msgstr "SuperNodes 인증하기"

#: ../../source/how-to-authenticate-accounts.rst:11
msgid ""
"OpenID Connect Authentication is a Flower Enterprise feature. See `Flower"
" Enterprise <https://flower.ai/enterprise>`_ for details."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:14
msgid ""
"In this guide, you'll learn how to configure SuperLink with account-level"
" authentication and authorization, and how to log in using the ``flwr`` "
"CLI. Once logged in, any Flower accounts that are authorized on the "
"SuperLink can run Flower CLI commands that interact with the SuperLink."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:21
msgid ""
"With account authentication and authorization enabled, only accounts that"
" have submitted the ``flwr run`` command can view and interact with their"
" runs. This means that your runs are **private by default**, ensuring "
"that only authorized accounts can access them."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:30
msgid ""
"To enable account authentication and authorization, the SuperLink must be"
" deployed with an `OpenID Connect (OIDC) <https://openid.net/developers"
"/how-connect-works/>`_ provider and an `OpenFGA <https://openfga.dev/>`_ "
"server. The OIDC provider is used for account authentication, while "
"OpenFGA is used for fine-grained access control. This means an "
"authenticated account can only run ``flwr`` CLI commands on the SuperLink"
" if they have been granted the necessary permissions by the SuperLink "
"administrator. When enabled, both account authentication and "
"authorization must be configured on the SuperLink."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:39
#, fuzzy
msgid "Enable Account Authentication and Authorization on the SuperLink"
msgstr ":code:`SuperLink`에서 노드 인증 활성화"

#: ../../source/how-to-authenticate-accounts.rst:41
#, fuzzy
msgid "Create a YAML configuration file with the following content:"
msgstr "다음 변경 사항이 포함된 pull request를 만듭니다:"

#: ../../source/how-to-authenticate-accounts.rst:65
msgid ""
"Save this file as ``account-auth-config.yaml``. Then pass it to the "
"SuperLink via the ``--account-auth-config`` flag when deploying the "
"SuperLink:"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:76
msgid ""
"To authorize an account, the SuperLink administrator must add the "
"account's OIDC ``sub`` claim to the OpenFGA store with the appropriate "
"relation."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:81
msgid ""
"Starting with Flower ``v1.23.0``, the following options/keys have been "
"renamed:"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:83
msgid "``auth_type`` → ``authn_type`` (in YAML configuration)"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:84
msgid "``auth_url`` → ``authn_url`` (in YAML configuration)"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:85
msgid "``--user-auth-config`` → ``--account-auth-config`` (in SuperLink CLI)"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:89
#, fuzzy
msgid "Login to the SuperLink"
msgstr "flower 초연결"

#: ../../source/how-to-authenticate-accounts.rst:91
msgid ""
"Once a SuperLink with account authentication and authorization is up and "
"running, an account can interface with it after installing the ``flwr`` "
"PyPI package via the Flower CLI. Then, ensure that the ``enable-account-"
"auth`` field is set to ``true`` in the federation section in the "
"``pyproject.toml`` of the Flower app you want to run:"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:108
#, fuzzy
msgid ""
"Account authentication and authorization is only supported with TLS "
"connections."
msgstr ":code:`SuperLink`에서 노드 인증 활성화"

#: ../../source/how-to-authenticate-accounts.rst:110
msgid ""
"Now, you need to login first before other CLI commands can be executed. "
"Upon executing ``flwr login``, a URL will be returned by the "
"authentication plugin in the SuperLink. Click on it and authenticate "
"directly against the OIDC provider."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:124
msgid ""
"Once the login is successful, the credentials returned by the OIDC "
"provider via the SuperLink will be saved to the app's directory under "
"``.flwr/.credentials/<federation-name>.json``. The tokens stored in this "
"file will be sent transparently with each subsequent ``flwr`` CLI request"
" to the SuperLink, and it will relay them to OIDC provider to perform the"
" authentication checks."
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:132
msgid "Run authorized ``flwr`` CLI commands"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:134
msgid ""
"With the above steps completed, you can now run ``flwr`` CLI commands "
"against a SuperLink setup with account authentication and authorization. "
"For example, as an authorized account, you can run the ``flwr run`` "
"command to start a Flower app:"
msgstr ""

#: ../../source/how-to-authenticate-accounts.rst:146
msgid ""
"If the account does not have the necessary permissions to run the "
"command, an error will be returned:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:-1
msgid ""
"Enable authentication for SuperNodes and SuperLink in Flower with public "
"key authentication, securing federated learning via TLS connections."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:11
msgid "Authenticate SuperNodes"
msgstr "SuperNodes 인증하기"

#: ../../source/how-to-authenticate-supernodes.rst:13
msgid ""
"When running a Flower Federation (see :doc:`ref-flower-network-"
"communication`) it is fundamental that an authentication mechanism is "
"available between the SuperLink and the SuperNodes that connect to it. "
"Flower comes with two different mechanisms to authenticate SuperNodes "
"that connect to a running SuperLink:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:18
msgid ""
"**Automatic authentication**: In this mode, the SuperLink checks the "
"timestamp-based signature in each request from SuperNodes to prevent "
"impersonation and replay attacks. The goal of this mode is to confirm the"
" identity of connected SuperNodes; however, it does **not** restrict "
"which SuperNodes can connect to the SuperLink. Consequently, any "
"SuperNode is allowed to connect to the SuperLink."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:23
msgid ""
"**CLI-managed authentication**: This mode operates similarly to automatic"
" authentication but requires starting the SuperLink with the ``--enable-"
"supernode-auth`` flag. To connect a SuperNode to the SuperLink, its "
"public key must first be registered using the "
"|flower_cli_supernode_link|_. Only registered SuperNodes are permitted to"
" connect to the SuperLink, making this mode more secure by restricting "
"connections to authorized SuperNodes only."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:30
msgid ""
"The automatic authentication mode works out of the box and therefore "
"requires no configuration. On the other hand, CLI-managed authentication "
"mode is more sophisticated and how it works and how it can be used is "
"presented reminder of this guide. Flower's CLI-managed SuperNode "
"authentication leverages a signature-based mechanism to verify each "
"SuperNode's identity and is only available when encrypted connections "
"(SSL/TLS) are enabled:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:37
msgid ""
"Each SuperNode must already possess a unique Elliptic Curve (EC) "
"public/private key pair."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:39
#, fuzzy
msgid ""
"The SuperLink (server) maintains a whitelist of EC public keys for all "
"trusted SuperNodes (clients), managed through the Flower CLI."
msgstr "SuperLink(서버)는 알려진 (클라이언트) 노드 공개키 목록을 저장합니다"

#: ../../source/how-to-authenticate-supernodes.rst:41
msgid ""
"A SuperNode signs a timestamp with its private key and sends the signed "
"timestamp to the SuperLink."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:43
msgid ""
"The SuperLink verifies the signature and timestamp using the SuperNode's "
"public key."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:47
msgid ""
"This guide builds on the Flower App setup presented in the :doc:`how-to-"
"enable-tls-connections` guide and extends it to introduce node "
"authentication to the SuperLink ↔ SuperNode connection."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:53
#, fuzzy
msgid ""
"Checkout the `Flower Authentication "
"<https://github.com/adap/flower/tree/main/examples/flower-"
"authentication>`_ example for a complete self-contained example on how to"
" setup TLS and node authentication."
msgstr ""
"인증된 환경에서 Flower로 연합 학습을 시연하는 전체 '코드 예제 "
"<https://github.com/adap/flower/tree/main/examples/flower-"
"authentication>`_를 확인하는 것이 좋습니다."

#: ../../source/how-to-authenticate-supernodes.rst:59
msgid "Generate authentication keys"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:61
msgid ""
"To establish an authentication mechanism by which only authorized "
"SuperNodes can connect to a running SuperLink, a set of key pairs for "
"both SuperLink and SuperNodes need to be created."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:65
msgid ""
"We have prepared a script that can be used to generate such set of keys. "
"While using these are fine for prototyping, we advice you to follow the "
"standards set in your team/organization and generated the keys and share "
"them with the corresponding parties. Refer to the **Generate public and "
"private keys for SuperNode authentication** section in the example linked"
" at the top of this guide."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:76
msgid ""
"This will generate the keys in a new ``keys/`` directory. By default it "
"creates a key pair for the SuperLink and one for each SuperNode. Copy "
"this directory into the directory of your app (e.g. a directory generated"
" earlier via ``flwr new``)."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:82
#, fuzzy
msgid "Enable node authentication in SuperLink"
msgstr ":code:`SuperLink`에서 노드 인증 활성화"

#: ../../source/how-to-authenticate-supernodes.rst:84
msgid ""
"To launch a SuperLink with SuperNode authentication enabled, you need to "
"provide three aditional files in addition to the certificates needed for "
"the TLS connections. Recall that the authentication feature can only be "
"enabled in the presence of TLS."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:99
msgid ""
"``--enable-supernode-auth``: Enables SuperNode authentication therefore "
"only Supernodes that are first register on the SuperLink will be able to "
"establish a connection."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:103
#, fuzzy
msgid "Register SuperNodes"
msgstr "SuperNodes 인증하기"

#: ../../source/how-to-authenticate-supernodes.rst:105
msgid ""
"Once your SuperLink is running, the next step is to register the "
"SuperNodes that will be allowed to connect to it. This process is handled"
" through the |flower_cli_supernode_link|_ using the public keys "
"previously generated for each SuperNode you plan to connect to the "
"SuperLink."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:110
msgid "Here's how this looks in code:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:117
msgid "Next, let’s register the second SuperNode as well:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:123
#, fuzzy
msgid "You can list the registered SuperNodes using the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/how-to-authenticate-supernodes.rst:130
msgid ""
"This will display the IDs of the SuperNodes you just registered as well "
"as their status. You should see a table similar to the following:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:143
msgid ""
"The status of the SuperNodes will change after they connect to the "
"SuperLink. Let's proceed and laucnh the SuperNodes."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:148
#, fuzzy
msgid "Enable node authentication in SuperNode"
msgstr ":code:`SuperNode`에서 노드 인증을 활성화합니다"

#: ../../source/how-to-authenticate-supernodes.rst:150
msgid ""
"Connecting a SuperNode to a SuperLink that has node authentication "
"enabled requires passing one additional argument (i.e. the private key of"
" the SuperNode) in addition to the TLS certificate."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:166
msgid "``--auth-supernode-private-key``: the private key of this SuperNode."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:168
msgid ""
"Follow the same procedure to launch the second SuperNode by passing its "
"corresponding private key:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:181
msgid ""
"After connecting both SuperNodes, you can check the status of the "
"SuperNodes again. You will notice their status is now ``online``:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:198
#, fuzzy
msgid "Unregister SuperNodes"
msgstr "SuperNodes 인증하기"

#: ../../source/how-to-authenticate-supernodes.rst:202
msgid ""
"This is a destructive operation. Unregistering a SuperNode is permanent "
"and cannot be undone. If you wish to connect a SuperNode again, a new key"
" pair is needed."
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:205
msgid ""
"At anypoint you can unregister a SuperNode from the SuperLink (even if it"
" has never connected). This will prevent the SuperNode from making future"
" request to the SuperLink. In other words, it will no longer be "
"authorized to pull/send, or participate in ongoing or future runs. "
"Unregistering a SuperNode can be done via the "
"|flower_cli_supernode_link|_ as follows:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:216
msgid ""
"The above command unregisters the first SuperNode. You can verify this by"
" listing the SuperNodes again:"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:229
msgid ""
"If you pass the ``--verbose`` flag to the previous command you'll see "
"that the status of the unregistered SuperNode has changed to "
"``unregistered``. By default, unregistered SuperNodes are hidden because "
"they can no longer reconnect to the SuperLink. That's right, **if you "
"wish to connect a second SuperNode a new EC key pair is needed.**"
msgstr ""

#: ../../source/how-to-authenticate-supernodes.rst:248
msgid "Security notice"
msgstr "보안 공지"

#: ../../source/how-to-authenticate-supernodes.rst:250
msgid ""
"The system's security relies on the credentials of the SuperLink and each"
" SuperNode. Therefore, it is imperative to safeguard and safely store the"
" credentials to avoid security risks such as Public Key Infrastructure "
"(PKI) impersonation attacks. The node authentication mechanism also "
"involves human interaction, so please ensure that all of the "
"communication is done in a secure manner, using trusted communication "
"methods."
msgstr ""
"시스템의 보안은 SuperLink와 각SuperNode의 자격 증명에 의존합니다. 따라서 공개키 기반구조(PKI) 사칭 공격과 같은"
" 보안 위험을 피하기 위해 자격 증명을 보호하고 안전하게 보관하는 것이 필수적입니다. 노드 인증 메커니즘에는 사람의 상호 작용도 "
"포함되므로 모든 통신이 신뢰할 수 있는 통신 방법을 사용하여 안전한 방식으로 이루어지도록 하세요."

#: ../../source/how-to-authenticate-supernodes.rst:258
#: ../../source/how-to-enable-tls-connections.rst:144
#: ../../source/how-to-use-built-in-mods.rst:175
#: ../../source/tutorial-series-what-is-federated-learning.rst:297
msgid "Conclusion"
msgstr "결론"

#: ../../source/how-to-authenticate-supernodes.rst:260
#, fuzzy
msgid ""
"You should now have learned how to start a long-running Flower SuperLink "
"and SuperNode with node authentication enabled. You should also know the "
"significance of the private key and store it securely to minimize risks."
msgstr ""
"이제 노드 인증이 활성화된 상태에서 장기간 실행되는 Flower 서버(:code:`SuperLink`)와 "
"클라이언트(:code:`SuperNode`)를 시작하는 방법을 배웠을 것입니다. 또한 보안 위험을 최소화하기 위해 개인키의 중요성을"
" 알고 안전하게 보관해야 합니다."

#: ../../source/how-to-authenticate-supernodes.rst:266
#: ../../source/how-to-enable-tls-connections.rst:154
msgid ""
"Refer to the :doc:`docker/index` documentation to learn how to setup a "
"federation where each component runs in its own Docker container. You can"
" make use of TLS and other security features in Flower such as implement "
"a SuperNode authentication mechanism."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:-1
msgid ""
"Configure SuperLink for audit logging to capture or store events such as "
"user interactions and application behavior."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:11
msgid ""
"Audit logging is a Flower Enterprise feature. See `Flower Enterprise "
"<https://flower.ai/enterprise>`_ for details."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:14
msgid ""
"In this guide, you'll learn how to configure SuperLink with audit "
"logging. Audit logging allows you to capture and store events that occur "
"in the SuperLink, such as valuable insights into the application's "
"behavior and performance, and when a user interfaces with the system."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:19
msgid ""
"The audit logging feature brings JSON-formatted log outputs to Flower. It"
" can be activated for the SuperLink to record events when users or "
"SuperNodes interact with the SuperLink. System administrators can then "
"configure a logging backend to systematically capture these events in a "
"database."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:24
msgid ""
"User events occur when a Flower user interacts with SuperLink, such as "
"logging in, starting a run, or querying the list of runs on the "
"SuperLink. These events capture the interaction of the user via the "
"``flwr`` CLI and the SuperLink."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:28
msgid ""
"Application events occur when the Flower components interact with one "
"another, specifically, between the SuperLink and SuperNodes. These events"
" will show, for example, when messages are pushed and pulled from/to the "
"SuperLink and when a SuperNode establishes a connection with the "
"SuperLink."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:33
msgid "By default, the output schema is as follows:"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:52
msgid "where,"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:57
msgid "Field"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:59
#, fuzzy
msgid "``timestamp``"
msgstr "``DISTRO``"

#: ../../source/how-to-configure-audit-logging.rst:60
msgid "Timestamp of the event in UTC format and RFC-3339 compliant"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:61
#, fuzzy
msgid "``actor.id``"
msgstr "``DISTRO``"

#: ../../source/how-to-configure-audit-logging.rst:62
msgid ""
"Flower account ID (when called by a ``flwr`` CLI user) or SuperNode ID "
"(when called by a SuperNode)"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:64
#, fuzzy
msgid "``actor.description``"
msgstr "설명"

#: ../../source/how-to-configure-audit-logging.rst:65
msgid "Username registered on the OIDC provider or ``SuperNode``"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:66
msgid "``actor.ip_address``"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:67
msgid "IPv4 or IPv6 address of the actor"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:68
msgid "``event.action``"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:69
msgid ""
"Name of the servicer method, e.g. "
"``ControlServicer.StartRun``/``FleetServicer.PullMessages``"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:71
msgid "``event.run_id``"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:72
#, fuzzy
msgid "The run ID of the Flower workflow"
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-configure-audit-logging.rst:73
msgid "``event.fab_hash``"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:74
#, fuzzy
msgid "The FAB hash of the Flower app"
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-configure-audit-logging.rst:75
#, fuzzy
msgid "``status``"
msgstr "Status"

#: ../../source/how-to-configure-audit-logging.rst:76
msgid "A string describing whether the action is started, completed or failed"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:82
msgid ""
"To enable audit logging, start the SuperLink with the argument "
"``--enable-event-log`` as follows:"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:89
msgid ""
"Note that the audit logging feature can only be activated with the "
":doc:`user authentication feature <how-to-authenticate-users>`."
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:94
#, fuzzy
msgid "Example Outputs"
msgstr "예시"

#: ../../source/how-to-configure-audit-logging.rst:96
msgid ""
"Here is an example output when a user runs ``flwr run`` (note the "
"``\"action\": \"ControlServicer.StartRun\"``):"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:105
msgid "Here is another example output when a user runs ``flwr ls``:"
msgstr ""

#: ../../source/how-to-configure-audit-logging.rst:113
msgid ""
"And here is an example when a SuperNode pulls a message from the "
"SuperLink:"
msgstr ""

#: ../../source/how-to-configure-clients.rst:-1
msgid ""
"Configure Flower clients by sending configurations from the strategy to "
"the clients and control client-side hyperparameters dynamically."
msgstr ""

#: ../../source/how-to-configure-clients.rst:35
#, fuzzy
msgid "Configure a ``ClientApp``"
msgstr "클라이언트 구성"

#: ../../source/how-to-configure-clients.rst:37
msgid ""
"Flower provides the ability to send configuration values to clients, "
"allowing server-side control over client behavior. This feature enables "
"flexible and dynamic adjustment of client-side hyperparameters, improving"
" collaboration and experimentation."
msgstr ""

#: ../../source/how-to-configure-clients.rst:43
#, fuzzy
msgid "Sending ``ConfigRecords`` to a ``ClientApp``"
msgstr "클라이언트앱"

#: ../../source/how-to-configure-clients.rst:45
msgid ""
"Make use of a |configrecord_link|_ to send configuration values in a "
"|message_link|_ from your |serverapp_link|_ to a |clientapp_link|_. A "
"``ConfigRecord`` is a special type of Python dictionary that allows "
"communicating basic types such as ``int``, ``float``, ``string``, "
"``bool`` and also ``bytes`` if you need to communicate more complex data "
"structures that need to be serialized. Lists of these types are also "
"supported."
msgstr ""

#: ../../source/how-to-configure-clients.rst:51
#, fuzzy
msgid "Let's see a few examples:"
msgstr "몇 가지 예를 살펴보겠습니다:"

#: ../../source/how-to-configure-clients.rst:63
msgid ""
"When you use a Flower strategy, the easiest way to get your "
"``ConfigRecord`` communicated as part of the ``Message`` that gets sent "
"to the ``ClientApp`` is by passing it to the |strategy_start_link|_ of "
"your strategy of choice (e.g. |fedavg_link|_). Let's see how this looks "
"in code:"
msgstr ""

#: ../../source/how-to-configure-clients.rst:95
msgid ""
"Passing the above ``ConfigRecord`` to the strategy's ``start`` method "
"ensures that the exact same ``ConfigRecord`` is received on the client "
"side. But what if we'd like the configuration to change during the course"
" of the federated learning process or as rounds advance?"
msgstr ""

#: ../../source/how-to-configure-clients.rst:102
msgid ""
"Note that Flower strategies insert the current server round number into "
"the ``ConfigRecord`` for you under the key ``server-round``. In this way,"
" the ``ClientApp`` knows what's the current round of the federated "
"learning process. Note this is always inserted even if no "
"``ConfigRecord`` is passed to the strategy ``start`` method. When that's "
"the case, the only content of the ``ConfigRecord`` that arrives to the "
"``ClientApp`` will be such key with the corresponding round number."
msgstr ""

#: ../../source/how-to-configure-clients.rst:112
msgid "Dynamic modification of ``ConfigRecord``"
msgstr ""

#: ../../source/how-to-configure-clients.rst:114
msgid ""
"Given a ``ConfigRecord`` passed upon starting the execution of a strategy"
" (i.e. passed to the |strategy_start_link|_ method), the contents of the "
"``ConfigRecord`` that arrive to the ``ClientApp`` won't change (with the "
"exception of the value under the ``server-round`` key)."
msgstr ""

#: ../../source/how-to-configure-clients.rst:119
msgid ""
"However, some applications do benefit or even require certain dynamism in"
" the configuration values that one might send over to the ``ClientApps``."
" For example, the learning rate the local optimizers at the "
"``ClientApps`` make use of. As the federated learning rounds go by, it is"
" often reasonable to reduce the learning rate. This dynamism can be "
"introduced at the strategy by implementing a custom strategy that just "
"overrides the ``configure_train`` method. This method is responsible for,"
" among other aspects, to create the ``Messages`` that will be sent to the"
" ``ClientApps``. These ``Messages`` would typically include an "
"|arrayrecord_link|_ carrying the parameters of the model to be federated "
"as well as the ``ConfigRecord`` containing the configurations that the "
"``ClientApp`` should use. Let's see how to design a custom strategy that "
"alters the ``ConfigRecord`` passed to the ``start`` method."
msgstr ""

#: ../../source/how-to-configure-clients.rst:133
msgid ""
"To learn more about how ``configure_train`` and other methods in the "
"strategies check the :doc:`Strategies Explainer <how-to-implement-"
"strategies>`."
msgstr ""

#: ../../source/how-to-configure-clients.rst:136
msgid ""
"Let's create a new class inheriting from |fedavg_link|_ and override the "
"``configure_train`` method. We then use this new strategy in our "
"``ServerApp``."
msgstr ""

#: ../../source/how-to-configure-clients.rst:161
msgid ""
"In this how-to guide, we have shown how to define (when calling the "
"``start`` method of the strategy) and modify (by overriding the "
"``configure_train`` method) a ``ConfigRecord`` to customize how "
"``ClientApps`` perform training. You can follow equivalent steps to "
"define and customize the ``ConfigRecord`` for an evaluation round. To do "
"this, use the ``evaluate_config`` argument in the strategy's ``start`` "
"method and then optionally override the ``configure_evaluate`` method."
msgstr ""

#: ../../source/how-to-configure-logging.rst:-1
msgid "Configure the logging level for your Flower processes."
msgstr ""

#: ../../source/how-to-configure-logging.rst:7
#, fuzzy
msgid "Configure logging"
msgstr "클라이언트 구성"

#: ../../source/how-to-configure-logging.rst:9
msgid ""
"By default, the Flower logger uses logging level ``INFO``. This can be "
"changed via the ``FLWR_LOG_LEVEL`` environment variable to any other "
"levels that Python's `logging module "
"<https://docs.python.org/3/library/logging.html#logging-levels>`_ "
"supports. For example, to launch your ``SuperLink`` with ``DEBUG`` logs, "
"use:"
msgstr ""

#: ../../source/how-to-configure-logging.rst:34
msgid ""
"You can make use of the ``FLWR_LOG_LEVEL`` environment variable when "
"executing other Flower commands to provision the different components in "
"a Flower Federation (see :doc:`how-to-run-flower-with-deployment-engine`)"
" or using the `flwr CLI <ref-api-cli.html>`_."
msgstr ""

#: ../../source/how-to-configure-logging.rst:41
#, fuzzy
msgid "Configure gRPC logging"
msgstr "클라이언트 구성"

#: ../../source/how-to-configure-logging.rst:43
msgid ""
"Flower uses `gRPC <https://grpc.io/>`_ to communicate between each "
"component (see :doc:`ref-flower-network-communication`). You can set the "
"verbosity level of ``gRPC`` logs using `gRPC environment variables "
"<https://github.com/grpc/grpc/blob/master/doc/environment_variables.md>`_."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:-1
msgid ""
"Learn how to configure your Flower app using the pyproject.toml file, "
"including dependencies, components, runtime settings, and federation "
"setup."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:7
#, fuzzy
msgid "Configure ``pyproject.toml``"
msgstr "또는 ``pyproject.toml``:"

#: ../../source/how-to-configure-pyproject-toml.rst:9
msgid ""
"All Flower Apps need a ``pyproject.toml``. When you create a new Flower "
"App using ``flwr new``, a ``pyproject.toml`` file is generated. This file"
" defines your app's dependencies, configuration, and federation setup."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:13
msgid "A complete ``pyproject.toml`` file, for example, looks like this:"
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst
#, fuzzy
msgid "Example ``pyproject.toml``"
msgstr "또는 ``pyproject.toml``:"

#: ../../source/how-to-configure-pyproject-toml.rst:53
msgid "Here are a few key sections to look out for:"
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:57
#, fuzzy
msgid "App Metadata and Dependencies"
msgstr "사전 릴리즈 설치"

#: ../../source/how-to-configure-pyproject-toml.rst
#, fuzzy
msgid "Understanding each field"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/how-to-configure-pyproject-toml.rst:78
#: ../../source/how-to-configure-pyproject-toml.rst:111
#: ../../source/how-to-configure-pyproject-toml.rst:156
#: ../../source/how-to-configure-pyproject-toml.rst:195
#, fuzzy
msgid "\\* Required fields"
msgstr "필수 변경 사항"

#: ../../source/how-to-configure-pyproject-toml.rst:80
msgid ""
"These fields follow the standard ``pyproject.toml`` metadata format, "
"commonly used by tools like ``uv``, ``poetry``, and others. Flower reuses"
" these for configuration and packaging."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:82
#, fuzzy
msgid "``name``\\*: The name of your Flower app."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-configure-pyproject-toml.rst:83
msgid ""
"``version``\\*: The current version of your app, used for packaging and "
"distribution. Must follow Semantic Versioning (e.g., \"1.0.0\")."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:84
msgid "``description``: A short summary of what your app does."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:85
msgid "``license``: The license your app is distributed under (e.g., Apache-2.0)."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:86
msgid "``dependencies``\\*: A list of Python packages required to run your app."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:87
msgid ""
"``publisher``\\*: The name of the person or organization publishing the "
"app."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:89
msgid ""
"Specify the metadata, including the app name, version, etc., in these "
"sections. Add any Python packages your app needs under ``dependencies``. "
"These will be installed when you run:"
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:99
#, fuzzy
msgid "App Components"
msgstr "공통"

#: ../../source/how-to-configure-pyproject-toml.rst:113
msgid "``serverapp``\\*: The import path to your ``ServerApp`` object."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:114
msgid "``clientapp``\\*: The import path to your ``ClientApp`` object."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:116
msgid ""
"These entries point to your ``ServerApp`` and ``ClientApp`` definitions, "
"using the format ``<module>:<object>``. Only update these import paths if"
" you rename your modules or the variables that reference your "
"``ServerApp`` or ``ClientApp``."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:122
#, fuzzy
msgid "App Configuration"
msgstr "구성 값"

#: ../../source/how-to-configure-pyproject-toml.rst:130
msgid ""
"Define configuration values that should be available to your app at "
"runtime. You can specify any number of key-value pairs in this section. "
"All the configuration values in this section are optional."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:134
msgid ""
"Access these values in your code using ``context.run_config``. For "
"example:"
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:142
#, fuzzy
msgid "Federation Configuration"
msgstr "구성 값"

#: ../../source/how-to-configure-pyproject-toml.rst:158
msgid ""
"``default``\\*: The name of the federation to use when running your app "
"with ``flwr run`` without explicitly specifying a federation."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:160
msgid ""
"Federations allow you to define how your app will run in different "
"environments. You can configure multiple federations, such as local "
"simulations or remote deployments, within the ``[tool.flwr.federations]``"
" section."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:165
#, fuzzy
msgid "Local Simulation Example"
msgstr "시뮬레이션 예제"

#: ../../source/how-to-configure-pyproject-toml.rst:172
msgid ""
"When using ``flwr new``, a federation named ``\"local-simulation\"`` is "
"included and set as the default. The example above sets up a local "
"simulation federation with 10 virtual SuperNodes using ``options.num-"
"supernodes = 10``."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:176
msgid ""
"Learn more in the `How to Run Simulations "
"<https://flower.ai/docs/framework/how-to-run-simulations.html>`_ guide."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:180
#, fuzzy
msgid "Remote Deployment Example"
msgstr "배포"

#: ../../source/how-to-configure-pyproject-toml.rst:182
msgid "You can also configure federations for remote deployment. For example:"
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:197
msgid "``address``\\*: The address of the SuperLink Control API to connect to."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:198
msgid ""
"``root-certificate``: Path to the root certificate file for TLS. Ignored "
"if ``insecure`` is ``true``. If omitted, Flower uses the default gRPC "
"root certificate."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:199
msgid ""
"``insecure``: Set to ``true`` to disable TLS (not recommended for "
"production). Defaults to ``false``, if omitted."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:201
msgid ""
"Refer to the `deployment documentation "
"<https://flower.ai/docs/framework/deploy.html>`_ for TLS setup and "
"advanced configurations."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:205
#, fuzzy
msgid "Running a Federation"
msgstr "시뮬레이션 실행"

#: ../../source/how-to-configure-pyproject-toml.rst:207
msgid "To run a specific federation, use the following command:"
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:213
msgid ""
"Both positional arguments—the app path and the federation name—are "
"optional. If omitted, the current directory is used as the app path, and "
"the default federation specified in the ``pyproject.toml`` file is used."
msgstr ""

#: ../../source/how-to-configure-pyproject-toml.rst:217
msgid "You can run ``flwr run --help`` for more details."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:-1
msgid ""
"Build stateful ClientApps in Flower with context objects, enabling "
"efficient simulations and deployments."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:7
#, fuzzy
msgid "Design stateful ClientApps"
msgstr "클라이언트앱"

#: ../../source/how-to-design-stateful-clients.rst:25
msgid ""
"By design, ClientApp_ objects are stateless. This means that the "
"``ClientApp`` object is recreated each time a new ``Message`` is to be "
"processed. This behavior is identical with Flower's Simulation Engine and"
" Deployment Engine. For the former, it allows us to simulate the running "
"of a large number of nodes on a single machine or across multiple "
"machines. For the latter, it enables each ``SuperNode`` to be part of "
"multiple runs, each running a different ``ClientApp``."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:32
msgid ""
"When a ``ClientApp`` is executed it receives a Context_. This context is "
"unique for each ``ClientApp``, meaning that subsequent executions of the "
"same ``ClientApp`` from the same node will receive the same ``Context`` "
"object. In the ``Context``, the ``.state`` attribute (of type "
"RecordDict_) can be used to store information that you would like the "
"``ClientApp`` to have access to for the duration of the run. This could "
"be anything from intermediate results such as the history of training "
"losses (e.g. as a list of ``float`` values with a new entry appended each"
" time the ``ClientApp`` is executed), certain parts of the model that "
"should persist on the client side, or some other arbitrary Python "
"objects. These items would need to be serialized before saving them into "
"the context."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:44
msgid "Saving metrics to the context"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:46
msgid ""
"This section will demonstrate how to save metrics such as accuracy/loss "
"values to the Context_ so they can be used in subsequent executions of "
"the ``ClientApp``."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:49
msgid ""
"Let's begin with a simple setting in which ``ClientApp`` is defined as "
"follows. The ``train()`` function only generates a random number, prints "
"it, and return an empty message."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:55
msgid ""
"You can create a PyTorch project with ready-to-use ``ClientApp`` and "
"other components by running ``flwr new``."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:77
msgid ""
"With the minimal ``ClientApp`` above, each time a ``Message`` is "
"addressed to this ``train`` function, a new random integer will be "
"generated and printed. Let's say we want to save that randomly generated "
"integer and append it to a list that persists in the ``Context``. This "
"way, each time the function executes,, it prints the history of random "
"integers. Let's see how this looks in code:"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:85
msgid ""
"Recall, the ``state`` attribute of a ``Context`` object is of type "
"RecordDict_, which is a special dictionary for different types of records"
" available in Flower. This means that you can save to it not just "
"MetricRecord_ as in the example below, but also ArrayRecord_ and "
"ConfigRecord_ objects."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:120
msgid ""
"If you run a Flower App including the above logic in your ``ClientApp`` "
"and having just two clients in your federation sampled in each round, "
"you'll see an output similar to the one below. See how after each round "
"the ``random-metrics`` record in the ``Context`` gets one additional "
"integer? Note that, in Simulation Runtime, the order of log messages may "
"change each round due to the random ordering of simulated clients."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:142
msgid "Saving model parameters to the context"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:144
msgid ""
"Using ConfigRecord_ or MetricRecord_ to save \"simple\" components is "
"fine (e.g., float, integer, boolean, string, bytes, and lists of these "
"types. Note that MetricRecord_ only supports float, integer, and lists of"
" these types). Flower has a specific type of record, an ArrayRecord_, for"
" storing model parameters, or more generally, data arrays."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:149
msgid ""
"Let's see a couple of examples of how to save NumPy arrays first and then"
" how to save parameters of PyTorch and TensorFlow models."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:154
msgid ""
"The examples below omit the definition of a ``ClientApp`` to keep the "
"code blocks concise. To make use of ``ArrayRecord`` objects in your "
"``ClientApp`` you can follow the same principles as outlined earlier."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:159
msgid "Saving NumPy arrays to the context"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:161
msgid ""
"Elements stored in an ``ArrayRecord`` are of type Array_, which is a data"
" structure that holds ``bytes`` and metadata that can be used for "
"deserialization. Let's see how to create an ``Array`` from a NumPy array "
"and insert it into an ``ArrayRecord``."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:167
msgid ""
"Array_ objects carry bytes as their main payload and additional metadata "
"to use for deserialization. You can also implement your own "
"serialization/deserialization."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:170
msgid ""
"Let's see how to use those functions to store a NumPy array into the "
"context."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:204
msgid ""
"To extract the data in an ``ArrayRecord``, you just need to deserialize "
"the array of interest. For example, following the example above:"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:224
msgid "Saving PyTorch parameters to the context"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:226
msgid ""
"Flower offers one-liner utilities to convert PyTorch model parameters "
"to/from ``ArrayRecord`` objects. Let's see how to do that."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:259
msgid ""
"Let's say now you want to apply the parameters stored in your context to "
"a new instance of the model (as it happens each time a ``ClientApp`` is "
"executed). You will need to:"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:262
msgid "Retrieve the ``ArrayRecord`` from the context"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:263
msgid "Construct a ``state_dict`` and load it"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:282
msgid ""
"And that's it! Recall that even though this example shows how to store "
"the entire ``state_dict`` in an ``ArrayRecord``, you can just save part "
"of it. The process would be identical, but you might need to adjust how "
"it is loaded into an existing model using PyTorch APIs."
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:288
msgid "Saving Tensorflow/Keras parameters to the context"
msgstr ""

#: ../../source/how-to-design-stateful-clients.rst:290
msgid ""
"Follow the same steps as done above but replace the ``state_dict`` logic "
"with simply `get_weights() "
"<https://www.tensorflow.org/api_docs/python/tf/keras/Layer#get_weights>`_"
" to convert the model parameters to a list of NumPy arrays that can then "
"be saved into an ``ArrayRecord``. Then, after deserialization, use "
"`set_weights() "
"<https://www.tensorflow.org/api_docs/python/tf/keras/Layer#set_weights>`_"
" to apply the new parameters to a model."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:-1
msgid ""
"Guide to starting a TLS-secured Flower server (“SuperLink”) and "
"connecting a Flower client (“SuperNode”) with secure connections."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:7
#, fuzzy
msgid "Enable TLS connections"
msgstr "SSL 연결 사용"

#: ../../source/how-to-enable-tls-connections.rst:9
msgid ""
"Transport Layer Security (TLS) ensures the communication between "
"endpoints is encrypted. This guide describes how to establish secure TLS "
"Superlink ↔ SuperNodes as well as User ↔ SuperLink connections."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:15
msgid ""
"This guide builds on the Flower App setup presented in :doc:`how-to-run-"
"flower-with-deployment-engine` guide and extends it to replace the use of"
" ``--insecure`` in favour of TLS."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:21
msgid ""
"Checkout the `Flower Authentication "
"<https://github.com/adap/flower/tree/main/examples/flower-"
"authentication>`_ example for a complete self-contained example on how to"
" setup TLS and (optionally) node authentication. Check out the :doc:`how-"
"to-authenticate-supernodes` guide to learn more about adding an "
"authentication layer to SuperLink ↔ SuperNode connections."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:29
msgid "Certificates"
msgstr "인증서"

#: ../../source/how-to-enable-tls-connections.rst:31
msgid ""
"Using TLS-enabled connections expects some certificates generated and "
"passed when launching the SuperLink, the SuperNodes and when a user (e.g."
" a data scientist that wants to submit a ``Run``) interacts with the "
"federation via the `flwr CLI <ref-api-cli.html>`_."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:36
msgid ""
"We have prepared a script that can be used to generate such set of "
"certificates. While using these are fine for prototyping, we advice you "
"to follow the standards set in your team/organization and generated the "
"certificates and share them with the corresponding parties. Refer to the "
"**Generate TLS certificates** section in the example linked at the top of"
" this guide."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:47
msgid ""
"This will generate the TLS certificates in a new ``certificates/`` "
"directory. Copy this directory into the directory of your app (e.g. a "
"directory generated earlier via ``flwr new``)."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:51
#, fuzzy
msgid ""
"The approach for generating TLS certificates in the context of this "
"example can serve as an inspiration and starting point, but it should not"
" be used as a reference for production environments. Please refer to "
"other sources regarding the issue of correctly generating certificates "
"for production environments. For non-critical prototyping or research "
"projects, it might be sufficient to use the self-signed certificates "
"generated using the scripts mentioned in this guide."
msgstr ""
"이 예의 맥락에서 SSL 인증서를 생성하는 접근 방식은 영감과 출발점이 될 수 있지만 프로덕션 환경에 대한 참조로 사용해서는 안 "
"됩니다. 프로덕션 환경용 인증서를 올바르게 생성하는 문제에 대해서는 다른 출처를 참조하세요. 중요하지 않은 프로토타이핑 또는 연구 "
"프로젝트의 경우, 이 가이드에 언급된 스크립트를 사용하여 생성한 자체 서명 인증서를 사용하는 것으로 충분할 수 있습니다."

#: ../../source/how-to-enable-tls-connections.rst:60
msgid "Launching the SuperLink with TLS"
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:62
msgid ""
"This section describes how to launch a SuperLink that works on TLS-"
"enabled connections. The code snippet below assumes the `certificates/` "
"directory is in the same directory where you execute the command from. "
"Edit the paths accordingtly if that is not the case. When providing "
"certificates, the SuperLink expects a tuple of three certificates paths: "
"CA certificate, server certificate and server private key."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:78
msgid ""
"``--ssl-ca-certfile``: Specify the location of the CA certificate file in"
" your file. This file is a certificate that is used to verify the "
"identity of the SuperLink."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst
msgid ""
"``--ssl-certfile``: Specify the location of the SuperLink's TLS "
"certificate file. This file is used to identify the SuperLink and to "
"encrypt the packages that are transmitted over the network."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst
msgid ""
"``--ssl-keyfile``: Specify the location of the SuperLink's TLS private "
"key file. This file is used to decrypt the packages that are transmitted "
"over the network."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:84
msgid "Connecting the SuperNodes with TLS"
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:86
msgid ""
"This section describes how to launch a SuperNode that works on TLS-"
"enabled connections. The code snippet below assumes the `certificates/` "
"directory is in the same directory where you execute the command from. To"
" enable TLS, the only change required when launching the SuperNode is "
"replacing ``--insecure`` with ``--root-certificates``"
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:102
msgid ""
"``--root-certificates``:This specifies the location of the CA certificate"
" file. The ``ca.crt`` file is used to verify the identity of the "
"SuperLink."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:104
msgid ""
"Follow the same procedure, i.e. replacing ``--insecure`` with ``--root-"
"certificates``, to launch the second SuperNode."
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:118
msgid "TLS-enabled Flower CLI"
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:120
msgid ""
"The `Flower CLI <ref-api-cli.html>`_ (e.g. ``flwr run`` command) is the "
"way a user (e.g. a data scientist) can interact with a deployed "
"federation. The Flower CLI commands are processed by the SuperLink and "
"therefore, if it has been configured to only operate on TLS conenction, "
"the requests sent by the Flower CLI need to make use of a TLS "
"certificate. To do so, replace the ``insecure = true`` field in the "
"``pyproject.toml`` with a new field that reads the certificate:"
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:135
msgid ""
"Note that the path to the ``root-certificates`` is relative to the root "
"of the project. Now, you can run the example by executing ``flwr run``:"
msgstr ""

#: ../../source/how-to-enable-tls-connections.rst:146
#, fuzzy
msgid ""
"You should now have learned how to generate self-signed certificates "
"using the given script, start an TLS-enabled server and have two clients "
"establish secure connections to it. You should also have learned how to "
"run your Flower project using ``flwr run`` with TLS enabled. All other "
"commands in the `Flower CLI <ref-api-cli.html>`_ will also be TLS-"
"enabled."
msgstr ""
"이제 주어진 스크립트를 사용하여 자체 서명 인증서를 생성하고, SSL 사용 서버를 시작하고, 클라이언트가 보안 연결을 설정하는 "
"방법을 배웠을 것입니다."

#: ../../source/how-to-enable-tls-connections.rst:161
msgid "Additional resources"
msgstr "추가 리소스"

#: ../../source/how-to-enable-tls-connections.rst:163
msgid ""
"These additional sources might be relevant if you would like to dive "
"deeper into the topic of certificates:"
msgstr "인증서에 대해 더 자세히 알아보고 싶다면 이러한 추가 자료를 참고하세요:"

#: ../../source/how-to-enable-tls-connections.rst:166
msgid "`Let's Encrypt <https://letsencrypt.org/docs/>`_"
msgstr "'암호화하세요 <https://letsencrypt.org/docs/>`_'"

#: ../../source/how-to-enable-tls-connections.rst:167
msgid "`certbot <https://certbot.eff.org/>`_"
msgstr "`인증봇 <https://certbot.eff.org/>`_"

#: ../../source/how-to-implement-fedbn.rst:-1
msgid ""
"Learn to build a federated ML workload using Flower with FedBN for non-"
"IID data. Train a CNN with PyTorch on CIFAR-10 with minimal changes from "
"the Quickstart."
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:7
#, fuzzy
msgid "Implement FedBN"
msgstr "전략 구현"

#: ../../source/how-to-implement-fedbn.rst:9
#, fuzzy
msgid ""
"This tutorial will show you how to use Flower to build a federated "
"version of an existing machine learning workload with `FedBN "
"<https://github.com/med-air/FedBN>`_, a federated training method "
"designed for non-IID data. We are using PyTorch to train a Convolutional "
"Neural Network (with Batch Normalization layers) on the CIFAR-10 dataset."
" When applying FedBN, only minor changes are needed compared to "
":doc:`Quickstart PyTorch <tutorial-quickstart-pytorch>`."
msgstr ""
"이 튜토리얼에서는 non-iid data를 위해 설계된 federated 훈련 전략인 `FedBN "
"<https://github.com/med-air/FedBN>`_으로 기존 머신러닝 워크로드의 federated 버전을 구축하기 "
"위해 Flower를 사용하는 방법을 보여드립니다. 우리는 PyTorch를 사용하여 CIFAR-10 데이터 세트에서 컨볼루션 "
"신경망(일괄 정규화 레이어 포함)을 훈련하고 있습니다. FedBN을 적용할 때, :doc:`예제: 파이토치 -중앙 집중식에서 "
"연합식으로 <example-pytorch-from-centralized-to-federated>` 와 비교했을 때 몇 가지 사항만 "
"변경 하면 됩니다."

#: ../../source/how-to-implement-fedbn.rst:18
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:196
#, fuzzy
msgid "Model"
msgstr "mod"

#: ../../source/how-to-implement-fedbn.rst:20
msgid ""
"A full introduction to federated learning with PyTorch and Flower can be "
"found in :doc:`Quickstart PyTorch <tutorial-quickstart-pytorch>`. This "
"how-to guide changes only a few details in ``task.py``. FedBN requires a "
"model architecture (defined in class ``Net()``) that uses Batch "
"Normalization layers:"
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:51
msgid ""
"Try editing the model architecture, then run the project to ensure "
"everything still works:"
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:58
msgid ""
"So far this should all look fairly familiar if you've used Flower with "
"PyTorch before."
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:62
msgid "FedBN"
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:64
#, fuzzy
msgid ""
"To adopt FedBN, we revise the ``train`` method in ``ClientApp``. The "
"batch normalization parameters are excluded from model state dict when "
"sending to or receiving from the ``ServerApp``:"
msgstr ""
"마지막으로, :code:`client.py`에서 :code:`get_parameters` 및 "
":code:`set_parameters`를 변경하여 *client* 로직을 수정할 것입니다. 서버로 보내거나 서버에서 받을 때 모델"
" 파라미터 목록에서 배치 정규화 파라미터를 제외할 수 있습니다."

#: ../../source/how-to-implement-fedbn.rst:97
msgid "To test the new approach, run the project again:"
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:103
msgid ""
"Your PyTorch project now runs federated learning with FedBN. "
"Congratulations!"
msgstr ""

#: ../../source/how-to-implement-fedbn.rst:107
#: ../../source/how-to-run-flower-on-azure.rst:220
msgid "Next Steps"
msgstr "다음 단계"

#: ../../source/how-to-implement-fedbn.rst:109
#, fuzzy
msgid ""
"The example is certainly over-simplified since all ``ClientApp``\\s load "
"the exact same dataset. This isn't realistic. You now have the tools to "
"explore this topic further. How about using different subsets of CIFAR-10"
" on each client? How about adding more clients?"
msgstr ""
"이 예제의 전체 소스 코드는 '여기 <https://github.com/adap/flower/blob/main/examples"
"/pytorch-from-centralized-to-federated>`_'에서 확인할 수 있습니다. 물론 이 예제는 두 "
"클라이언트가 완전히 동일한 데이터 세트를 로드하기 때문에 다소 지나치게 단순화되어 있으며, 이는 현실적이지 않습니다. 이제 이 "
"주제를 더 자세히 살펴볼 준비가 되셨습니다. 각 클라이언트에서 서로 다른 CIFAR-10의 하위 집합을 사용해 보는 것은 어떨까요?"
" 클라이언트를 더 추가하는 것은 어떨까요?"

#: ../../source/how-to-implement-strategies.rst:3
msgid "Implement strategies"
msgstr "전략 구현"

#: ../../source/how-to-implement-strategies.rst:5
msgid ""
"This page has moved. Please see :doc:`Flower Strategy Abstraction "
"<explanation-flower-strategy-abstraction>`."
msgstr ""

#: ../../source/how-to-install-flower.rst:-1
msgid ""
"Learn how to install Flower, the Python-based federated learning "
"framework, using PyPI, conda, or Docker in this easy-to-follow guide."
msgstr ""

#: ../../source/how-to-install-flower.rst:7
msgid "Install Flower"
msgstr "Flower 설치"

#: ../../source/how-to-install-flower.rst:11
msgid "Python version"
msgstr "Python 버전"

#: ../../source/how-to-install-flower.rst:17
msgid "Install stable release"
msgstr "안정적인 릴리즈 설치"

#: ../../source/how-to-install-flower.rst:20
msgid "Using pip"
msgstr "pip 사용"

#: ../../source/how-to-install-flower.rst:22
#, fuzzy
msgid "Stable releases are available on `PyPI <https://pypi.org/project/flwr/>`_:"
msgstr "안정적인 릴리즈는 `PyPI <https://pypi.org/project/flwr/>`_:: 에서 확인할 수 있습니다::"

#: ../../source/how-to-install-flower.rst:28
#, fuzzy
msgid ""
"For simulations that use the Virtual Client Engine, ``flwr`` should be "
"installed with the ``simulation`` extra:"
msgstr "가상 클라이언트 엔진을 사용하는 시뮬레이션의 경우 ``flwr``을 ``simulation``extra와 함께 설치해야 합니다:"

#: ../../source/how-to-install-flower.rst:36
msgid "Using conda (or mamba)"
msgstr "conda(또는 mamba) 사용"

#: ../../source/how-to-install-flower.rst:38
msgid "Flower can also be installed from the ``conda-forge`` channel."
msgstr "Flower은 'conda-forge' 채널에서도 설치할 수 있습니다."

#: ../../source/how-to-install-flower.rst:40
#, fuzzy
msgid ""
"If you have not added ``conda-forge`` to your channels, you will first "
"need to run the following:"
msgstr "채널에 'conda-forge'를 추가하지 않은 경우 먼저 다음을 실행해야 합니다:"

#: ../../source/how-to-install-flower.rst:48
#, fuzzy
msgid ""
"Once the ``conda-forge`` channel has been enabled, ``flwr`` can be "
"installed with ``conda``:"
msgstr "conda-forge`` 채널이 활성화되면 ``flwr``을 ``conda``로 설치할 수 있습니다::"

#: ../../source/how-to-install-flower.rst:55
#, fuzzy
msgid "or with ``mamba``:"
msgstr "또는 ``mamba``::"

#: ../../source/how-to-install-flower.rst:63
msgid "Verify installation"
msgstr "설치 확인"

#: ../../source/how-to-install-flower.rst:65
#, fuzzy
msgid ""
"The following command can be used to verify if Flower was successfully "
"installed. If everything worked, it should print the version of Flower to"
" the command line:"
msgstr ""
"다음 명령을 사용하여 Flower가 성공적으로 설치되었는지 확인할 수 있습니다. 모든 것이 정상적으로 작동하면 명령줄에 "
"Flower의 버전이 출력됩니다:"

#: ../../source/how-to-install-flower.rst:76
msgid "Advanced installation options"
msgstr "고급 설치 옵션"

#: ../../source/how-to-install-flower.rst:79
msgid "Install via Docker"
msgstr "Docker를 통해 설치"

#: ../../source/how-to-install-flower.rst:81
#, fuzzy
msgid ":doc:`Run Flower using Docker <docker/index>`"
msgstr ":doc:`Docker를 사용하여 Flower를 실행하는 방법 <how-to-run-flower-using-docker>`"

#: ../../source/how-to-install-flower.rst:84
msgid "Install pre-release"
msgstr "사전 릴리즈 설치"

#: ../../source/how-to-install-flower.rst:86
#, fuzzy
msgid ""
"New (possibly unstable) versions of Flower are sometimes available as "
"pre-release versions (alpha, beta, release candidate) before the stable "
"release happens:"
msgstr ""
"새(불안정할 수 있는) 버전의 Flower는 안정 버전이 출시되기 전에 사전 릴리즈 버전(알파, 베타, 릴리즈 후보)으로 제공되는 "
"경우가 있습니다:"

#: ../../source/how-to-install-flower.rst:93
#, fuzzy
msgid ""
"For simulations that use the Virtual Client Engine, ``flwr`` pre-releases"
" should be installed with the ``simulation`` extra:"
msgstr ""
"가상 클라이언트 엔진을 사용하는 시뮬레이션의 경우 ``flwr`` 사전 릴리즈를 ``simulation`` extra와 함께 "
"설치해야 합니다:"

#: ../../source/how-to-install-flower.rst:101
msgid "Install nightly release"
msgstr "야간 릴리즈 설치"

#: ../../source/how-to-install-flower.rst:103
#, fuzzy
msgid ""
"The latest (potentially unstable) changes in Flower are available as "
"nightly releases:"
msgstr "Flower의 최신 (불안정할 수 있는) 변경 사항은 다음과 같이 야간 릴리즈로 제공됩니다:"

#: ../../source/how-to-install-flower.rst:109
#, fuzzy
msgid ""
"For simulations that use the Virtual Client Engine, ``flwr-nightly`` "
"should be installed with the ``simulation`` extra:"
msgstr ""
"가상 클라이언트 엔진을 사용하는 시뮬레이션의 경우, ``flwr-nightly``를 ``simulation`` extr와 함께 "
"설치해야 합니다::"

#: ../../source/how-to-manage-flower-federations.rst:-1
msgid "Guide to manage Flower federations using the Deployment Engine."
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:11
msgid ""
"Flower Federation management is a new feature introduced in Flower "
"1.24.0. It gains new functionality in subsequent releases. Changes to the"
" functionality described in this guide are also expected as the features "
"provided via the ``flwr federation`` commands mature."
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:18
#, fuzzy
msgid "Manage Flower Federations"
msgstr "시뮬레이션 실행"

#: ../../source/how-to-manage-flower-federations.rst:20
msgid ""
"A Flower federation is comprised of a set of users and some or all the "
"SuperNodes they own that are registered with the same SuperLink. Members "
"of a Flower federation can execute runs (e.g. to federate the training of"
" an AI model) across all SuperNodes that are part of it."
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:25
#: ../../source/how-to-run-flower-with-deployment-engine.rst:13
msgid "In this how-to guide, you will:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:27
msgid "Learn how to see the federations you are part of."
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:28
msgid "Learn how to display information about a specific federation."
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:32
#, fuzzy
msgid "List Federations"
msgstr "시뮬레이션 실행"

#: ../../source/how-to-manage-flower-federations.rst:34
msgid ""
"With the |flower_cli_federation_link|_, you can easily inspect the "
"federations your Flower account is part of:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:41
msgid ""
"The above command will display a table with a row for each federation you"
" are part of. In this case there is only one federation named "
"``default``:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:55
#, fuzzy
msgid "Inspect a Federation"
msgstr "시뮬레이션 실행"

#: ../../source/how-to-manage-flower-federations.rst:57
msgid ""
"You can inspect a specific federation by using the ``flwr federation "
"show`` command, another command provided by the "
"|flower_cli_federation_link|_. With this command, you will be able to see"
" the following information about a federation:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:61
#, fuzzy
msgid "The members of the federation."
msgstr "flower 초연결"

#: ../../source/how-to-manage-flower-federations.rst:62
#, fuzzy
msgid "The SuperNodes registered with the federation and their status."
msgstr "flower 초연결"

#: ../../source/how-to-manage-flower-federations.rst:63
#, fuzzy
msgid "The runs executed via the federation."
msgstr "flower 초연결"

#: ../../source/how-to-manage-flower-federations.rst:65
msgid ""
"The ``flwr federation show`` command requires the name of the federation "
"to inspect as an argument. This can be specified as part of your "
"``pyproject.toml`` configuration. For example:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:78
msgid ""
"In this example, the federation named ``default`` is specified. You can "
"now inspect it by running:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:85
msgid ""
"Then, assuming that there are two ``SuperNodes`` connected and that three"
" runs have been submitted through the federation, a representative output"
" would be similar to:"
msgstr ""

#: ../../source/how-to-manage-flower-federations.rst:116
msgid ""
"Note how the ``SuperNodes`` table shows a subset of the information "
"available via the command ``flwr supernode list`` (Learn more about this "
"command in the :doc:`how-to-authenticate-supernodes` guide). Similarly, "
"the ``Runs`` table shows a subset of the information available via the "
"``flwr list`` command."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:-1
msgid "Migrate your OpenFL workloads to Flower in this step-by-step tutorial"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:45
#, fuzzy
msgid "OpenFL Migration Guide"
msgstr "구성 값"

#: ../../source/how-to-migrate-from-openfl.rst:47
msgid ""
"It was `recently announced "
"<https://github.com/securefederatedai/openfederatedlearning>`_ that The "
"Open Federated Learning project (formerly known as OpenFL) is no longer "
"being developed or maintained. This guide, written in collaboration with "
"the OpenFL developers, aims to create an easy path for OpenFL users to "
"bring their workloads into Flower."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:55
msgid "Creating a Flower App for OpenFL code"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:57
msgid ""
"Let's start by creating a Flower app where the OpenFL code can be "
"migrated to."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:60
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:77
#, fuzzy
msgid "Install dependencies"
msgstr "사전 릴리즈 설치"

#: ../../source/how-to-migrate-from-openfl.rst:62
#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:59
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:63
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:79
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:68
msgid "First, we install the Flower package ``flwr``:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:69
#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:66
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:70
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:86
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:75
msgid ""
"Then, we create a new Flower app called ``flower-tutorial`` using the "
"PyTorch template. We also specify a username (``flwrlabs``) for the "
"project:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:76
msgid ""
"After running the command, a new directory called ``flower-tutorial`` "
"will be created. Here is a comparison between it and the relevant files "
"in a typical ``openfl-example`` folder:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:82
#, fuzzy
msgid "OpenFL Example"
msgstr "예시"

#: ../../source/how-to-migrate-from-openfl.rst:105
#, fuzzy
msgid "Flower Tutorial"
msgstr "튜토리얼"

#: ../../source/how-to-migrate-from-openfl.rst:119
msgid ""
"Let's start with an overview of which areas of OpenFL and Flower "
"directory structures you'll want to focus on. We will go through these in"
" depth in later sections of the guide:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:123
msgid ""
"**Model**: In OpenFL, the model is usually defined in ``taskrunner.py``. "
"In Flower, the model definition is usually located in ``task.py``."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:125
msgid ""
"**Train and Evaluate Functions**: In OpenFL, these are part of the "
"`TaskRunner` subclass in ``taskrunner.py``. For Flower, you'll find these"
" in ``client_app.py`` and identified beneath the ``@app.train()`` and "
"``@app.evaluate`` decorators."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:128
msgid ""
"**Aggregation Functions**: In OpenFL, most examples use the "
"``WeightedAverage()`` aggregation algorithm by default. If you're using a"
" different aggregation algorithm, you'll find it in ``plan.yaml`` by "
"searching for `aggregation_type`. In Flower, the aggregation algorithm is"
" defined as a |strategy_link|_."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:134
msgid "Migrate your model"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:136
msgid ""
"The model is very straightforward to port from OpenFL to Flower. If you "
"are working with a PyTorch model, OpenFL has a ``PyTorchTaskRunner`` that"
" inherits from ``nn.module`` (in ``taskrunner.py``) - and includes other "
"things like the ``train`` and ``validate`` functions. Flower assumes you "
"bring a standard PyTorch model, so it's as easy as moving the model "
"definition to ``task.py`` in the ``flower_tutorial`` directory, and "
"changing the inheritance of the Net back to ``nn.module``. For a concrete"
" example, see the following OpenFL TaskRunner code snippet:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:208
msgid "And the corresponding PyTorch model used by Flower:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:234
#, fuzzy
msgid "Migrate your training and test functions"
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: ../../source/how-to-migrate-from-openfl.rst:236
msgid ""
"Recent versions of OpenFL had a simple way of defining training and "
"evaluation functions. The setting and extraction of model weights was "
"hidden from users, and a list of ``Metric`` values resulting from "
"training or validation could be explicitly returned from the function. To"
" make migration easy, see the highlighted blocks that can carry over "
"directly to the Flower ``client_app.py`` file:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:321
msgid ""
"In Flower more control is given to users by default. With the "
"introduction of the Message API, the training and validation functions "
"are assumed to be stateless, so there is some initialization that must be"
" handled by user code. The good news is that this setup is standard and "
"quite reusable across examples. Let's see how the relevant OpenFL "
"``train_`` function fits into Flower:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:379
msgid ""
"Notice the model is reininitialized, the dataloader is initialized and "
"configured, and hyperparameters are each set before the core training "
"operation begins. At the conclusion of the training, the model weights "
"are extracted and packed into an ``ArrayRecord`` and the model metrics "
"are captured in a ``MetricRecord``. It's necessary to also send the `num-"
"examples` as a metric, as this is needed for capturing the weight to give"
" to the model parameters for ``FedAvg``."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:386
msgid ""
"Here is the corresponding evaluation function, with the highlighted area "
"representing the migrated code from OpenFL:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:434
msgid ""
"The code can be mostly pasted in unmodified! There are a few references "
"to cleanup (i.e. changing `self` to `model`) to fit with the Flower "
"variables, but the logic remains the same."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:439
msgid "Migrating the Data Loaders"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:441
msgid ""
"Unlike OpenFL, Flower does not require that you use their own Dataloaders"
" when developing your application. This means you can simply DataLoaders "
"in the same way that you would for PyTorch, Tensorflow, or any other "
"framework. For research and experimentation purposes, a single dataset "
"can be sharded into multiple partitions. This information is passed to "
"each ``ClientApp`` through the ``Context``:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:459
msgid ""
"Flower also has its own library for partitioning single datasets in "
"distributions representative of what can be expected in real world "
"settings. For more information, see the `flwr-datasets "
"<https://flower.ai/docs/datasets/>`_ documentation for details."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:464
#, fuzzy
msgid "Client-side Code"
msgstr "클라이언트 측 클리핑"

#: ../../source/how-to-migrate-from-openfl.rst:466
msgid ""
"In OpenFL, the client side code was known as a Collaborator. In Flower, "
"the application that data owners operate is referred to as a "
"``ClientApp``. Each of the files referred to so far (``client_app.py``, "
"``task.py``) are launched by the clients using the `flwr run` command. "
"Beyond the code that is defined, Flower has the ability to insert dynamic"
" changes through a configuration file, called ``pyproject.toml``. This "
"can include application specific changes like hyperparameters, but also "
"other information like ServerApp address, etc. Importantly, this file is "
"shared between parties operating the ``ClientApp`` and ``ServerApp``. "
"This concept directly maps to the Federated Learning Plan (FLPlan) "
"concept in OpenFL captured in the ``plan.yaml`` file of every workspace."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:492
#, fuzzy
msgid "Server-side Code"
msgstr "서버 측 클리핑"

#: ../../source/how-to-migrate-from-openfl.rst:494
msgid ""
"In OpenFL, all of the aggregator-side code is configured via the "
"`plan.yaml` file through the specification of different arguments. In "
"Flower, the exact tasks performed by the server are more configurable "
"through code. For example, aggregation algorithms are added through a "
"``Strategy``, and the logic to save models is added explictly. Here is a "
"``ServerApp`` (akin to an OpenFL Aggregator) compatible with the prior "
"code snippets:"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:544
msgid ""
"You'll notice that most ``ServerApp`` examples have specific logic for "
"working with a given deep learning framework (in this case PyTorch) due "
"to the saving of a final model. This functionality is optional, but "
"mirrors the automatic saving of a model at the end of an OpenFL "
"experiment. This ``ServerApp`` change requires only a few lines of "
"modifications, and Flower has support for an extensive set of deep "
"learning frameworks in it's `examples "
"<https://github.com/adap/flower/tree/main/examples>`_ (Tensorflow, "
"FastAI, Huggingface, etc.) should you need reference code."
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:554
#: ../../source/how-to-upgrade-to-flower-1.0.rst:139
#: ../../source/how-to-upgrade-to-flower-1.13.rst:462
msgid "Further help"
msgstr "추가 도움말"

#: ../../source/how-to-migrate-from-openfl.rst:556
msgid ""
"For a complete PyTorch example that goes into depth on various Flower "
"components, see the `Get started with Flower "
"<https://flower.ai/docs/framework/tutorial-series-get-started-with-"
"flower-pytorch.html>`_ tutorial. While we expect this guide will help "
"most users get migrated quickly to the Flower ecosystem, certain complex "
"OpenFL workloads may require more clarification or help. If you have "
"further questions, `join the Flower Slack <https://flower.ai/join-"
"slack/>`_ (and use the channel ``#questions``) or join our `OpenFL "
"Continuity Program "
"<https://docs.google.com/forms/d/e/1FAIpQLScprGGX_jFRoEUv4HbJkkhkg6O7e5eCiq7uP95_0xK5Qnt1gA/viewform>`_"
" to get in touch with our team!"
msgstr ""

#: ../../source/how-to-migrate-from-openfl.rst:567
#: ../../source/how-to-upgrade-to-flower-1.13.rst:471
msgid "Important"
msgstr "중요"

#: ../../source/how-to-migrate-from-openfl.rst:569
#, fuzzy
msgid ""
"As we work with the OpenFL community, we'll be periodically updating this"
" guide. Please feel free to share any feedback with us!"
msgstr ""
"Flower Next는 빠른 속도로 지속적으로 개선되고 있으므로 이 가이드는 주기적으로 업데이트될 예정입니다. 피드백이 있으면 "
"언제든지 공유해 주세요!"

#: ../../source/how-to-migrate-from-openfl.rst:572
#: ../../source/how-to-upgrade-to-flower-1.13.rst:476
msgid "Happy migrating! 🚀"
msgstr "행복한 마이그레이션! 🚀"

#: ../../source/how-to-run-flower-on-azure.rst:19
#, fuzzy
msgid "Run Flower on Azure"
msgstr "Flower 서버."

#: ../../source/how-to-run-flower-on-azure.rst:23
msgid ""
"There are many ways to deploy Flower on Microsoft Azure. The instructions"
" provided in this guide is just a basic walkthrough, step-by-step guide "
"on how to quickly setup and run a Flower application on a Federated "
"Learning environment on Microsoft Azure."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:28
msgid ""
"In this how-to guide, we want to create a Federated Learning environment "
"on Microsoft Azure using three Virtual Machines (VMs). From the three "
"machines, one machine will be used as the Federation server and two as "
"the Federation clients. Our goal is to create a Flower federation on "
"Microsoft Azure where we can run Flower apps from our local machine, "
"e.g., laptop."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:34
msgid ""
"On the Federation server VM we will deploy the long-running Flower server"
" (``SuperLink``) and on the two Federation client VMs we will deploy the "
"long-running Flower client (``SuperNode``). For more details For more "
"details regarding the ``SuperLink`` and ``SuperNode`` concepts, please "
"see the |flower_architecture_link|_ ."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:41
msgid "Azure VMs"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:43
msgid ""
"First we need to create the three VMs configure their Python "
"environments, and inbound networking rules to allow cross-VM "
"communication."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:47
msgid "VM Create"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:49
msgid ""
"Assuming we are already inside the Microsoft Azure portal, we navigate to"
" the ``Create`` page and we select ``Azure virtual machine``. In the new "
"page, for each VM we edit the properties as follows:"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:58
msgid "**Virtual machine name**"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:59
msgid ""
"for server machine we can use ``flower-server`` and for clients, "
"``flower-client-1`` and ``flower-client-2``"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:61
#, fuzzy
msgid "**Image**"
msgstr "**변경하기**"

#: ../../source/how-to-run-flower-on-azure.rst:62
msgid "in this guide, we use ``Ubuntu Server 24.04 - x64 Gen2 LTS``"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:63
msgid "**Size**"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:64
msgid "in this guide, we use ``Standard_D2s_v3 - 2 vcpus, 8GiB memory``"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:68
msgid "For resource group, we can create a new group and assign it to all VMs."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:70
msgid ""
"When each VM instance has been created the portal will allow you to "
"download the public key (.pem) of each instance. Make sure you save this "
"key in safe place and change its permissions to user read only, i.e., run"
" the ``chmod 400 <PATH_TO_PEM_FILE>`` command for every .pem file."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:75
msgid ""
"Once all three VMs are created then navigate to the overview page where "
"all three VMs are listed and open every other VM, and copy its Public IP "
"address. Using the Public IP address and the public key (after changing "
"the permissions), login to the instances from our local machine by "
"running the following command (by default Azure creates the "
"``azureuser``):"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:86
msgid "VM Networking"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:88
#, python-brace-format
msgid ""
"During the execution of the Flower application, the server VM "
"(``SuperLink``) will be responsible to orchestrate the execution of the "
"application across the client VMs (``SuperNode``). When the SuperLink "
"server starts, by default, it listens to the following ports: ``{9092, "
"9093}``. Port `9092` is used to communicate with the Federation clients "
"(``SuperNode``) and port ``9093`` to receive and execute Flower "
"applications."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:95
msgid ""
"Therefore, to enable this communication we need to allow inbound traffic "
"to the server VM instance. To achieve this, we need to navigate to the "
"Networking page of the server VM in the Microsoft Azure portal. There, we"
" will click the ``Add inbound port rule``. In the new window that "
"appears, we edit the rule properties as follows:"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:100
msgid "The rest of the fields can be left at their default values."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:107
#: ../../source/how-to-run-flower-on-azure.rst:148
#, fuzzy
msgid "**Source**"
msgstr "run\\_supernode"

#: ../../source/how-to-run-flower-on-azure.rst:108
msgid "``IP Addresses``"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:109
#: ../../source/how-to-run-flower-on-azure.rst:136
msgid "**Source IP addresses/CIDR ranges**"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:110
msgid "add client VMs' Public IP (separated by comma)"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:111
#, fuzzy
msgid "**Destination**"
msgstr "설명"

#: ../../source/how-to-run-flower-on-azure.rst:112
#: ../../source/how-to-run-flower-on-azure.rst:149
#, fuzzy
msgid "``Any``"
msgstr "``flwr/base``"

#: ../../source/how-to-run-flower-on-azure.rst:113
#, fuzzy
msgid "**Service**"
msgstr "run\\_supernode"

#: ../../source/how-to-run-flower-on-azure.rst:114
#, fuzzy
msgid "``custom``"
msgstr "``DISTRO``"

#: ../../source/how-to-run-flower-on-azure.rst:115
#: ../../source/how-to-run-flower-on-azure.rst:138
#: ../../source/how-to-run-flower-on-azure.rst:150
msgid "**Destination port ranges**"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:116
msgid "``9092``"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:117
msgid "**Protocol**"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:118
#, fuzzy
msgid "``TCP``"
msgstr "``DISTRO``"

#: ../../source/how-to-run-flower-on-azure.rst:120
msgid ""
"Finally, we need to also open port 9093 to allow receiving and executing "
"incoming application requests. To enable this we just need to repeat the "
"steps above, i.e., create a new inbound rule, where for port range we "
"assign port 9093. If we already know the Public IP from which our local "
"machine (e.g., laptop) will be submitting applications to the Azure "
"cluster, then we just need to specify the Source IP address/CIDR range. "
"However, if we want to keep the port widely open we simply need to change"
" source to ``Any``."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:128
msgid ""
"To be more precise, if we know the Public IP of our machine, then we make"
" the following changes:"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:137
msgid "add machine's Public IP"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:139
#: ../../source/how-to-run-flower-on-azure.rst:151
msgid "``9093``"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:141
msgid "Otherwise, we change the properties as follows:"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:155
#, fuzzy
msgid "Flower Environment"
msgstr "Flower 개발 환경 만들기"

#: ../../source/how-to-run-flower-on-azure.rst:157
msgid ""
"Assuming we have been able to login to each VM, and create a Python "
"environment with Flower and all its dependencies installed (``pip install"
" flwr``), we can create a Flower application by running the ``flwr new`` "
"command. The console will then prompt us to give a name to the project, "
"e.g., ``flwr_azure_test``, the name of the author and select the type of "
"the Flower Framework we want to run, e.g., ``numpy``."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:165
msgid ""
"An alternative approach would be to use Docker in each VM, with each "
"image containing the necessary environment and dependencies. For more "
"details please refer to the |flower_docker_index|_ guide."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:170
#, fuzzy
msgid "Server Initialization"
msgstr "설치 확인"

#: ../../source/how-to-run-flower-on-azure.rst:172
msgid ""
"After configuring the Flower application environment, we proceed by "
"starting the Flower long-running processes (i.e., ``SuperLink`` and "
"``SuperNode``) at each VM instance. In particular, we need to run the "
"following commands, first in the server (``SuperLink``) and then at each "
"client (``SuperNode``)."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:179
msgid ""
"To enable authentication and encrypted communication during the execution"
" lifecycle of the Flower application, please have a look at the following"
" resources: |authenticate_supernodes|_, |enable_tls_connections|_"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:199
#: ../../source/how-to-run-flower-on-gcp.rst:591
#, fuzzy
msgid "Run Flower App"
msgstr "Flower 서버."

#: ../../source/how-to-run-flower-on-azure.rst:201
msgid ""
"Finally, after all running Flower processes have been initialized on the "
"Microsoft Azure cluster, in our local machine, we first need to install "
"Flower and can create a project with a similar structure as the one we "
"have in the server and the clients, or copy the project structure from "
"one of them. Once we have the project locally, we can open the "
"``pyproject.toml`` file, and then add the following sections:"
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:216
msgid "Then from our local machine we need to run ``flwr run . my-federation``."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:224
msgid ""
"This guide is not suitable for production environments due to missing "
"authentication and TLS security."
msgstr ""

#: ../../source/how-to-run-flower-on-azure.rst:227
msgid ""
"To enable authentication and establish secure connections, please refer "
"to the following resources: |authenticate_supernodes|_, "
"|enable_tls_connections|_"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:-1
msgid ""
"A step-by-step guide to learn how to create, deploy and run a Flower app "
"on the Google Cloud Platform (GCP) using the Google Kubernetes Engine "
"(GKE)."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:7
#, fuzzy
msgid "Run Flower on GCP"
msgstr "Flower 서버."

#: ../../source/how-to-run-flower-on-gcp.rst:9
msgid ""
"A step-by-step guide to learn how to create, deploy and run a Flower app "
"on the `Google Cloud Platform (GCP) <https://console.cloud.google.com>`_ "
"using the `Google Kubernetes Engine (GKE) <https://cloud.google.com"
"/kubernetes-engine>`_. The figure below presents an overview of the "
"architecture of the Flower components we will deploy on GCP using GKE. In"
" this architecture, **ServerApps** and **ClientApps** are executed by the"
" Flower SuperExec (`flower-superexec`)."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:16
#, fuzzy
msgid "Running Flower on GCP using GKE Architecture"
msgstr "Flower 아키텍처"

#: ../../source/how-to-run-flower-on-gcp.rst:22
#, fuzzy
msgid "Running Flower on GCP using GKE Architecture."
msgstr "Flower 아키텍처"

#: ../../source/how-to-run-flower-on-gcp.rst:24
msgid ""
"Part of this guide has also been presented during the `Flower AI Summit "
"2025 <https://flower.ai/events/flower-ai-summit-2025/>`_, by Prashant "
"Kulkarni, GenAI Security Engineer at Google Cloud."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:34
msgid "Create a Kubernetes Cluster"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:36
msgid ""
"Here, we outline the steps to create a Kubernetes cluster in GCP through "
"the GCP user interface. Before proceeding, please make sure you have an "
"account on GCP."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:39
msgid ""
"**Create GCP Project**: Once you have created the account, please create "
"a new project, by selecting the project picker button, i.e., the button "
"with the project name appearing at the top of the page. This will open a "
"new window from where you can press the ``NEW PROJECT`` button and create"
" the new project and assign a name, e.g., ``flower-gcp``. Before "
"proceeding to the next step, please ensure that the ``flower-gcp`` "
"project is selected in the top left corner."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:45
msgid ""
"**Enable Kubernetes API**: After the GCP project is created, in the "
"search bar at the top of the GCP page type ``Kubernetes Engine API`` and "
"click on it (it has an ``API`` icon). This will redirect you to the "
"``Kubernetes Engine API`` Product page. From there you need to select "
"``Enable``; if you see a ``Billing required`` pop-up, please check with "
"your administrator to continue, if necessary. After you enable it you "
"should see a green mark in the ``Kubernetes Engine API`` saying ``API "
"Enabled``."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:51
msgid ""
"**Create Kubernetes Cluster**: in the home page of the GCP project, under"
" the ``Products`` section, look for the tab called ``Create a Kubernetes "
"Cluster``. This will redirect you to a page where you will see an "
"overview of the existing Kubernetes clusters. At the top of the page you "
"should see a button called ``Create cluster``. By default, the Kubernetes"
" clusters are deployed using the ``Autopilot`` mode. For the current "
"guide, we use the ``Autopilot`` mode."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:57
msgid ""
"**Configure Kubernetes Cluster**: in the page that is shown, we assign a "
"name to the new cluster, e.g., ``flower-numpy-example`` and we select the"
" region, e.g., ``us-central1``. For the rest of the configuration "
"settings, such as ``Cluster Tier``, ``Fleet Registration``, "
"``Networking``, and other settings we use the default values. Now, press "
"the ``Create`` button."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:65
msgid ""
"Please wait for a couple of minutes until the cluster is ready and fully "
"deployed."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:69
#, fuzzy
msgid "Configure Google Cloud SDK"
msgstr "클라이언트 구성"

#: ../../source/how-to-run-flower-on-gcp.rst:71
msgid ""
"To interact with our newly deployed Kubernetes cluster, we will use the "
"Google Cloud SDK and configure it locally. This SDK allows us to directly"
" interact with GCP and in turn with our recently deployed Kubernetes "
"cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:75
msgid ""
"To install the Google Cloud SDK, we first need to install and configure "
"the ``gcloud`` CLI:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:97
msgid ""
"For more detailed installation instructions and for installing ``gcloud``"
" for different operating systems, please take look at the official "
"``gcloud`` CLI installation page "
"https://cloud.google.com/sdk/docs/install"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:101
msgid ""
"Once ``gcloud`` is installed we need to install ``kubectl``, which is a "
"command-line tool to interact with Kubernetes clusters:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:109
msgid ""
"Before proceeding with the next steps, please make sure that you have an "
"active account selected, otherwise you will receive a ``ERROR: "
"(gcloud.container.clusters.get-credentials)`` when running the commands "
"below. To obtain new credentials or select an already authenticated "
"account please run the following commands"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:120
msgid ""
"Now you need to set the ``project`` property in your current workspace "
"using the unique project identifier, which can be found under the ID "
"column when clicking on the project picker."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:131
msgid ""
"The <YOUR_PROJECT_ID> value will be different for each user, e.g., "
"``flower-gcp``, ``flower-gcp-XXXXXX``. Its value will be used in "
"subsequent steps, e.g.,"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:134
msgid ""
"The next step is to configure ``kubectl`` to point to the GKE cluster you"
" created in the previous steps by using the name of the cluster, e.g., "
"``flower-numpy-example``, and the name of the region where the cluster "
"was created:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:142
msgid ""
"This will configure the required metadata and fetch the necessary "
"credentials to allow your local ``kubectl`` to communicate with the GKE "
"cluster. To verify that ``kubectl`` was able to connect to the cluster "
"and get the necessary information, you can run the following command:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:153
msgid ""
"For more information on how ``kubectl`` works, please have a look at the "
"following `official quick-reference guide "
"<https://kubernetes.io/docs/reference/kubectl/quick-reference/>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:159
msgid "Create a Google Artifact Registry"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:161
msgid ""
"The Google Cloud Artifact Registry is a fully managed, scalable, and "
"private service for storing and managing software build artifacts and "
"dependencies. Consequently, to run our Flower app on the GKE cluster, we "
"need to store the app's specific Flower Docker image within the registry,"
" i.e., the Flower SuperExec, which we discuss in the next section. For "
"typical use-cases, the Flower SuperLink and SuperNode Docker images do "
"not need to be built and can be pulled directly from the official `Flower"
" DockerHub repository <https://hub.docker.com/u/flwr>`_. This step is "
"crucial as it enables the cluster, and subsequently the ``Pods``, to "
"download the built Docker images and deploy the necessary Flower "
"components. Please see below the instructions on how to create the "
"repository using the ``gcloud`` CLI:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:188
msgid "Registry Validation & Permissions"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:190
msgid ""
"The steps below validate that the Google Artifact Registry has been "
"properly configured, you have correct access and you have writing "
"permissions to push the docker images discussed in the next section."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:198
msgid ""
"The above command shows that the ``flower-gcp-example-artifacts`` "
"repository has been successfully created under the specified project with"
" ID ``<YOUR_PROJECT_ID>``. Finally, you need to update your role and "
"assign writing permissions to the artifact registry. To accomplish this, "
"please run the following command:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:211
msgid "Configure Flower App Docker Images"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:213
msgid ""
"To proceed with the next step, we first create a local Flower app and "
"then define a dedicated Dockerfile for the Docker image that will run "
"SuperExec. Within SuperExec, either ServerApp or ClientApp will be "
"executed. After building the image, we tag it and push it to the newly "
"created Google registry. Most of the steps on how to build Docker image "
"discussed below are based on the `Flower Quickstart with Docker Tutorial "
"<https://flower.ai/docs/framework/docker/tutorial-quickstart-"
"docker.html>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:220
msgid "We create the Flower NumPy app as follows:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:228
msgid "Create Docker Images"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:230
msgid ""
"With ``flower-superexec``, **you do not need to bake your app code into "
"the image**. SuperExec receives and installs the Flower App Bundle (FAB) "
"at runtime inside the container, keeping your images lightweight."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:236
msgid ""
"SuperExec does **NOT** install dependencies at runtime. If your app "
"requires additional dependencies, make sure they are included in your "
"Docker image, as shown in the Dockerfile example below."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:256
msgid ""
"Once we have created the required Dockerfile, we build the Docker Image "
"as follows:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:260
msgid ""
"Before running the commands below, make sure ``Docker`` is installed and "
"it is up running. The ``--platform`` type is set to ``linux/amd64``, "
"because when using the ``Autopilot`` mode, all ``Pods`` in the Kubernetes"
" cluster (by default) are deployed with an ``amd64``-based architecture."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:270
msgid "Tag Docker Images"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:272
msgid ""
"Before we are able to push our two newly locally created Docker images, "
"we need to tag them with the Google Artifact Registry repository name and"
" image name we created during the previous steps. If you have followed "
"the earlier naming suggestions, the repository name is ``flower-gcp-"
"example-artifacts``, the local Docker image name is "
"``flower_numpy_example_superexec:0.0.1``, and the region is ``us-"
"central1``. Please note that the ``<YOUR_PROJECT_ID>`` is different from "
"user to user, so in the commands below we use the ``<YOUR_PROJECT_ID>`` "
"placeholder. Putting all this together, the final command you need to run"
" to tag the ``SuperExec`` Docker image is:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:289
msgid "Push Docker Images"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:291
msgid ""
"Once our image is tagged correctly, you can push it to your ``Artifact "
"Registry`` repository using the ``docker push`` command with the tagged "
"name:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:303
msgid "Deploy Flower Infrastructure"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:305
msgid ""
"Before running our Flower app, we first need to deploy our ``Pods`` on "
"the Kubernetes cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:308
msgid ""
"In this step, we shall deploy six ``Pods``: 1x ``SuperLink``, 2x "
"``SuperNode``, 2x ``SuperExec(ClientApp)``, and 1x "
"``SuperExec(ServerApp)``. To achieve this, below we provide the "
"definition of the six ``yaml`` files that are necessary to deploy the "
"``Pods`` on the cluster and which are passed to ``kubectl``, and a helper"
" ``k8s-deploy.sh`` script, which will deploy the ``Pods``."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst
msgid "superlink-deployment.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst
msgid "supernode-1-deployment.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst
msgid "supernode-2-deployment.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
msgid "superexec-serverapp-deployment.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
msgid "superexec-clientapp-1-deployment.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
msgid "superexec-clientapp-2-deployment.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:544
msgid ""
"Once you have created the required files, you can use the following "
"``k8s-deploy.sh`` helper script to deploy all the ``Pods``."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:549
msgid ""
"Make sure the Flower version you use to deploy the ``Pods`` matches the "
"version of your Flower app."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
#, fuzzy
msgid "k8s-deploy.sh"
msgstr "배포"

#: ../../source/how-to-run-flower-on-gcp.rst:579
msgid ""
"To see that your ``Pods`` are deployed, please go to the ``Navigation "
"Menu`` on the Google Console, select ``Kubernetes Engine`` and then the "
"``Workloads`` page. The new window that appears will show the status of "
"the ``Pods`` under deployment."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:585
msgid ""
"Please wait for a couple of minutes (3' to 5' minutes should be enough) "
"before the ``Pods`` are up and running. While ``Pods`` resources are "
"being provisioned, some warnings are expected."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:593
msgid ""
"Once all ``Pods`` are up and running, we need to get the ``EXTERNAL_IP`` "
"of the ``superlink-service`` and point our Flower app to use the "
"Kubernetes cluster to submit and execute the job."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:597
msgid ""
"To get the ``EXTERNAL-IP`` of the ``superlink-service`` we run the "
"following command, which will show the ``NAME``, ``TYPE``, ``CLUSTER-"
"IP``, ``EXTERNAL-IP`` and ``PORTS`` of the service:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:605
msgid ""
"After we get the ``EXTERNAL-IP`` , we go to the directory of the Flower "
"example, we open the ``pyproject.toml`` and then add the following "
"section at the end of the file:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:614
msgid "Then we can execute the example on the GCP cluster by running:"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:622
msgid ""
"Please note that in the current deployment, communication is not "
"encrypted. To enable TLS for secure connections, check the following "
"`guide <https://flower.ai/docs/framework/how-to-enable-tls-"
"connections.html>`_. We will also be updating the current guide soon with"
" more details on how to configure TLS."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:627
msgid ""
"If the job is successfully submitted, and executed, then in your console "
"you should see the logs from the run. The output should look like the one"
" shared below."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
msgid "Expected Output"
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:678
msgid ""
"Please note that if you terminate or shut down the cluster, and create a "
"new one, the value of the ``EXTERNAL_IP`` changes. In that case, you will"
" have to update the ``pyproject.toml``."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst:684
#, fuzzy
msgid "Shutdown Flower Infrastructure"
msgstr "Flower 서버."

#: ../../source/how-to-run-flower-on-gcp.rst:686
msgid ""
"If you would like to shutdown all the running pods deployed during this "
"guide, you can use the ``kubectl delete`` command and pass the the "
"``.yaml`` file of each pod, as also shown in the helper script below."
msgstr ""

#: ../../source/how-to-run-flower-on-gcp.rst
msgid "k8s-shutdown.sh"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:-1
msgid ""
"Deploy Flower across OpenShift Clusters using Red Hat Service "
"Interconnect for secure, scalable federated AI across environments."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:7
#, fuzzy
msgid "Run Flower on Multiple OpenShift Clusters"
msgstr "Flower 서버."

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:9
msgid ""
"In this guide, you will learn how to deploy Flower in multiple `Red Hat "
"OpenShift (RHOS) <https://www.redhat.com/en/technologies/cloud-"
"computing/openshift>`_ application platforms. This deployment pattern is "
"useful when connecting multiple OpenShift clusters deployed in "
"environments that run critical workloads, such as in secure research "
"environments (also known as trusted research environments, or `secure "
"data environments <https://digital.nhs.uk/services/secure-data-"
"environment-service>`_), datacenters, high-performance computing "
"clusters, or on-premises servers."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:19
msgid ""
"This guide assumes you have a working knowledge of OpenShift and have "
"deployed Flower in a single OpenShift cluster before. If you are new to "
"OpenShift or Flower, please refer to our guide on `how to run Flower on "
"OpenShift <how-to-run-flower-on-red-hat-openshift.rst>`_ before "
"proceeding with this multi-cluster deployment."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:25
msgid ""
"To connect multiple OpenShift clusters, we will use `Red Hat Service "
"Interconnect <https://www.redhat.com/en/technologies/cloud-computing"
"/service-interconnect>`_. Based on the open source `Skupper "
"<https://skupper.io/>`_ project, the Service Interconnect simplifies "
"connections between sites. Applications and services, such as SuperLink "
"and SuperNodes, can communicate with each other using the interconnect as"
" if they were in the same network."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:32
msgid ""
"Skupper works by creating a site in each cluster, with a router (or "
"routers) that connect to other sites over the application network. The "
"application network is the network that connects multiple K8s clusters. "
"So, the cluster where SuperLink is deployed requires a Skupper site to "
"accept links and route incoming traffic and the cluster where SuperNode "
"is deployed must have a Skupper site to join the application network and "
"route outgoing requests via the interconnect."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:41
#, fuzzy
msgid "Pre-requisites"
msgstr "전제 조건"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:43
msgid ""
"Install the Skupper CLI on your local system by following the "
"instructions `on the Skupper website "
"<https://skupper.io/docs/install/index.html#installing-the-skupper-"
"cli>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:46
msgid ""
"Install Kubectl tools on your local system by following the instructions "
"`on the Kubernetes website <https://kubernetes.io/docs/tasks/tools/>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:51
msgid "Create OpenShift Clusters"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:53
msgid ""
"For this guide, we will create two OpenShift clusters using the ``Red Hat"
" OpenShift Service on AWS (ROSA)``. Follow the steps in our companion "
"guide `here <how-to-run-flower-on-red-hat-openshift.rst#create-a-red-hat-"
"openshift-cluster-on-aws>`_ on deploying the clusters. In this guide, we "
"will assume that your clusters are deployed in different AWS regions or "
"availability zones."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:59
msgid ""
"Next, deploy SuperLink in the first cluster. For reference, you can "
"follow the `deployment steps <how-to-run-flower-on-red-hat-openshift.rst"
"#deploy-flower-superlink-and-supernodes-on-openshift>`_ in our companion "
"guide."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:66
msgid "Install Service Interconnect Operator"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:68
msgid ""
"In each OpenShift cluster, install the Red Hat Service Interconnect "
"Operator from the OperatorHub:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:71
msgid "Red Hat Service Interconnect Operator"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:76
msgid "Search for Red Hat Service Interconnect Operator on OperatorHub."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:82
msgid "Install Red Hat Service Interconnect Operator"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:87
msgid "Install Red Hat Service Interconnect Operator from OperatorHub."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:91
#, fuzzy
msgid "Create Skupper Sites"
msgstr "새 페이지 만들기"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:93
msgid ""
"From your local system, you will now create a Skupper site in each "
"OpenShift cluster and connect the sites to form an application network."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:96
msgid ""
"First, set the namespace in your CLI by logging in to your first "
"OpenShift cluster (the one with SuperLink deployed):"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:103
msgid "If successful, you should see a message similar to this:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:115
msgid ""
"Now, switch the project to the project name (i.e. namespace) where you "
"deployed SuperLink:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:122
msgid ""
"In our `previous guide <how-to-run-flower-on-red-hat-openshift>`_, we "
"used the project name ``flower-openshift-demo``, so let's do that:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:132
msgid ""
"If you are unsure of the project name, you can list all projects you have"
" access to using the command ``oc projects``. You can also check that you"
" are in the correct context by running ``oc whoami --show-context``."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:136
msgid "With the correct namespace set, create a Skupper site in this cluster:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:142
msgid ""
"This command creates a Skupper site named ``superlink-interconnect`` and "
"the ``--enable-link-access`` option enables external access for links "
"*from* remote sites; this option is necessary for the site where "
"SuperLink is deployed so that SuperNodes in other clusters can connect to"
" it. You should see output similar to this:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:153
msgid ""
"Finally, repeat the steps above to create a Skupper site in the second "
"OpenShift cluster (where SuperNode will be deployed). Log in to the "
"second cluster, switch to the correct namespace, and create the Skupper "
"site:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:163
msgid ""
"Note that the namespace can be different from the first cluster and "
"depends on the *project name* you created in the second cluster. Note "
"also that we do not use the ``--enable-link-access`` option in the "
"Skupper command because this site only needs to connect *to* the "
"SuperLink site."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:170
msgid "Link Skupper Sites"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:172
msgid ""
"Now that we have created Skupper sites in both clusters, we will link the"
" sites to form an application network."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:175
msgid ""
"From your local system and in the namespace of the SuperLink cluster, "
"generate a ``Link`` resource as follows:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:185
msgid ""
"For more information about the concepts of sites and links, please refer "
"to the `Skupper Link concepts "
"<https://skupperproject.github.io/refdog/concepts/link.html>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:189
msgid ""
"This command generates a ``Link`` resource and saves it to the file "
"``superlink-interconnect-link.yaml``. The ``--namespace`` option "
"specifies the namespace of the SuperLink cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:193
msgid ""
"With the ``Link`` resource generated, switch to the namespace of the "
"SuperNode cluster, and apply the resource in it:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:200
msgid "You should see output similar to this:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:208
#, fuzzy
msgid "To verify the status of the link, run the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:214
msgid ""
"You might need to issue the command multiple times before the link is "
"ready:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:228
#, fuzzy
msgid "Create a Connector"
msgstr "SSL 연결 사용"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:230
msgid ""
"A connector binds a local connection endpoint to connectors in remote "
"sites, which in this case is the SuperNode cluster. This allows SuperLink"
" to communicate with SuperNode. Listeners and connectors are matched "
"using routing keys. In the first cluster (where SuperLink is deployed), "
"create a connector using the following command:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:239
msgid ""
"Here, ``<name>`` is a name for the connector, ``<port>`` is the port "
"number that the connector will listen on, and ``--workload <workload-"
"name>`` is an optional argument that specifies the name of a workload "
"(i.e. deployment) to associate with the connector. The ``<name>`` is the "
"default routing key if the ``--routing-key`` option is not specified."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:245
msgid ""
"In our deployment, SuperLink listens on port ``9092`` corresponding to "
"the Fleet API (for more details, read our reference on `Flower network "
"communication <ref-flower-network-communication.rst#flower-components-"
"apis>`_). Since we have given the SuperLink deployment the name "
"``superlink``, we will use that as the workload name:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:258
#, fuzzy
msgid "Create a Listener"
msgstr "새 페이지 만들기"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:260
msgid ""
"A listener binds a local connection endpoint to connectors in remote "
"sites, which in this case is the SuperLink cluster. This allows SuperNode"
" to communicate with SuperLink. On the second cluster (where SuperNode "
"will be deployed), create a listener using the following command:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:269
msgid ""
"The ``<name>`` is the name of the listener resource, and will be the "
"default routing key and host if the ``--routing-key`` and ``--host`` "
"options are not specified. In our case, the ``<name>`` must match the "
"name of the connector we created in the SuperLink cluster, which is "
"``fleet-api``. The ``<port>`` is the port number that the listener will "
"listen on, which must also match the port number of the connector "
"(``9092``):"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:283
msgid "Deploy SuperNode in a Separate OpenShift Cluster"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:285
msgid ""
"With the listener created, we can now deploy SuperNode in the second "
"OpenShift cluster using the listener service created by Skupper. The "
"listener service is a Kubernetes service that Skupper automatically "
"creates when you create a listener. You can find the DNS of the listener "
"service by navigating to the OpenShift console > Networking > Services, "
"and look for the service named ``fleet-api``. The ``Hostname`` is listed "
"under the ``Service details`` section."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:292
msgid "Copy and paste the following YAML definition for the SuperNode pod."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:351
msgid ""
"Now, when you check the logs of the SuperLink pod in the first OpenShift "
"cluster, you should see that the SuperNode has successfully connected to "
"it from the remote cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:354
msgid ""
"Congratulations! You have successfully deployed and run SuperLink and "
"SuperNode in different OpenShift clusters. You can further extend your "
"federation by deploying additional SuperNodes in other clusters by "
"repeating the steps above."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:358
msgid ""
"This deployment pattern allows you to scale your Flower deployment across"
" multiple clusters where secure deployment platforms like OpenShift are "
"required, making it suitable for critical workloads in research "
"environments, datacenters, and on-premises servers."
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:367
msgid ""
"To learn more about Red Hat Service Interconnect and Skupper concepts, "
"please refer to the following resources:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:370
msgid ""
"`Red Hat Service Interconnect webpage "
"<https://www.redhat.com/en/technologies/cloud-computing/service-"
"interconnect>`_"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:372
msgid "`Skupper concepts <https://skupperproject.github.io/refdog/concepts/>`_"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:374
msgid ""
"For further reading about deploying Flower with Red Hat, Docker, and "
"Kubernetes, check out our guides below:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:377
msgid ""
":doc:`How to run Flower on Red Hat OpenShift <how-to-run-flower-on-red-"
"hat-openshift>`"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:378
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:695
#, fuzzy
msgid ":doc:`How to run Flower with Docker <docker/index>`"
msgstr ":doc:`Docker를 사용하여 Flower를 실행하는 방법 <how-to-run-flower-using-docker>`"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:379
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:696
#, fuzzy
msgid ":doc:`How to run Flower with Helm <helm/index>`"
msgstr ":doc:`Docker를 사용하여 Flower를 실행하는 방법 <how-to-run-flower-using-docker>`"

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:381
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:698
msgid ""
"To learn about running Flower on other cloud platforms, check out our "
"guides below:"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:383
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:700
msgid ":doc:`How to run Flower on Microsoft Azure <how-to-run-flower-on-azure>`"
msgstr ""

#: ../../source/how-to-run-flower-on-multiple-openshift-clusters.rst:384
#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:701
msgid ""
":doc:`How to run Flower on Google Cloud Platform <how-to-run-flower-on-"
"gcp>`"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:-1
msgid ""
"A step-by-step guide to learn how to create, deploy and run a Flower app "
"on Red Hat OpenShift using the Red Hat OpenShift Service on AWS."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:7
#, fuzzy
msgid "Run Flower on Red Hat OpenShift"
msgstr "Flower 서버."

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:9
msgid ""
"In this guide, you will learn how to create, deploy, and run a Flower app"
" on the `Red Hat OpenShift (RHOS) <https://www.redhat.com/en/technologies"
"/cloud-computing/openshift>`_ application platform. The platform will be "
"hosted in AWS and we will follow the steps to install the cluster on "
"installer-provisioned infrastructure using the `Red Hat OpenShift Service"
" on AWS <https://aws.amazon.com/rosa/>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:18
msgid "Login to Red Hat OpenShift Console"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:20
msgid ""
"Start by logging in to your `Red Hat Hybrid Cloud Console "
"<https://console.redhat.com/>`_ and click on ``OpenShift`` link in the "
"``Red Hat OpenShift`` card."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:24
msgid "Red Hat OpenShift link in Red Hat Hybrid Cloud Console"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:29
msgid "Red Hat OpenShift link in the cloud console."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:31
msgid ""
"This will take you to the OpenShift console. Under ``Overview``, look for"
" the ``Red Hat OpenShift Service on AWS (ROSA)`` card and click on "
"``Create Cluster``. You will be taken to the page to setup a Red Hat "
"OpenShift service on AWS. There are two pre-requisites that you have to "
"fulfill before you can create a cluster:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:36
msgid "AWS Pre-requisites - Sets up your AWS account for deploying ROSA."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:37
msgid ""
"ROSA Pre-requisites - Installs the ROSA CLI tool on your system and login"
" to your Red Hat account."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:41
#, fuzzy
msgid "Complete AWS Pre-requisites"
msgstr "전제 조건"

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:43
msgid ""
"Follow the steps required to fulfill the pre-requisites for AWS to create"
" and manage a Red Hat OpenShift cluster:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:46
msgid "Enable RHOS service on AWS (ROSA) in your AWS account."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:47
msgid "Ensure that you have sufficient service quotas for ROSA."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:48
msgid ""
"Create a service-linked role for Elastic Load Balancing. This should be "
"automatically created for you if not present."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:50
msgid "Link your AWS and Red Hat account."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:51
msgid ""
"Create AWS Identity and Access Management (IAM) roles. You will need to "
"create an IAM user with these required permissions:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:54
msgid "``AmazonEC2FullAccess``"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:55
msgid "``AWSCloudFormationFullAccess``"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:56
msgid "``IAMFullAccess``"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:57
msgid "``ServiceQuotasReadOnlyAccess``"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:59
msgid ""
"For more details, refer to the RHOS getting started guide from your AWS "
"console."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:62
#, fuzzy
msgid "Complete ROSA Pre-requisites"
msgstr "전제 조건"

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:64
msgid ""
"Follow the steps shown in the section to download and install the ROSA "
"CLI tool."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:66
msgid ""
"Next, install the |aws_cli_link|_ CLI tool for your system. You can "
"alternatively run it with Docker using the command:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:73
msgid ""
"The ``--volume ~/.aws:/root/.aws`` option mounts your AWS credentials to "
"the Docker container. Next, run the following to configure the AWS CLI "
"tool and provide your AWS credentials for the IAM user you created "
"earlier:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:85
msgid ""
"Download and install the ROSA CLI tool by following the instructions for "
"your operating system. Once you have installed the ROSA CLI tool, login "
"with your Red Hat account:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:96
msgid ""
"If you are already logged into your Red Hat account on your browser, you "
"will be redirected back to your terminal."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:99
msgid "Then, create the necessary account-wide roles and policies:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:105
msgid "Finally, create a Virtual Private Network (VPC) for your cluster:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:113
msgid ""
"With the AWS and ROSA pre-requisites completed, you are now ready to "
"deploy a cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:117
msgid "Create a Red Hat OpenShift Cluster on AWS"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:119
msgid ""
"There are three ways to create the cluster: via ``rosa`` CLI, web "
"interface, or with Terraform. For this guide, we will use the web "
"interface. Click on the ``Create with web interface`` button in the "
"``Deploy with web interface`` card:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:123
msgid "Deploy Red Hat OpenShift cluster with web interface"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:128
msgid "Deploy Red Hat OpenShift cluster with web interface."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:130
msgid ""
"You will be taken to a series of steps to create a ROSA cluster. In the "
"following, some key steps are highlighted and we recommend that you "
"follow the official guide in the Red Hat Cloud Console for more details."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:134
msgid ""
"**Define Control Plane** - Select the ROSA hosted architecture and click "
"on ``Next``."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:135
msgid ""
"**Accounts and Roles** - Ensure the infrastructure and billing account "
"details are correct and click ``Next``."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:137
msgid "**Cluster settings**"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:139
msgid ""
"**Details** - Specify ``flower-demo-cluster`` as the ``Cluster name``. "
"For this guide, select version ``4.18.22`` (you may select a newer "
"version that suits your requirements). Select the AWS region appropriate "
"for your AWS account."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:142
msgid ""
"**Machine Pool** - Select an EC2 compute node instance type that is "
"available in your region. In this guide, we use the ``eu-north-1`` "
"region, and therefore selected ``m6i.2xlarge - 8 vCPU 32 GiB RAM``. "
"Enable autoscaling and set the minimum node count to 2 and maximum to 4. "
"This allows the cluster to scale up when you deploy the OpenShift "
"platform and OpenShift AI in the same cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:148
msgid "**Networking**"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:150
msgid ""
"**Configuration** - Under \"Cluster privacy\", select ``public`` and "
"leave other values as defaults."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:152
msgid "**CIDR ranges** - Leave the default CIDR ranges as is."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:154
msgid ""
"**Cluster roles and policies** - Follow the steps to create a new OIDC "
"config ID."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:155
msgid ""
"**Cluster updates** - Leave the default settings as is to \"Recurring "
"updates\"."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:156
msgid "Finally, review the cluster details and click ``Create cluster``."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:158
msgid ""
"This will start the cluster creation process and may take several minutes"
" to complete. You will be able to monitor the installation status of the "
"control plane and machine pools in the \"Overview\" tab."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:162
msgid ""
"Once your cluster is created, you will be prompted to create an identity "
"provider to access the cluster. Click on the ``Create identity provider``"
" link and follow the steps for your preferred OIDC provider. Grant the "
"user in your OIDC provider the ``cluster-admin`` rights so that you can "
"add apps from the OperatorHub later. To do so, go to ``Access control``, "
"``Cluster Roles and Access`` tab, and click on ``Add user``. Enter the "
"user ID from your OIDC provider and save the changes."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:169
msgid ""
"Your cluster is now ready. To view the cluster details, click on the "
"``Cluster List`` link in the left sidebar. Click on your cluster name "
"(``flower-demo-cluster``) to view the cluster details:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:173
msgid "Red Hat OpenShift cluster details"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:178
msgid "Red Hat OpenShift cluster details."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:180
msgid ""
"To access the OpenShift web console, click on the ``Open console`` link "
"in the top right. You will be redirected to your OIDC provider to login. "
"Once logged in, you will be taken to the OpenShift web console:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:184
msgid "Red Hat OpenShift web console"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:189
msgid "Red Hat OpenShift web console."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:191
msgid ""
"Congratulations! You now have a running Red Hat OpenShift cluster on AWS."
" Now, let's walk through how to deploy Flower on your OpenShift cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:196
msgid "Deploy Flower SuperLink and SuperNodes on OpenShift"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:198
msgid ""
"With the OpenShift cluster active, we can now deploy SuperLink and "
"SuperNode pods and run a federated workload. In this guide, we will "
"deploy four pods: 1x SuperLink, 2x SuperNodes, and 1x service pod to "
"route the traffic to the designated ports in the SuperLink."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:203
msgid ""
"First, we need to create an OpenShift project which is equivalent of a "
"Kubernetes namespace. We will then deploy the SuperLink and SuperNode "
"pods in this project. Navigate to ``Home`` > ``Projects`` and click on "
"the ``Create Project`` button on the right. Set ``flower-openshift-demo``"
" as the project name."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:208
msgid ""
"Next, we will add pods. Navigate to ``Workloads`` > ``Pods`` and click on"
" the ``Create Pod`` button on the right. There are several ways to create"
" a pod, such as using YAML or JSON definitions. For this guide, we will "
"use the YAML definition. Copy and paste the following YAML definition for"
" the SuperLink pod. This manifest is adapted from our tutorial on "
":doc:`how to deploy Flower in GCP <how-to-run-flower-on-gcp>`."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:270
msgid ""
"After the SuperLink pod is created, add the service pod following the "
"steps to create a pod and insert the following YAML definition:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst
#, fuzzy
msgid "superlink-service.yaml"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:297
msgid "Finally, spin up two SuperNode pods with the following YAML definitions:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:413
msgid ""
"To view the status of pods that were just deployed, click on the "
"``Workloads`` link in the left panel. You should be able to see three "
"Flower pods in the \"Running\" status as shown in the screenshot below:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:417
msgid "Flower SuperLink and SuperNode pods in Red Hat OpenShift"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:422
msgid "Flower SuperLink and SuperNode pods in Red Hat OpenShift."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:424
msgid ""
"Click on the SuperLink pod to view the pod details and click on the "
"``Logs`` tab. You should be able to view the SuperLink logs showing two "
"connected SuperNodes."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:429
msgid ""
"To shut down the pods, navigate to ``Workloads`` > ``Deployments``, "
"select the deployed pods, and click on ``Edit Pod Count`` to set the "
"replica count to 0. Now, you can delete the pods by selecting them and "
"clicking on the ``Delete Deployment`` button."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:436
msgid "Deploy Red Hat OpenShift AI"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:438
msgid ""
"To interface with the deployed SuperLink and SuperNode in the OpenShift "
"cluster, we want to make use of OpenShift AI workbench. So, we need to "
"enable this Operator in the OpenShift cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:442
msgid ""
"First, ensure that the Red Hat OpenShift AI is enabled via the Red Hat "
"OpenShift console. You may enable a free trial if you do not have a "
"subscription. Navigate to ``Operators`` > ``OperatorHub`` and search for "
"``Red Hat OpenShift AI``. Click on the ``Red Hat OpenShift AI`` card and "
"then click on the ``Install`` button. Alternatively, install the "
"OpenShift AI Operator via the OpenShift CLI tool following the official "
"instructions `here <https://docs.redhat.com/en/documentation"
"/red_hat_openshift_ai_self-managed/2.23/html"
"/installing_and_uninstalling_openshift_ai_self-managed/installing-and-"
"deploying-openshift-ai_install#installing-openshift-ai-operator-using-"
"cli_operator-install>`_. Once the installation is complete, you should "
"see a green check mark under the ``Status`` column for the ``Red Hat "
"OpenShift AI`` Operator in the ``Installed Operators`` tab:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:453
msgid "Red Hat OpenShift AI Operator in OpenShift"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:458
msgid "Red Hat OpenShift AI Operator in OpenShift."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:461
msgid "Install Data Science Cluster"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:463
msgid ""
"After installing the Operator, we need to install the "
"``DataScienceCluster`` using the web console. Follow the official steps "
"`in this link <https://docs.redhat.com/en/documentation"
"/red_hat_openshift_ai_self-managed/2.23/html"
"/installing_and_uninstalling_openshift_ai_self-managed/installing-and-"
"deploying-openshift-ai_install#installing-openshift-ai-components-using-"
"web-console_component-install>`_. It is also recommended to `disable "
"KServe dependencies <https://docs.redhat.com/en/documentation"
"/red_hat_openshift_ai_self-managed/2.23/html"
"/installing_and_uninstalling_openshift_ai_self-managed/installing-the-"
"single-model-serving-platform_component-install#disabling-kserve-"
"dependencies_component-install>`_ since we are not serving ML models for "
"inference. In the ``Installed Operators`` tab, click on ``Red Hat "
"OpenShift AI``, navigate to the ``Data Science Cluster`` tab, and click "
"on ``Create DataScienceCluster``. Select the YAML view of the "
"configuration and paste the following YAML definition:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst
msgid "rhosai-datasciencecluster.yaml"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:518
msgid ""
"Click on ``Create`` to create the Data Science Cluster. If successful, "
"you should see a ``default-dsc`` instance in the ``Data Science "
"Clusters`` tab with a green check mark:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:521
msgid "View of a successfully created Red Hat OpenShift AI Data Science Cluster"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:526
msgid "View of a successfully created Red Hat OpenShift AI Data Science Cluster."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:528
msgid ""
"Once the above is complete, you will be able to launch OpenShift AI by "
"clicking on the grid icon on the top right of the OpenShift console and "
"clicking on the ``Red Hat OpenShift AI`` link:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:532
msgid "Launch Red Hat OpenShift AI from OpenShift console"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:537
msgid "Launch Red Hat OpenShift AI from OpenShift console."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:539
msgid ""
"Follow the instructions when prompted to ``Log in with OpenShift``. After"
" logging in, you will be taken to the OpenShift AI dashboard."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:543
msgid "Create a Custom OpenShift AI Image with Flower"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:545
msgid ""
"In OpenShift AI, you will be building and running your Flower app in a "
"workbench, which is a Jupyter notebook environment. However, the default "
"OpenShift AI workbench image does not come with Flower installed. "
"Therefore, we will first create a custom OpenShift AI image with Flower "
"pre-installed. This custom image will then be used to create a workbench."
" The steps in this section are adapted from the official Red Hat "
"OpenShift AI guide for `creating a custom workbench image "
"<https://docs.redhat.com/en/documentation/red_hat_openshift_ai_self-"
"managed/2.16/html/managing_openshift_ai/creating-custom-workbench-"
"images#creating-a-custom-image-from-default-image_custom-images>`_."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:553
msgid ""
"**Pre-requisites**: Given that Red Hat OpenShift AI needs to be able to "
"pull from a container registry, you will need to create an account on "
"``quay.io`` if you do not have one already. Then, create a new "
"repository, e.g., ``flowerlabs/demo``, and make it public. You will also "
"need to install the `Docker CLI tool <https://docs.docker.com/get-"
"docker/>`_ on your system. Then, login to your ``quay.io`` account using "
"the command:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:564
msgid ""
"Now, we select a base image for our custom OpenShift AI image. In the Red"
" Hat OpenShift console, go to ``Builds`` > ``ImageStreams``. You can find"
" the default workbench images for the ``redhat-ods-applications`` "
"project. Select the ``s2i-minimal-notebook`` and choose the image tag "
"that you want to use and copy the ``sha256`` identifier. In this guide, "
"we will use the ``2025.1`` tag."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:570
#, fuzzy
msgid "Next, in your machine, create a Dockerfile with the following contents:"
msgstr "다음 변경 사항이 포함된 pull request를 만듭니다:"

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst
#, fuzzy
msgid "Dockerfile"
msgstr "SuperNode Dockerfile 만들기"

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:583
msgid ""
"Build and push the container image to your public repository on "
"``quay.io``:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:589
msgid ""
"Once the image is pushed, we will configure OpenShift AI to load this "
"custom workbench image. In the OpenShift AI dashboard, go to ``Settings``"
" > ``Workbench images`` and click on ``Import new image``. Set the "
"``Image location`` to your custom image (e.g., ``quay.io/flowerlabs/demo"
"/flwr-rhos:0.0.1@sha256[...]``) and give it a name (e.g., ``flwr-rhos-"
"image``). Take note of the resource name as you will need it in the next "
"section when creating your workbench. Then, click on ``Import`` to import"
" the image. If successful, you should see your custom image in the list "
"of workbench images:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:597
msgid "Custom OpenShift AI workbench image with Flower"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:602
msgid "Custom OpenShift AI workbench image with Flower."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:605
#, fuzzy
msgid "Create a Data Science Project"
msgstr "새 페이지 만들기"

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:607
msgid ""
"Now we are ready to create a Data Science project in OpenShift AI and "
"create a workbench using the custom image we just created from the "
"previous section."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:610
msgid ""
"On the left sidebar, click on ``Home``, navigate to the ``Data Science "
"Projects`` section, and click on the ``Create project`` button. Give your"
" project a name, e.g., ``flower-openshift-demo`` and - if you like, a "
"description. Then, click ``Create``. Click on your created project to "
"open it."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:615
msgid "Data Science project in Red Hat OpenShift AI"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:620
msgid "Data Science project in Red Hat OpenShift AI."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:622
msgid ""
"Navigate to the ``Workbenches`` tab and click on ``Create workbench`` to "
"create a new workbench. Under \"Name and description\", provide a name "
"for your workbench, e.g. ``flwr-rhos-demo-workbench``. Under ``Workbench "
"image`` > ``Image selection``, select the name of the image that you "
"provided earlier (i.e., ``flwr-rhos-image``). Choose a medium container "
"size and leave other settings as default. Finally, click on ``Create "
"Workbench``. The status of your workbench should switch to ``Running`` "
"after a few minutes:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:630
msgid "Running workbench in Red Hat OpenShift AI"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:635
msgid "Running workbench in Red Hat OpenShift AI."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:637
msgid "Now, click on your workbench and launch the JupyterLab environment."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:641
msgid "Run the Flower App in OpenShift AI"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:643
msgid ""
"With a running workbench and deployed SuperLink and SuperNode pods in "
"your OpenShift cluster, you are now ready to run a Flower app! In the "
"JupyterLab environment of your workbench, let's verify Flower is "
"installed correctly and working as expected: open a new terminal and run "
"``flwr --version`` to check the Flower version:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:648
msgid "Verify Flower installation in OpenShift AI workbench"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:653
msgid "Verify Flower installation in OpenShift AI workbench."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:655
msgid ""
"With Flower running correctly, you can now follow the usual steps of "
"using ``flwr new`` to create a new Flower app from a template, and ``flwr"
" run`` to run your Flower app on the deployed SuperLink and SuperNode "
"pods. Given that we deployed the OpenShift AI instance in the same "
"namespace (``flower-openshift-demo``) as the SuperLink in the OpenShift "
"cluster, the only change you need to make is to specify the SuperLink "
"service name as the address in your ``pyproject.toml``:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:670
msgid "And finally, run your Flower app as usual with ``flwr run``:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:672
msgid "Running Flower app in OpenShift AI workbench"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:677
msgid "Running Flower app in OpenShift AI workbench."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:679
msgid ""
"You can also view the logs of the SuperLink pod in the OpenShift console."
" Navigate to ``Workloads`` > ``Pods``, click on the SuperLink pod, and "
"then click on the ``Logs``:"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:682
msgid "SuperLink logs showing connected SuperNodes and running Flower app"
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:687
msgid "SuperLink logs showing connected SuperNodes and running Flower app."
msgstr ""

#: ../../source/how-to-run-flower-on-red-hat-openshift.rst:689
msgid ""
"Congratulations! You have successfully created, deployed, and run a "
"Flower app on Red Hat OpenShift using the Red Hat OpenShift Service on "
"AWS. You can explore running different Flower apps and federated "
"workloads on your OpenShift cluster, for instance, :doc:`with PyTorch "
"<tutorial-quickstart-pytorch>`. For further reading about deploying "
"Flower with Docker and Kubernetes, check out our guides below:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:-1
msgid ""
"Guide to use Flower's Deployment Engine and run a Flower App trough a "
"federation consisting of a SuperLink and two SuperNodes."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:7
msgid "Run Flower with the Deployment Engine"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:9
msgid ""
"This how-to guide demonstrates how to set up and run Flower with the "
"Deployment Engine using minimal configurations to illustrate the "
"workflow. This is a complementary guide to the :doc:`docker/index` "
"guides."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:15
#, fuzzy
msgid "Create a Flower App using the PyTorch template."
msgstr "gRPC transport layer를 사용하여 Flower 서버를 실행하세요."

#: ../../source/how-to-run-flower-with-deployment-engine.rst:16
msgid ""
"Start a Flower federation consisting of one SuperLink (\"the server\") "
"and two SuperNodes (\"the clients\")."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:18
msgid "Run the Flower App on this federation."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:20
msgid "The how-to guide should take less than 10 minutes to complete."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:28
msgid ""
"The latest ``flwr`` CLI version is installed on your machine. Follow the "
"installation instructions :doc:`here <../how-to-install-flower>`."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:30
msgid ""
"This guide assumes all commands to be executed in the same machine in "
"different terminals, each making use of the same Python environment."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:32
msgid ""
"This guide also assumes that you are familiar with the basic components "
"in a Flower deployment (i.e. SuperLink and SuperNode), what their roles "
"are and how they interact with each other. Please refer to the :doc"
":`explanation-flower-architecture` guide and the :doc:`ref-flower-"
"network-communication` for an overview of what each component does and "
"how they interact with each other."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:40
msgid ""
"In a real deployment you would typically run the SuperLink the SuperNodes"
" in different machines/servers from the one you develop your Flower app "
"(i.e. from where you do ``flwr new`` and ``flwr run``). The guide "
"presented below is still valid for such scenarios but you will need to "
"have setup a Python environment with the right set of dependencies for "
"SuperLink and SuperNodes. An often easier way to achieve such deployments"
" is by means of Docker. Check the :doc:`docker/index` to gain a better "
"understanding on how to do so."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:50
#, fuzzy
msgid "Step 1: Create a Flower App"
msgstr "새 페이지 만들기"

#: ../../source/how-to-run-flower-with-deployment-engine.rst:52
msgid ""
"Although you could write a Flower app from scratch, it is often easier to"
" start from one of the templates available via ``flwr new`` and then "
"customize it to your use case. Create a new Flower app (PyTorch), and "
"follow the instructions show upon executing ``flwr new``:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:76
msgid ""
"You might want to update the ``torch`` and ``torchvision`` packages that "
"come with the proejct to the latets released versions. Do so with: ``pip "
"install -U torch torchvision``."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:80
msgid ""
"If you decide to run the project with ``flwr run .``, the Simulation "
"Engine will be used. Continue to Step 2 to know how to instead use the "
"Deployment Engine."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:85
msgid ""
"Feel free to inspect the code using your favorite code editor before "
"proceeding. Just open the ``my-project`` that was automatically created "
"via ``flwr new``. If you would like to get an overview of the code that "
"was generated, take a look at the :doc:`tutorial-quickstart-pytorch` "
"tutorial."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:92
#, fuzzy
msgid "Step 2: Launch Flower Federation"
msgstr "Flower SuperNode를 실행합니다."

#: ../../source/how-to-run-flower-with-deployment-engine.rst:94
msgid ""
"In this section you will learn how to launch a SuperLink and connect two "
"SuperNodes to it."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:98
#, fuzzy
msgid "Start a Flower SuperLink"
msgstr "flower 초연결"

#: ../../source/how-to-run-flower-with-deployment-engine.rst:100
msgid ""
"In a new terminal, activate your environment and start the SuperLink "
"process in insecure mode:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:109
msgid "``flower-superlink``: Name of the SuperLink installed CLI executable."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:110
msgid ""
"``--insecure``: This flag tells the SuperLink to operate in an insecure "
"mode, allowing unencrypted communication. Refer to the :doc:`how-to-"
"enable-tls-connections` guide to learn how to run your SuperLink with "
"TLS."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:114
#, fuzzy
msgid "Start two Flower SuperNodes"
msgstr "서버(SuperLink)"

#: ../../source/how-to-run-flower-with-deployment-engine.rst:116
msgid ""
"In this step, you will launch two SuperNodes and connect them to the "
"SuperLink. You will need two terminals for this step."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:121
msgid ""
"Note that the values passed via the ``--node-config`` argument are "
"specific to the behaviour of the ``ClientApp``. If you inspect the code "
"generated in the first step via ``flwr new``, you'd see that the "
"``ClientApp`` is expecting a certain set of key-value pairs to be present"
" in order to partition and load some data. Typically, your ``ClientApp`` "
"wouldn't partition a dataset, instead it would access the data directly "
"available. In such cases you would write your ``ClientApp`` and make it "
"receive, for example, the path to a directory of images."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:129
msgid ""
"**Terminal 1** Start the first SuperNode after activating your "
"environment:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:141
msgid "``flower-supernode``: Name of the SuperNode installed CLI executable."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:142
msgid ""
"``--insecure``: This flag tells the SuperNode to operate in an insecure "
"mode, allowing unencrypted communication. Refer to the :doc:`how-to-"
"enable-tls-connections` guide to learn how to run your SuperNode with "
"TLS."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:144
msgid ""
"``--superlink 127.0.0.1:9092``: Connect to the SuperLink's Fleet API at "
"the address ``127.0.0.1:9092``. If you had launched the SuperLink in a "
"different machine, you'd replace ``127.0.0.1`` with the public IP of that"
" machine."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:146
msgid ""
"``--clientappio-api-address 127.0.0.1:9094``: Set the address and port "
"number where the SuperNode is listening to communicate with the "
"``ClientApp``."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:148
msgid ""
"``--node-config \"partition-id=0 num-partitions=2\"``: The ``ClientApp`` "
"code generated via the ``flwr new`` template expects those two key-value "
"pairs to be defined at run time. Set the partition ID to ``0`` and the "
"number of partitions to ``2`` for the SuperNode configuration."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:150
msgid ""
"**Terminal 2** Start the second SuperNode after activating your "
"environment:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:162
msgid ""
"``--clientappio-api-address 127.0.0.1:9095``: Note that a different port "
"is being used. This is only needed because you are running two SuperNodes"
" on the same machine. Typically you would run one node per machine and "
"therefore, the ``--clientappio-api-address`` could be omitted all "
"together and left with its default value."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:163
msgid ""
"``--node-config \"partition-id=1 num-partitions=2\"``: Note here we "
"indicate a different `partition-id`. In this way, a ``ClientApp`` will "
"use a different data partition depending on which SuperNode runs in."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:167
#, fuzzy
msgid "Step 3: Run a Flower App on the Federation"
msgstr "Flower SuperNode를 실행합니다."

#: ../../source/how-to-run-flower-with-deployment-engine.rst:169
msgid ""
"At this point, you have launched two SuperNodes that are connected to the"
" same SuperLink. The system is idling waiting for a ``Run`` to be "
"submitted. Before you can run your Flower App through the federation we "
"need a way to tell ``flwr run`` that the App is to be executed via the "
"SuperLink we just started, instead of using the local Simulation Engine "
"(the default). Doing this is easy: define a new federation section in the"
" ``pyproject.toml``, indicate the address of the SuperLink and pass a "
"certificate (if any) or set the insecure flag (only when testing locally,"
" real deployments require TLS)."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:177
msgid ""
"Open the ``pyproject.toml`` file and at the end add a new federation "
"configuration:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:195
msgid ""
"In another terminal and with your Python environment activated, run the "
"Flower App and follow the ``ServerApp`` logs to track the execution of "
"the run:"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:202
msgid ""
"If you want to rerun the project or test an updated version by making "
"changes to the code, simply re-run the command above."
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:207
msgid "Step 4: Clean Up"
msgstr ""

#: ../../source/how-to-run-flower-with-deployment-engine.rst:209
msgid ""
"Use the ``Ctrl+C`` command in each terminal to stop the respective "
"processes."
msgstr ""

#: ../../source/how-to-run-simulations.rst:-1
msgid ""
"Run federated learning simulations in Flower using the "
"VirtualClientEngine for scalable, resource-aware, and multi-node "
"simulations on any system configuration."
msgstr ""

#: ../../source/how-to-run-simulations.rst:27
msgid "Run simulations"
msgstr "시뮬레이션 실행"

#: ../../source/how-to-run-simulations.rst:29
#, fuzzy
msgid ""
"Simulating Federated Learning workloads is useful for a multitude of use "
"cases: you might want to run your workload on a large cohort of clients "
"without having to source, configure, and manage a large number of "
"physical devices; you might want to run your FL workloads as fast as "
"possible on the compute systems you have access to without going through "
"a complex setup process; you might want to validate your algorithm in "
"different scenarios at varying levels of data and system heterogeneity, "
"client availability, privacy budgets, etc. These are among some of the "
"use cases where simulating FL workloads makes sense."
msgstr ""
"Federated 학습 워크로드 시뮬레이션은 다양한 사용 사례에 유용합니다. 대규모 클라이언트 집단에서 워크로드를 실행하되 많은 "
"수의 물리적 장치를 소싱, 구성 및 관리할 필요가 없는 경우, 복잡한 설정 과정을 거치지 않고도 액세스 가능한 컴퓨팅 시스템에서 "
"최대한 빠르게 FL 워크로드를 실행하려는 경우, 다양한 수준의 데이터 및 시스템 이질성, 클라이언트 가용성, 개인정보 예산 등의 "
"다양한 시나리오에서 알고리즘을 검증하려는 경우 등 여러 가지 사용 사례에 유용합니다. 이러한 사례는 FL 워크로드 시뮬레이션이 "
"적합한 사용 사례 중 일부입니다. Flower는 `VirtualClientEngine <contributor-explanation-"
"architecture.html#virtual-client-engine>`_ 또는 VCE를 통해 이러한 시나리오를 수용할 수 "
"있습니다."

#: ../../source/how-to-run-simulations.rst:40
msgid ""
"Flower's ``Simulation Engine`` is built on top of `Ray "
"<https://www.ray.io/>`_, an open-source framework for scalable Python "
"workloads. Flower fully supports Linux and macOS. On Windows, Ray support"
" remains experimental, and while you can run simulations directly from "
"the `PowerShell <https://learn.microsoft.com/en-"
"us/powershell/scripting/overview?view=powershell-7.5>`_, we recommend "
"using `WSL2 <https://learn.microsoft.com/en-us/windows/wsl/about>`_."
msgstr ""

#: ../../source/how-to-run-simulations.rst:49
msgid ""
"The ``Flower AI Simulation 2025`` tutorial series is available on "
"YouTube. You can find all the videos `here "
"<https://www.youtube.com/playlist?list=PLNG4feLHqCWkdlSrEL2xbCtGa6QBxlUZb>`_"
" or by clicking on the video previews below. The associated code for the "
"tutorial can be found in the `Flower Github repository "
"<https://github.com/adap/flower/tree/main/examples/flower-simulation-"
"step-by-step-pytorch>`_"
msgstr ""

#: ../../source/how-to-run-simulations.rst:106
msgid ""
"Flower's ``Simulation Engine`` schedules, launches, and manages "
"|clientapp_link|_ instances. It does so through a ``Backend``, which "
"contains several workers (i.e., Python processes) that can execute a "
"``ClientApp`` by passing it a |context_link|_ and a |message_link|_. "
"These ``ClientApp`` objects are identical to those used by Flower's "
"`Deployment Engine <contributor-explanation-architecture.html>`_, making "
"alternating between *simulation* and *deployment* an effortless process. "
"The execution of ``ClientApp`` objects through Flower's ``Simulation "
"Engine`` is:"
msgstr ""

#: ../../source/how-to-run-simulations.rst:114
#, fuzzy
msgid ""
"**Resource-aware**: Each backend worker executing ``ClientApp``\\s gets "
"assigned a portion of the compute and memory on your system. You can "
"define these at the beginning of the simulation, allowing you to control "
"the degree of parallelism of your simulation. For a fixed total pool of "
"resources, the fewer the resources per backend worker, the more "
"``ClientApps`` can run concurrently on the same hardware."
msgstr ""
"resource-aware: 이는 각 클라이언트가 시스템에서 컴퓨팅 및 메모리의 일부를 할당받는다는 것을 의미합니다. 사용자는 "
"시뮬레이션을 시작할 때 이를 제어할 수 있으며, 이를 통해 Flower FL 시뮬레이션의 병렬 처리 정도를 제어할 수 있습니다. "
"클라이언트당 리소스가 적을수록 동일한 하드웨어에서 더 많은 클라이언트를 동시에 실행할 수 있습니다."

#: ../../source/how-to-run-simulations.rst:119
msgid ""
"**Batchable**: When there are more ``ClientApps`` to execute than backend"
" workers, ``ClientApps`` are queued and executed as soon as resources are"
" freed. This means that ``ClientApps`` are typically executed in batches "
"of N, where N is the number of backend workers."
msgstr ""

#: ../../source/how-to-run-simulations.rst:123
#, fuzzy
msgid ""
"**Self-managed**: This means that you, as a user, do not need to launch "
"``ClientApps`` manually; instead, the ``Simulation Engine``'s internals "
"orchestrates the execution of all ``ClientApp``\\s."
msgstr ""
"self-managed: 이는 사용자가 클라이언트를 수동으로 실행할 필요가 없으며, 대신 "
":code:`VirtualClientEngine`의 내부에 위임된다는 의미입니다."

#: ../../source/how-to-run-simulations.rst:126
#, fuzzy
msgid ""
"**Ephemeral**: This means that a ``ClientApp`` is only materialized when "
"it is required by the application (e.g., to do `fit() <ref-api-"
"flwr.html#flwr.client.Client.fit>`_). The object is destroyed afterward, "
"releasing the resources it was assigned and allowing other clients to "
"participate."
msgstr ""
"ephemeral: 이는 클라이언트가 FL 프로세스에서 필요할 때만 구체화됨을 의미합니다(예: `fit() <ref-api-"
"flwr.html#flwr.client.Client.fit>`_을 수행하기 위해). 객체는 나중에 소멸되어 할당된 리소스를 해제하고"
" 다른 클라이언트가 참여할 수 있도록 허용합니다."

#: ../../source/how-to-run-simulations.rst:133
msgid ""
"You can preserve the state (e.g., internal variables, parts of an ML "
"model, intermediate results) of a ``ClientApp`` by saving it to its "
"``Context``. Check the `Designing Stateful Clients <how-to-design-"
"stateful-clients.rst>`_ guide for a complete walkthrough."
msgstr ""

#: ../../source/how-to-run-simulations.rst:138
#, fuzzy
msgid ""
"The ``Simulation Engine`` delegates to a ``Backend`` the role of spawning"
" and managing ``ClientApps``. The default backend is the ``RayBackend``, "
"which uses `Ray <https://www.ray.io/>`_, an open-source framework for "
"scalable Python workloads. In particular, each worker is an `Actor "
"<https://docs.ray.io/en/latest/ray-core/actors.html>`_ capable of "
"spawning a ``ClientApp`` given its ``Context`` and a ``Message`` to "
"process."
msgstr ""
":code:`VirtualClientEngine`은 확장 가능한 파이썬 워크로드를 위한 오픈 소스 프레임워크인 `Ray "
"<https://www.ray.io/>`_를 사용하여 `virtual` 클라이언트를 구현합니다. 특히 Flower의 "
":code:`VirtualClientEngine`은 `Actors <https://docs.ray.io/en/latest/ray-"
"core/actors.html>`_를 사용하여 `virtual` 클라이언트를 생성하고 해당 워크로드를 실행합니다."

#: ../../source/how-to-run-simulations.rst:147
msgid "Launch your Flower simulation"
msgstr "Flower 시뮬레이션 시작"

#: ../../source/how-to-run-simulations.rst:149
msgid ""
"Running a simulation is straightforward; in fact, it is the default mode "
"of operation for |flwr_run_link|_. Therefore, running Flower simulations "
"primarily requires you to first define a ``ClientApp`` and a "
"``ServerApp``. A convenient way to generate a minimal but fully "
"functional Flower app is by means of the |flwr_new_link|_ command. There "
"are multiple templates to choose from. The example below uses the "
"``PyTorch`` template."
msgstr ""

#: ../../source/how-to-run-simulations.rst:157
msgid ""
"If you haven't already, install Flower via ``pip install -U flwr`` in a "
"Python environment."
msgstr ""

#: ../../source/how-to-run-simulations.rst:165
msgid ""
"Then, follow the instructions shown after completing the |flwr_new_link|_"
" command. When you execute |flwr_run_link|_, you'll be using the "
"``Simulation Engine``."
msgstr ""

#: ../../source/how-to-run-simulations.rst:168
msgid ""
"If we take a look at the ``pyproject.toml`` that was generated from the "
"|flwr_new_link|_ command (and loaded upon |flwr_run_link|_ execution), we"
" see that a *default* federation is defined. It sets the number of "
"supernodes to 10."
msgstr ""

#: ../../source/how-to-run-simulations.rst:180
msgid ""
"You can modify the size of your simulations by adjusting ``options.num-"
"supernodes``."
msgstr ""

#: ../../source/how-to-run-simulations.rst:183
msgid "Simulation examples"
msgstr "시뮬레이션 예제"

#: ../../source/how-to-run-simulations.rst:185
msgid ""
"In addition to the quickstart tutorials in the documentation (e.g., "
"`quickstart PyTorch Tutorial <tutorial-quickstart-pytorch.html>`_, "
"`quickstart JAX Tutorial <tutorial-quickstart-jax.html>`_), most examples"
" in the Flower repository are simulation-ready."
msgstr ""

#: ../../source/how-to-run-simulations.rst:190
#, fuzzy
msgid ""
"`Quickstart TensorFlow/Keras "
"<https://github.com/adap/flower/tree/main/examples/quickstart-"
"tensorflow>`_."
msgstr ""
"이것이 바로`Tensorflow/Keras Simulation "
"<https://github.com/adap/flower/tree/main/examples/simulation-"
"tensorflow>`_ 예제에서 사용된 메커니즘입니다."

#: ../../source/how-to-run-simulations.rst:192
#, fuzzy
msgid ""
"`Quickstart PyTorch <https://github.com/adap/flower/tree/main/examples"
"/quickstart-pytorch>`_"
msgstr ""
"파이토치 시뮬레이션 <https://github.com/adap/flower/tree/main/examples/simulation-"
"pytorch>`_: 100개의 클라이언트가 공동으로 MNIST에서 CNN 모델을 훈련합니다."

#: ../../source/how-to-run-simulations.rst:194
#, fuzzy
msgid ""
"`Advanced PyTorch <https://github.com/adap/flower/tree/main/examples"
"/advanced-pytorch>`_"
msgstr ""
"보안 연결을 보여주는 전체 코드 예제는 '여기 "
"<https://github.com/adap/flower/tree/main/examples/advanced-"
"tensorflow>`_'에서 확인할 수 있습니다."

#: ../../source/how-to-run-simulations.rst:196
msgid ""
"`Quickstart MLX <https://github.com/adap/flower/tree/main/examples"
"/quickstart-mlx>`_"
msgstr ""

#: ../../source/how-to-run-simulations.rst:197
msgid ""
"`ViT fine-tuning <https://github.com/adap/flower/tree/main/examples"
"/flowertune-vit>`_"
msgstr ""

#: ../../source/how-to-run-simulations.rst:199
#, fuzzy
msgid ""
"The complete list of examples can be found in `the Flower GitHub "
"<https://github.com/adap/flower/tree/main/examples>`_."
msgstr ""
"보안 연결을 보여주는 전체 코드 예제는 '여기 "
"<https://github.com/adap/flower/tree/main/examples/advanced-"
"tensorflow>`_'에서 확인할 수 있습니다."

#: ../../source/how-to-run-simulations.rst:206
#, fuzzy
msgid "Defining ``ClientApp`` resources"
msgstr "클라이언트 리소스 할당"

#: ../../source/how-to-run-simulations.rst:208
msgid ""
"By default, the ``Simulation Engine`` assigns two CPU cores to each "
"backend worker. This means that if your system has 10 CPU cores, five "
"backend workers can be running in parallel, each executing a different "
"``ClientApp`` instance."
msgstr ""

#: ../../source/how-to-run-simulations.rst:212
#, fuzzy
msgid ""
"More often than not, you would probably like to adjust the resources your"
" ``ClientApp`` gets assigned based on the complexity (i.e., compute and "
"memory footprint) of your workload. You can do so by adjusting the "
"backend resources for your federation."
msgstr ""
"대부분의 경우 FL 워크로드의 복잡성(즉, 컴퓨팅 및 메모리 사용량)에 따라 클라이언트에 할당되는 리소스를 조정하고 싶을 것입니다."
" 시뮬레이션을 시작할 때 `client_resources` argument를 `start_simulation <ref-api-"
"flwr.html#flwr.simulation.start_simulation>`_로 설정하여 이를 수행할 수 있습니다. Ray는 "
"내부적으로 두 개의 키를 사용하여 워크로드(이 경우 Flower 클라이언트)를 스케줄링하고 스폰합니다:"

#: ../../source/how-to-run-simulations.rst:218
#, python-format
msgid ""
"Note that the resources the backend assigns to each worker (and hence to "
"each ``ClientApp`` being executed) are assigned in a *soft* manner. This "
"means that the resources are primarily taken into account in order to "
"control the degree of parallelism at which ``ClientApp`` instances should"
" be executed. Resource assignment is **not strict**, meaning that if you "
"specified your ``ClientApp`` is assumed to make use of 25% of the "
"available VRAM but it ends up using 50%, it might cause other "
"``ClientApp`` instances to crash throwing an out-of-memory (OOM) error."
msgstr ""

#: ../../source/how-to-run-simulations.rst:226
msgid ""
"Customizing resources can be done directly in the ``pyproject.toml`` of "
"your app."
msgstr ""

#: ../../source/how-to-run-simulations.rst:235
msgid ""
"With the above backend settings, your simulation will run as many "
"``ClientApps`` in parallel as CPUs you have in your system. GPU resources"
" for your ``ClientApp`` can be assigned by specifying the **ratio** of "
"VRAM each should make use of."
msgstr ""

#: ../../source/how-to-run-simulations.rst:248
msgid ""
"If you are using TensorFlow, you need to `enable memory growth "
"<https://www.tensorflow.org/guide/gpu#limiting_gpu_memory_growth>`_ so "
"multiple ``ClientApp`` instances can share a GPU. This needs to be done "
"before launching the simulation. To do so, set the environment variable "
"``TF_FORCE_GPU_ALLOW_GROWTH=\"1\"``."
msgstr ""

#: ../../source/how-to-run-simulations.rst:254
msgid ""
"Let's see how the above configuration results in a different number of "
"``ClientApps`` running in parallel depending on the resources available "
"in your system. If your system has:"
msgstr ""

#: ../../source/how-to-run-simulations.rst:258
#, python-format
msgid ""
"10x CPUs and 1x GPU: at most 4 ``ClientApps`` will run in parallel since "
"each requires 25% of the available VRAM."
msgstr ""

#: ../../source/how-to-run-simulations.rst:260
msgid ""
"10x CPUs and 2x GPUs: at most 8 ``ClientApps`` will run in parallel "
"(VRAM-limited)."
msgstr ""

#: ../../source/how-to-run-simulations.rst:261
msgid ""
"6x CPUs and 4x GPUs: at most 6 ``ClientApps`` will run in parallel (CPU-"
"limited)."
msgstr ""

#: ../../source/how-to-run-simulations.rst:262
msgid ""
"10x CPUs but 0x GPUs: you won't be able to run the simulation since not "
"even the resources for a single ``ClientApp`` can be met."
msgstr ""

#: ../../source/how-to-run-simulations.rst:265
msgid ""
"A generalization of this is given by the following equation. It gives the"
" maximum number of ``ClientApps`` that can be executed in parallel on "
"available CPU cores (SYS_CPUS) and VRAM (SYS_GPUS)."
msgstr ""

#: ../../source/how-to-run-simulations.rst:269
msgid ""
"N = \\min\\left(\\left\\lfloor \\frac{\\text{SYS_CPUS}}{\\text{num_cpus}}"
" \\right\\rfloor, \\left\\lfloor "
"\\frac{\\text{SYS_GPUS}}{\\text{num_gpus}} \\right\\rfloor\\right)"
msgstr ""

#: ../../source/how-to-run-simulations.rst:273
msgid ""
"Both ``num_cpus`` (an integer higher than 1) and ``num_gpus`` (a non-"
"negative real number) should be set on a per ``ClientApp`` basis. If, for"
" example, you want only a single ``ClientApp`` to run on each GPU, then "
"set ``num_gpus=1.0``. If, for example, a ``ClientApp`` requires access to"
" two whole GPUs, you'd set ``num_gpus=2``."
msgstr ""

#: ../../source/how-to-run-simulations.rst:278
#, fuzzy
msgid ""
"While the ``options.backend.client-resources`` can be used to control the"
" degree of concurrency in your simulations, this does not stop you from "
"running hundreds or even thousands of clients in the same round and "
"having orders of magnitude more *dormant* (i.e., not participating in a "
"round) clients. Let's say you want to have 100 clients per round but your"
" system can only accommodate 8 clients concurrently. The ``Simulation "
"Engine`` will schedule 100 ``ClientApps`` to run and then will execute "
"them in a resource-aware manner in batches of 8."
msgstr ""
"code:`client_resources`를 사용하여 FL 시뮬레이션의 동시성 정도를 제어할 수 있지만, 동일한 라운드에서 수십, "
"수백 또는 수천 개의 클라이언트를 실행하고 훨씬 더 많은 '휴면'(즉, 라운드에 참여하지 않는) 클라이언트를 보유하는 것을 막을 "
"수는 없습니다. 라운드당 100명의 클라이언트를 받고 싶지만 시스템이 동시에 8명의 클라이언트만 수용할 수 있다고 가정해 봅시다. "
"code:`VirtualClientEngine`은 실행할 100개의 작업(각각 전략에서 샘플링한 클라이언트를 시뮬레이션)을 예약한 "
"다음 리소스 인식 방식으로 8개씩 일괄적으로 실행합니다."

#: ../../source/how-to-run-simulations.rst:288
#, fuzzy
msgid "Simulation Engine resources"
msgstr "VirtualClientEngine 리소스"

#: ../../source/how-to-run-simulations.rst:290
msgid ""
"By default, the ``Simulation Engine`` has **access to all system "
"resources** (i.e., all CPUs, all GPUs). However, in some settings, you "
"might want to limit how many of your system resources are used for "
"simulation. You can do this in the ``pyproject.toml`` of your app by "
"setting the ``options.backend.init_args`` variable."
msgstr ""

#: ../../source/how-to-run-simulations.rst:304
msgid ""
"With the above setup, the Backend will be initialized with a single CPU "
"and GPU. Therefore, even if more CPUs and GPUs are available in your "
"system, they will not be used for the simulation. The example above "
"results in a single ``ClientApp`` running at any given point."
msgstr ""

#: ../../source/how-to-run-simulations.rst:309
msgid ""
"For a complete list of settings you can configure, check the `ray.init "
"<https://docs.ray.io/en/latest/ray-core/api/doc/ray.init.html#ray-init>`_"
" documentation."
msgstr ""

#: ../../source/how-to-run-simulations.rst:312
msgid "For the highest performance, do not set ``options.backend.init_args``."
msgstr ""

#: ../../source/how-to-run-simulations.rst:316
#, fuzzy
msgid "Simulation in Colab/Jupyter"
msgstr "CLI 시뮬레이션"

#: ../../source/how-to-run-simulations.rst:318
msgid ""
"The preferred way of running simulations should always be "
"|flwr_run_link|_. However, the core functionality of the ``Simulation "
"Engine`` can be used from within a Google Colab or Jupyter environment by"
" means of `run_simulation <ref-api-"
"flwr.html#flwr.simulation.run_simulation>`_."
msgstr ""

#: ../../source/how-to-run-simulations.rst:339
msgid ""
"With ``run_simulation``, you can also control the amount of resources for"
" your ``ClientApp`` instances. Do so by setting ``backend_config``. If "
"unset, the default resources are assigned (i.e., 2xCPUs per ``ClientApp``"
" and no GPU)."
msgstr ""

#: ../../source/how-to-run-simulations.rst:350
msgid ""
"Refer to the `30 minutes Federated AI Tutorial "
"<https://colab.research.google.com/github/adap/flower/blob/main/examples"
"/flower-in-30-minutes/tutorial.ipynb>`_ for a complete example on how to "
"run Flower Simulations in Colab."
msgstr ""

#: ../../source/how-to-run-simulations.rst:358
msgid "Multi-node Flower simulations"
msgstr "멀티 노드 Flower 시뮬레이션"

#: ../../source/how-to-run-simulations.rst:360
#, fuzzy
msgid ""
"Flower's ``Simulation Engine`` allows you to run FL simulations across "
"multiple compute nodes so that you're not restricted to running "
"simulations on a _single_ machine. Before starting your multi-node "
"simulation, ensure that you:"
msgstr ""
"Flower의 :code:`VirtualClientEngine`을 사용하면 여러 컴퓨팅 노드에서 FL 시뮬레이션을 실행할 수 "
"있습니다. 멀티 노드 시뮬레이션을 시작하기 전에 다음 사항을 확인하세요:"

#: ../../source/how-to-run-simulations.rst:364
#, fuzzy
msgid "Have the same Python environment on all nodes."
msgstr "모든 노드에서 동일한 Python 환경을 유지합니다."

#: ../../source/how-to-run-simulations.rst:365
#, fuzzy
msgid "Have a copy of your code on all nodes."
msgstr "모든 노드에 코드 사본(예: 전체 레포지토리)을 보관하세요."

#: ../../source/how-to-run-simulations.rst:366
msgid ""
"Have a copy of your dataset on all nodes. If you are using partitions "
"from `Flower Datasets <https://flower.ai/docs/datasets>`_, ensure the "
"partitioning strategy its parameterization are the same. The expectation "
"is that the i-th dataset partition is identical in all nodes."
msgstr ""

#: ../../source/how-to-run-simulations.rst:370
#, fuzzy
msgid ""
"Start Ray on your head node: on the terminal, type ``ray start --head``. "
"This command will print a few lines, one of which indicates how to attach"
" other nodes to the head node."
msgstr ""
"헤드 노드에서 Ray 시작: 터미널에서 :code:`ray start --head`를 입력합니다. 이 명령은 몇 줄을 출력하며, 그"
" 중 하나는 다른 노드를 헤드 노드에 연결하는 방법을 나타냅니다."

#: ../../source/how-to-run-simulations.rst:373
#, fuzzy
msgid ""
"Attach other nodes to the head node: copy the command shown after "
"starting the head and execute it on the terminal of a new node (before "
"executing |flwr_run_link|_). For example: ``ray start "
"--address='192.168.1.132:6379'``. Note that to be able to attach nodes to"
" the head node they should be discoverable by each other."
msgstr ""
"헤드 노드에 다른 노드 연결: 헤드를 시작한 후 표시된 명령어을 복사하여 새 노드의 터미널에서 실행합니다: 예: :code:`ray"
" start --address='192.168.1.132:6379'`"

#: ../../source/how-to-run-simulations.rst:378
#, fuzzy
msgid ""
"With all the above done, you can run your code from the head node as you "
"would if the simulation were running on a single node. In other words:"
msgstr "위의 모든 작업이 완료되면 단일 노드에서 시뮬레이션을 실행할 때와 마찬가지로 헤드 노드에서 코드를 실행할 수 있습니다."

#: ../../source/how-to-run-simulations.rst:386
#, fuzzy
msgid ""
"Once your simulation is finished, if you'd like to dismantle your "
"cluster, you simply need to run the command ``ray stop`` in each node's "
"terminal (including the head node)."
msgstr ""
"시뮬레이션이 완료되면 클러스터를 해체하려면 각 노드(헤드 노드 포함)의 터미널에서 :code:`ray stop` 명령을 실행하기만 "
"하면 됩니다."

#: ../../source/how-to-run-simulations.rst:391
#, fuzzy
msgid ""
"When attaching a new node to the head, all its resources (i.e., all CPUs,"
" all GPUs) will be visible by the head node. This means that the "
"``Simulation Engine`` can schedule as many ``ClientApp`` instances as "
"that node can possibly run. In some settings, you might want to exclude "
"certain resources from the simulation. You can do this by appending "
"``--num-cpus=<NUM_CPUS_FROM_NODE>`` and/or ``--num-"
"gpus=<NUM_GPUS_FROM_NODE>`` in any ``ray start`` command (including when "
"starting the head)."
msgstr ""
"새 노드를 헤드에 연결하면 해당 노드의 모든 리소스(즉, 모든 CPU, 모든 GPU)가 헤드 노드에 표시됩니다. 즉, "
":code:`VirtualClientEngine`은 해당 노드가 실행할 수 있는 만큼의 `가상` 클라이언트를 예약할 수 있습니다. "
"일부 설정에서는 시뮬레이션에서 특정 리소스를 제외하고 싶을 수 있습니다. 모든 :code:`ray start` 명령(헤드 시작 시 "
"포함)에 `--num-cpus=<NUM_CPUS_FROM_NODE>` 및/또는 `--num-"
"gpus=<NUM_GPUS_FROM_NODE>`를 추가하여 이 작업을 수행하면 됩니다"

#: ../../source/how-to-run-simulations.rst:401
#, fuzzy
msgid "FAQ for Simulations"
msgstr "시뮬레이션 실행"

#: ../../source/how-to-run-simulations.rst
msgid "Can I make my ``ClientApp`` instances stateful?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:405
msgid ""
"Yes. Use the ``state`` attribute of the |context_link|_ object that is "
"passed to the ``ClientApp`` to save variables, parameters, or results to "
"it. Read the `Designing Stateful Clients <how-to-design-stateful-"
"clients.rst>`_ guide for a complete walkthrough."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid "Can I run multiple simulations on the same machine?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:409
msgid ""
"Yes, but bear in mind that each simulation isn't aware of the resource "
"usage of the other. If your simulations make use of GPUs, consider "
"setting the ``CUDA_VISIBLE_DEVICES`` environment variable to make each "
"simulation use a different set of the available GPUs. Export such an "
"environment variable before starting |flwr_run_link|_."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid ""
"Do the CPU/GPU resources set for each ``ClientApp`` restrict how much "
"compute/memory these make use of?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:413
msgid ""
"No. These resources are exclusively used by the simulation backend to "
"control how many workers can be created on startup. Let's say N backend "
"workers are launched, then at most N ``ClientApp`` instances will be "
"running in parallel. It is your responsibility to ensure ``ClientApp`` "
"instances have enough resources to execute their workload (e.g., fine-"
"tune a transformer model)."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid "My ``ClientApp`` is triggering OOM on my GPU. What should I do?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:417
msgid ""
"It is likely that your `num_gpus` setting, which controls the number of "
"``ClientApp`` instances that can share a GPU, is too low (meaning too "
"many ``ClientApps`` share the same GPU). Try the following:"
msgstr ""

#: ../../source/how-to-run-simulations.rst:419
msgid ""
"Set your ``num_gpus=1``. This will make a single ``ClientApp`` run on a "
"GPU."
msgstr ""

#: ../../source/how-to-run-simulations.rst:420
msgid "Inspect how much VRAM is being used (use ``nvidia-smi`` for this)."
msgstr ""

#: ../../source/how-to-run-simulations.rst:421
msgid ""
"Based on the VRAM you see your single ``ClientApp`` using, calculate how "
"many more would fit within the remaining VRAM. One divided by the total "
"number of ``ClientApps`` is the ``num_gpus`` value you should set."
msgstr ""

#: ../../source/how-to-run-simulations.rst:423
msgid "Refer to :ref:`clientappresources` for more details."
msgstr ""

#: ../../source/how-to-run-simulations.rst:425
msgid ""
"If your ``ClientApp`` is using TensorFlow, make sure you are exporting "
"``TF_FORCE_GPU_ALLOW_GROWTH=\"1\"`` before starting your simulation. For "
"more details, check."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid ""
"How do I know what's the right ``num_cpus`` and ``num_gpus`` for my "
"``ClientApp``?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:429
msgid ""
"A good practice is to start by running the simulation for a few rounds "
"with higher ``num_cpus`` and ``num_gpus`` than what is really needed "
"(e.g., ``num_cpus=8`` and, if you have a GPU, ``num_gpus=1``). Then "
"monitor your CPU and GPU utilization. For this, you can make use of tools"
" such as ``htop`` and ``nvidia-smi``. If you see overall resource "
"utilization remains low, try lowering ``num_cpus`` and ``num_gpus`` "
"(recall this will make more ``ClientApp`` instances run in parallel) "
"until you see a satisfactory system resource utilization."
msgstr ""

#: ../../source/how-to-run-simulations.rst:431
msgid ""
"Note that if the workload on your ``ClientApp`` instances is not "
"homogeneous (i.e., some come with a larger compute or memory footprint), "
"you'd probably want to focus on those when coming up with a good value "
"for ``num_gpus`` and ``num_cpus``."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid "Can I assign different resources to each ``ClientApp`` instance?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:435
msgid ""
"No. All ``ClientApp`` objects are assumed to make use of the same "
"``num_cpus`` and ``num_gpus``. When setting these values (refer to "
":ref:`clientappresources` for more details), ensure the ``ClientApp`` "
"with the largest memory footprint (either RAM or VRAM) can run in your "
"system with others like it in parallel."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid ""
"Can I run single simulation accross multiple compute nodes (e.g. GPU "
"servers)?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:439
msgid ""
"Yes. If you are using the ``RayBackend`` (the *default* backend) you can "
"first interconnect your nodes through Ray's cli and then launch the "
"simulation. Refer to :ref:`multinodesimulations` for a step-by-step "
"guide."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid ""
"My ``ServerApp`` also needs to make use of the GPU (e.g., to do "
"evaluation of the *global model* after aggregation). Is this GPU usage "
"taken into account by the ``Simulation Engine``?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:443
msgid ""
"No. The ``Simulation Engine`` only manages ``ClientApps`` and therefore "
"is only aware of the system resources they require. If your ``ServerApp``"
" makes use of substantial compute or memory resources, factor that into "
"account when setting ``num_cpus`` and ``num_gpus``."
msgstr ""

#: ../../source/how-to-run-simulations.rst
msgid ""
"Can I indicate on what resource a specific instance of a ``ClientApp`` "
"should run? Can I do resource placement?"
msgstr ""

#: ../../source/how-to-run-simulations.rst:447
msgid ""
"Currently, the placement of ``ClientApp`` instances is managed by the "
"``RayBackend`` (the only backend available as of ``flwr==1.13.0``) and "
"cannot be customized. Implementing a *custom* backend would be a way of "
"achieving resource placement."
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:-1
msgid ""
"Save and load model checkpoints in Flower with custom strategies, "
"including PyTorch checkpoints, for efficient federated learning "
"workflows."
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:23
#, fuzzy
msgid "Save and load model checkpoints"
msgstr "모델 체크포인트 저장 및 로드"

#: ../../source/how-to-save-and-load-model-checkpoints.rst:25
#, fuzzy
msgid ""
"This how-to guide describes the steps to save (and load) model "
"checkpoints in ``ClientApp`` and ``ServerApp``."
msgstr ""
"Flower는 서버 측에서 모델 업데이트를 자동으로 저장하지 않습니다. 이 사용법 가이드에서는 Flower에서 모델 체크포인트를 "
"저장(및 로드)하는 단계에 대해 설명합니다."

#: ../../source/how-to-save-and-load-model-checkpoints.rst:30
msgid "How to save model checkpoints in ``ClientApp``"
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:32
msgid ""
"Model updates are saved in |arrayrecord_link|_ and transmitted between "
"|serverapp_link|_ and |clientapp_link|_. To save model checkpoints in "
"|clientapp_link|_, you need to convert the |arrayrecord_link|_ into a "
"format compatible with your ML framework (e.g., PyTorch, TensorFlow, or "
"NumPy). Include the following code in your functions registered with the "
"``ClientApp`` (e.g., in your training function decorated with "
"``@app.train()``):"
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:39
msgid "PyTorch"
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:49
#, fuzzy
msgid "TensorFlow"
msgstr "빠른 시작 튜토리얼"

#: ../../source/how-to-save-and-load-model-checkpoints.rst:62
#, fuzzy
msgid "NumPy"
msgstr "NumPyClient"

#: ../../source/how-to-save-and-load-model-checkpoints.rst:74
msgid "How to save model checkpoints in ``ServerApp``"
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:76
msgid ""
"To save model checkpoints in |serverapp_link|_ across different FL "
"rounds, you can implement this in a customized ``evaluate_fn`` and pass "
"it to the strategy's |strategy_start_link|_ method. Here's an example "
"showing how to save the global PyTorch model:"
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:99
msgid ""
"Then, pass it to the |strategy_start_link|_ method of the defined "
"strategy:"
msgstr ""

#: ../../source/how-to-save-and-load-model-checkpoints.rst:108
msgid ""
"If you are interested, checkout the details in `Advanced PyTorch Example "
"<https://github.com/adap/flower/tree/main/examples/advanced-pytorch>`_ "
"and `Advanced TensorFlow Example "
"<https://github.com/adap/flower/tree/main/examples/advanced-"
"tensorflow>`_."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.0.rst:-1
msgid "Upgrade seamlessly from Flower 0.x to Flower 1.0 with this guide."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.0.rst:7
msgid "Upgrade to Flower 1.0"
msgstr "Flower 1.0으로 업그레이드"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:11
msgid ""
"This guide is for users who have already worked with Flower 0.x and want "
"to upgrade to Flower 1.0. Newer versions of Flower (1.13 and later) are "
"based on a new architecture and not covered in this guide. After "
"upgrading Flower 0.x projects to Flower 1.0, please refer to "
":doc:`Upgrade to Flower 1.13 <how-to-upgrade-to-flower-1.13>` to make "
"your project compatible with the lastest version of Flower."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.0.rst:18
msgid ""
"Flower 1.0 is here. Along with new features, Flower 1.0 provides a stable"
" foundation for future growth. Compared to Flower 0.19 (and other 0.x "
"series releases), there are a few breaking changes that make it necessary"
" to change the code of existing 0.x-series projects."
msgstr ""
"Flower 1.0이 출시되었습니다. 새로운 기능과 함께 Flower 1.0은 향후 성장을 위한 안정적인 기반을 제공합니다. "
"Flower 0.19(및 다른 0.x 시리즈 릴리스)와 비교했을 때 기존 0.x 시리즈 프로젝트의 코드를 변경해야 하는 몇 가지 "
"획기적인 변경 사항이 있습니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:25
#: ../../source/how-to-upgrade-to-flower-1.13.rst:55
#: ../../source/how-to-upgrade-to-message-api.rst:127
msgid "Install update"
msgstr "업데이트 설치"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:27
msgid ""
"Here's how to update an existing installation to Flower 1.0 using either "
"pip or Poetry:"
msgstr "다음은 pip 또는 Poetry를 사용하여 기존 설치를 Flower 1.0으로 업데이트하는 방법입니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:29
msgid "pip: add ``-U`` when installing."
msgstr "pip: 설치할 때 ``-U``를 추가합니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:31
msgid ""
"``python -m pip install -U flwr`` (when using ``start_server`` and "
"``start_client``)"
msgstr ""
"``python -m pip install -U flwr``(``start_server`` 및 ``start_client``를 "
"사용하는 경우)"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:32
msgid ""
"``python -m pip install -U 'flwr[simulation]'`` (when using "
"``start_simulation``)"
msgstr "``python -m pip install -U 'flwr[simulation]'``(``start_simulation`` 사용 시)"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:34
msgid ""
"Poetry: update the ``flwr`` dependency in ``pyproject.toml`` and then "
"reinstall (don't forget to delete ``poetry.lock`` via ``rm poetry.lock`` "
"before running ``poetry install``)."
msgstr ""
"Poetry: ``pyproject.toml``에서 ``flwr`` dependency을 업데이트한 다음 다시 "
"설치하세요(``poetry 설치``를 실행하기 전에 ``rm poetry.lock``을 통해 ``poetry.lock``을 삭제하는"
" 것을 잊지 마세요)."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:38
msgid "``flwr = \"^1.0.0\"`` (when using ``start_server`` and ``start_client``)"
msgstr "``flwr = \"^1.0.0\"``(``start_server`` 및 ``start_client`` 사용 시)"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:39
#, python-brace-format
msgid ""
"``flwr = { version = \"^1.0.0\", extras = [\"simulation\"] }`` (when "
"using ``start_simulation``)"
msgstr ""
"``flwr = { version = \"^1.0.0\", extras = [\"simulation\"] }`` "
"(``start_simulation`` 사용 시)"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:44
#: ../../source/how-to-upgrade-to-flower-1.13.rst:95
msgid "Required changes"
msgstr "필수 변경 사항"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:46
msgid "The following breaking changes require manual updates."
msgstr "다음과 같은 주요 변경 사항에는 수동 업데이트가 필요합니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:49
msgid "General"
msgstr "일반"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:51
msgid ""
"Pass all arguments as keyword arguments (not as positional arguments). "
"Here's an example:"
msgstr "모든 전달인자를 위치 전달인자가 아닌 키워드 전달인자로 전달합니다. 다음은 예시입니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:54
msgid ""
"Flower 0.19 (positional arguments): ``start_client(\"127.0.0.1:8080\", "
"FlowerClient())``"
msgstr ""
"Flower 0.19 (위치 전달인자): ``start_client(\"127.0.0.1:8080\", "
"FlowerClient())``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:55
msgid ""
"Flower 1.0 (keyword arguments): "
"``start_client(server_address=\"127.0.0.1:8080\", "
"client=FlowerClient())``"
msgstr ""
"Flower 1.0 (키워드 전달인자): ``start_client(server_address=\"127.0.0.1:8080\", "
"client=FlowerClient())``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:59
msgid "Client"
msgstr "클라이언트"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:61
msgid ""
"Subclasses of ``NumPyClient``: change ``def get_parameters(self):``` to "
"``def get_parameters(self, config):``"
msgstr ""
"``NumPyClient``의 서브클래스: ``def get_parameters(self):``를 ``def "
"get_parameters(self, config):``로 변경합니다"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:63
msgid ""
"Subclasses of ``Client``: change ``def get_parameters(self):``` to ``def "
"get_parameters(self, ins: GetParametersIns):``"
msgstr ""
"``클라이언트``의 서브클래스: ``def get_parameters(self):``를 ``def "
"get_parameters(self, ins: GetParametersIns):``로 변경합니다"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:67
msgid "Strategies / ``start_server`` / ``start_simulation``"
msgstr "전략 / ``start_server`` / ``start_simulation``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:69
msgid ""
"Pass ``ServerConfig`` (instead of a dictionary) to ``start_server`` and "
"``start_simulation``. Here's an example:"
msgstr ""
"Dictionary 대신 ``ServerConfig``를 ``start_server`` 및 ``start_simulation``에 "
"전달합니다. 다음은 예제입니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:72
#, python-brace-format
msgid ""
"Flower 0.19: ``start_server(..., config={\"num_rounds\": 3, "
"\"round_timeout\": 600.0}, ...)``"
msgstr ""
"Flower 0.19: ``start_server(..., config={\"num_rounds\": 3, "
"\"round_timeout\": 600.0}, ...)``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:74
msgid ""
"Flower 1.0: ``start_server(..., "
"config=flwr.server.ServerConfig(num_rounds=3, round_timeout=600.0), "
"...)``"
msgstr ""
"Flower 1.0: ``start_server(..., "
"config=flwr.server.ServerConfig(num_rounds=3, round_timeout=600.0), "
"...)``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:77
msgid ""
"Replace ``num_rounds=1`` in ``start_simulation`` with the new "
"``config=ServerConfig(...)`` (see previous item)"
msgstr ""
"``start_simulation``의 ``num_rounds=1``을 새로운 ``config=ServerConfig(...)``로"
" 바꿉니다(이전 항목 참조)"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:79
msgid ""
"Remove ``force_final_distributed_eval`` parameter from calls to "
"``start_server``. Distributed evaluation on all clients can be enabled by"
" configuring the strategy to sample all clients for evaluation after the "
"last round of training."
msgstr ""
"'start_server`` 호출에서 ``force_final_distributed_eval`` 매개변수를 제거합니다. 모든 "
"클라이언트에 대한 분산 평가는 마지막 훈련 라운드 후 평가를 위해 모든 클라이언트를 샘플링하도록 전략을 구성하여 활성화할 수 "
"있습니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:82
msgid "Rename parameter/ndarray conversion functions:"
msgstr "매개변수/ndarray 변환 함수의 이름을 바꿉니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:84
msgid "``parameters_to_weights`` --> ``parameters_to_ndarrays``"
msgstr "``parameters_to_weights`` --> ``parameters_to_ndarrays``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:85
msgid "``weights_to_parameters`` --> ``ndarrays_to_parameters``"
msgstr "``weights_to_parameters`` --> ``ndarrays_to_parameters``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:87
msgid ""
"Strategy initialization: if the strategy relies on the default values for"
" ``fraction_fit`` and ``fraction_evaluate``, set ``fraction_fit`` and "
"``fraction_evaluate`` manually to ``0.1``. Projects that do not manually "
"create a strategy (by calling ``start_server`` or ``start_simulation`` "
"without passing a strategy instance) should now manually initialize "
"FedAvg with ``fraction_fit`` and ``fraction_evaluate`` set to ``0.1``."
msgstr ""
"전략 초기화: 전략이 ``fraction_fit`` 및 ``fraction_evaluate``의 기본값에 의존하는 경우 "
"``fraction_fit`` 및 ``fraction_evaluate``를 ``0.1``로 수동 설정합니다. 전략을 수동으로 "
"생성하지 않는 프로젝트(전략 인스턴스를 전달하지 않고 ``start_server`` 또는 ``start_simulation``을 "
"호출하여)는 이제 ``fraction_fit`` 및 ``fraction_evaluate``를 ``0.1``로 설정하여 FedAvg를"
" 수동으로 초기화해야 합니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:93
msgid "Rename built-in strategy parameters (e.g., ``FedAvg``):"
msgstr "기본 제공 전략 매개변수의 이름을 바꿉니다(예: ``FedAvg``):"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:95
msgid "``fraction_eval`` --> ``fraction_evaluate``"
msgstr "``fraction_eval`` --> ``fraction_evaluate``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:96
msgid "``min_eval_clients`` --> ``min_evaluate_clients``"
msgstr "``min_eval_clients`` --> ``min_evaluate_clients``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:97
msgid "``eval_fn`` --> ``evaluate_fn``"
msgstr "``eval_fn`` --> ``evaluate_fn``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:99
msgid ""
"Rename ``rnd`` to ``server_round``. This impacts multiple methods and "
"functions, for example, ``configure_fit``, ``aggregate_fit``, "
"``configure_evaluate``, ``aggregate_evaluate``, and ``evaluate_fn``."
msgstr ""
"``rnd``의 이름을 ``server_round``로 바꿉니다. 이는 여러 메서드 및 함수(예: ``configure_fit``,"
" ``aggregate_fit``, ``configure_evaluate``, ``aggregate_evaluate`` 및 "
"``evaluate_fn``)에 영향을 미칩니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:102
msgid "Add ``server_round`` and ``config`` to ``evaluate_fn``:"
msgstr "``server_round`` 및 ``config``를 ``evaluate_fn``에 추가합니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:104
msgid ""
"Flower 0.19: ``def evaluate(parameters: NDArrays) -> "
"Optional[Tuple[float, Dict[str, Scalar]]]:``"
msgstr ""
"Flower 0.19: ``def evaluate(parameters: NDArrays) -> "
"Optional[Tuple[float, Dict[str, Scalar]]]:``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:106
msgid ""
"Flower 1.0: ``def evaluate(server_round: int, parameters: NDArrays, "
"config: Dict[str, Scalar]) -> Optional[Tuple[float, Dict[str, "
"Scalar]]]:``"
msgstr ""
"Flower 1.0: ``def evaluate(server_round: int, parameters: NDArrays, "
"config: Dict[str, Scalar]) -> Optional[Tuple[float, Dict[str, "
"Scalar]]]:``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:110
msgid "Custom strategies"
msgstr "사용자 정의 전략"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:112
msgid ""
"The type of parameter ``failures`` has changed from "
"``List[BaseException]`` to ``List[Union[Tuple[ClientProxy, FitRes], "
"BaseException]]`` (in ``aggregate_fit``) and "
"``List[Union[Tuple[ClientProxy, EvaluateRes], BaseException]]`` (in "
"``aggregate_evaluate``)"
msgstr ""
"매개변수 ``failures``의 유형이 ``List[BaseException]``에서 "
"``List[Union[Tuple[ClientProxy], FitRes], "
"BaseException]]``(``aggregate_fit``에서) 및 ``List[Union[Tuple[ClientProxy],"
" EvaluateRes], BaseException]]``(``aggregate_evaluate``)로 변경되었습니다"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:116
msgid ""
"The ``Strategy`` method ``evaluate`` now receives the current round of "
"federated learning/evaluation as the first parameter:"
msgstr "이제 ``Strategy`` 메서드 ``evaluate``는 현재 federated 학습/평가 라운드를 첫 번째 파라미터로 받습니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:119
msgid ""
"Flower 0.19: ``def evaluate(self, parameters: Parameters) -> "
"Optional[Tuple[float, Dict[str, Scalar]]]:``"
msgstr ""
"Flower 0.19: ``def evaluate(self, parameters: Parameters) -> "
"Optional[Tuple[float, Dict[str, Scalar]]]:``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:121
msgid ""
"Flower 1.0: ``def evaluate(self, server_round: int, parameters: "
"Parameters) -> Optional[Tuple[float, Dict[str, Scalar]]]:``"
msgstr ""
"Flower 1.0: ``def evaluate(self, server_round: int, parameters: "
"Parameters) -> Optional[Tuple[float, Dict[str, Scalar]]]:``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:126
msgid "Optional improvements"
msgstr "선택적 개선 사항"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:128
msgid ""
"Along with the necessary changes above, there are a number of potential "
"improvements that just became possible:"
msgstr "위의 필수 변경 사항과 함께 방금 가능한 여러 가지 잠재적 개선 사항이 있습니다:"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:131
msgid ""
"Remove \"placeholder\" methods from subclasses of ``Client`` or "
"``NumPyClient``. If you, for example, use server-side evaluation, then "
"empty placeholder implementations of ``evaluate`` are no longer "
"necessary."
msgstr ""
"``Client`` 또는 ``NumPyClient``의 서브 클래스에서 \"placeholder\" 메서드를 제거합니다. 예를 들어"
" 서버 측 평가를 사용하는 경우 ``evaluate``의 빈 자리 표시자 구현은 더 이상 필요하지 않습니다."

#: ../../source/how-to-upgrade-to-flower-1.0.rst:134
msgid ""
"Configure the round timeout via ``start_simulation``: "
"``start_simulation(..., config=flwr.server.ServerConfig(num_rounds=3, "
"round_timeout=600.0), ...)``"
msgstr ""
"``start_simulation``을 통해 라운드 타임아웃을 구성합니다: ``start_simulation(..., "
"config=flwr.server.ServerConfig(num_rounds=3, round_timeout=600.0), "
"...)``"

#: ../../source/how-to-upgrade-to-flower-1.0.rst:141
msgid ""
"Most official `Flower code examples "
"<https://github.com/adap/flower/tree/main/examples>`_ are already updated"
" to Flower 1.0, they can serve as a reference for using the Flower 1.0 "
"API. If there are further questions, `join the Flower Slack "
"<https://flower.ai/join-slack/>`_ and use the channel ``#questions``."
msgstr ""
"대부분의 공식 ``Flower code 예제 "
"<https://github.com/adap/flower/tree/main/examples>`_는 이미 Flower 1.0으로 "
"업데이트되어 있으며, Flower 1.0 API를 사용하기 위한 참고 자료로 사용할 수 있습니다. 더 궁금한 점이 있다면 ``플라워"
" 슬랙 <https://flower.ai/join-slack/>`_에 가입하여 ``#questions`` 채널을 이용하세요."

#: ../../source/how-to-upgrade-to-flower-1.13.rst:-1
msgid ""
"Upgrade seamlessly to Flower 1.13 with this guide for transitioning your "
"setup to the latest features and enhancements."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:7
#, fuzzy
msgid "Upgrade to Flower 1.13"
msgstr "Flower 1.0으로 업그레이드"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:9
#, fuzzy
msgid ""
"Welcome to the migration guide for updating Flower to Flower 1.13! "
"Whether you're a seasoned user or just getting started, this guide will "
"help you smoothly transition your existing setup to take advantage of the"
" latest features and improvements in Flower 1.13."
msgstr ""
"Flower에서 Flower Next로의 업데이트를 위한 이동 가이드에 오신 것을 환영합니다! 이 가이드는 숙련된 사용자든 이제 막"
" 시작한 사용자든 상관없이 기존 설정을 원활하게 전환하여 버전 1.8부터 Flower Next의 최신 기능 및 개선 사항을 활용할 "
"수 있도록 도와드립니다."

#: ../../source/how-to-upgrade-to-flower-1.13.rst:15
msgid ""
"This guide shows how to make pre-``1.13`` Flower code compatible with "
"Flower 1.13 (and later) with only minimal code changes."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:18
#: ../../source/how-to-upgrade-to-message-api.rst:59
msgid "Let's dive in!"
msgstr "자세히 알아봅시다!"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:57
#, fuzzy
msgid ""
"Here's how to update an existing installation of Flower to Flower 1.13 "
"with ``pip``:"
msgstr "기존에 설치된 Flower to Flower Next를 ``pip``으로 업데이트하는 방법은 다음과 같습니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:63
#, fuzzy
msgid "or if you need Flower 1.13 with simulation:"
msgstr "또는 시뮬레이션이 포함된 Flower Next가 필요한 경우:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:69
msgid ""
"Ensure you set the following version constraint in your "
"``requirements.txt``"
msgstr "``requirements.txt``에서 다음 버전 제약 조건을 설정했는지 확인하세요"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:79
msgid "or ``pyproject.toml``:"
msgstr "또는 ``pyproject.toml``:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:97
msgid ""
"Starting with Flower 1.8, the *infrastructure* and *application layers* "
"have been decoupled. Flower 1.13 enforces this separation further. Among "
"other things, this allows you to run the exact same code in a simulation "
"as in a real deployment."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:101
#, fuzzy
msgid ""
"Instead of starting a client in code via ``start_client()``, you create a"
" |clientapp_link|_. Instead of starting a server in code via "
"``start_server()``, you create a |serverapp_link|_. Both ``ClientApp`` "
"and ``ServerApp`` are started by the long-running components of the "
"server and client: the `SuperLink` and `SuperNode`, respectively."
msgstr ""
"Flower Next에서는 *infrastructure*와 *application layers*가 분리되었습니다. 코드에서 "
"``start_client()``를 통해 클라이언트를 시작하는 대신, 명령줄을 통해 |clientapp_link|_를 생성하여 "
"시작합니다. 코드에서 ``start_server()``를 통해 서버를 시작하는 대신 |serverapp_link|_를 생성하고 "
"명령줄을 통해 서버를 시작합니다. 서버와 클라이언트의 장기 실행 컴포넌트를 SuperLink와 SuperNode라고 합니다. 수동 "
"업데이트가 필요하지 않고 기존 방식과 Flower Next 방식 모두에서 프로젝트를 실행할 수 있는 non-breaking 변경 "
"사항은 다음과 같습니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:109
msgid ""
"For more details on SuperLink and SuperNode, please see the "
"|flower_architecture_link|_ ."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:112
msgid ""
"The following non-breaking changes require manual updates and allow you "
"to run your project both in the traditional (now deprecated) way and in "
"the new (recommended) Flower 1.13 way:"
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:117
msgid "|clientapp_link|_"
msgstr "|clientapp_link|_"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:119
#, fuzzy
msgid ""
"Wrap your existing client with |clientapp_link|_ instead of launching it "
"via ``start_client()``. Here's an example:"
msgstr ""
"|clientapp_link|_를 통해 실행하는 대신 기존 클라이언트를 |clientapp_link|_로 래핑하세요. 다음은 "
"예시입니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:154
msgid "|serverapp_link|_"
msgstr "|serverapp_link|_"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:156
#, fuzzy
msgid ""
"Wrap your existing strategy with |serverapp_link|_ instead of starting "
"the server via ``start_server()``. Here's an example:"
msgstr ""
"서버를 시작하려면 |startserver_link|_를 통해 서버를 시작하는 대신 기존 전략을 |serverapp_link|_로 "
"래핑하세요. 다음은 예시입니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:194
msgid "Deployment"
msgstr "배포"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:196
#, fuzzy
msgid ""
"In a terminal window, start the SuperLink using |flower_superlink_link|_."
" Then, in two additional terminal windows, start two SuperNodes using "
"|flower_supernode_link|_ (2x). There is no need to directly run "
"``client.py`` and ``server.py`` as Python scripts."
msgstr ""
"실행하기 전에 |flowernext_superlink_link|_를 사용하여 ``SuperLink``를 실행한 후 "
"|flowernext_clientapp_link|_(2회) 및 |flowernext_serverapp_link|_를 순서대로 "
"실행합니다. 'client.py'와 'server.py'를 Python 스크립트로 실행할 필요는 없습니다."

#: ../../source/how-to-upgrade-to-flower-1.13.rst:199
#, fuzzy
msgid ""
"Here's an example to start the server without HTTPS (insecure mode, only "
"for prototyping):"
msgstr "다음은 HTTPS 없이 서버를 시작하는 예제입니다(프로토타이핑용으로만 사용):"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:204
msgid ""
"For a comprehensive walk-through on how to deploy Flower using Docker, "
"please refer to the :doc:`docker/index` guide."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:227
#, fuzzy
msgid ""
"Here's another example to start both SuperLink and SuperNodes with HTTPS."
" Use the ``--ssl-ca-certfile``, ``--ssl-certfile``, and ``--ssl-keyfile``"
" command line options to pass paths to (CA certificate, server "
"certificate, and server private key)."
msgstr ""
"다음은 HTTPS로 시작하는 또 다른 예제입니다. '`--ssl-ca-certfile``, '`--ssl-certfile``, "
"'`--ssl-keyfile`` 명령줄 옵션을 사용하여 (CA 인증서, 서버 인증서 및 서버 개인 키)의 경로를 전달합니다."

#: ../../source/how-to-upgrade-to-flower-1.13.rst:255
#, fuzzy
msgid "Simulation (CLI)"
msgstr "CLI 시뮬레이션"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:257
#, fuzzy
msgid ""
"Wrap your existing client and strategy with |clientapp_link|_ and "
"|serverapp_link|_, respectively. There is no need to use "
"``start_simulation()`` anymore. Here's an example:"
msgstr ""
"기존 클라이언트와 전략을 각각 |clientapp_link|_와 |serverapp_link|_로 래핑하세요. 더 이상 "
"|startsim_link|_를 사용할 필요가 없습니다. 다음은 예시입니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:262
#: ../../source/how-to-upgrade-to-flower-1.13.rst:399
msgid ""
"For a comprehensive guide on how to setup and run Flower simulations "
"please read the |flower_how_to_run_simulations_link|_ guide."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:320
msgid "Depending on your Flower version, you can run your simulation as follows:"
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:322
msgid ""
"For Flower 1.11 and later, run ``flwr run`` in the terminal. This is the "
"recommended way to start simulations, other ways are deprecated and no "
"longer recommended."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:324
#, fuzzy
msgid ""
"DEPRECATED For Flower versions between 1.8 and 1.10, run ``flower-"
"simulation`` in the terminal and point to the ``server_app`` / "
"``client_app`` object in the code instead of executing the Python script."
" In the code snippet below, there is an example (assuming the "
"``server_app`` and ``client_app`` objects are in a ``sim.py`` module)."
msgstr ""
"CLI에서 |flower_simulation_link|_를 실행하고 Python 스크립트를 실행하는 대신 코드에서 "
"``server_app`` / ``client_app`` 개체를 가리키세요. 다음은 예제입니다(``server_app`` 및 "
"``client_app`` 객체가 ``sim.py`` 모듈에 있다고 가정):"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:328
msgid "DEPRECATED For Flower versions before 1.8, run the Python script directly."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:347
msgid ""
"Depending on your Flower version, you can also define the default "
"resources as follows:"
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:349
msgid ""
"For Flower 1.11 and later, you can edit your ``pyproject.toml`` file and "
"then run ``flwr run`` in the terminal as shown in the example below."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:351
#, fuzzy
msgid ""
"DEPRECATED For Flower versions between 1.8 and 1.10, you can adjust the "
"resources for each |clientapp_link|_ using the ``--backend-config`` "
"command line argument instead of setting the ``client_resources`` "
"argument in ``start_simulation()``."
msgstr ""
"|startsim_link|_에서 ``client_resources`` 인수를 설정하는 대신 ``--backend-config`` "
"명령줄 인수를 사용하여 각 |clientapp_link|_에 대한 기본 리소스를 설정하세요. 다음은 예시입니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:354
#: ../../source/how-to-upgrade-to-flower-1.13.rst:394
msgid ""
"DEPRECATED For Flower versions before 1.8, you need to run "
"``start_simulation()`` and pass a dictionary of the required resources to"
" the ``client_resources`` argument."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:385
#, fuzzy
msgid "Simulation (Notebook)"
msgstr "Notebook에서 시뮬레이션"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:387
msgid ""
"To run your simulation from within a notebook, please consider the "
"following examples depending on your Flower version:"
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:390
#, fuzzy
msgid ""
"For Flower 1.11 and later, you need to run |runsim_link|_ in your "
"notebook instead of ``start_simulation()``."
msgstr "notebook에서 |startsim_link|_ 대신 |runsim_link|_를 실행하세요. 다음은 예시입니다:"

#: ../../source/how-to-upgrade-to-flower-1.13.rst:392
msgid ""
"DEPRECATED For Flower versions between 1.8 and 1.10, you need to run "
"|runsim_link|_ in your notebook instead of ``start_simulation()`` and "
"configure the resources."
msgstr ""

#: ../../source/how-to-upgrade-to-flower-1.13.rst:464
#, fuzzy
msgid ""
"Most official `Flower code examples <https://flower.ai/docs/examples/>`_ "
"are already updated to Flower 1.13 so they can serve as a reference for "
"using the Flower 1.13 API. If there are further questions, `join the "
"Flower Slack <https://flower.ai/join-slack/>`_ (and use the channel "
"``#questions``) or post them on `Flower Discuss "
"<https://discuss.flower.ai/>`_ where you can find the community posting "
"and answering questions."
msgstr ""
"일부 공식 ``Flower 코드 예제 <https://flower.ai/docs/examples/>`_는 이미 플라워 넥스트에 "
"업데이트되어 있으므로 플라워 넥스트 API를 사용하는 데 참고할 수 있습니다. 더 궁금한 점이 있다면 ``플라워 슬랙 "
"<https://flower.ai/join-slack/>`_에 가입하고 ``#questions`` 채널을 이용하세요. 또한, "
"``Flower Discuss <https://discuss.flower.ai/>`_에 참여하여 질문에 대한 답변을 확인하거나 다른"
" 사람들과 Flower Next로의 이동에 대해 공유하고 배울 수 있습니다."

#: ../../source/how-to-upgrade-to-flower-1.13.rst:473
#, fuzzy
msgid ""
"As we continuously enhance Flower at a rapid pace, we'll be periodically "
"updating this guide. Please feel free to share any feedback with us!"
msgstr ""
"Flower Next는 빠른 속도로 지속적으로 개선되고 있으므로 이 가이드는 주기적으로 업데이트될 예정입니다. 피드백이 있으면 "
"언제든지 공유해 주세요!"

#: ../../source/how-to-upgrade-to-message-api.rst:-1
msgid ""
"Upgrade seamlessly to Flower 1.21 with this guide for transitioning your "
"setup to the latest features and enhancements powered by Flower's Message"
" API."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:51
#, fuzzy
msgid "Upgrade to Message API"
msgstr "Flower 1.0으로 업그레이드"

#: ../../source/how-to-upgrade-to-message-api.rst:53
msgid ""
"Welcome to the migration guide for updating your Flower Apps to use "
"Flower's Message API! This guide will walk you through the necessary "
"steps to transition from Flower Apps based on ``Strategy`` and "
"``NumPyClient`` to their equivalent using the new Message API. This guide"
" is relevant when updating pre-``1.21`` Flower apps to the latest stable "
"version."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:63
msgid ""
"If you would like to create a new Flower App using the `Message API`, run"
" the ``flwr new`` command and choose the appropriate template. "
"Alternatively, you may want to take a look at the `quickstart-pytorch "
"<https://github.com/adap/flower/blob/main/examples/quickstart-pytorch>`_ "
"example."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:70
#, fuzzy
msgid "Summary of changes"
msgstr "변경하기"

#: ../../source/how-to-upgrade-to-message-api.rst:72
msgid ""
"Thousands of Flower Apps have been created using the Strategies and "
"|numpyclient_link|_ abstractions. With the introduction of the Message "
"API, these apps can now take advantage of a more powerful and flexible "
"communication layer with the |message_link|_ abstraction being its "
"cornerstone. Messages replace the previous ``FitIns`` and ``FitRes`` data"
" structures (and their equivalent for the other operations) into a "
"single, unified and more versatile data structure."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:79
msgid ""
"To fully take advantage of the new Message API, you will need to update "
"your app's code to use the new message-based communication patterns. This"
" guide will show you how to:"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:82
msgid ""
"Update your |serverapp_link|_ to make use of the new ``Message``-based "
"strategies. You won't need to use the ``server_fn`` anymore. The new "
"strategies make it easier to customize how the different federated "
"learning rounds are executed, to retrieve results from your run, and "
"more."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:86
msgid ""
"Update your |clientapp_link|_ so it operates directly on ``Message`` "
"objects received from the |serverapp_link|_. You will be able to keep "
"most of the code from your |numpyclient_link|_ implementation but you "
"won't need to create a new class anymore or use the helper ``client_fn`` "
"function."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:93
msgid ""
"The main payload ``Message`` objects carry are of type "
"|recorddict_link|_. You can think of it as a dictionary that can hold "
"other types of records, namely |arrayrecord_link|_, |metricrecord_link|_,"
" and |configrecord_link|_. Let's see with a few short examples what's the"
" intended usage behind each type of record."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:120
msgid ""
"Please refer to the documentation for each record for all the details on "
"how they can be constructed and adapted to your usecase. In this guide we"
" won't delve into the specifics of each record type, but rather focus on "
"the overall migration process."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:129
msgid ""
"The first step is to update the Flower version defined in the "
"`pyproject.toml` in your app:"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:141
msgid "Then, run the following command to install the updated dependencies:"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:150
#, fuzzy
msgid "Update your ``ServerApp``"
msgstr "Flower 서버앱"

#: ../../source/how-to-upgrade-to-message-api.rst:152
msgid ""
"Starting with Flower 1.21, the ``ServerApp`` no longer requires a "
"``server_fn`` function to make use of strategies. This is because a new "
"collection of strategies (all sharing the common |strategy_link|_ base "
"class) has been created to operate directly on ``Message`` objects, "
"allowing for a more streamlined and flexible approach to federated "
"learning rounds."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:160
msgid ""
"The new ``Message``-based strategies are located in the "
"`flwr.serverapp.strategy <ref-api/flwr.serverapp.strategy.html>`_ module "
"unlike the previous strategies which were located in the "
"`flwr.server.strategy <ref-api/flwr.server.strategy.html>`_ module. Over "
"time more strategies will be added to the `flwr.serverapp.strategy` "
"module. Users are encouraged to use these new strategies."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:166
msgid ""
"Since Flower 1.10, the recommended ``ServerApp`` implementation would "
"look something like the code snippet below. Naturally, more customization"
" can be applied to the Strategy by, for example, reading the config from "
"the ``Context``. But to keep things focused, we will use a simple example"
" and assume we are federating a PyTorch model."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:173
msgid ""
"``Context`` has moved to ``flwr.app`` and ``ServerApp`` to "
"``flwr.serverapp``. Importing them from ``flwr.common`` or "
"``flwr.server`` is deprecated."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:200
msgid ""
"With Flower 1.21 and later, the equivalent ``ServerApp`` using the new "
"Message API would look as shown below after following these steps:"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:203
msgid ""
"Define the ``main`` method under the ``@app.main()`` decorator. If your "
"``server_fn`` was reading config values from the ``Context`` you can "
"still do so (consider copying those lines directly from your "
"``server_fn`` function)"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:206
msgid ""
"Instantiate your model as usual and construct an ``ArrayRecord`` out of "
"its parameters."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:208
msgid ""
"Replace your existing strategy with one from the "
"``flwr.serverapp.strategy`` module. For example with |fedavg_link|_. Pass"
" the arguments related to node sampling to the constructor of your "
"strategy."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:211
msgid ""
"Call the ``start`` method of the new strategy passing to it the "
"``ArrayRecord`` representing the initial state of your global model, the "
"number of FL rounds and, the ``Grid`` object (which is used internally to"
" communicate with the nodes executing the ``ClientApp``)."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:216
msgid ""
"Note how we no longer need the ``server_fn`` function. The ``Context`` is"
" still accessible, allowing you to customize how the ``ServerApp`` "
"behaves at runtime. With the new strategies, a new ``start`` method is "
"available. It defines a for loop which sets the steps involved in a round"
" of FL. By default it behaves as the original strategies do, i.e. a round"
" of FL training followed by one of FL evaluation and a stage to evaluate "
"the global model. Note how the ``start`` method returns results. These "
"are of type ``Result`` and by default contain the final global model (via"
" ``result.arrays``) as well as aggregated |metricrecord_link|_ from "
"federated stages and, optionally, metrics from evaluation stages done at "
"the ``ServerApp``."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:228
msgid ""
"In addition to helper methods for working with PyTorch models, the "
"|arrayrecord_link|_ class comes with a pair of methods to convert such "
"record to and from a list of `NumPy` arrays (i.e. to "
"``to_numpy_ndarrays`` and ``from_numpy_ndarrays``). You may choose these "
"methods if you aren't working with PyTorch models."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:236
msgid ""
"Note that the new strategies have renamed several arguments related to "
"node/client sampling, replacing the term `\"fit\"` with `\"train\"` and "
"`\"clients\"` with `\"nodes\"`. The following arguments were renamed:"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:240
#, fuzzy
msgid "``fraction_fit`` → ``fraction_train``"
msgstr "``fraction_eval`` --> ``fraction_evaluate``"

#: ../../source/how-to-upgrade-to-message-api.rst:241
#, fuzzy
msgid "``min_fit_clients`` → ``min_train_nodes``"
msgstr "``min_eval_clients`` --> ``min_evaluate_clients``"

#: ../../source/how-to-upgrade-to-message-api.rst:242
msgid "``min_evaluate_clients`` → ``min_evaluate_nodes``"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:243
#, fuzzy
msgid "``min_available_clients`` → ``min_available_nodes``"
msgstr "``min_eval_clients`` --> ``min_evaluate_clients``"

#: ../../source/how-to-upgrade-to-message-api.rst:276
#, fuzzy
msgid "Update your ClientApp"
msgstr "클라이언트앱"

#: ../../source/how-to-upgrade-to-message-api.rst:278
msgid ""
"Similar to the ``ServerApp``, the ``ClientApp`` no longer requires a "
"helper function (i.e. ``client_fn`` ) that instantiates a "
"|numpyclient_link|_ or base |client_link|_ object. Instead, with the "
"Message API, you get to define directly how the ClientApp operates on "
"``Message`` objects received from the ``ServerApp``."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:283
msgid ""
"Remember ``NumPyClient`` came with two key built-in methods, ``fit`` and "
"``evaluate``, that were respectively designed for doing federated "
"training and evaluation using the client's local data. With the new "
"Message API, you can define similar methods directly on the ``ClientApp``"
" via decorators to handle incoming ``Message`` objects."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:288
msgid ""
"Let's see a basic example showing first a minimal ``NumPyClient``-based "
"``ClientApp`` and then the upgraded design using the Message API."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:293
msgid ""
"``Context`` has moved to ``flwr.app`` and ``ClientApp`` to "
"``flwr.clientapp``. Importing them from ``flwr.common`` or "
"``flwr.client`` is deprecated."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:337
msgid ""
"Upgrading a ClientApp designed around the ``NumPyClient`` and "
"``client_fn`` abstractions to the Message API would result in the "
"following code. Note that the behavior of the ``ClientApp`` is defined "
"directly in its methods (i.e. a secondary class based on ``NumPyClient`` "
"is no longer needed)."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:342
msgid ""
"The |clientapp_link|_ abstraction comes with built-in ``@app.train`` and "
"``@app.evaluate`` decorators. The arguments the associated methods "
"receive have been unified and they both operate on ``Message`` objects. "
"Each method is responsible for handling the incoming ``Message`` objects "
"and returning the appropriate response (also as a ``Message``). Note that"
" you'll still be able to use the functions you might have written to, for"
" example, train your model using the ML framework of your choice. In this"
" example those are represented by ``train_fn`` and ``test_fn``. Follow "
"these steps to migrate your existing ``ClientApp``:"
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:351
msgid ""
"Introduce the ``@app.train`` and ``@app.evaluate`` decorators and "
"respective methods."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:352
msgid ""
"Copy the lines of code you had in your ``client_fn`` reading config "
"values from the ``Context`` into your ``train`` and ``evaluate`` methods "
"implementations (created in step 1)."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:355
msgid ""
"From the ``Message`` object, extract the relevant items (e.g. an "
"``ArrayRecord`` defining the global model, a ``ConfigRecord`` containing "
"configs for the current round) to use in your training and evaluation "
"logic."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:358
msgid ""
"Copy the lines calling the functions that do the actual "
"training/evaluation (in the code snippet below we named those "
"``train_fn`` and ``test_fn``)."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:360
msgid ""
"Based on the method, construct a ``RecordDict`` and use it to construct "
"the reply ``Message``."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:365
msgid ""
"The payload that ``Message`` objects carry is of type |recorddict_link|_ "
"which can contain records of type ``ArrayRecord``, ``MetricRecord`` and "
"``ConfigRecord``."
msgstr ""

#: ../../source/how-to-upgrade-to-message-api.rst:438
msgid ""
"This concludes the migration guide, we hope you found it useful! Happy "
"federating!"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:-1
msgid ""
"Learn how to use built-in modifiers to enhance the behaviour of a "
"ClientApp in Flower for federated learning."
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:7
msgid "Use Built-in Mods"
msgstr "기본 제공 모드 사용"

#: ../../source/how-to-use-built-in-mods.rst:11
#, fuzzy
msgid ""
"This tutorial covers preview features. The functionality and interfaces "
"may change in future versions."
msgstr "**참고: 이 튜토리얼은 실험적인 기능을 다룹니다. 기능 및 인터페이스는 향후 버전에서 변경될 수 있습니다.**"

#: ../../source/how-to-use-built-in-mods.rst:14
msgid ""
"In this tutorial, we will learn how to utilize built-in mods to augment "
"the behavior of a ``ClientApp``. Mods (sometimes also called Modifiers) "
"allow us to perform operations before and after a task is processed in "
"the ``ClientApp``."
msgstr ""
"이 튜토리얼에서는 내장 모드를 활용하여 ``ClientApp``의 동작을 보강하는 방법을 배우겠습니다. "
"Mods(Modifiers라고도 함)를 사용하면 ``ClientApp``에서 작업이 처리되기 전과 후에 작업을 수행할 수 있습니다."

#: ../../source/how-to-use-built-in-mods.rst:20
msgid "What are Mods?"
msgstr "Mods란 무엇인가요?"

#: ../../source/how-to-use-built-in-mods.rst:22
msgid ""
"A Mod is a callable that wraps around a ``ClientApp``. It can manipulate "
"or inspect the incoming ``Message`` and the resulting outgoing "
"``Message``. The signature for a ``Mod`` is as follows:"
msgstr ""
"Mod는 ``ClientApp``을 감싸는 콜러블입니다. 들어오는 ``Message``와 그 결과로 나가는 ``Message``를 "
"조작하거나 검사할 수 있습니다. ``Mod``의 시그니처는 다음과 같습니다:"

#: ../../source/how-to-use-built-in-mods.rst:31
msgid "A typical mod function might look something like this:"
msgstr "일반적인 mod 함수는 다음과 같은 모습일 수 있습니다:"

#: ../../source/how-to-use-built-in-mods.rst:50
msgid "Using Mods"
msgstr "Mods 사용"

#: ../../source/how-to-use-built-in-mods.rst:52
msgid ""
"Mods can be registered in two ways: **Application-wide mods** and "
"**Function-specific mods**."
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:55
msgid ""
"**Application-wide mods**: These mods apply to all functions within the "
"``ClientApp``."
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:57
msgid ""
"**Function-specific mods**: These mods apply only to a specific function "
"(e.g, the function decorated by ``@app.train()``)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:61
msgid "1. Registering Application-wide Mods"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:63
#, fuzzy
msgid "To use application-wide mods in your ``ClientApp``, follow these steps:"
msgstr "``ClientApp``에서 mods를 사용하려면 다음 단계를 따르세요:"

#: ../../source/how-to-use-built-in-mods.rst:66
#, fuzzy
msgid "Import the required mods"
msgstr "1. 필요한 mods를 가져옵니다"

#: ../../source/how-to-use-built-in-mods.rst:74
#, fuzzy
msgid "Create the ``ClientApp`` with application-wide mods"
msgstr "3. mods로 ``ClientApp``을 생성합니다"

#: ../../source/how-to-use-built-in-mods.rst:76
msgid ""
"Create your ``ClientApp`` and pass the mods as a list to the ``mods`` "
"argument. The order in which you provide the mods matters:"
msgstr ""
"``ClientApp``을 생성하고 mods를 ``mods`` argument에 목록으로 전달합니다. mods를 제공하는 순서가 "
"중요합니다:"

#: ../../source/how-to-use-built-in-mods.rst:89
msgid "2. Registering Function-specific Mods"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:91
msgid ""
"Instead of applying mods to the entire ``ClientApp``, you can specify "
"them for a particular function:"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:113
msgid ""
"In this case, ``example_mod_3`` and ``example_mod_4`` are only applied to"
" the ``train`` function."
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:118
#, fuzzy
msgid "Order of Execution"
msgstr "실행 순서"

#: ../../source/how-to-use-built-in-mods.rst:120
#, fuzzy
msgid "When the ``ClientApp`` runs, the mods execute in the following order:"
msgstr "``ClientApp``이 실행되면 목록에 제공된 순서대로 모드가 실행됩니다:"

#: ../../source/how-to-use-built-in-mods.rst:122
msgid "**Application-wide mods** (executed first, in the order they are provided)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:123
msgid ""
"**Function-specific mods** (executed after application-wide mods, in the "
"order they are provided)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:125
#, fuzzy
msgid ""
"**ClientApp** (core function that handles the incoming ``Message`` and "
"returns the outgoing ``Message``)"
msgstr "Message handler(들어오는 ``Message``를 처리하고 나가는 ``Message``를 반환하는 핵심 함수)"

#: ../../source/how-to-use-built-in-mods.rst:127
msgid "**Function-specific mods** (on the way back, in reverse order)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:128
msgid "**Application-wide mods** (on the way back, in reverse order)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:130
msgid ""
"Each mod has a chance to inspect and modify the incoming ``Message`` "
"before passing it to the next mod, and likewise with the outgoing "
"``Message`` before returning it up the stack."
msgstr ""
"각 mod는 다음 mod로 전달하기 전에 들어오는 ``Message``를 검사하고 수정할 기회가 있으며, 스택 위로 반환하기 전에 "
"나가는 ``Message``도 마찬가지로 검사하고 수정할 수 있습니다."

#: ../../source/how-to-use-built-in-mods.rst:135
#, fuzzy
msgid "Example Execution Flow"
msgstr "예시: 아래를 참조하세요."

#: ../../source/how-to-use-built-in-mods.rst:137
msgid "Assuming the following registration:"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:153
msgid "The execution order for an incoming **train** message is as follows:"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:155
#: ../../source/how-to-use-built-in-mods.rst:167
#, fuzzy
msgid "``example_mod_1`` (before handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:156
#: ../../source/how-to-use-built-in-mods.rst:168
#, fuzzy
msgid "``example_mod_2`` (before handling)"
msgstr "``example_mod_2`` (다음 mod)"

#: ../../source/how-to-use-built-in-mods.rst:157
#, fuzzy
msgid "``example_mod_3`` (before handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:158
#, fuzzy
msgid "``example_mod_4`` (before handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:159
msgid "``train`` (handling message)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:160
#, fuzzy
msgid "``example_mod_4`` (after handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:161
#, fuzzy
msgid "``example_mod_3`` (after handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:162
#: ../../source/how-to-use-built-in-mods.rst:170
#, fuzzy
msgid "``example_mod_2`` (after handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:163
#: ../../source/how-to-use-built-in-mods.rst:171
#, fuzzy
msgid "``example_mod_1`` (after handling)"
msgstr "``example_mod_1``(가장 바깥쪽 mod)"

#: ../../source/how-to-use-built-in-mods.rst:165
msgid "The execution order for an incoming **evaluate** message is as follows:"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:169
msgid "``evaluate`` (handling message)"
msgstr ""

#: ../../source/how-to-use-built-in-mods.rst:177
msgid ""
"By following this guide, you have learned how to effectively use mods to "
"enhance your ``ClientApp``'s functionality. Remember that the order of "
"mods is crucial and affects how the input and output are processed."
msgstr ""
"이 가이드를 따라 mods를 효과적으로 사용하여 ``ClientApp``의 기능을 향상시키는 방법을 배웠습니다. mods 순서는 "
"매우 중요하며 입력과 출력이 처리되는 방식에 영향을 미친다는 점을 기억하세요."

#: ../../source/how-to-use-built-in-mods.rst:181
msgid "Enjoy building a more robust and flexible ``ClientApp`` with mods!"
msgstr "Mods를 통해 더욱 강력하고 유연한 ``ClientApp``을 구축해 보세요!"

#: ../../source/how-to-use-cli-json-output.rst:3
msgid "Use CLI JSON output"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:5
msgid ""
"The `Flower CLIs <ref-api-cli.html>`_ come with a built-in JSON output "
"mode. This mode is useful when you want to consume the output of a Flower"
" CLI programmatically. For example, you might want to use the output of "
"the ``flwr`` CLI in a script or a continuous integration pipeline."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:12
msgid ""
"The JSON output mode is currently only available when using the Flower "
"CLIs with a `SuperLink <ref-api-cli.html#flower-superlink>`_. Learn more "
"about the `SuperLink` in the `Flower Architecture Overview <explanation-"
"flower-architecture.html>`_ page."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:16
msgid ""
"In this guide, we'll show you how to specify a JSON output with the "
"``flwr run``, ``flwr ls``, and ``flwr stop`` commands. We will also "
"provide examples of the JSON output for each of these commands."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:34
msgid "``flwr run`` JSON output"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:36
msgid ""
"The |flwr_run|_ command runs a Flower app from a provided directory. Note"
" that if the app path argument is not passed to ``flwr run``, the current"
" working directory is used as the default Flower app directory. By "
"default, executing the ``flwr run`` command prints the status of the app "
"build and run process as follows:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:49
msgid ""
"To get the output in JSON format, pass an additional ``--format json`` "
"flag:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:64
#, fuzzy
msgid "The JSON output for ``flwr run`` contains the following fields:"
msgstr "다음 변경 사항이 포함된 pull request를 만듭니다:"

#: ../../source/how-to-use-cli-json-output.rst:66
msgid "``success``: A boolean indicating whether the command was successful."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:67
msgid "``run-id``: The ID of the run."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:68
#, fuzzy
msgid "``fab-id``: The ID of the Flower app."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-use-cli-json-output.rst:69
#, fuzzy
msgid "``fab-name``: The name of the Flower app."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-use-cli-json-output.rst:70
#, fuzzy
msgid "``fab-version``: The version of the Flower app."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-use-cli-json-output.rst:71
#, fuzzy
msgid "``fab-hash``: The short hash of the Flower app."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-use-cli-json-output.rst:72
#, fuzzy
msgid "``fab-filename``: The filename of the Flower app."
msgstr "Flower 기본 이미지의 태그."

#: ../../source/how-to-use-cli-json-output.rst:74
msgid ""
"If the command fails, the JSON output will contain two fields, "
"``success`` with the value of ``false`` and ``error-message``. For "
"example, if the command fails to find the name of the federation on the "
"SuperLink, the output will look like this:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:90
msgid "``flwr ls`` JSON output"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:92
msgid ""
"The |flwr_ls|_ command lists all the runs in the current project. Similar"
" to ``flwr run``, if the app path argument is not passed to ``flwr ls``, "
"the current working directory is used as the Flower app directory. By "
"default, the command list the details of all runs in a Flower federation "
"in a tabular format:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:113
#: ../../source/how-to-use-cli-json-output.rst:185
msgid "To get the output in JSON format, simply pass the ``--format json`` flag:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:148
msgid ""
"The JSON output for ``flwr ls`` contains similar fields as ``flwr run`` "
"with the addition of the ``status``, ``elapsed``, ``created-at``, "
"``running-at``, and ``finished-at`` fields. The ``runs`` key contains a "
"list of dictionaries, each representing a run. The additional fields are:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:153
msgid ""
"``status``: The status of the run, either pending, starting, running, or "
"finished."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:154
msgid ""
"``elapsed``: The time elapsed since the run started, formatted as "
"``HH:MM:SS``."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:155
msgid "``created-at``: The time the run was created."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:156
msgid "``running-at``: The time the run started running."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:157
msgid "``finished-at``: The time the run finished."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:159
msgid ""
"All timestamps adhere to ISO 8601, UTC and are formatted as ``YYYY-MM-DD "
"HH:MM:SSZ``."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:161
msgid ""
"You can also use the ``--run-id`` flag to list the details for one run. "
"In this case, the JSON output will have the same structure as above with "
"only one entry in the ``runs`` key. For more details of this command, see"
" the |flwr_ls|_ documentation. If the command fails, the JSON output will"
" return two fields, ``success`` and ``error-message``, as shown in "
":ref:`the above example <json_error_output>`. Note that the content of "
"the error message will be different depending on the error that occurred."
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:170
msgid "``flwr stop`` JSON output"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:172
msgid ""
"The |flwr_stop|_ command stops a running Flower app for a provided run "
"ID. Similar to ``flwr run``, if the app path argument is not passed to "
"``flwr stop``, the current working directory is used as the Flower app "
"directory. By default, the command prints the status of the stop process "
"as follows:"
msgstr ""

#: ../../source/how-to-use-cli-json-output.rst:195
msgid ""
"If the command fails, the JSON output will contain two fields ``success``"
" with the value of ``false`` and ``error-message``, as shown in :ref:`the"
" above example <json_error_output>`. Note that the content of the error "
"message will be different depending on the error that occurred."
msgstr ""

#: ../../source/how-to-use-differential-privacy.rst:-1
msgid ""
"Apply differential privacy in Flower with server-side/client-side "
"clipping or local DP techniques to enhance data security in federated "
"learning."
msgstr ""

#: ../../source/how-to-use-differential-privacy.rst:39
msgid "Use Differential Privacy"
msgstr "차분 개인정보 보호 사용"

#: ../../source/how-to-use-differential-privacy.rst:41
msgid ""
"This guide explains how you can utilize differential privacy in the "
"Flower framework. If you are not yet familiar with differential privacy, "
"you can refer to :doc:`explanation-differential-privacy`."
msgstr ""
"이 가이드에서는 Flower 프레임워크에서 차분 개인정보 보호 기능을 활용하는 방법을 설명합니다. 차분 개인정보 보호에 대해 아직 "
"익숙하지 않은 경우 :doc:`explanation-differential-privacy`를 참조하세요."

#: ../../source/how-to-use-differential-privacy.rst:47
msgid ""
"Differential Privacy in Flower is in a preview phase. If you plan to use "
"these features in a production environment with sensitive data, feel free"
" contact us to discuss your requirements and to receive guidance on how "
"to best use these features."
msgstr ""
"Flower의 차분 개인정보 보호는 현재 프리뷰 단계에 있습니다. 민감한 데이터가 있는 프로덕션 환경에서 이러한 기능을 사용할 "
"계획이라면 언제든지 문의하여 요구 사항을 논의하고 이러한 기능을 가장 잘 사용하는 방법에 대한 안내를 받으세요."

#: ../../source/how-to-use-differential-privacy.rst:55
#, fuzzy
msgid ""
"This approach consists of two separate phases: clipping of the updates "
"and adding noise to the aggregated model. For the clipping phase, Flower "
"framework has made it possible to decide whether to perform clipping on "
"the server side or the client side."
msgstr ""
"이 접근 방식은 업데이트 클리핑과 집계된 모델에 노이즈 추가라는 두 가지 단계로 구성됩니다. 클리핑 단계의 경우, Flower "
"프레임워크는 클리핑을 서버 측에서 수행할지 클라이언트 측에서 수행할지 결정할 수 있도록 했습니다."

#: ../../source/how-to-use-differential-privacy.rst:59
msgid ""
"**Server-side Clipping**: This approach has the advantage of the server "
"enforcing uniform clipping across all clients' updates and reducing the "
"communication overhead for clipping values. However, it also has the "
"disadvantage of increasing the computational load on the server due to "
"the need to perform the clipping operation for all clients."
msgstr ""
"**Server-side Clipping**: 이 방식은 서버가 모든 클라이언트의 업데이트에 대해 균일한 클리핑을 적용하고 클리핑 "
"값에 대한 통신 오버헤드를 줄일 수 있다는 장점이 있습니다. 하지만 모든 클라이언트에 대해 클리핑 작업을 수행해야 하기 때문에 "
"서버의 계산 부하가 증가한다는 단점도 있습니다."

#: ../../source/how-to-use-differential-privacy.rst:64
msgid ""
"**Client-side Clipping**: This approach has the advantage of reducing the"
" computational overhead on the server. However, it also has the "
"disadvantage of lacking centralized control, as the server has less "
"control over the clipping process."
msgstr ""
"**Client-side Clipping**: 이 방식은 서버의 계산 오버헤드를 줄일 수 있다는 장점이 있습니다. 하지만 서버가 "
"클리핑 프로세스에 대한 통제력이 떨어지기 때문에 centralized 제어가 부족하다는 단점도 있습니다."

#: ../../source/how-to-use-differential-privacy.rst:69
msgid "Server-side Clipping"
msgstr "서버 측 클리핑"

#: ../../source/how-to-use-differential-privacy.rst:71
#, fuzzy
msgid ""
"For central DP with server-side clipping, there are two ``Strategy`` "
"classes that act as wrappers around the actual ``Strategy`` instance (for"
" example, |fedavg_link|_). The two wrapper classes are "
"|dpserverfix_link|_ and |dpserveradapt_link|_ for fixed and adaptive "
"clipping."
msgstr ""
"서버 측 클리핑이 있는 중앙 DP의 경우, 실제 :code:`Strategy` 인스턴스를 감싸는 래퍼 역할을 하는 두 개의 "
":code:`Strategy` 클래스가 있습니다(예: :code:`FedAvg`). 두 개의 래퍼 클래스는 고정 및 적응형 클리핑을"
" 위한 :code:`DifferentialPrivacyServerSideFixedClipping`과 "
":code:`DifferentialPrivacyServerSideAdaptiveClipping`입니다."

#: ../../source/how-to-use-differential-privacy.rst:76
msgid "server side clipping"
msgstr "서버 측 클리핑"

#: ../../source/how-to-use-differential-privacy.rst:81
#, fuzzy
msgid ""
"The code sample below enables the ``FedAvg`` strategy to use server-side "
"fixed clipping using the ``DifferentialPrivacyServerSideFixedClipping`` "
"wrapper class. The same approach can be used with "
"``DifferentialPrivacyServerSideAdaptiveClipping`` by adjusting the "
"corresponding input parameters."
msgstr ""
"아래 코드 샘플은 :code:`FedAvg` 전략이 "
":code:`DifferentialPrivacyServerSideFixedClipping` 래퍼 클래스를 사용하여 서버 측 고정 "
"클리핑을 사용할 수 있도록 합니다. 해당 입력 매개변수를 조정하여 "
":code:`DifferentialPrivacyServerSideAdaptiveClipping`과 동일한 접근 방식을 사용할 수 "
"있습니다."

#: ../../source/how-to-use-differential-privacy.rst:102
msgid "Client-side Clipping"
msgstr "클라이언트 측 클리핑"

#: ../../source/how-to-use-differential-privacy.rst:104
#, fuzzy
msgid ""
"For central DP with client-side clipping, the server sends the clipping "
"value to selected clients on each round. Clients can use existing Flower "
"``Mods`` to perform the clipping. Two mods are available for fixed and "
"adaptive client-side clipping: |fixedclipping_mod_link|_ and "
"|adaptiveclipping_mod_link|_ with corresponding server-side wrappers "
"|dpclientfix_link|_ and |dpclientadapt_link|_."
msgstr ""
"클라이언트 측 클리핑이 있는 중앙 DP의 경우 서버는 각 라운드마다 선택한 클라이언트에 클리핑 값을 보냅니다. 클라이언트는 기존 "
"Flower :code:`Mods`를 사용하여 클리핑을 수행할 수 있습니다. 고정 및 적응형 클라이언트 측 클리핑에는 두 가지 "
"모드를 사용할 수 있습니다: :code:`fixedclipping_mod` 및 :code:`adaptiveclipping_mod`와"
" 해당 서버 측 래퍼 :code:`DifferentialPrivacyClientSideFixedClipping` 및 "
":code:`DifferentialPrivacyClientSideAdaptiveClipping`이 있습니다."

#: ../../source/how-to-use-differential-privacy.rst:110
msgid "client side clipping"
msgstr "클라이언트 측 클리핑"

#: ../../source/how-to-use-differential-privacy.rst:115
#, fuzzy
msgid ""
"The code sample below enables the ``FedAvg`` strategy to use differential"
" privacy with client-side fixed clipping using both the "
"``DifferentialPrivacyClientSideFixedClipping`` wrapper class and, on the "
"client, ``fixedclipping_mod``:"
msgstr ""
"아래 코드 샘플은 :code:`FedAvg` 전략이 클라이언트 측 고정 클리핑과 함께 차분 프라이버시를 사용할 수 있도록 "
":code:`DifferentialPrivacyClientSideFixedClipping` 래퍼 클래스와 클라이언트에서 "
":code:`fixedclipping_mod`를 모두 사용하도록 합니다:"

#: ../../source/how-to-use-differential-privacy.rst:134
#, fuzzy
msgid ""
"In addition to the server-side strategy wrapper, the ``ClientApp`` needs "
"to configure the matching ``fixedclipping_mod`` to perform the client-"
"side clipping:"
msgstr ""
"서버 측 전략 래퍼 외에도 클라이언트 측 클리핑을 수행하려면 :code:`ClientApp`이 일치하는 "
":code:`fixedclipping_mod`를 구성해야 합니다:"

#: ../../source/how-to-use-differential-privacy.rst:149
#, fuzzy
msgid ""
"To utilize local differential privacy (DP) and add noise to the client "
"model parameters before transmitting them to the server in Flower, you "
"can use the |localdp_mod_link|_. The following hyperparameters need to be"
" set: clipping norm value, sensitivity, epsilon, and delta."
msgstr ""
"로컬 차분 프라이버시(DP)를 활용하고 클라이언트 모델 파라미터를 서버로 전송하기 전에 노이즈를 추가하려면 `LocalDpMod`를"
" 사용하면 됩니다. 클리핑 노멀 값, 감도, 엡실론, 델타 등의 하이퍼파라미터를 설정해야 합니다."

#: ../../source/how-to-use-differential-privacy.rst:154
msgid "local DP mod"
msgstr "로컬 DP mod"

#: ../../source/how-to-use-differential-privacy.rst:159
#, fuzzy
msgid "Below is a code example that shows how to use ``LocalDpMod``:"
msgstr "다음은 :code:`LocalDpMod`를 사용하는 방법을 보여주는 코드 예시입니다:"

#: ../../source/how-to-use-differential-privacy.rst:163
msgid ""
"Apply the mod only to the functions that require it. For example, to use "
"local DP during training, add the mod to the training function with "
"``@app.train(mods=[your_mod])``. Avoid adding it directly to "
"``ClientApp`` with ``ClientApp(mods=[your_mod])``, as this applies the "
"mod to all functions (including evaluation), which is generally "
"unnecessary and error-prone."
msgstr ""

#: ../../source/how-to-use-differential-privacy.rst:188
msgid ""
"Please note that the order of mods, especially those that modify "
"parameters, is important when using multiple modifiers. Typically, "
"differential privacy (DP) modifiers should be the last to operate on "
"parameters."
msgstr ""
"여러 개의 수정자를 사용할 때는 수정자, 특히 매개변수를 수정하는 수정자의 순서가 중요하다는 점에 유의하세요. 일반적으로 차분 "
"프라이버시(DP) 수정자는 매개변수에서 가장 마지막에 작동해야 합니다."

#: ../../source/how-to-use-differential-privacy.rst:193
msgid "Local Training using Privacy Engines"
msgstr "Privacy Engines을 사용한 로컬 훈련"

#: ../../source/how-to-use-differential-privacy.rst:195
#, fuzzy
msgid ""
"For ensuring data instance-level privacy during local model training on "
"the client side, consider leveraging privacy engines such as Opacus and "
"TensorFlow Privacy. For examples of using Flower with these engines, "
"please refer to the Flower examples directory (`Opacus "
"<https://github.com/adap/flower/tree/main/examples/opacus>`_, `Tensorflow"
" Privacy <https://github.com/adap/flower/tree/main/examples/tensorflow-"
"privacy>`_)."
msgstr ""
"클라이언트 측에서 로컬 모델을 훈련하는 동안 데이터 인스턴스 수준의 개인 정보 보호를 보장하려면 Opacus 및 TensorFlow"
" Privacy와 같은 개인 정보 보호 엔진을 활용하는 것을 고려하세요. 이러한 엔진과 함께 Flower를 사용하는 예제는 "
"Flower examples directory (`Opacus "
"<https://github.com/adap/flower/tree/main/examples/opacus>`_, `Tensorflow"
" Privacy <https://github.com/adap/flower/tree/main/examples/dp-sgd-"
"mnist>`_)를 참조하세요."

#: ../../source/how-to-use-strategies.rst:-1
msgid ""
"Customize federated learning in Flower with built-in strategies, "
"callbacks, and custom server-side implementations for maximum flexibility"
" and control."
msgstr ""

#: ../../source/how-to-use-strategies.rst:47
msgid "Use strategies"
msgstr "전략 사용하기"

#: ../../source/how-to-use-strategies.rst:49
#, fuzzy
msgid ""
"Flower allows full customization of the learning process through the "
"|strategy_link|_ abstraction. A number of built-in `strategies <ref-"
"api/flwr.serverapp.strategy.html>`_ are provided in the core framework."
msgstr ""
"Flower는 :code:`Strategy` abstraction를 통해 학습 과정을 완전히 사용자 정의할 수 있습니다. 핵심 "
"프레임워크에는 여러 가지 기본 제공 전략이 제공됩니다."

#: ../../source/how-to-use-strategies.rst:53
#, fuzzy
msgid ""
"There are four ways to customize the way Flower orchestrates the learning"
" process on the server side:"
msgstr "서버 측에서 Flower가 학습 과정을 조율하는 방식을 사용자 지정하는 방법에는 세 가지가 있습니다:"

#: ../../source/how-to-use-strategies.rst:56
#, fuzzy
msgid "Use an existing strategy, for example, ``FedAvg``"
msgstr "기존 전략(예: :code:`FedAvg`)을 사용합니다"

#: ../../source/how-to-use-strategies.rst:57
#, fuzzy
msgid ""
"Customize an existing strategy with callback functions to its ``start`` "
"method"
msgstr "콜백 함수로 기존 전략 사용자 지정"

#: ../../source/how-to-use-strategies.rst:58
msgid "Customize an existing strategy by overriding one or more of its methods."
msgstr ""

#: ../../source/how-to-use-strategies.rst:59
#, fuzzy
msgid "Implement a novel strategy from scratch"
msgstr "새로운 전략 구현"

#: ../../source/how-to-use-strategies.rst:63
msgid ""
"Flower built-in strategies communicate one |arrayrecord_link|_ and one "
"|metricrecord_link|_ in a ``Message`` to the ``ClientApps``. The "
"strategies expect replies containing one ``MetricRecord`` and, if it's a "
"round where ``ClientApps`` do local training, one ``ArrayRecord`` as "
"well. The ``Message`` abstraction allows for unlimited records of any "
"type. If you want to communicate multiple records you'd need to either "
"expand an existing strategy or implement one from scratch."
msgstr ""

#: ../../source/how-to-use-strategies.rst:72
msgid "Use an existing strategy"
msgstr "기존 전략 사용"

#: ../../source/how-to-use-strategies.rst:74
#, fuzzy
msgid ""
"Flower comes with a number of popular federated learning ``Strategies`` "
"which can be instantiated as follows as part of a simple "
"|serverapp_link|_:"
msgstr "Flower에는 여러 가지 인기 있는 연합 학습 전략이 기본으로 제공됩니다. 기본 제공 전략은 다음과 같이 인스턴스화할 수 있습니다:"

#: ../../source/how-to-use-strategies.rst:100
msgid ""
"In the code above, instantiating ``FedAvg`` does not launch the logic "
"built into the strategy (i.e. sampling nodes, communicating "
"|message_link|_, performing aggregation, etc). In order to do so, we need"
" to execute the |strategy_start_link|_ method."
msgstr ""

#: ../../source/how-to-use-strategies.rst:104
msgid ""
"The above ``ServerApp`` is very minimal, makes use of the default "
"settings for ``FedAvg`` and only passes the required arguments to the "
"``start`` method. Let's see in a bit more detail what options we have "
"when instantiating strategies and when launching it."
msgstr ""

#: ../../source/how-to-use-strategies.rst:111
#, fuzzy
msgid "Parameterizing an existing strategy"
msgstr "기존 전략 사용"

#: ../../source/how-to-use-strategies.rst:113
msgid ""
"The constructor of strategies accepts different parameters based on, "
"primarily, the aggregation algorithm they implement. For example, "
"|fedadam_link|_ accepts additional arguments (i.e. to apply momentum "
"during aggregation) compared to those that |fedavg_link|_ requires. "
"However, common to all strategies are settings to control how nodes that "
"run ``ClientApp`` instances get sampled. Let's take a look at this set of"
" arguments:"
msgstr ""

#: ../../source/how-to-use-strategies.rst:131
#, python-format
msgid ""
"For most applications specifying one or all of the arguments shown above "
"is sufficient. A Flower strategy defined like the one above would wait "
"for 100 nodes to be connected before any federated stage begins. Then, "
"50% of the connected nodes will be involved in a stage of federated "
"training, followed by another stage of federated evaluation where all "
"connected nodes will participate. It is possible to set the "
"``min_train_nodes`` and ``min_evaluate_nodes`` arguments for finer "
"control."
msgstr ""

#: ../../source/how-to-use-strategies.rst:138
msgid ""
"In addition to arguments to customize how the strategy performs sampling,"
" we can define at construction time which keys will be used to "
"communicate different information between the strategy in the "
"``ServerApp`` and the ``ClientApp``. Note that these keys are used in "
"both types of stages within the strategy ``start`` logic, i.e. federated "
"training and federated evaluation."
msgstr ""

#: ../../source/how-to-use-strategies.rst:156
msgid ""
"``arrayrecord_key``: the ``Message`` communicated to the ``ClientApp`` "
"will contain an ``ArrayRecord`` containing the arrays of the global model"
" under this key. By default the key is ``\"arrays\"``."
msgstr ""

#: ../../source/how-to-use-strategies.rst:159
msgid ""
"``configrecord_key``: the ``Message`` communicated to the ``ClientApp`` "
"will contain a ``ConfigRecord`` containing config settings. By default "
"the key is ``\"config\"``."
msgstr ""

#: ../../source/how-to-use-strategies.rst:161
msgid ""
"``weighted_by_key``: A key inside the |metricrecord_link|_ that the "
"``ClientApp`` returns as part of its reply to the ``ServerApp``. The "
"value under this key is used to perform weighted aggregation of "
"``MetricRecords`` and, after a round of federated training, "
"``ArrayRecords``. The default value is ``\"num-examples\"``."
msgstr ""

#: ../../source/how-to-use-strategies.rst:166
msgid ""
"With a strategy defined as in the code snippet above, the ``ClientApp`` "
"should receive a ``Message`` with the following structure:"
msgstr ""

#: ../../source/how-to-use-strategies.rst:200
msgid ""
"While the strategies fix the keys used to communicate the ``ArrayRecord``"
" and ``MetricRecord`` to the ``ClientApps``, the replies these send back "
"to the ``ServerApp`` can use different keys. In the code snippet above we"
" used ``\"locally-updated-params\"`` and ``\"local-metrics\"``. However, "
"all ``ClientApps`` need to use the same keys in their reply ``Messages`` "
"otherwise the aggregation of replies (``ArrayRecord`` and "
"``MetricRecord``) cannot be performed."
msgstr ""

#: ../../source/how-to-use-strategies.rst:207
msgid ""
"Finally, the strategy constructor also allows passing two callbacks to "
"control how the ``MetricRecords`` in the replies that ``ClientApps`` send"
" are aggregated. Follow the :doc:`how-to-aggregate-evaluation-results` "
"guide for a walkthrough on how to define these callbacks."
msgstr ""

#: ../../source/how-to-use-strategies.rst:214
msgid "Using the strategy's ``start`` method"
msgstr ""

#: ../../source/how-to-use-strategies.rst:216
msgid ""
"As mentioned earlier, it is the ``start`` method of the strategy that "
"launches the federated learning process. Let's see what each argument "
"passed to this method represents."
msgstr ""

#: ../../source/how-to-use-strategies.rst:222
msgid ""
"Check the |strategy_explainer_link|_ explainer for a deep dive into how "
"the different stages implemented as part of the ``start`` method operate."
msgstr ""

#: ../../source/how-to-use-strategies.rst:225
msgid ""
"The only required arguments are the |grid_link|_ and an ``ArrayRecord``. "
"The former is an object that will be used to interface with the nodes "
"running the ``ClientApp`` to involve them in a round of "
"train/evaluate/query or other. The latter contains the parameters of the "
"model we want to federate. Therefore, a minimal execution of the "
"``start`` method looks like this:"
msgstr ""

#: ../../source/how-to-use-strategies.rst:239
msgid ""
"In most settings, we want to customize how the ``start`` method is "
"executed by passing also the number of rounds to execute and, a pair of "
"``ConfigRecord`` objects to be sent to the ``ClientApp`` during a step of"
" training and evaluation respectively."
msgstr ""

#: ../../source/how-to-use-strategies.rst:259
msgid ""
"The ``start`` method also allows you to limit for how long the "
"``strategy`` will wait for replies from the ``ClientApps`` until it "
"proceeds with the rest of the stages. This can be controlled with the "
"argument ``timeout`` (which defaults to 3600s, i.e., 1h). For example, if"
" we want to increase the timeout to 2 hours, we would do:"
msgstr ""

#: ../../source/how-to-use-strategies.rst:281
msgid ""
"Finally, the last argument in ``start`` is named ``evaluate_fn`` and it "
"allows passing to it a callback function to evaluate the aggregated model"
" on some local data that the ``ServerApp`` might have access to. This "
"callback is also useful if you want to save the global model at the end "
"of every round (or every N rounds). Let's see what the signature of this "
"callback is and how to use it:"
msgstr ""

#: ../../source/how-to-use-strategies.rst:312
msgid ""
"Take a look at the `quickstart-pytorch "
"<https://github.com/adap/flower/blob/main/examples/quickstart-pytorch>`_ "
"example on GitHub for a complete example using several of the concepts "
"presented in this how-to guide."
msgstr ""

#: ../../source/index.rst:37
msgid "Tutorial"
msgstr "튜토리얼"

#: ../../source/index.rst:78
msgid "Build"
msgstr ""

#: ../../source/index.rst:78
#, fuzzy
msgid "Simulate"
msgstr "시뮬레이션 실행"

#: ../../source/index.rst:78
#, fuzzy
msgid "Deploy"
msgstr "배포"

#: ../../source/index.rst:74 ../../source/index.rst:78
#, fuzzy
msgid "How-to Guides"
msgstr "사용 방법 가이드"

#: ../../source/index.rst:117
msgid "Contributor docs"
msgstr "기여자 문서"

#: ../../source/index.rst:-1
msgid ""
"Check out the documentation of the main Flower Framework enabling easy "
"Python development for Federated Learning."
msgstr "연합 학습을 위한 Python 개발을 쉽게 할 수 있는 주요 Flower 프레임워크의 설명서를 확인하세요."

#: ../../source/index.rst:3
msgid "Flower Framework Documentation"
msgstr "플라워 프레임워크 문서"

#: ../../source/index.rst:8
#, fuzzy
msgid ""
"Welcome to Flower's documentation. `Flower <https://flower.ai>`_ is a "
"friendly federated learning framework."
msgstr "Flower 문서에 오신 것을 환영합니다. Flower <https://flower.ai>`_는 편한 연합 학습 프레임워크입니다."

#: ../../source/index.rst:13
msgid "Join the Flower Community"
msgstr "Flower 커뮤니티 가입하기"

#: ../../source/index.rst:15
msgid ""
"The Flower Community is growing quickly - we're a friendly group of "
"researchers, engineers, students, professionals, academics, and other "
"enthusiasts."
msgstr "Flower 커뮤니티는 연구원, 엔지니어, 학생, 전문가, 학자 및 기타 애호가들로 구성된 편한 그룹으로 빠르게 성장하고 있습니다."

#: ../../source/index.rst:18
msgid "Join us on Slack"
msgstr "Slack에 가입하세요"

#: ../../source/index.rst:26
msgid "Flower Framework"
msgstr "Flower 프레임워크"

#: ../../source/index.rst:28
#, fuzzy
msgid ""
"The user guide is targeted at researchers and developers who want to use "
"Flower to bring existing machine learning workloads into a federated "
"setting. One of Flower's design goals was to make this simple. Read on to"
" learn more."
msgstr ""
"이 사용자 가이드는 Flower를 사용해 기존 머신 러닝 워크로드를 연합된 환경으로 가져오고자 하는 연구자와 개발자를 대상으로 "
"합니다. Flower의 설계 목표 중 하나는 이를 간단하게 만드는 것이었습니다. 자세히 알아보려면 계속 읽어보세요."

#: ../../source/index.rst:35
msgid ""
"A learning-oriented series of federated learning tutorials, the best "
"place to start."
msgstr "학습 중심의 연합 학습 튜토리얼 시리즈로, 시작하기에 가장 좋은 곳입니다."

#: ../../source/index.rst:53
#, fuzzy
msgid ""
"QUICKSTART TUTORIALS: :doc:`PyTorch <tutorial-quickstart-pytorch>` | "
":doc:`TensorFlow <tutorial-quickstart-tensorflow>` | :doc:`MLX <tutorial-"
"quickstart-mlx>` | :doc:`🤗 Transformers <tutorial-quickstart-"
"huggingface>` | :doc:`JAX <tutorial-quickstart-jax>` | :doc:`Pandas "
"<tutorial-quickstart-pandas>` | :doc:`fastai <tutorial-quickstart-"
"fastai>` | :doc:`PyTorch Lightning <tutorial-quickstart-pytorch-"
"lightning>` | :doc:`scikit-learn <tutorial-quickstart-scikitlearn>` | "
":doc:`XGBoost <tutorial-quickstart-xgboost>` | :doc:`Android <tutorial-"
"quickstart-android>` | :doc:`iOS <tutorial-quickstart-ios>`"
msgstr ""
"QUICKSTART TUTORIALS: :doc:`PyTorch <tutorial-quickstart-pytorch>` | "
":doc:`TensorFlow <tutorial-quickstart-tensorflow>` | :doc:`🤗 Transformers"
" <tutorial-quickstart-huggingface>` | :doc:`JAX <tutorial-quickstart-"
"jax>` | :doc:`Pandas <tutorial-quickstart-pandas>` | :doc:`fastai "
"<tutorial-quickstart-fastai>` | :doc:`PyTorch Lightning <tutorial-"
"quickstart-pytorch-lightning>` | :doc:`scikit-learn <tutorial-quickstart-"
"scikitlearn>` | :doc:`XGBoost <tutorial-quickstart-xgboost>` | "
":doc:`Android <tutorial-quickstart-android>` | :doc:`iOS <tutorial-"
"quickstart-ios>`"

#: ../../source/ref-api-cli.rst:3
msgid "Flower CLI reference"
msgstr "Flower CLI 참조"

#: ../../source/ref-api-cli.rst:7
msgid "Basic Commands"
msgstr ""

#: ../../source/ref-api-cli.rst:12
#, fuzzy
msgid "``flwr`` CLI"
msgstr "Flower 클라이언트."

#: ../../flwr:1
#, fuzzy
msgid "flwr is the Flower command line interface."
msgstr "Flower ClientProxy 인스턴스 등록 해제."

#: ../../source/ref-api-cli.rst
#, fuzzy
msgid "Options"
msgstr "해결법"

#: ../../flwr:1
#, fuzzy
msgid "Install completion for the current shell."
msgstr "현재 실행에 대한 식별자입니다."

#: ../../flwr:1
msgid ""
"Show completion for the current shell, to copy it or customize the "
"installation."
msgstr ""

#: ../../flwr build:1
msgid "Build a Flower App into a Flower App Bundle (FAB)."
msgstr ""

#: ../../flwr build:1
msgid ""
"You can run ``flwr build`` without any arguments to bundle the app "
"located in the current directory. Alternatively, you can you can specify "
"a path using the ``--app`` option to bundle an app located at the "
"provided path. For example:"
msgstr ""

#: ../../flwr build:1
msgid "``flwr build --app ./apps/flower-hello-world``."
msgstr ""

#: ../../flwr build:1
msgid "Path of the Flower App to bundle into a FAB"
msgstr ""

#: ../../flwr federation:1
#, fuzzy
msgid "Manage Federations"
msgstr "시뮬레이션 실행"

#: ../../flwr federation list:1
#, fuzzy
msgid "List available federations."
msgstr "시뮬레이션 실행"

#: ../../flwr federation list:1 register:1 run:1 show:1 stop:1 supernode
#: unregister:1
msgid "Format output using 'default' view or 'json'"
msgstr ""

#: ../../flwr federation list log register run show stop supernode unregister
msgid "default"
msgstr ""

#: ../../flwr federation list:1 register:1 run:1 show:1 stop:1 supernode
#: unregister:1
#, fuzzy
msgid "``'default'``"
msgstr "``flwr/base``"

#: ../../source/ref-api-cli.rst
#, fuzzy
msgid "Arguments"
msgstr "빌드 전달인자"

#: ../../flwr federation install:1 list:1 log:1 login:1 new:1 pull:1 register:1
#: run:1 show:1 stop:1 supernode unregister:1
#, fuzzy
msgid "Optional argument"
msgstr "선택적 개선 사항"

#: ../../flwr federation list:1 register:1 show:1 stop:1 supernode unregister:1
#, fuzzy
msgid "Path of the Flower project"
msgstr "Flower 기본 이미지의 태그."

#: ../../flwr federation list:1 register:1 show:1 stop:1 supernode unregister:1
msgid "Name of the federation"
msgstr ""

#: ../../flwr federation show:1
#, fuzzy
msgid "Show details of a federation."
msgstr "flower 초연결"

#: ../../flwr install:1
#, fuzzy
msgid "Install a Flower App Bundle."
msgstr "Flower 설치"

#: ../../flwr install:1
msgid "It can be ran with a single FAB file argument:"
msgstr ""

#: ../../flwr install:1
msgid "``flwr install ./target_project.fab``"
msgstr ""

#: ../../flwr install:1
msgid "The target install directory can be specified with ``--flwr-dir``:"
msgstr ""

#: ../../flwr install:1
msgid "``flwr install ./target_project.fab --flwr-dir ./docs/flwr``"
msgstr ""

#: ../../flwr install:1
msgid ""
"This will install ``target_project`` to ``./docs/flwr/``. By default, "
"``flwr-dir`` is equal to:"
msgstr ""

#: ../../flwr install:1
msgid "``$FLWR_HOME/`` if ``$FLWR_HOME`` is defined"
msgstr ""

#: ../../flwr install:1
msgid "``$XDG_DATA_HOME/.flwr/`` if ``$XDG_DATA_HOME`` is defined"
msgstr ""

#: ../../flwr install:1
msgid "``$HOME/.flwr/`` in all other cases"
msgstr ""

#: ../../flwr install:1
msgid "The desired install path."
msgstr ""

#: ../../flwr install:1
msgid "The source FAB file to install."
msgstr ""

#: ../../flwr list:1
msgid ""
"List the details of one provided run ID or all runs in a Flower "
"federation."
msgstr ""

#: ../../flwr list:1
msgid "The following details are displayed:"
msgstr ""

#: ../../flwr list:1
#, fuzzy
msgid "**Run ID:** Unique identifier for the run."
msgstr "현재 실행에 대한 식별자입니다."

#: ../../flwr list:1
msgid "**Federation:** The federation to which the run belongs."
msgstr ""

#: ../../flwr list:1
msgid "**App:** The App associated with the run (``<APP_ID>==<APP_VERSION>``)."
msgstr ""

#: ../../flwr list:1
msgid ""
"**Status:** Current status of the run (pending, starting, running, "
"finished)."
msgstr ""

#: ../../flwr list:1
msgid "**Elapsed:** Time elapsed since the run started (``HH:MM:SS``)."
msgstr ""

#: ../../flwr list:1
#, fuzzy
msgid "**Status Changed @:** Timestamp of the most recent status change."
msgstr "메시지가 생성된 때의 Unix timestamp입니다."

#: ../../flwr list:1
msgid ""
"All timestamps follow ISO 8601, UTC and are formatted as ``YYYY-MM-DD "
"HH:MM:SSZ``."
msgstr ""

#: ../../flwr list:1 log:1 login:1 pull:1 run:1 stop:1
#, fuzzy
msgid ""
"Override federation configuration values using one of the following "
"formats:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../flwr list:1 log:1 login:1 pull:1 run:1 stop:1
msgid ""
"--federation-config '<k1>=<v1> <k2>=<v2>' | --federation-config "
"'<k1>=<v1>' --federation-config '<k2>=<v2>'"
msgstr ""

#: ../../flwr list:1 log:1 login:1 pull:1 run:1 stop:1
msgid ""
"When providing key-value pairs, values can be of any type supported by "
"TOML (e.g., bool, int, float, string). The specified keys (<k1> and <k2> "
"in the example) must exist in the federation configuration under the "
"`[tool.flwr.federations.<YOUR-FEDERATION>]` section of `pyproject.toml` "
"to be overridden."
msgstr ""

#: ../../flwr list:1
msgid "List all runs"
msgstr ""

#: ../../flwr list:1 run:1 supernode
#, fuzzy
msgid "``False``"
msgstr "``flwr/base``"

#: ../../flwr list:1
msgid "Specific run ID to display"
msgstr ""

#: ../../flwr log:1
msgid "Get logs from a Flower project run."
msgstr ""

#: ../../flwr log:1
msgid "Flag to stream or print logs from the Flower run"
msgstr ""

#: ../../flwr log:1
#, fuzzy
msgid "``True``"
msgstr "``DISTRO``"

#: ../../flwr log:1 register:1 stop:1 supernode unregister:1
#, fuzzy
msgid "Required argument"
msgstr "빌드 전달인자"

#: ../../flwr log:1
#, fuzzy
msgid "The Flower run ID to query"
msgstr "Flower 커뮤니티 가입하기"

#: ../../flwr log:1
msgid "Path of the Flower project to run"
msgstr ""

#: ../../flwr log:1
msgid "Name of the federation to run the app on"
msgstr ""

#: ../../flwr login:1
#, fuzzy
msgid "Login to Flower SuperLink."
msgstr "flower 초연결"

#: ../../flwr login:1 pull:1 run:1
#, fuzzy
msgid "Path of the Flower App to run."
msgstr "Flower 기본 이미지의 태그."

#: ../../flwr login:1
msgid "Name of the federation to login into."
msgstr ""

#: ../../flwr new:1
#, fuzzy
msgid "Create new Flower App."
msgstr "새 페이지 만들기"

#: ../../flwr new:1
msgid "The ML framework to use"
msgstr ""

#: ../../flwr new
#, fuzzy
msgid "options"
msgstr "해결법"

#: ../../flwr new:1
msgid ""
"PyTorch | TensorFlow | sklearn | HuggingFace | JAX | MLX | NumPy | "
"XGBoost | FlowerTune | Flower Baseline | PyTorch (Legacy API, deprecated)"
msgstr ""

#: ../../flwr new:1
msgid "The Flower username of the author"
msgstr ""

#: ../../flwr new:1
msgid ""
"Flower app name. For remote apps, use the format '@account_name/app_name'"
" or '@account_name/app_name==x.y.z'. Version is optional (defaults to "
"latest)."
msgstr ""

#: ../../flwr pull:1
msgid "Pull artifacts from a Flower run."
msgstr ""

#: ../../flwr pull:1
msgid "**Required** Run ID to pull artifacts from."
msgstr ""

#: ../../flwr pull:1
#, fuzzy
msgid "Name of the federation."
msgstr "flower 초연결"

#: ../../flwr run:1
#, fuzzy
msgid "Run Flower App."
msgstr "Flower 서버."

#: ../../flwr run:1
#, fuzzy
msgid "Override run configuration values using one of the following formats:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../flwr run:1
msgid ""
"--run-config '<k1>=<v1> <k2>=<v2>' | --run-config '<k1>=<v1>' --run-"
"config '<k2>=<v2>' | --run-config <path/to/your/toml>"
msgstr ""

#: ../../flwr run:1
msgid ""
"When providing key-value pairs, values can be of any type supported by "
"TOML (e.g., bool, int, float, string). The specified keys (<k1> and <k2> "
"in the example) must exist in the run configuration under the "
"`[tool.flwr.app.config]` section of `pyproject.toml` to be overridden. "
"Alternatively, provide a TOML file containing overrides."
msgstr ""

#: ../../flwr run:1
msgid ""
"Use `--stream` with `flwr run` to display logs; logs are not streamed by "
"default."
msgstr ""

#: ../../flwr run:1
msgid "Name of the federation to run the app on."
msgstr ""

#: ../../flwr stop:1
msgid "Stop a run."
msgstr ""

#: ../../flwr stop:1
#, fuzzy
msgid "The Flower run ID to stop"
msgstr "Flower 커뮤니티 가입하기"

#: ../../flwr supernode:1
#, fuzzy
msgid "Manage SuperNodes"
msgstr "SuperNodes 인증하기"

#: ../../flwr list:1 supernode
#, fuzzy
msgid "List SuperNodes in the federation."
msgstr "flower 초연결"

#: ../../flwr list:1 supernode
#, fuzzy
msgid "Enable verbose output"
msgstr "예시"

#: ../../flwr register:1 supernode
#, fuzzy
msgid "Add a SuperNode to the federation."
msgstr "flower 초연결"

#: ../../flwr register:1 supernode
msgid "Path to a P-384 (or any other NIST EC curve) public key file."
msgstr ""

#: ../../flwr supernode unregister:1
#, fuzzy
msgid "Unregister a SuperNode from the federation."
msgstr "flower 초연결"

#: ../../flwr supernode unregister:1
#, fuzzy
msgid "ID of the SuperNode to remove."
msgstr "서버(SuperLink)"

#: ../../source/ref-api-cli.rst:21
#, fuzzy
msgid "``flower-superlink``"
msgstr "flower 초연결"

#: ../../source/ref-api-cli.rst:31
#, fuzzy
msgid "``flower-supernode``"
msgstr "Flower SuperNode"

#: ../../source/ref-api-cli.rst:40
#, fuzzy
msgid "Advanced Commands"
msgstr "고급 Docker 옵션"

#: ../../source/ref-api-cli.rst:45
#, fuzzy
msgid "``flower-superexec``"
msgstr "Flower SuperNode"

#: ../../source/ref-api/flwr.rst:2
msgid "flwr"
msgstr "flwr"

#: ../../source/reference.rst:18:<autosummary>:1 flwr:1 of
msgid "Flower main package."
msgstr "Flower 메인 패키지."

#: ../../source/ref-api/flwr.clientapp.rst:33 ../../source/ref-api/flwr.rst:25
#: ../../source/ref-api/flwr.serverapp.rst:34
msgid "Modules"
msgstr "Modules"

#: ../../source/ref-api/flwr.rst:34:<autosummary>:1
#, fuzzy
msgid ":py:obj:`flwr.app <flwr.app>`\\"
msgstr ":py:obj:`flwr <flwr>`\\"

#: ../../source/ref-api/flwr.rst:34:<autosummary>:1 flwr.app:1 of
#, fuzzy
msgid "Public Flower App APIs."
msgstr "Flower 서버."

#: ../../source/ref-api/flwr.rst:34:<autosummary>:1
#, fuzzy
msgid ":py:obj:`flwr.clientapp <flwr.clientapp>`\\"
msgstr ":py:obj:`flwr.client <flwr.client>`\\"

#: ../../source/ref-api/flwr.rst:34:<autosummary>:1 flwr.clientapp:1 of
#, fuzzy
msgid "Public Flower ClientApp APIs."
msgstr "Flower ClientApp."

#: ../../source/ref-api/flwr.rst:34:<autosummary>:1
#, fuzzy
msgid ":py:obj:`flwr.serverapp <flwr.serverapp>`\\"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.rst:34:<autosummary>:1 flwr.serverapp:1 of
#, fuzzy
msgid "Public Flower ServerApp APIs."
msgstr "Flower 서버."

#: ../../source/ref-api/flwr.app.rst:2
msgid "app"
msgstr ""

#: ../../source/ref-api/flwr.app.rst:17
#: ../../source/ref-api/flwr.clientapp.mod.rst:27
#: ../../source/ref-api/flwr.clientapp.rst:17
#: ../../source/ref-api/flwr.serverapp.rst:17
#: ../../source/ref-api/flwr.serverapp.strategy.rst:17
msgid "Classes"
msgstr "클래스"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`Array <flwr.app.Array>`\\ \\(\\)"
msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.record.array.Array:1 of
msgid "Array type."
msgstr "배열 유형."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`ArrayRecord <flwr.app.ArrayRecord>`\\ \\(\\)"
msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord:1 of
#, fuzzy
msgid "Array record."
msgstr "매개변수 기록."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`ConfigRecord <flwr.app.ConfigRecord>`\\ \\(\\[config\\_dict\\, "
"keep\\_input\\]\\)"
msgstr ""
":py:obj:`ConfigsRecord <flwr.common.ConfigsRecord>`\\ "
"\\(\\[configs\\_dict\\, keep\\_input\\]\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.record.configrecord.ConfigRecord:1 of
#, fuzzy
msgid "Config record."
msgstr "레코드를 설정합니다."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`Context <flwr.app.Context>`\\ \\(run\\_id\\, node\\_id\\, "
"node\\_config\\, state\\, ...\\)"
msgstr ":py:obj:`Context <flwr.common.Context>`\\ \\(state\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.context.Context:1 of
#, fuzzy
msgid "Context of your run."
msgstr "실행 상태."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`Error <flwr.app.Error>`\\ \\(code\\[\\, reason\\]\\)"
msgstr ":py:obj:`Error <flwr.common.Error>`\\ \\(code\\[\\, reason\\]\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1 flwr.app.error.Error:1
#: of
#, fuzzy
msgid "The class storing information about an error that occurred."
msgstr "발생한 오류에 대한 정보를 저장하는 데이터 클래스입니다."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`Message <flwr.app.Message>`\\ \\(\\)"
msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.message.Message:1 of
msgid "Represents a message exchanged between ClientApp and ServerApp."
msgstr ""

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`MessageType <flwr.app.MessageType>`\\ \\(\\)"
msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.constant.MessageType:1 of
msgid "Message type."
msgstr "메시지 타입."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`Metadata <flwr.app.Metadata>`\\ \\(run\\_id\\, message\\_id\\, "
"src\\_node\\_id\\, ...\\)"
msgstr ""
":py:obj:`Metadata <flwr.common.Metadata>`\\ \\(run\\_id\\, "
"message\\_id\\, src\\_node\\_id\\, ...\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.app.metadata.Metadata:1 of
#, fuzzy
msgid "The class representing metadata associated with the current message."
msgstr "현재 메시지와 관련된 메타데이터를 보유한 데이터 클래스입니다."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`MetricRecord <flwr.app.MetricRecord>`\\ \\(\\[metric\\_dict\\, "
"keep\\_input\\]\\)"
msgstr ""
":py:obj:`MetricsRecord <flwr.common.MetricsRecord>`\\ "
"\\(\\[metrics\\_dict\\, keep\\_input\\]\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.record.metricrecord.MetricRecord:1 of
#, fuzzy
msgid "Metric record."
msgstr "메트릭 기록."

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`RecordDict <flwr.app.RecordDict>`\\ \\(\\[records\\, "
"parameters\\_records\\, ...\\]\\)"
msgstr ""
":py:obj:`RecordSet <flwr.common.RecordSet>`\\ "
"\\(\\[parameters\\_records\\, ...\\]\\)"

#: ../../source/ref-api/flwr.app.rst:31:<autosummary>:1
#: flwr.common.record.recorddict.RecordDict:1 of
#, fuzzy
msgid "RecordDict stores groups of arrays, metrics and configs."
msgstr "RecordSet은 매개변수, 메트릭 및 설정 그룹을 저장합니다."

#: ../../source/ref-api/flwr.app.Array.rst:2
msgid "Array"
msgstr "배열"

#: flwr.common.message.Message:1 flwr.common.record.array.Array:1 of
#, fuzzy
msgid "Bases: :py:class:`~flwr.common.inflatable.InflatableObject`"
msgstr "Bases: :py:class:`~abc.ABC`"

#: flwr.common.record.array.Array:3 of
#, fuzzy
msgid ""
"A dataclass containing serialized data from an array-like or tensor-like "
"object along with metadata about it. The class can be initialized in one "
"of three ways:"
msgstr "배열형 또는 텐서형 객체의 직렬화된 데이터와 그에 대한 일부 메타데이터를 포함하는 데이터 클래스입니다."

#: flwr.common.record.array.Array:6 of
msgid "By specifying explicit values for `dtype`, `shape`, `stype`, and `data`."
msgstr ""

#: flwr.common.record.array.Array:7 of
msgid "By providing a NumPy ndarray (via the `ndarray` argument)."
msgstr ""

#: flwr.common.record.array.Array:8 of
msgid "By providing a PyTorch tensor (via the `torch_tensor` argument)."
msgstr ""

#: flwr.common.record.array.Array:10 of
msgid ""
"In scenarios (2)-(3), the `dtype`, `shape`, `stype`, and `data` are "
"automatically derived from the input. In scenario (1), these fields must "
"be specified manually."
msgstr ""

#: flwr.common.record.array.Array:13 of
#, fuzzy
msgid ""
"A string representing the data type of the serialized object (e.g. "
"`\"float32\"`). Only required if you are not passing in a ndarray or a "
"tensor."
msgstr "직렬화된 객체의 데이터 유형을 나타내는 문자열(예: `np.float32`)"

#: flwr.common.record.array.Array:16 of
#, fuzzy
msgid ""
"A tuple representing the shape of the unserialized array-like object. "
"Only required if you are not passing in a ndarray or a tensor."
msgstr ""
"직렬화되지 않은 배열과 같은 객체의 모양을 나타내는 목록입니다. 직렬화 방법에 따라 데이터를 역직렬화하는 데 사용되거나 단순히 "
"메타데이터 필드로 사용됩니다."

#: flwr.common.record.array.Array:19 of
#, fuzzy
msgid ""
"A string indicating the serialization mechanism used to generate the "
"bytes in `data` from an array-like or tensor-like object. Only required "
"if you are not passing in a ndarray or a tensor."
msgstr "배열형 또는 텐서형 객체에서 `데이터`의 바이트를 생성하는 데 사용되는 직렬화 메커니즘의 유형을 나타내는 문자열입니다."

#: flwr.common.record.array.Array:23 of
#, fuzzy
msgid ""
"A buffer of bytes containing the data. Only required if you are not "
"passing in a ndarray or a tensor."
msgstr ""
"직렬화되지 않은 배열과 같은 객체의 모양을 나타내는 목록입니다. 직렬화 방법에 따라 데이터를 역직렬화하는 데 사용되거나 단순히 "
"메타데이터 필드로 사용됩니다."

#: flwr.common.record.array.Array:26 of
msgid ""
"A NumPy ndarray. If provided, the `dtype`, `shape`, `stype`, and `data` "
"fields are derived automatically from it."
msgstr ""

#: flwr.common.record.array.Array:29 of
msgid ""
"A PyTorch tensor. If provided, it will be **detached and moved to CPU** "
"before conversion, and the `dtype`, `shape`, `stype`, and `data` fields "
"will be derived automatically from it."
msgstr ""

#: flwr.clientapp.client_app.ClientApp:4
#: flwr.clientapp.client_app.ClientApp.evaluate:12
#: flwr.clientapp.client_app.ClientApp.lifespan:7
#: flwr.clientapp.client_app.ClientApp.query:12
#: flwr.clientapp.client_app.ClientApp.train:12
#: flwr.clientapp.mod.localdp_mod.LocalDpMod:22
#: flwr.common.record.array.Array:35
#: flwr.common.record.arrayrecord.ArrayRecord:36
#: flwr.common.record.configrecord.ConfigRecord:20
#: flwr.common.record.metricrecord.MetricRecord:19
#: flwr.common.record.recorddict.RecordDict:14
#: flwr.server.server_app.ServerApp:4
#: flwr.server.server_app.ServerApp.lifespan:7
#: flwr.server.server_app.ServerApp.main:4
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:31
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:21
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:14
#: of
msgid "Examples"
msgstr "예시"

#: flwr.common.record.array.Array:36 of
msgid "Initializing by specifying all fields directly::"
msgstr ""

#: flwr.common.record.array.Array:45 of
#, fuzzy
msgid "Initializing with a NumPy ndarray::"
msgstr "Dictionary holding ParametersRecord instances."

#: flwr.common.record.array.Array:50 of
msgid "Initializing with a PyTorch tensor::"
msgstr ""

#: ../../source/ref-api/flwr.app.Array.rst:15
#: ../../source/ref-api/flwr.app.ArrayRecord.rst:15
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:15
#: ../../source/ref-api/flwr.app.Context.rst:15
#: ../../source/ref-api/flwr.app.Error.rst:15
#: ../../source/ref-api/flwr.app.Message.rst:15
#: ../../source/ref-api/flwr.app.MessageType.rst:15
#: ../../source/ref-api/flwr.app.Metadata.rst:15
#: ../../source/ref-api/flwr.app.MetricRecord.rst:15
#: ../../source/ref-api/flwr.app.RecordDict.rst:15
#: ../../source/ref-api/flwr.clientapp.ClientApp.rst:15
#: ../../source/ref-api/flwr.clientapp.mod.LocalDpMod.rst:15
#: ../../source/ref-api/flwr.serverapp.Grid.rst:15
#: ../../source/ref-api/flwr.serverapp.ServerApp.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.Bulyan.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedAdagrad.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedAdam.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedAvg.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedAvgM.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedMedian.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedProx.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedTrimmedAvg.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbCyclic.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.FedYogi.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.Krum.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.MultiKrum.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.QFedAvg.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:15
#: ../../source/ref-api/flwr.serverapp.strategy.Strategy.rst:15
msgid "Methods"
msgstr "메소드"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`deflate <flwr.app.Array.deflate>`\\ \\(\\)"
msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#: flwr.common.record.array.Array.deflate:1 of
msgid "Deflate the Array."
msgstr ""

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`from_numpy_ndarray <flwr.app.Array.from_numpy_ndarray>`\\ "
"\\(ndarray\\)"
msgstr ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ \\(ndarray\\)"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#: flwr.common.record.array.Array.from_numpy_ndarray:1 of
msgid "Create Array from NumPy ndarray."
msgstr "NumPy에서 배열을 만듭니다."

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`from_torch_tensor <flwr.app.Array.from_torch_tensor>`\\ "
"\\(tensor\\)"
msgstr ":py:obj:`ndarray_to_bytes <flwr.common.ndarray_to_bytes>`\\ \\(ndarray\\)"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#: flwr.common.record.array.Array.from_torch_tensor:1 of
#, fuzzy
msgid "Create Array from PyTorch tensor."
msgstr "NumPy에서 배열을 만듭니다."

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`inflate <flwr.app.Array.inflate>`\\ \\(object\\_content\\[\\, "
"children\\]\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#: flwr.common.record.array.Array.inflate:1 of
#, fuzzy
msgid "Inflate an Array from bytes."
msgstr "바이트에서 NumPy를 역직렬화합니다."

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`numpy <flwr.app.Array.numpy>`\\ \\(\\)"
msgstr ":py:obj:`numpy <flwr.common.Array.numpy>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#: flwr.common.record.array.Array.numpy:1 of
msgid "Return the array as a NumPy array."
msgstr "배열을 NumPy 배열로 반환합니다."

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`slice_array <flwr.app.Array.slice_array>`\\ \\(\\)"
msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#: ../../source/ref-api/flwr.app.Array.rst:41:<autosummary>:1
#: flwr.common.record.array.Array.slice_array:1 of
msgid "Slice Array data and construct a list of ArrayChunks."
msgstr ""

#: ../../source/ref-api/flwr.app.Array.rst:43
#: ../../source/ref-api/flwr.app.ArrayRecord.rst:79
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:64
#: ../../source/ref-api/flwr.app.Context.rst:25
#: ../../source/ref-api/flwr.app.Error.rst:25
#: ../../source/ref-api/flwr.app.Message.rst:43
#: ../../source/ref-api/flwr.app.MessageType.rst:25
#: ../../source/ref-api/flwr.app.Metadata.rst:25
#: ../../source/ref-api/flwr.app.MetricRecord.rst:64
#: ../../source/ref-api/flwr.app.RecordDict.rst:61
#: ../../source/ref-api/flwr.serverapp.Grid.rst:43
#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:43
#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:25
msgid "Attributes"
msgstr "속성"

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`children <flwr.app.Array.children>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.Array.children:1 flwr.app.Array.children:1:<autosummary>:1 of
msgid "Return a dictionary of ArrayChunks with their Object IDs as keys."
msgstr ""

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`is_dirty <flwr.app.Array.is_dirty>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.Array.children:1:<autosummary>:1 flwr.app.Array.is_dirty:1
#: flwr.app.ArrayRecord.children:1:<autosummary>:1
#: flwr.app.ArrayRecord.is_dirty:1
#: flwr.app.ConfigRecord.children:1:<autosummary>:1
#: flwr.app.ConfigRecord.is_dirty:1 flwr.app.Message.children:1:<autosummary>:1
#: flwr.app.Message.is_dirty:1 flwr.app.MetricRecord.children:1:<autosummary>:1
#: flwr.app.MetricRecord.is_dirty:1
#: flwr.app.RecordDict.array_records:1:<autosummary>:1
#: flwr.app.RecordDict.is_dirty:1 of
msgid "Check if the object is dirty after the last deflation."
msgstr ""

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`object_id <flwr.app.Array.object_id>`\\"
msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#: flwr.app.Array.children:1:<autosummary>:1 flwr.app.Array.object_id:1
#: flwr.app.ArrayRecord.children:1:<autosummary>:1
#: flwr.app.ArrayRecord.object_id:1 of
msgid "Get object ID."
msgstr ""

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`dtype <flwr.app.Array.dtype>`\\"
msgstr ":py:obj:`dtype <flwr.common.Array.dtype>`\\"

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`shape <flwr.app.Array.shape>`\\"
msgstr ":py:obj:`shape <flwr.common.Array.shape>`\\"

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`stype <flwr.app.Array.stype>`\\"
msgstr ":py:obj:`stype <flwr.common.Array.stype>`\\"

#: flwr.app.Array.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`data <flwr.app.Array.data>`\\"
msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#: flwr.common.record.array.Array.inflate:3 of
msgid "The deflated object content of the Array."
msgstr ""

#: flwr.common.record.array.Array.inflate:5 of
msgid ""
"Must be ``None``. ``Array`` must have child objects. Providing no "
"children will raise a ``ValueError``."
msgstr ""

#: flwr.clientapp.client_app.ClientApp.evaluate
#: flwr.clientapp.client_app.ClientApp.query
#: flwr.clientapp.client_app.ClientApp.train
#: flwr.common.message.Message.create_error_reply
#: flwr.common.message.Message.create_reply flwr.common.message.Message.inflate
#: flwr.common.record.array.Array.inflate
#: flwr.common.record.arrayrecord.ArrayRecord.inflate
#: flwr.common.record.configrecord.ConfigRecord.inflate
#: flwr.common.record.metricrecord.MetricRecord.inflate
#: flwr.common.record.recorddict.RecordDict.inflate
#: flwr.server.grid.grid.Grid.create_message
#: flwr.server.grid.grid.Grid.pull_messages
#: flwr.server.grid.grid.Grid.push_messages
#: flwr.server.grid.grid.Grid.send_and_receive
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train
#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate
#: flwr.serverapp.strategy.strategy.Strategy.configure_train
#: flwr.serverapp.strategy.strategy.Strategy.start of
msgid "Returns"
msgstr "반환"

#: flwr.common.record.array.Array.inflate:9 of
msgid "The inflated Array."
msgstr ""

#: flwr.clientapp.client_app.ClientApp.evaluate
#: flwr.clientapp.client_app.ClientApp.query
#: flwr.clientapp.client_app.ClientApp.train
#: flwr.common.message.Message.create_error_reply
#: flwr.common.message.Message.create_reply flwr.common.message.Message.inflate
#: flwr.common.record.array.Array.inflate
#: flwr.common.record.arrayrecord.ArrayRecord.inflate
#: flwr.common.record.configrecord.ConfigRecord.inflate
#: flwr.common.record.metricrecord.MetricRecord.inflate
#: flwr.common.record.recorddict.RecordDict.inflate
#: flwr.server.grid.grid.Grid.create_message
#: flwr.server.grid.grid.Grid.pull_messages
#: flwr.server.grid.grid.Grid.push_messages
#: flwr.server.grid.grid.Grid.send_and_receive
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train
#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate
#: flwr.serverapp.strategy.strategy.Strategy.configure_train
#: flwr.serverapp.strategy.strategy.Strategy.start of
msgid "Return type"
msgstr "반환 타입"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:2
#: flwr.serverapp.strategy.result.Result:13 of
#, fuzzy
msgid "ArrayRecord"
msgstr "ParametersRecord"

#: flwr.common.record.arrayrecord.ArrayRecord:1 of
#, fuzzy
msgid ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`~flwr.common.record.array.Array`], "
":py:class:`~flwr.common.inflatable.InflatableObject`"
msgstr ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`~flwr.common.record.parametersrecord.Array`]"

#: flwr.common.record.arrayrecord.ArrayRecord:3 of
msgid ""
"A typed dictionary (``str`` to :class:`Array`) that can store named "
"arrays, including model parameters, gradients, embeddings or non-"
"parameter arrays. Internally, this behaves similarly to an ``dict[str, "
"Array]``. An ``ArrayRecord`` can be viewed as an equivalent to PyTorch's "
"``state_dict``, but it holds arrays in a serialized form."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:9 of
msgid ""
"This object is one of the record types supported by :class:`RecordDict` "
"and can therefore be stored in the ``content`` of a :class:`Message` or "
"the ``state`` of a :class:`Context`."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:13 of
msgid "This class can be instantiated in multiple ways:"
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:15 of
msgid "By providing nothing (empty container)."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:16 of
msgid ""
"By providing a dictionary of :class:`Array` (via the ``array_dict`` "
"argument)."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:17 of
msgid ""
"By providing a list of NumPy ``ndarray`` (via the ``numpy_ndarrays`` "
"argument)."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:18 of
msgid ""
"By providing a PyTorch ``state_dict`` (via the ``torch_state_dict`` "
"argument)."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:20 of
msgid ""
"An existing dictionary containing named :class:`Array` instances. If "
"provided, these entries will be used directly to populate the record."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:23 of
msgid ""
"A list of NumPy arrays. Each array will be automatically converted into "
"an :class:`Array` and stored in this record with generated keys."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:26 of
msgid ""
"A PyTorch ``state_dict`` (``str`` keys to ``torch.Tensor`` values). Each "
"tensor will be converted into an :class:`Array` and stored in this "
"record."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:29 of
msgid ""
"If ``False``, entries from the input are removed after being added to "
"this record to free up memory. If ``True``, the input remains unchanged. "
"Regardless of this value, no duplicate memory is used if the input is a "
"dictionary of :class:`Array`, i.e., ``array_dict``."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:37 of
#, fuzzy
msgid "Initializing an empty ArrayRecord::"
msgstr "Dictionary holding ParametersRecord instances."

#: flwr.common.record.arrayrecord.ArrayRecord:41 of
#, fuzzy
msgid "Initializing with a dictionary of :class:`Array`::"
msgstr "NumPy에서 배열을 만듭니다."

#: flwr.common.record.arrayrecord.ArrayRecord:46 of
#, fuzzy
msgid "Initializing with a list of NumPy arrays::"
msgstr "Dictionary holding ParametersRecord instances."

#: flwr.common.record.arrayrecord.ArrayRecord:53 of
msgid "Initializing with a PyTorch model state_dict::"
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord:59 of
msgid "Initializing with a TensorFlow model weights (a list of NumPy arrays)::"
msgstr ""

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`clear <flwr.app.ArrayRecord.clear>`\\ \\(\\)"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`copy <flwr.app.ArrayRecord.copy>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#: flwr.common.record.typeddict.TypedDict.copy:1 of
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`count_bytes <flwr.app.ArrayRecord.count_bytes>`\\ \\(\\)"
msgstr ":py:obj:`count_bytes <flwr.common.ParametersRecord.count_bytes>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.count_bytes:1
#: flwr.common.record.configrecord.ConfigRecord.count_bytes:1
#: flwr.common.record.metricrecord.MetricRecord.count_bytes:1 of
msgid "Return number of Bytes stored in this object."
msgstr "이 객체에 저장된 바이트 수를 반환합니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`deflate <flwr.app.ArrayRecord.deflate>`\\ \\(\\)"
msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.deflate:1 of
#, fuzzy
msgid "Deflate the ArrayRecord."
msgstr "매개변수 기록."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`from_array_dict <flwr.app.ArrayRecord.from_array_dict>`\\ "
"\\(array\\_dict\\, \\*\\[\\, keep\\_input\\]\\)"
msgstr ""
":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
"\\(\\[array\\_dict\\, keep\\_input\\]\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.from_array_dict:1 of
#, fuzzy
msgid "Create ArrayRecord from a dictionary of :class:`Array`."
msgstr "NumPy에서 배열을 만듭니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`from_numpy_ndarrays "
"<flwr.app.ArrayRecord.from_numpy_ndarrays>`\\ \\(ndarrays\\, \\*\\[\\, "
"keep\\_input\\]\\)"
msgstr ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ \\(ndarray\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.from_numpy_ndarrays:1 of
#, fuzzy
msgid "Create ArrayRecord from a list of NumPy ``ndarray``."
msgstr "NumPy에서 배열을 만듭니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`from_torch_state_dict "
"<flwr.app.ArrayRecord.from_torch_state_dict>`\\ \\(state\\_dict\\, "
"\\*\\[\\, ...\\]\\)"
msgstr ":py:obj:`get <flwr.common.ParametersRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.from_torch_state_dict:1 of
#, fuzzy
msgid "Create ArrayRecord from PyTorch ``state_dict``."
msgstr "NumPy에서 배열을 만듭니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`get <flwr.app.ArrayRecord.get>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`inflate <flwr.app.ArrayRecord.inflate>`\\ "
"\\(object\\_content\\[\\, children\\]\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.inflate:1 of
#, fuzzy
msgid "Inflate an ArrayRecord from bytes."
msgstr "바이트에서 NumPy를 역직렬화합니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`items <flwr.app.ArrayRecord.items>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`keys <flwr.app.ArrayRecord.keys>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`pop <flwr.app.ArrayRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#: collections.abc.MutableMapping.pop:1 of
msgid "If key is not found, d is returned if given, otherwise KeyError is raised."
msgstr "키를 찾을 수 없으면 주어진 경우 d가 반환되고, 그렇지 않으면 KeyError가 발생합니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`popitem <flwr.app.ArrayRecord.popitem>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#: collections.abc.MutableMapping.popitem:1 of
msgid "as a 2-tuple; but raise KeyError if D is empty."
msgstr ""

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`setdefault <flwr.app.ArrayRecord.setdefault>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`to_numpy_ndarrays <flwr.app.ArrayRecord.to_numpy_ndarrays>`\\ "
"\\(\\*\\[\\, keep\\_input\\]\\)"
msgstr ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ \\(ndarray\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.to_numpy_ndarrays:1 of
#, fuzzy
msgid "Return the ArrayRecord as a list of NumPy ``ndarray``."
msgstr "**parameters** -- 로컬 모델 파라미터를 NumPy 배열 목록으로 표시합니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`to_torch_state_dict "
"<flwr.app.ArrayRecord.to_torch_state_dict>`\\ \\(\\*\\[\\, "
"keep\\_input\\]\\)"
msgstr ""
":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
"\\(\\[array\\_dict\\, keep\\_input\\]\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: flwr.common.record.arrayrecord.ArrayRecord.to_torch_state_dict:1 of
#, fuzzy
msgid "Return the ArrayRecord as a PyTorch ``state_dict``."
msgstr "**parameters** -- 로컬 모델 파라미터를 NumPy 배열 목록으로 표시합니다."

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`update <flwr.app.ArrayRecord.update>`\\ \\(\\[E\\, \\]\\*\\*F\\)"
msgstr ""
":py:obj:`update <flwr.common.MetricsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#: collections.abc.MutableMapping.update:1 of
msgid ""
"If E present and has a .keys() method, does:     for k in E: D[k] = E[k] "
"If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = "
"v In either case, this is followed by: for k, v in F.items(): D[k] = v"
msgstr ""

#: ../../source/ref-api/flwr.app.ArrayRecord.rst:77:<autosummary>:1
#, fuzzy
msgid ":py:obj:`values <flwr.app.ArrayRecord.values>`\\ \\(\\)"
msgstr ""
":py:obj:`update <flwr.common.MetricsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: flwr.app.ArrayRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`children <flwr.app.ArrayRecord.children>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.ArrayRecord.children:1
#: flwr.app.ArrayRecord.children:1:<autosummary>:1 of
msgid "Return a dictionary of Arrays with their Object IDs as keys."
msgstr ""

#: flwr.app.ArrayRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`is_dirty <flwr.app.ArrayRecord.is_dirty>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.ArrayRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`object_id <flwr.app.ArrayRecord.object_id>`\\"
msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#: flwr.common.record.arrayrecord.ArrayRecord.count_bytes:3 of
msgid ""
"Note that a small amount of Bytes might also be included in this counting"
" that correspond to metadata of the serialized object (e.g. of NumPy "
"array) needed for deseralization."
msgstr "역직렬화에 필요한 직렬화된 객체의 메타데이터(예: NumPy 배열)에 해당하는 소량의 바이트도 이 카운팅에 포함될 수 있습니다."

#: flwr.common.record.arrayrecord.ArrayRecord.inflate:3 of
#, fuzzy
msgid "The deflated object content of the ArrayRecord."
msgstr "레코드를 설정합니다."

#: flwr.common.record.arrayrecord.ArrayRecord.inflate:5 of
msgid ""
"Dictionary of children InflatableObjects mapped to their Object IDs. "
"These children enable the full inflation of the ArrayRecord."
msgstr ""

#: flwr.common.record.arrayrecord.ArrayRecord.inflate:9 of
#, fuzzy
msgid "The inflated ArrayRecord."
msgstr "메트릭 기록."

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:2
#, fuzzy
msgid "ConfigRecord"
msgstr "컨피그 레코드"

#: flwr.common.record.configrecord.ConfigRecord:1 of
#, fuzzy
msgid ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`int` | :py:class:`float` | :py:class:`str` |"
" :py:class:`bytes` | :py:class:`bool` | :py:class:`list`\\ "
"[:py:class:`int`] | :py:class:`list`\\ [:py:class:`float`] | "
":py:class:`list`\\ [:py:class:`str`] | :py:class:`list`\\ "
"[:py:class:`bytes`] | :py:class:`list`\\ [:py:class:`bool`]], "
":py:class:`~flwr.common.inflatable.InflatableObject`"
msgstr ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`int` | :py:class:`float` | :py:class:`str` |"
" :py:class:`bytes` | :py:class:`bool` | :py:class:`~typing.List`\\ "
"[:py:class:`int`] | :py:class:`~typing.List`\\ [:py:class:`float`] | "
":py:class:`~typing.List`\\ [:py:class:`str`] | :py:class:`~typing.List`\\"
" [:py:class:`bytes`] | :py:class:`~typing.List`\\ [:py:class:`bool`]]"

#: flwr.common.record.configrecord.ConfigRecord:3 of
msgid ""
"A :code:`ConfigRecord` is a Python dictionary designed to ensure that "
"each key-value pair adheres to specified data types. A "
":code:`ConfigRecord` is one of the types of records that a "
"`flwr.common.RecordDict <flwr.common.RecordDict.html#recorddict>`_ "
"supports and can therefore be used to construct :code:`common.Message` "
"objects."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord:9 of
msgid ""
"A dictionary that stores basic types (i.e. `str`, `int`, `float`, `bytes`"
" as defined in `ConfigsScalar`) and lists of such types (see "
"`ConfigsScalarList`)."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord:13 of
msgid ""
"A boolean indicating whether config passed should be deleted from the "
"input dictionary immediately after adding them to the record. When set to"
" True, the data is duplicated in memory. If memory is a concern, set it "
"to False."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord:21 of
msgid ""
"The usage of a :code:`ConfigRecord` is envisioned for sending "
"configuration values telling the target node how to perform a certain "
"action (e.g. train/evaluate a model ). You can use standard Python built-"
"in types such as :code:`float`, :code:`str` , :code:`bytes`. All types "
"allowed are defined in :code:`flwr.common.ConfigRecordValues`. While "
"lists are supported, we encourage you to use a :code:`ArrayRecord` "
"instead if these are of high dimensionality."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord:29 of
msgid ""
"Let's see some examples of how to construct a :code:`ConfigRecord` from "
"scratch::"
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord:42 of
msgid ""
"Just like the other types of records in a :code:`flwr.common.RecordDict`,"
" types are enforced. If you need to add a custom data structure or "
"object, we recommend to serialise it into bytes and save it as such "
"(bytes are allowed in a :code:`ConfigRecord`)"
msgstr ""

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`clear <flwr.app.ConfigRecord.clear>`\\ \\(\\)"
msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`copy <flwr.app.ConfigRecord.copy>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`count_bytes <flwr.app.ConfigRecord.count_bytes>`\\ \\(\\)"
msgstr ":py:obj:`count_bytes <flwr.common.ConfigsRecord.count_bytes>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`deflate <flwr.app.ConfigRecord.deflate>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: flwr.common.record.configrecord.ConfigRecord.deflate:1
#: flwr.common.record.metricrecord.MetricRecord.deflate:1 of
msgid "Deflate object."
msgstr ""

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`get <flwr.app.ConfigRecord.get>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`inflate <flwr.app.ConfigRecord.inflate>`\\ "
"\\(object\\_content\\[\\, children\\]\\)"
msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#: flwr.common.record.configrecord.ConfigRecord.inflate:1 of
msgid "Inflate a ConfigRecord from bytes."
msgstr ""

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`items <flwr.app.ConfigRecord.items>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`keys <flwr.app.ConfigRecord.keys>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`pop <flwr.app.ConfigRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`pop <flwr.common.ConfigsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`popitem <flwr.app.ConfigRecord.popitem>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`setdefault <flwr.app.ConfigRecord.setdefault>`\\ "
"\\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`update <flwr.app.ConfigRecord.update>`\\ \\(\\[E\\, \\]\\*\\*F\\)"
msgstr ""
":py:obj:`update <flwr.common.ConfigsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: ../../source/ref-api/flwr.app.ConfigRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`values <flwr.app.ConfigRecord.values>`\\ \\(\\)"
msgstr ":py:obj:`values <flwr.common.ConfigsRecord.values>`\\ \\(\\)"

#: flwr.app.ConfigRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`children <flwr.app.ConfigRecord.children>`\\"
msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#: flwr.app.ConfigRecord.children:1
#: flwr.app.ConfigRecord.children:1:<autosummary>:1
#: flwr.app.MetricRecord.children:1
#: flwr.app.MetricRecord.children:1:<autosummary>:1 of
msgid "Get all child objects as a dictionary or None if there are no children."
msgstr ""

#: flwr.app.ConfigRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`is_dirty <flwr.app.ConfigRecord.is_dirty>`\\"
msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#: flwr.app.ConfigRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`object_id <flwr.app.ConfigRecord.object_id>`\\"
msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#: flwr.app.ConfigRecord.children:1:<autosummary>:1
#: flwr.app.ConfigRecord.object_id:1
#: flwr.app.Message.children:1:<autosummary>:1 flwr.app.Message.object_id:1
#: flwr.app.MetricRecord.children:1:<autosummary>:1
#: flwr.app.MetricRecord.object_id:1
#: flwr.app.RecordDict.array_records:1:<autosummary>:1
#: flwr.app.RecordDict.object_id:1 of
msgid "Get object_id."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord.count_bytes:3 of
msgid "This function counts booleans as occupying 1 Byte."
msgstr "이 함수는 booleans을 1바이트를 차지하는 것으로 계산합니다."

#: flwr.common.record.configrecord.ConfigRecord.inflate:3 of
msgid "The deflated object content of the ConfigRecord."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord.inflate:5 of
msgid ""
"Must be ``None``. ``ConfigRecord`` does not support child objects. "
"Providing any children will raise a ``ValueError``."
msgstr ""

#: flwr.common.record.configrecord.ConfigRecord.inflate:9 of
#, fuzzy
msgid "The inflated ConfigRecord."
msgstr "레코드를 설정합니다."

#: flwr.app.ConfigRecord.is_dirty:3 flwr.app.Message.is_dirty:3
#: flwr.app.MetricRecord.is_dirty:3 flwr.app.RecordDict.is_dirty:3 of
msgid ""
"An object is considered dirty if its content has changed since the last "
"its object ID was computed."
msgstr ""

#: ../../source/ref-api/flwr.app.Context.rst:2
msgid "Context"
msgstr "컨텍스트"

#: flwr.app.error.Error:1 flwr.app.metadata.Metadata:1
#: flwr.clientapp.client_app.ClientApp:1
#: flwr.clientapp.mod.localdp_mod.LocalDpMod:1
#: flwr.common.constant.MessageType:1 flwr.common.context.Context:1
#: flwr.server.server_app.ServerApp:1 flwr.serverapp.strategy.result.Result:1
#: of
msgid "Bases: :py:class:`object`"
msgstr "Bases: :py:class:`object`"

#: flwr.common.context.Context:3 of
#, fuzzy
msgid "The ID that identifies the run."
msgstr "오류 식별자입니다."

#: flwr.common.context.Context:5 of
#, fuzzy
msgid "The ID that identifies the node."
msgstr "오류 식별자입니다."

#: flwr.common.context.Context:7 of
msgid ""
"A config (key/value mapping) unique to the node and independent of the "
"`run_config`. This config persists across all runs this node participates"
" in."
msgstr ""

#: flwr.common.context.Context:10 of
#, fuzzy
msgid ""
"Holds records added by the entity in a given `run_id` and that will stay "
"local. This means that the data it holds will never leave the system it's"
" running from. This can be used as an intermediate storage or scratchpad "
"when executing mods. It can also be used as a memory to access at "
"different points during the lifecycle of this entity (e.g. across "
"multiple rounds)"
msgstr ""
"특정 실행에서 엔티티가 추가한 레코드를 보유하며 로컬에 유지됩니다. 즉, 저장된 데이터는 실행 중인 시스템을 벗어나지 않습니다. "
"모드를 실행할 때 중간 저장소나 스크래치 패드로 사용할 수 있습니다. 또한 이 엔티티의 수명 주기 동안 다른 시점에서 액세스하기 "
"위한 메모리로도 사용할 수 있습니다(예: 여러 라운드에 걸쳐)"

#: flwr.common.context.Context:17 of
msgid ""
"A config (key/value mapping) held by the entity in a given `run_id` and "
"that will stay local. It can be used at any point during the lifecycle of"
" this entity (e.g. across multiple rounds)"
msgstr ""

#: ../../source/ref-api/flwr.app.Context.rst:32:<autosummary>:1
#, fuzzy
msgid ":py:obj:`run_id <flwr.app.Context.run_id>`\\"
msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#: ../../source/ref-api/flwr.app.Context.rst:32:<autosummary>:1
#, fuzzy
msgid ":py:obj:`node_id <flwr.app.Context.node_id>`\\"
msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#: ../../source/ref-api/flwr.app.Context.rst:32:<autosummary>:1
#, fuzzy
msgid ":py:obj:`node_config <flwr.app.Context.node_config>`\\"
msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#: ../../source/ref-api/flwr.app.Context.rst:32:<autosummary>:1
#, fuzzy
msgid ":py:obj:`state <flwr.app.Context.state>`\\"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: ../../source/ref-api/flwr.app.Context.rst:32:<autosummary>:1
#, fuzzy
msgid ":py:obj:`run_config <flwr.app.Context.run_config>`\\"
msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#: ../../source/ref-api/flwr.app.Error.rst:2
msgid "Error"
msgstr "오류"

#: flwr.app.error.Error:3 of
msgid "An identifier for the error."
msgstr "오류 식별자입니다."

#: flwr.app.error.Error:5 of
msgid "A reason for why the error arose (e.g. an exception stack-trace)"
msgstr "오류가 발생한 이유(예: 예외 스택 추적)"

#: flwr.app.Error.code:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`code <flwr.app.Error.code>`\\"
msgstr ":py:obj:`code <flwr.common.Error.code>`\\"

#: flwr.app.Error.code:1 flwr.app.Error.code:1:<autosummary>:1 of
msgid "Error code."
msgstr "오류 코드."

#: flwr.app.Error.code:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`reason <flwr.app.Error.reason>`\\"
msgstr ":py:obj:`reason <flwr.common.Error.reason>`\\"

#: flwr.app.Error.code:1:<autosummary>:1 flwr.app.Error.reason:1 of
msgid "Reason reported about the error."
msgstr "오류에 대해 보고된 사유입니다."

#: ../../source/ref-api/flwr.app.Message.rst:2
msgid "Message"
msgstr "Message"

#: flwr.common.message.Message:3 of
msgid ""
"This class encapsulates the payload and metadata necessary for "
"communication between a ClientApp and a ServerApp."
msgstr ""

#: flwr.common.message.Message:6 of
msgid ""
"Holds records either sent by another entity (e.g. sent by the server-side"
" logic to a client, or vice-versa) or that will be sent to it."
msgstr "다른 엔터티(예: 서버 측 로직이 클라이언트로 전송하거나 그 반대로 전송하는 등)가 전송했거나 전송할 레코드를 보유합니다."

#: flwr.common.message.Message:9 of
msgid ""
"A dataclass that captures information about an error that took place when"
" processing another message."
msgstr "다른 메시지를 처리할 때 발생한 오류에 대한 정보를 캡처하는 데이터 클래스입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1
#: flwr.app.Metadata.dst_node_id:1 flwr.app.metadata.Metadata:9
#: flwr.common.message.Message:12 of
msgid "An identifier for the node receiving this message."
msgstr "이 메시지를 수신하는 노드의 식별자입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1
#: flwr.app.Metadata.message_type:1 flwr.app.metadata.Metadata:20
#: flwr.common.message.Message:14 of
msgid "A string that encodes the action to be executed on the receiving end."
msgstr "수신 측에서 실행할 작업을 인코딩하는 문자열입니다."

#: flwr.common.message.Message:17 of
msgid ""
"Time-to-live (TTL) for this message in seconds. If `None` (default), the "
"TTL is set to 43,200 seconds (12 hours)."
msgstr ""

#: flwr.app.metadata.Metadata:13 flwr.common.message.Message:20 of
msgid ""
"An identifier for grouping messages. In some settings, this is used as "
"the FL round."
msgstr "메시지를 그룹화하기 위한 식별자입니다. 일부 설정에서는 FL 라운드로 사용됩니다."

#: flwr.common.message.Message:23 of
msgid ""
"The instruction message to which this message is a reply. This message "
"does not retain the original message's content but derives its metadata "
"from it."
msgstr ""

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`create_error_reply <flwr.app.Message.create_error_reply>`\\ "
"\\(error\\[\\, ttl\\]\\)"
msgstr ""
":py:obj:`create_error_reply <flwr.common.Message.create_error_reply>`\\ "
"\\(error\\[\\, ttl\\]\\)"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#: flwr.common.message.Message.create_error_reply:1 of
msgid "Construct a reply message indicating an error happened."
msgstr "오류가 발생했음을 나타내는 답장 메시지를 작성합니다."

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`create_reply <flwr.app.Message.create_reply>`\\ \\(content\\[\\,"
" ttl\\]\\)"
msgstr ""
":py:obj:`create_reply <flwr.common.Message.create_reply>`\\ "
"\\(content\\[\\, ttl\\]\\)"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#: flwr.common.message.Message.create_reply:1 of
msgid "Create a reply to this message with specified content and TTL."
msgstr "지정된 콘텐츠와 TTL을 사용하여 이 메시지에 대한 답글을 작성합니다."

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`deflate <flwr.app.Message.deflate>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#: flwr.common.message.Message.deflate:1 of
#, fuzzy
msgid "Deflate message."
msgstr "ServerMessage"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`has_content <flwr.app.Message.has_content>`\\ \\(\\)"
msgstr ":py:obj:`has_content <flwr.common.Message.has_content>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#: flwr.common.message.Message.has_content:1 of
msgid "Return True if message has content, else False."
msgstr "메시지에 콘텐츠가 있으면 True을 반환하고, 그렇지 않으면 False을 반환합니다."

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`has_error <flwr.app.Message.has_error>`\\ \\(\\)"
msgstr ":py:obj:`has_error <flwr.common.Message.has_error>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#: flwr.common.message.Message.has_error:1 of
msgid "Return True if message has an error, else False."
msgstr "메시지에 오류가 있으면 True을 반환하고, 그렇지 않으면 False을 반환합니다."

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`inflate <flwr.app.Message.inflate>`\\ \\(object\\_content\\[\\, "
"children\\]\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.Message.rst:41:<autosummary>:1
#: flwr.common.message.Message.inflate:1 of
#, fuzzy
msgid "Inflate an Message from bytes."
msgstr "바이트에서 NumPy를 역직렬화합니다."

#: flwr.app.Message.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`children <flwr.app.Message.children>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.Message.children:1 flwr.app.Message.children:1:<autosummary>:1 of
msgid "Return a dictionary of a single RecordDict with its Object IDs as key."
msgstr ""

#: flwr.app.Message.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`content <flwr.app.Message.content>`\\"
msgstr ":py:obj:`content <flwr.common.Message.content>`\\"

#: flwr.app.Message.children:1:<autosummary>:1 flwr.app.Message.content:1 of
msgid "The content of this message."
msgstr "이 메시지의 내용입니다."

#: flwr.app.Message.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`error <flwr.app.Message.error>`\\"
msgstr ":py:obj:`error <flwr.common.Message.error>`\\"

#: flwr.app.Message.children:1:<autosummary>:1 flwr.app.Message.error:1 of
msgid "Error captured by this message."
msgstr "이 메시지가 캡처한 오류입니다."

#: flwr.app.Message.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`is_dirty <flwr.app.Message.is_dirty>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.Message.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`metadata <flwr.app.Message.metadata>`\\"
msgstr ":py:obj:`metadata <flwr.common.Message.metadata>`\\"

#: flwr.app.Message.children:1:<autosummary>:1 flwr.app.Message.metadata:1 of
msgid "A dataclass including information about the message to be executed."
msgstr "실행할 메시지에 대한 정보를 포함한 데이터 클래스입니다."

#: flwr.app.Message.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`object_id <flwr.app.Message.object_id>`\\"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: flwr.common.message.Message.create_error_reply:3 of
msgid "The error that was encountered."
msgstr "오류가 발생했습니다."

#: flwr.common.message.Message.create_error_reply:5
#: flwr.common.message.Message.create_reply:9 of
msgid ""
"Time-to-live for this message in seconds. If unset, it will be set based "
"on the remaining time for the received message before it expires. This "
"follows the equation:  ttl = msg.meta.ttl - (reply.meta.created_at - "
"msg.meta.created_at)"
msgstr ""
"이 메시지의 남은 시간(초)입니다. 설정하지 않으면 수신된 메시지가 만료되기 전까지 남은 시간을 기준으로 설정됩니다. 이는 다음과 "
"같은 공식을 따릅니다: ttl = msg.meta.ttl - (reply.meta.created_at - "
"msg.meta.created_at)"

#: flwr.common.message.Message.create_error_reply:5
#: flwr.common.message.Message.create_reply:9 of
msgid ""
"Time-to-live for this message in seconds. If unset, it will be set based "
"on the remaining time for the received message before it expires. This "
"follows the equation:"
msgstr ""
"이 메시지의 남은 시간(초)입니다. 설정하지 않으면 수신된 메시지가 만료되기 전까지 남은 시간을 기준으로 설정됩니다. 이는 다음 "
"공식을 따릅니다:"

#: flwr.common.message.Message.create_error_reply:9
#: flwr.common.message.Message.create_reply:13 of
msgid "ttl = msg.meta.ttl - (reply.meta.created_at - msg.meta.created_at)"
msgstr "ttl = msg.meta.ttl - (reply.meta.created_at - msg.meta.created_at)"

#: flwr.common.message.Message.create_error_reply:12 of
msgid "**message** -- A Message containing only the relevant error and metadata."
msgstr ""

#: flwr.common.message.Message.create_reply:3 of
#, fuzzy
msgid ""
"The method generates a new `Message` as a reply to this message. It "
"inherits 'run_id', 'src_node_id', 'dst_node_id', and 'message_type' from "
"this message and sets 'reply_to_message_id' to the ID of this message."
msgstr ""
"이 메서드는 이 메시지에 대한 응답으로 새로운 '메시지'를 생성합니다. 이 메시지에서 'run_id', 'src_node_id', "
"'dst_node_id', 'message_type'을 상속하고 'reply_to_message'를 이 메시지의 ID로 설정합니다."

#: flwr.common.message.Message.create_reply:7 of
msgid "The content for the reply message."
msgstr "답장 메시지의 콘텐츠입니다."

#: flwr.common.message.Message.create_reply:16 of
msgid "A new `Message` instance representing the reply."
msgstr "답장을 나타내는 새로운 `메시지` 인스턴스입니다."

#: flwr.common.message.Message.inflate:3 of
#, fuzzy
msgid "The deflated object content of the Message."
msgstr "레코드를 설정합니다."

#: flwr.common.message.Message.inflate:5 of
msgid ""
"Dictionary of children InflatableObjects mapped to their Object IDs. "
"These children enable the full inflation of the Message."
msgstr ""

#: flwr.common.message.Message.inflate:9 of
#, fuzzy
msgid "The inflated Message."
msgstr "메트릭 기록."

#: ../../source/ref-api/flwr.app.MessageType.rst:2
msgid "MessageType"
msgstr "MessageType"

#: ../../source/ref-api/flwr.app.MessageType.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`EVALUATE <flwr.app.MessageType.EVALUATE>`\\"
msgstr ":py:obj:`EVALUATE <flwr.common.MessageType.EVALUATE>`\\"

#: ../../source/ref-api/flwr.app.MessageType.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`QUERY <flwr.app.MessageType.QUERY>`\\"
msgstr ":py:obj:`QUERY <flwr.common.MessageType.QUERY>`\\"

#: ../../source/ref-api/flwr.app.MessageType.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`SYSTEM <flwr.app.MessageType.SYSTEM>`\\"
msgstr ":py:obj:`TRAIN <flwr.common.MessageType.TRAIN>`\\"

#: ../../source/ref-api/flwr.app.MessageType.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`TRAIN <flwr.app.MessageType.TRAIN>`\\"
msgstr ":py:obj:`TRAIN <flwr.common.MessageType.TRAIN>`\\"

#: ../../source/ref-api/flwr.app.Metadata.rst:2
msgid "Metadata"
msgstr "Metadata"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 flwr.app.Metadata.run_id:1
#: flwr.app.metadata.Metadata:3 of
msgid "An identifier for the current run."
msgstr "현재 실행에 대한 식별자입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1
#: flwr.app.Metadata.message_id:1 flwr.app.metadata.Metadata:5 of
msgid "An identifier for the current message."
msgstr "현재 메시지의 식별자입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1
#: flwr.app.Metadata.src_node_id:1 flwr.app.metadata.Metadata:7 of
msgid "An identifier for the node sending this message."
msgstr "이 메시지를 보내는 노드의 식별자입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1
#: flwr.app.Metadata.reply_to_message_id:1 flwr.app.metadata.Metadata:11 of
#, fuzzy
msgid "An identifier for the message to which this message is a reply."
msgstr "이 메시지가 회신하는 메시지의 식별자입니다."

#: flwr.app.Metadata.created_at:1
#: flwr.app.Metadata.created_at:1:<autosummary>:1 flwr.app.metadata.Metadata:16
#: of
msgid "Unix timestamp when the message was created."
msgstr "메시지가 생성된 때의 Unix timestamp입니다."

#: flwr.app.metadata.Metadata:18 of
msgid "Time-to-live for this message in seconds."
msgstr "이 메시지의 유효 시간(초)입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`created_at <flwr.app.Metadata.created_at>`\\"
msgstr ":py:obj:`created_at <flwr.common.Metadata.created_at>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`delivered_at <flwr.app.Metadata.delivered_at>`\\"
msgstr ":py:obj:`created_at <flwr.common.Metadata.created_at>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1
#: flwr.app.Metadata.delivered_at:1 of
#, fuzzy
msgid "Unix timestamp when the message was delivered."
msgstr "메시지가 생성된 때의 Unix timestamp입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`dst_node_id <flwr.app.Metadata.dst_node_id>`\\"
msgstr ":py:obj:`dst_node_id <flwr.common.Metadata.dst_node_id>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`group_id <flwr.app.Metadata.group_id>`\\"
msgstr ":py:obj:`group_id <flwr.common.Metadata.group_id>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 flwr.app.Metadata.group_id:1
#: of
msgid "An identifier for grouping messages."
msgstr "메시지를 그룹화하기 위한 식별자입니다."

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`message_id <flwr.app.Metadata.message_id>`\\"
msgstr ":py:obj:`message_id <flwr.common.Metadata.message_id>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`message_type <flwr.app.Metadata.message_type>`\\"
msgstr ":py:obj:`message_type <flwr.common.Metadata.message_type>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`reply_to_message_id <flwr.app.Metadata.reply_to_message_id>`\\"
msgstr ":py:obj:`reply_to_message <flwr.common.Metadata.reply_to_message>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`run_id <flwr.app.Metadata.run_id>`\\"
msgstr ":py:obj:`run_id <flwr.common.Metadata.run_id>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`src_node_id <flwr.app.Metadata.src_node_id>`\\"
msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`ttl <flwr.app.Metadata.ttl>`\\"
msgstr ":py:obj:`ttl <flwr.common.Metadata.ttl>`\\"

#: flwr.app.Metadata.created_at:1:<autosummary>:1 flwr.app.Metadata.ttl:1 of
msgid "Time-to-live for this message."
msgstr "이 메시지를 기다리는 시간입니다."

#: ../../source/ref-api/flwr.app.MetricRecord.rst:2
#, fuzzy
msgid "MetricRecord"
msgstr "MetricsRecord"

#: flwr.common.record.metricrecord.MetricRecord:1 of
#, fuzzy
msgid ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`int` | :py:class:`float` | "
":py:class:`list`\\ [:py:class:`int`] | :py:class:`list`\\ "
"[:py:class:`float`]], "
":py:class:`~flwr.common.inflatable.InflatableObject`"
msgstr ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`int` | :py:class:`float` | "
":py:class:`~typing.List`\\ [:py:class:`int`] | :py:class:`~typing.List`\\"
" [:py:class:`float`]]"

#: flwr.common.record.metricrecord.MetricRecord:3 of
msgid ""
"A :code:`MetricRecord` is a Python dictionary designed to ensure that "
"each key-value pair adheres to specified data types. A "
":code:`MetricRecord` is one of the types of records that a "
"`flwr.common.RecordDict <flwr.common.RecordDict.html#recorddict>`_ "
"supports and can therefore be used to construct :code:`common.Message` "
"objects."
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord:9 of
msgid ""
"A dictionary that stores basic types (i.e. `int`, `float` as defined in "
"`MetricScalar`) and list of such types (see `MetricScalarList`)."
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord:12 of
msgid ""
"A boolean indicating whether metrics should be deleted from the input "
"dictionary immediately after adding them to the record. When set to True,"
" the data is duplicated in memory. If memory is a concern, set it to "
"False."
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord:20 of
msgid ""
"The usage of a :code:`MetricRecord` is envisioned for communicating "
"results obtained when a node performs an action. A few typical examples "
"include: communicating the training accuracy after a model is trained "
"locally by a :code:`ClientApp`, reporting the validation loss obtained at"
" a :code:`ClientApp`, or, more generally, the output of executing a query"
" by the :code:`ClientApp`. Common to these examples is that the output "
"can be typically represented by a single scalar (:code:`int`, "
":code:`float`) or list of scalars."
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord:28 of
msgid ""
"Let's see some examples of how to construct a :code:`MetricRecord` from "
"scratch::"
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord:39 of
msgid ""
"Since types are enforced, the types of the objects inserted are checked. "
"For a :code:`MetricRecord`, value types allowed are those in defined in "
":code:`flwr.common.MetricRecordValues`. Similarly, only :code:`str` keys "
"are allowed::"
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord:50 of
msgid ""
"If you need a more versatily type of record try :code:`ConfigRecord` or "
":code:`ArrayRecord`."
msgstr ""

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`clear <flwr.app.MetricRecord.clear>`\\ \\(\\)"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`copy <flwr.app.MetricRecord.copy>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`count_bytes <flwr.app.MetricRecord.count_bytes>`\\ \\(\\)"
msgstr ":py:obj:`count_bytes <flwr.common.MetricsRecord.count_bytes>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`deflate <flwr.app.MetricRecord.deflate>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`get <flwr.app.MetricRecord.get>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`inflate <flwr.app.MetricRecord.inflate>`\\ "
"\\(object\\_content\\[\\, children\\]\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#: flwr.common.record.metricrecord.MetricRecord.inflate:1 of
msgid "Inflate a MetricRecord from bytes."
msgstr ""

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`items <flwr.app.MetricRecord.items>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`keys <flwr.app.MetricRecord.keys>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`pop <flwr.app.MetricRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`popitem <flwr.app.MetricRecord.popitem>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`setdefault <flwr.app.MetricRecord.setdefault>`\\ "
"\\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`update <flwr.app.MetricRecord.update>`\\ \\(\\[E\\, \\]\\*\\*F\\)"
msgstr ""
":py:obj:`update <flwr.common.MetricsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: ../../source/ref-api/flwr.app.MetricRecord.rst:62:<autosummary>:1
#, fuzzy
msgid ":py:obj:`values <flwr.app.MetricRecord.values>`\\ \\(\\)"
msgstr ""
":py:obj:`update <flwr.common.MetricsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: flwr.app.MetricRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`children <flwr.app.MetricRecord.children>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.MetricRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`is_dirty <flwr.app.MetricRecord.is_dirty>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.MetricRecord.children:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`object_id <flwr.app.MetricRecord.object_id>`\\"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: flwr.common.record.metricrecord.MetricRecord.inflate:3 of
msgid "The deflated object content of the MetricRecord."
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord.inflate:5 of
msgid ""
"Must be ``None``. ``MetricRecord`` does not support child objects. "
"Providing any children will raise a ``ValueError``."
msgstr ""

#: flwr.common.record.metricrecord.MetricRecord.inflate:9 of
#, fuzzy
msgid "The inflated MetricRecord."
msgstr "메트릭 기록."

#: ../../source/ref-api/flwr.app.RecordDict.rst:2
#, fuzzy
msgid "RecordDict"
msgstr "RecordSet"

#: flwr.common.record.recorddict.RecordDict:1 of
#, fuzzy
msgid ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`~flwr.common.record.arrayrecord.ArrayRecord`"
" | :py:class:`~flwr.common.record.metricrecord.MetricRecord` | "
":py:class:`~flwr.common.record.configrecord.ConfigRecord`], "
":py:class:`~flwr.common.inflatable.InflatableObject`"
msgstr ""
"Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
"[:py:class:`str`, :py:class:`~flwr.common.record.parametersrecord.Array`]"

#: flwr.common.record.recorddict.RecordDict:3 of
msgid ""
"A :class:`RecordDict` is the unified mechanism by which arrays, metrics "
"and configs can be either stored as part of a :class:`Context` in your "
"apps or communicated as part of a :class:`Message` between your apps."
msgstr ""

#: flwr.common.record.recorddict.RecordDict:8 of
msgid ""
"A dictionary mapping string keys to record instances, where each value is"
" either a :class:`ParametersRecord`, :class:`MetricsRecord`, or "
":class:`ConfigsRecord`."
msgstr ""

#: flwr.common.record.recorddict.RecordDict:15 of
msgid ""
"A :class:`RecordDict` can hold three types of records, each designed with"
" an specific purpose. What is common to all of them is that they are "
"Python dictionaries designed to ensure that each key-value pair adheres "
"to specified data types."
msgstr ""

#: flwr.common.record.recorddict.RecordDict:20 of
#, fuzzy
msgid "Let's see an example::"
msgstr "몇 가지 예를 살펴보겠습니다:"

#: flwr.common.record.recorddict.RecordDict:38 of
msgid ""
"Adding an :code:`ArrayRecord` follows the same steps as above but first, "
"the array needs to be serialized and represented as a "
":code:`flwr.common.Array`. For example::"
msgstr ""

#: flwr.common.record.recorddict.RecordDict:55 of
msgid ""
"For additional examples on how to construct each of the records types "
"shown above, please refer to the documentation for :code:`ConfigRecord`, "
":code:`MetricRecord` and :code:`ArrayRecord`."
msgstr ""

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`clear <flwr.app.RecordDict.clear>`\\ \\(\\)"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`copy <flwr.app.RecordDict.copy>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`deflate <flwr.app.RecordDict.deflate>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#: flwr.common.record.recorddict.RecordDict.deflate:1 of
#, fuzzy
msgid "Deflate the RecordDict."
msgstr "메트릭 기록."

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`get <flwr.app.RecordDict.get>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`inflate <flwr.app.RecordDict.inflate>`\\ "
"\\(object\\_content\\[\\, children\\]\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#: flwr.common.record.recorddict.RecordDict.inflate:1 of
#, fuzzy
msgid "Inflate an RecordDict from bytes."
msgstr "바이트에서 NumPy를 역직렬화합니다."

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`items <flwr.app.RecordDict.items>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`keys <flwr.app.RecordDict.keys>`\\ \\(\\)"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`pop <flwr.app.RecordDict.pop>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`popitem <flwr.app.RecordDict.popitem>`\\ \\(\\)"
msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`setdefault <flwr.app.RecordDict.setdefault>`\\ \\(k\\[\\,d\\]\\)"
msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`update <flwr.app.RecordDict.update>`\\ \\(\\[E\\, \\]\\*\\*F\\)"
msgstr ""
":py:obj:`update <flwr.common.MetricsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: ../../source/ref-api/flwr.app.RecordDict.rst:59:<autosummary>:1
#, fuzzy
msgid ":py:obj:`values <flwr.app.RecordDict.values>`\\ \\(\\)"
msgstr ""
":py:obj:`update <flwr.common.MetricsRecord.update>`\\ \\(\\[E\\, "
"\\]\\*\\*F\\)"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`array_records <flwr.app.RecordDict.array_records>`\\"
msgstr ":py:obj:`parameters_records <flwr.common.RecordSet.parameters_records>`\\"

#: flwr.app.RecordDict.array_records:1
#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid "Dictionary holding only ArrayRecord instances."
msgstr "Dictionary holding ParametersRecord instances."

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`children <flwr.app.RecordDict.children>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1
#: flwr.app.RecordDict.children:1 of
msgid "Return a dictionary of records with their Object IDs as keys."
msgstr ""

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`config_records <flwr.app.RecordDict.config_records>`\\"
msgstr ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1
#: flwr.app.RecordDict.config_records:1 of
#, fuzzy
msgid "Dictionary holding only ConfigRecord instances."
msgstr "Dictionary holding ConfigsRecord instances."

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`configs_records <flwr.app.RecordDict.configs_records>`\\"
msgstr ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1
#: flwr.app.RecordDict.configs_records:1 flwr.app.RecordDict.metrics_records:1
#: flwr.app.RecordDict.parameters_records:1 of
msgid "Deprecated property."
msgstr ""

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`is_dirty <flwr.app.RecordDict.is_dirty>`\\"
msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`metric_records <flwr.app.RecordDict.metric_records>`\\"
msgstr ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1
#: flwr.app.RecordDict.metric_records:1 of
#, fuzzy
msgid "Dictionary holding only MetricRecord instances."
msgstr "Dictionary holding MetricsRecord instances."

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`metrics_records <flwr.app.RecordDict.metrics_records>`\\"
msgstr ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`object_id <flwr.app.RecordDict.object_id>`\\"
msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#: flwr.app.RecordDict.array_records:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`parameters_records <flwr.app.RecordDict.parameters_records>`\\"
msgstr ":py:obj:`parameters_records <flwr.common.RecordSet.parameters_records>`\\"

#: flwr.app.RecordDict.configs_records:3 of
msgid "Use ``config_records`` instead."
msgstr ""

#: flwr.common.record.recorddict.RecordDict.inflate:3 of
#, fuzzy
msgid "The deflated object content of the RecordDict."
msgstr "레코드를 설정합니다."

#: flwr.common.record.recorddict.RecordDict.inflate:5 of
msgid ""
"Dictionary of children InflatableObjects mapped to their Object IDs. "
"These children enable the full inflation of the RecordDict. Default is "
"None."
msgstr ""

#: flwr.common.record.recorddict.RecordDict.inflate:9 of
#, fuzzy
msgid "The inflated RecordDict."
msgstr "메트릭 기록."

#: flwr.app.RecordDict.metrics_records:3 of
msgid "Use ``metric_records`` instead."
msgstr ""

#: flwr.app.RecordDict.parameters_records:3 of
msgid "Use ``array_records`` instead."
msgstr ""

#: ../../source/ref-api/flwr.clientapp.rst:2
#, fuzzy
msgid "clientapp"
msgstr "클라이언트앱"

#: ../../source/ref-api/flwr.clientapp.rst:22:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`ClientApp <flwr.clientapp.ClientApp>`\\ \\(\\[client\\_fn\\, "
"mods\\]\\)"
msgstr ""
":py:obj:`ClientApp <flwr.client.ClientApp>`\\ \\(\\[client\\_fn\\, "
"mods\\]\\)"

#: ../../source/ref-api/flwr.clientapp.rst:22:<autosummary>:1
#: flwr.clientapp.client_app.ClientApp:1 of
msgid "Flower ClientApp."
msgstr "Flower ClientApp."

#: ../../source/ref-api/flwr.clientapp.rst:40:<autosummary>:1
#, fuzzy
msgid ":py:obj:`flwr.clientapp.mod <flwr.clientapp.mod>`\\"
msgstr ":py:obj:`flwr.client.mod <flwr.client.mod>`\\"

#: ../../source/ref-api/flwr.clientapp.rst:40:<autosummary>:1
#: flwr.clientapp.mod:1 of
msgid "Flower Built-in Mods."
msgstr "Flower 내장 모드."

#: flwr.clientapp.client_app.ClientApp:5 of
#, fuzzy
msgid ""
"Assuming a typical ``Client`` implementation named ``FlowerClient``, you "
"can wrap it in a ``ClientApp`` as follows::"
msgstr ""
"일반적인 `Client` 구현의 이름이 `FlowerClient`라고 가정하면, 다음과 같이 `ClientApp`으로 래핑할 수 "
"있습니다:"

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1 of
#, fuzzy
msgid ""
":py:obj:`evaluate <flwr.clientapp.ClientApp.evaluate>`\\ \\(\\[action\\, "
"mods\\]\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.clientapp.client_app.ClientApp.evaluate:1
#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1 of
#, fuzzy
msgid "Register an evaluate function with the ``ClientApp``."
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`lifespan <flwr.clientapp.ClientApp.lifespan>`\\ \\(\\)"
msgstr ":py:obj:`Client <flwr.client.Client>`\\ \\(\\)"

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1
#: flwr.clientapp.client_app.ClientApp.lifespan:1 of
#, fuzzy
msgid "Return a decorator that registers the lifespan fn with the client app."
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1 of
#, fuzzy
msgid ""
":py:obj:`query <flwr.clientapp.ClientApp.query>`\\ \\(\\[action\\, "
"mods\\]\\)"
msgstr ":py:obj:`query <flwr.client.ClientApp.query>`\\ \\(\\)"

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1
#: flwr.clientapp.client_app.ClientApp.query:1 of
#, fuzzy
msgid "Register a query function with the ``ClientApp``."
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1 of
#, fuzzy
msgid ""
":py:obj:`train <flwr.clientapp.ClientApp.train>`\\ \\(\\[action\\, "
"mods\\]\\)"
msgstr ":py:obj:`train <flwr.client.ClientApp.train>`\\ \\(\\)"

#: flwr.clientapp.client_app.ClientApp.evaluate:1:<autosummary>:1
#: flwr.clientapp.client_app.ClientApp.train:1 of
#, fuzzy
msgid "Register a train function with the ``ClientApp``."
msgstr "클라이언트 앱에 train fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:3
#: flwr.clientapp.client_app.ClientApp.query:3
#: flwr.clientapp.client_app.ClientApp.train:3 of
msgid "The action name used to route messages. Defaults to \"default\"."
msgstr ""

#: flwr.clientapp.client_app.ClientApp.evaluate:5
#: flwr.clientapp.client_app.ClientApp.query:5
#: flwr.clientapp.client_app.ClientApp.train:5 of
#, fuzzy
msgid "A list of function-specific modifiers."
msgstr "CLI 시뮬레이션"

#: flwr.clientapp.client_app.ClientApp.evaluate:8 of
#, fuzzy
msgid "A decorator that registers an evaluate function with the ``ClientApp``."
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:13 of
#, fuzzy
msgid "Registering an evaluate function::"
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:23 of
#, fuzzy
msgid "Registering an evaluate function with a custom action name::"
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.evaluate:34 of
#, fuzzy
msgid "Registering an evaluate function with a function-specific Flower Mod::"
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.lifespan:3
#: flwr.server.server_app.ServerApp.lifespan:3 of
msgid ""
"The decorated function should accept a `Context` object and use `yield` "
"to define enter and exit behavior."
msgstr ""

#: flwr.clientapp.client_app.ClientApp.query:8 of
#, fuzzy
msgid "A decorator that registers a query function with the ``ClientApp``."
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.query:13 of
#, fuzzy
msgid "Registering a query function::"
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.query:23 of
#, fuzzy
msgid "Registering a query function with a custom action name::"
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.query:34 of
#, fuzzy
msgid "Registering a query function with a function-specific Flower Mod::"
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.train:8 of
#, fuzzy
msgid "A decorator that registers a train function with the ``ClientApp``."
msgstr "클라이언트 앱에 train fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.train:13 of
#, fuzzy
msgid "Registering a train function::"
msgstr "클라이언트 앱에 train fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.train:23 of
#, fuzzy
msgid "Registering a train function with a custom action name::"
msgstr "클라이언트 앱에 train fn을 등록하는 데코레이터를 반환합니다."

#: flwr.clientapp.client_app.ClientApp.train:34 of
#, fuzzy
msgid "Registering a train function with a function-specific Flower Mod::"
msgstr "클라이언트 앱에 train fn을 등록하는 데코레이터를 반환합니다."

#: ../../source/ref-api/flwr.clientapp.mod.rst:2
msgid "mod"
msgstr "mod"

#: ../../source/ref-api/flwr.clientapp.mod.rst:13
msgid "Functions"
msgstr "함수"

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`adaptiveclipping_mod "
"<flwr.clientapp.mod.adaptiveclipping_mod>`\\ \\(msg\\, ctxt\\, "
"call\\_next\\)"
msgstr ""
":py:obj:`adaptiveclipping_mod <flwr.client.mod.adaptiveclipping_mod>`\\ "
"\\(msg\\, ctxt\\, call\\_next\\)"

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:1 of
msgid "Client-side adaptive clipping modifier."
msgstr "클라이언트 측 적응형 클리핑 수정자."

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`arrays_size_mod <flwr.clientapp.mod.arrays_size_mod>`\\ "
"\\(msg\\, ctxt\\, call\\_next\\)"
msgstr ""
":py:obj:`parameters_size_mod <flwr.client.mod.parameters_size_mod>`\\ "
"\\(msg\\, ctxt\\, call\\_next\\)"

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#: flwr.client.mod.comms_mods.arrays_size_mod:1 of
#, fuzzy
msgid "Arrays size mod."
msgstr "매개변수 크기 mod."

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`fixedclipping_mod <flwr.clientapp.mod.fixedclipping_mod>`\\ "
"\\(msg\\, ctxt\\, call\\_next\\)"
msgstr ""
":py:obj:`fixedclipping_mod <flwr.client.mod.fixedclipping_mod>`\\ "
"\\(msg\\, ctxt\\, call\\_next\\)"

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:1 of
msgid "Client-side fixed clipping modifier."
msgstr "클라이언트 측 고정 클리핑 수정자."

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`message_size_mod <flwr.clientapp.mod.message_size_mod>`\\ "
"\\(msg\\, ctxt\\, call\\_next\\)"
msgstr ""
":py:obj:`message_size_mod <flwr.client.mod.message_size_mod>`\\ \\(msg\\,"
" ctxt\\, call\\_next\\)"

#: ../../source/ref-api/flwr.clientapp.mod.rst:25:<autosummary>:1
#: flwr.client.mod.comms_mods.message_size_mod:1 of
msgid "Message size mod."
msgstr "메시지 크기 수정."

#: ../../source/ref-api/flwr.clientapp.mod.rst:32:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`LocalDpMod <flwr.clientapp.mod.LocalDpMod>`\\ "
"\\(clipping\\_norm\\, sensitivity\\, ...\\)"
msgstr ""
":py:obj:`LocalDpMod <flwr.client.mod.LocalDpMod>`\\ \\(clipping\\_norm\\,"
" sensitivity\\, ...\\)"

#: ../../source/ref-api/flwr.clientapp.mod.rst:32:<autosummary>:1
#: flwr.clientapp.mod.localdp_mod.LocalDpMod:1 of
msgid "Modifier for local differential privacy."
msgstr "로컬 차분 프라이버시를 위한 수정자."

#: ../../source/ref-api/flwr.clientapp.mod.LocalDpMod.rst:2
msgid "LocalDpMod"
msgstr "LocalDpMod"

#: flwr.clientapp.mod.localdp_mod.LocalDpMod:3 of
msgid ""
"This mod clips the client model updates and adds noise to the params "
"before sending them to the server."
msgstr "이 모드는 클라이언트 모델 업데이트를 클립하고 서버로 보내기 전에 파라미터에 노이즈를 추가합니다."

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:12
#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:10
#: flwr.clientapp.mod.localdp_mod.LocalDpMod:6 of
msgid "It operates on messages of type `MessageType.TRAIN`."
msgstr "이 함수는 `MessageType.TRAIN` 유형의 메시지에 대해 작동합니다."

#: flwr.clientapp.mod.localdp_mod.LocalDpMod:8
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:15
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:8
#: of
msgid "The value of the clipping norm."
msgstr "클리핑 기준값입니다."

#: flwr.clientapp.mod.localdp_mod.LocalDpMod:10 of
msgid "The sensitivity of the client model."
msgstr "클라이언트 모델의 민감도입니다."

#: flwr.clientapp.mod.localdp_mod.LocalDpMod:12 of
msgid ""
"The privacy budget. Smaller value of epsilon indicates a higher level of "
"privacy protection."
msgstr "개인정보 보호 예산. 엡실론 값이 작을수록 개인정보 보호 수준이 높음을 나타냅니다."

#: flwr.clientapp.mod.localdp_mod.LocalDpMod:15 of
msgid ""
"The failure probability. The probability that the privacy mechanism fails"
" to provide the desired level of privacy. A smaller value of delta "
"indicates a stricter privacy guarantee."
msgstr ""
"실패 확률입니다. 프라이버시 메커니즘이 원하는 수준의 프라이버시를 제공하지 못할 확률입니다. 델타 값이 작을수록 프라이버시가 더 "
"엄격하게 보장된다는 의미입니다."

#: flwr.clientapp.mod.localdp_mod.LocalDpMod:23 of
#, fuzzy
msgid ""
"Create an instance of the local DP mod and add it to the client-side "
"mods::"
msgstr "로컬 DP 모드의 인스턴스를 생성하고 클라이언트 측 모드에 추가합니다:"

#: ../../source/ref-api/flwr.clientapp.mod.adaptiveclipping_mod.rst:2
msgid "adaptiveclipping\\_mod"
msgstr "adaptiveclipping\\_mod"

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:3 of
msgid ""
"This mod needs to be used with the "
"DifferentialPrivacyClientSideAdaptiveClipping server-side strategy "
"wrapper."
msgstr "이 모드는 서버 측 전략 래퍼인 차분 프라이버시 클라이언트 측 적응형 클리핑과 함께 사용해야 합니다."

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:6
#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:6 of
msgid "The wrapper sends the clipping_norm value to the client."
msgstr "래퍼는 클라이언트에 clipping_norm 값을 전송합니다."

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:8
#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:8 of
msgid "This mod clips the client model updates before sending them to the server."
msgstr "이 모드는 클라이언트 모델 업데이트를 서버로 보내기 전에 클립합니다."

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:10 of
msgid ""
"It also sends KEY_NORM_BIT to the server for computing the new clipping "
"value."
msgstr "또한 새 클리핑 값을 계산하기 위해 서버로 KEY_NORM_BIT을 전송합니다."

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:15
#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:13
#: flwr.server.grid.grid.Grid.send_and_receive:18
#: flwr.serverapp.strategy.multikrum.MultiKrum:42 of
msgid "Notes"
msgstr "참고"

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:16
#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:14 of
msgid "Consider the order of mods when using multiple."
msgstr "여러 개를 사용할 때는 모드의 순서를 고려하세요."

#: flwr.clientapp.mod.centraldp_mods.adaptiveclipping_mod:18 of
msgid "Typically, adaptiveclipping_mod should be the last to operate on params."
msgstr "일반적으로 adaptiveclipping_mod는 매개변수에서 가장 마지막으로 작동해야 합니다."

#: ../../source/ref-api/flwr.clientapp.mod.arrays_size_mod.rst:2
#, fuzzy
msgid "arrays\\_size\\_mod"
msgstr "parameters\\_size\\_mod"

#: flwr.client.mod.comms_mods.arrays_size_mod:3 of
#, fuzzy
msgid ""
"This mod logs the number of array elements transmitted in ``ArrayRecord``"
" objects of the message as well as their sizes in bytes."
msgstr "이 모드는 메시지에서 전송된 매개변수의 수와 그 크기를 바이트 단위로 기록합니다."

#: ../../source/ref-api/flwr.clientapp.mod.fixedclipping_mod.rst:2
msgid "fixedclipping\\_mod"
msgstr "fixedclipping\\_mod"

#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:3 of
#, fuzzy
msgid ""
"This mod needs to be used with the "
"`DifferentialPrivacyClientSideFixedClipping` server-side strategy "
"wrapper."
msgstr "이 모드는 서버 측 전략 래퍼인 DifferentialPrivacyClientSideFixedClipping과 함께 사용해야 합니다."

#: flwr.clientapp.mod.centraldp_mods.fixedclipping_mod:16 of
msgid "Typically, fixedclipping_mod should be the last to operate on params."
msgstr "일반적으로 fixedclipping_mod는 매개변수에서 가장 마지막으로 작동해야 합니다."

#: ../../source/ref-api/flwr.clientapp.mod.message_size_mod.rst:2
msgid "message\\_size\\_mod"
msgstr "message\\_size\\_mod"

#: flwr.client.mod.comms_mods.message_size_mod:3 of
msgid "This mod logs the size in bytes of the message being transmited."
msgstr "이 모드는 전송되는 메시지의 크기를 바이트 단위로 기록합니다."

#: ../../source/ref-api/flwr.serverapp.rst:2
#, fuzzy
msgid "serverapp"
msgstr "flower 서버 프로그램"

#: ../../source/ref-api/flwr.serverapp.rst:23:<autosummary>:1
#, fuzzy
msgid ":py:obj:`Grid <flwr.serverapp.Grid>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.rst:23:<autosummary>:1
#: flwr.server.grid.grid.Grid:1 of
#, fuzzy
msgid "Abstract base class Grid to send/receive messages."
msgstr "Driver API를 위한 Abstract base Driver class."

#: ../../source/ref-api/flwr.serverapp.rst:23:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`ServerApp <flwr.serverapp.ServerApp>`\\ \\(\\[server\\, "
"config\\, strategy\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.rst:23:<autosummary>:1
#: flwr.server.server_app.ServerApp:1 of
msgid "Flower ServerApp."
msgstr "Flower 서버."

#: ../../source/ref-api/flwr.serverapp.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`flwr.serverapp.strategy <flwr.serverapp.strategy>`\\"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: ../../source/ref-api/flwr.serverapp.rst:41:<autosummary>:1
#: flwr.serverapp.strategy:1 of
#, fuzzy
msgid "ServerApp strategies."
msgstr "전략 사용하기"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:2
msgid "Grid"
msgstr ""

#: flwr.server.grid.grid.Grid:1 flwr.serverapp.strategy.strategy.Strategy:1 of
msgid "Bases: :py:class:`~abc.ABC`"
msgstr "Bases: :py:class:`~abc.ABC`"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`create_message <flwr.serverapp.Grid.create_message>`\\ "
"\\(content\\, message\\_type\\, ...\\[\\, ttl\\]\\)"
msgstr ""
":py:obj:`create_reply <flwr.common.Message.create_reply>`\\ "
"\\(content\\[\\, ttl\\]\\)"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#: flwr.server.grid.grid.Grid.create_message:1 of
msgid "Create a new message with specified parameters."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`get_node_ids <flwr.serverapp.Grid.get_node_ids>`\\ \\(\\)"
msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#: flwr.server.grid.grid.Grid.get_node_ids:1 of
msgid "Get node IDs."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`pull_messages <flwr.serverapp.Grid.pull_messages>`\\ "
"\\(message\\_ids\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#: flwr.server.grid.grid.Grid.pull_messages:1 of
msgid "Pull messages based on message IDs."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`push_messages <flwr.serverapp.Grid.push_messages>`\\ "
"\\(messages\\)"
msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#: flwr.server.grid.grid.Grid.push_messages:1 of
msgid "Push messages to specified node IDs."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`send_and_receive <flwr.serverapp.Grid.send_and_receive>`\\ "
"\\(messages\\, \\*\\[\\, timeout\\]\\)"
msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#: flwr.server.grid.grid.Grid.send_and_receive:1 of
msgid "Push messages to specified node IDs and pull the reply messages."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`set_run <flwr.serverapp.Grid.set_run>`\\ \\(run\\_id\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.Grid.rst:41:<autosummary>:1
#: flwr.server.grid.grid.Grid.set_run:1 of
msgid "Request a run to the SuperLink with a given ``run_id``."
msgstr ""

#: flwr.server.grid.grid.Grid.create_message:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`run <flwr.serverapp.Grid.run>`\\"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: flwr.server.grid.grid.Grid.create_message:1:<autosummary>:1
#: flwr.serverapp.Grid.run:1 of
#, fuzzy
msgid "Run information."
msgstr "시뮬레이션 실행"

#: flwr.server.grid.grid.Grid.create_message:3 of
msgid ""
"This method constructs a new ``Message`` with given content and metadata."
" The ``run_id`` and ``src_node_id`` will be set automatically."
msgstr ""

#: flwr.server.grid.grid.Grid.create_message:6 of
msgid ""
"The content for the new message. This holds records that are to be sent "
"to the destination node."
msgstr ""

#: flwr.server.grid.grid.Grid.create_message:9 of
msgid ""
"The type of the message, defining the action to be executed on the "
"receiving end."
msgstr ""

#: flwr.server.grid.grid.Grid.create_message:12 of
msgid "The ID of the destination node to which the message is being sent."
msgstr ""

#: flwr.server.grid.grid.Grid.create_message:14 of
#, fuzzy
msgid ""
"The ID of the group to which this message is associated. In some "
"settings, this is used as the federated learning round."
msgstr "메시지를 그룹화하기 위한 식별자입니다. 일부 설정에서는 FL 라운드로 사용됩니다."

#: flwr.server.grid.grid.Grid.create_message:17 of
msgid ""
"Time-to-live for the round trip of this message, i.e., the time from "
"sending this message to receiving a reply. It specifies in seconds the "
"duration for which the message and its potential reply are considered "
"valid. If unset, the default TTL (i.e., ``common.DEFAULT_TTL``) will be "
"used."
msgstr ""

#: flwr.server.grid.grid.Grid.create_message:23 of
msgid ""
"**message** -- A new `Message` instance with the specified content and "
"metadata."
msgstr ""

#: flwr.server.grid.grid.Grid.pull_messages:3 of
msgid ""
"This method is used to collect messages from the SuperLink that "
"correspond to a set of given message IDs."
msgstr ""

#: flwr.server.grid.grid.Grid.pull_messages:6 of
msgid "An iterable of message IDs for which reply messages are to be retrieved."
msgstr ""

#: flwr.server.grid.grid.Grid.pull_messages:9 of
msgid "**messages** -- An iterable of messages received."
msgstr ""

#: flwr.server.grid.grid.Grid.push_messages:3 of
msgid ""
"This method takes an iterable of messages and sends each message to the "
"node specified in ``dst_node_id``."
msgstr ""

#: flwr.server.grid.grid.Grid.push_messages:6
#: flwr.server.grid.grid.Grid.send_and_receive:7 of
msgid "An iterable of messages to be sent."
msgstr ""

#: flwr.server.grid.grid.Grid.push_messages:9 of
msgid ""
"**message_ids** -- An iterable of IDs for the messages that were sent, "
"which can be used to pull replies."
msgstr ""

#: flwr.server.grid.grid.Grid.send_and_receive:3 of
msgid ""
"This method sends a list of messages to their destination node IDs and "
"then waits for the replies. It continues to pull replies until either all"
" replies are received or the specified timeout duration is exceeded."
msgstr ""

#: flwr.server.grid.grid.Grid.send_and_receive:9 of
msgid ""
"The timeout duration in seconds. If specified, the method will wait for "
"replies for this duration. If `None`, there is no time limit and the "
"method will wait until replies for all messages are received."
msgstr ""

#: flwr.server.grid.grid.Grid.send_and_receive:14 of
msgid "**replies** -- An iterable of reply messages received from the SuperLink."
msgstr ""

#: flwr.server.grid.grid.Grid.send_and_receive:19 of
msgid ""
"This method uses ``push_messages`` to send the messages and "
"``pull_messages`` to collect the replies. If ``timeout`` is set, the "
"method may not return replies for all sent messages. A message remains "
"valid until its TTL, which is not affected by ``timeout``."
msgstr ""

#: flwr.server.grid.grid.Grid.set_run:3 of
msgid ""
"If a ``Run`` with the specified ``run_id`` exists, a local ``Run`` object"
" will be created. It enables further functionality in the grid, such as "
"sending ``Message`` objects."
msgstr ""

#: flwr.server.grid.grid.Grid.set_run:7 of
msgid "The ``run_id`` of the ``Run`` this ``Grid`` object operates in."
msgstr ""

#: flwr.server.server_app.ServerApp:5 of
#, fuzzy
msgid "Use the ``ServerApp`` with an existing ``Strategy``::"
msgstr "기존 전략 사용"

#: flwr.server.server_app.ServerApp:17 of
#, fuzzy
msgid "Use the ``ServerApp`` with a custom main function::"
msgstr "기존 전략 사용"

#: flwr.server.server_app.ServerApp.lifespan:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`lifespan <flwr.serverapp.ServerApp.lifespan>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: flwr.server.server_app.ServerApp.lifespan:1
#: flwr.server.server_app.ServerApp.lifespan:1:<autosummary>:1 of
#, fuzzy
msgid "Return a decorator that registers the lifespan fn with the server app."
msgstr "클라이언트 앱에 query fn을 등록하는 데코레이터를 반환합니다."

#: flwr.server.server_app.ServerApp.lifespan:1:<autosummary>:1 of
#, fuzzy
msgid ":py:obj:`main <flwr.serverapp.ServerApp.main>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: flwr.server.server_app.ServerApp.lifespan:1:<autosummary>:1
#: flwr.server.server_app.ServerApp.main:1 of
msgid "Return a decorator that registers the main fn with the server app."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:2
msgid "strategy"
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`Bulyan <flwr.serverapp.strategy.Bulyan>`\\ "
"\\(\\[fraction\\_train\\, fraction\\_evaluate\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.bulyan.Bulyan:1 of
msgid "Bulyan strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`DifferentialPrivacyClientSideAdaptiveClipping "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping>`\\"
" \\(...\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:1
#: of
msgid "Strategy wrapper for central DP with client-side adaptive clipping."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
msgid ""
":py:obj:`DifferentialPrivacyClientSideFixedClipping "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping>`\\ "
"\\(...\\)"
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:1
#: of
msgid "Strategy wrapper for central DP with client-side fixed clipping."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`DifferentialPrivacyServerSideAdaptiveClipping "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping>`\\"
" \\(...\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyServerSideAdaptiveClipping:1
#: of
msgid "Message-based central DP with server-side adaptive clipping."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
msgid ""
":py:obj:`DifferentialPrivacyServerSideFixedClipping "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping>`\\ "
"\\(...\\)"
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:1
#: of
msgid "Strategy wrapper for central DP with server-side fixed clipping."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedAdagrad <flwr.serverapp.strategy.FedAdagrad>`\\ \\(\\*\\[\\, "
"fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:1 of
msgid "FedAdagrad strategy - Adaptive Federated Optimization using Adagrad."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedAdam <flwr.serverapp.strategy.FedAdam>`\\ \\(\\*\\[\\, "
"fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedadam.FedAdam:1 of
msgid "FedAdam - Adaptive Federated Optimization using Adam."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedAvg <flwr.serverapp.strategy.FedAvg>`\\ "
"\\(\\[fraction\\_train\\, fraction\\_evaluate\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg:1 of
msgid "Federated Averaging strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedAvgM <flwr.serverapp.strategy.FedAvgM>`\\ "
"\\(\\[fraction\\_train\\, fraction\\_evaluate\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedavgm.FedAvgM:1 of
msgid "Federated Averaging with Momentum strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedMedian <flwr.serverapp.strategy.FedMedian>`\\ "
"\\(\\[fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedmedian.FedMedian:1 of
#, fuzzy
msgid "Federated Median (FedMedian) strategy."
msgstr "연합 학습"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedProx <flwr.serverapp.strategy.FedProx>`\\ "
"\\(\\[fraction\\_train\\, fraction\\_evaluate\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedprox.FedProx:1 of
msgid "Federated Optimization strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedTrimmedAvg <flwr.serverapp.strategy.FedTrimmedAvg>`\\ "
"\\(\\[fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:1 of
msgid "Federated Averaging with Trimmed Mean [Dong Yin, et al., 2021]."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedXgbBagging <flwr.serverapp.strategy.FedXgbBagging>`\\ "
"\\(\\[fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:1 of
msgid "Configurable FedXgbBagging strategy implementation."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedXgbCyclic <flwr.serverapp.strategy.FedXgbCyclic>`\\ "
"\\(\\[fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:1 of
msgid "Configurable FedXgbCyclic strategy implementation."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`FedYogi <flwr.serverapp.strategy.FedYogi>`\\ \\(\\*\\[\\, "
"fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedyogi.FedYogi:1 of
msgid "FedYogi [Reddi et al., 2020] strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`Krum <flwr.serverapp.strategy.Krum>`\\ \\(\\[fraction\\_train\\,"
" fraction\\_evaluate\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.krum.Krum:1 of
msgid "Krum [Blanchard et al., 2017] strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`MultiKrum <flwr.serverapp.strategy.MultiKrum>`\\ "
"\\(\\[fraction\\_train\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.multikrum.MultiKrum:1 of
msgid "MultiKrum [Blanchard et al., 2017] strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`QFedAvg <flwr.serverapp.strategy.QFedAvg>`\\ "
"\\(client\\_learning\\_rate\\[\\, q\\, ...\\]\\)"
msgstr ""
":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
"\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.qfedavg.QFedAvg:1 of
msgid "Q-FedAvg strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`Result <flwr.serverapp.strategy.Result>`\\ \\(arrays\\, "
"train\\_metrics\\_clientapp\\, ...\\)"
msgstr ""
":py:obj:`RecordSet <flwr.common.RecordSet>`\\ "
"\\(\\[parameters\\_records\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.result.Result:1 of
msgid "Data class carrying records generated during the execution of a strategy."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`Strategy <flwr.serverapp.strategy.Strategy>`\\ \\(\\)"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy:1 of
msgid "Abstract base class for server strategy implementations."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.Bulyan.rst:2
msgid "Bulyan"
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:1
#: flwr.serverapp.strategy.fedavgm.FedAvgM:1
#: flwr.serverapp.strategy.fedmedian.FedMedian:1
#: flwr.serverapp.strategy.fedprox.FedProx:1
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:1
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:1
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:1
#: flwr.serverapp.strategy.multikrum.MultiKrum:1
#: flwr.serverapp.strategy.qfedavg.QFedAvg:1 of
#, fuzzy
msgid "Bases: :py:class:`~flwr.serverapp.strategy.fedavg.FedAvg`"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: flwr.serverapp.strategy.bulyan.Bulyan:3 of
msgid "Implementation based on https://arxiv.org/abs/1802.07927."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:5
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:5
#: flwr.serverapp.strategy.fedadam.FedAdam:5
#: flwr.serverapp.strategy.fedavg.FedAvg:5
#: flwr.serverapp.strategy.fedavgm.FedAvgM:5
#: flwr.serverapp.strategy.fedmedian.FedMedian:5
#: flwr.serverapp.strategy.fedprox.FedProx:45
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:5
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:3
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:3
#: flwr.serverapp.strategy.fedyogi.FedYogi:6
#: flwr.serverapp.strategy.krum.Krum:5
#: flwr.serverapp.strategy.multikrum.MultiKrum:5
#: flwr.serverapp.strategy.qfedavg.QFedAvg:16 of
msgid ""
"Fraction of nodes used during training. In case `min_train_nodes` is "
"larger than `fraction_train * total_connected_nodes`, `min_train_nodes` "
"will still be sampled."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:9
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:9
#: flwr.serverapp.strategy.fedadam.FedAdam:9
#: flwr.serverapp.strategy.fedavg.FedAvg:9
#: flwr.serverapp.strategy.fedavgm.FedAvgM:9
#: flwr.serverapp.strategy.fedmedian.FedMedian:9
#: flwr.serverapp.strategy.fedprox.FedProx:49
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:9
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:7
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:7
#: flwr.serverapp.strategy.fedyogi.FedYogi:10
#: flwr.serverapp.strategy.krum.Krum:9
#: flwr.serverapp.strategy.multikrum.MultiKrum:9
#: flwr.serverapp.strategy.qfedavg.QFedAvg:20 of
msgid ""
"Fraction of nodes used during validation. In case `min_evaluate_nodes` is"
" larger than `fraction_evaluate * total_connected_nodes`, "
"`min_evaluate_nodes` will still be sampled."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:13
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:13
#: flwr.serverapp.strategy.fedadam.FedAdam:13
#: flwr.serverapp.strategy.fedavg.FedAvg:13
#: flwr.serverapp.strategy.fedavgm.FedAvgM:13
#: flwr.serverapp.strategy.fedmedian.FedMedian:13
#: flwr.serverapp.strategy.fedprox.FedProx:53
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:13
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:11
#: flwr.serverapp.strategy.fedyogi.FedYogi:14
#: flwr.serverapp.strategy.krum.Krum:13
#: flwr.serverapp.strategy.multikrum.MultiKrum:13
#: flwr.serverapp.strategy.qfedavg.QFedAvg:24 of
msgid "Minimum number of nodes used during training."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:15
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:15
#: flwr.serverapp.strategy.fedadam.FedAdam:15
#: flwr.serverapp.strategy.fedavg.FedAvg:15
#: flwr.serverapp.strategy.fedavgm.FedAvgM:15
#: flwr.serverapp.strategy.fedmedian.FedMedian:15
#: flwr.serverapp.strategy.fedprox.FedProx:55
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:15
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:13
#: flwr.serverapp.strategy.fedyogi.FedYogi:16
#: flwr.serverapp.strategy.krum.Krum:15
#: flwr.serverapp.strategy.multikrum.MultiKrum:15
#: flwr.serverapp.strategy.qfedavg.QFedAvg:26 of
msgid "Minimum number of nodes used during validation."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:17
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:17
#: flwr.serverapp.strategy.fedadam.FedAdam:17
#: flwr.serverapp.strategy.fedavg.FedAvg:17
#: flwr.serverapp.strategy.fedavgm.FedAvgM:17
#: flwr.serverapp.strategy.fedmedian.FedMedian:17
#: flwr.serverapp.strategy.fedprox.FedProx:57
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:17
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:15
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:11
#: flwr.serverapp.strategy.fedyogi.FedYogi:18
#: flwr.serverapp.strategy.krum.Krum:17
#: flwr.serverapp.strategy.multikrum.MultiKrum:17
#: flwr.serverapp.strategy.qfedavg.QFedAvg:28 of
msgid "Minimum number of total nodes in the system."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:19 of
msgid "Number of malicious nodes in the system."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:21
#: flwr.serverapp.strategy.fedmedian.FedMedian:19
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:17
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:13
#: flwr.serverapp.strategy.krum.Krum:21
#: flwr.serverapp.strategy.qfedavg.QFedAvg:30 of
msgid ""
"The key within each MetricRecord whose value is used as the weight when "
"computing weighted averages for MetricRecords."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:24
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:22
#: flwr.serverapp.strategy.fedadam.FedAdam:22
#: flwr.serverapp.strategy.fedavg.FedAvg:22
#: flwr.serverapp.strategy.fedavgm.FedAvgM:22
#: flwr.serverapp.strategy.fedmedian.FedMedian:22
#: flwr.serverapp.strategy.fedprox.FedProx:62
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:22
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:20
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:16
#: flwr.serverapp.strategy.fedyogi.FedYogi:23
#: flwr.serverapp.strategy.krum.Krum:24
#: flwr.serverapp.strategy.multikrum.MultiKrum:26
#: flwr.serverapp.strategy.qfedavg.QFedAvg:33 of
msgid "Key used to store the ArrayRecord when constructing Messages."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:26
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:24
#: flwr.serverapp.strategy.fedadam.FedAdam:24
#: flwr.serverapp.strategy.fedavg.FedAvg:24
#: flwr.serverapp.strategy.fedavgm.FedAvgM:24
#: flwr.serverapp.strategy.fedmedian.FedMedian:24
#: flwr.serverapp.strategy.fedprox.FedProx:64
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:24
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:22
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:18
#: flwr.serverapp.strategy.fedyogi.FedYogi:25
#: flwr.serverapp.strategy.krum.Krum:26
#: flwr.serverapp.strategy.multikrum.MultiKrum:28
#: flwr.serverapp.strategy.qfedavg.QFedAvg:35 of
msgid "Key used to store the ConfigRecord when constructing Messages."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:28
#: flwr.serverapp.strategy.bulyan.Bulyan:33
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:26
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:31
#: flwr.serverapp.strategy.fedadam.FedAdam:26
#: flwr.serverapp.strategy.fedadam.FedAdam:31
#: flwr.serverapp.strategy.fedavg.FedAvg:26
#: flwr.serverapp.strategy.fedavg.FedAvg:31
#: flwr.serverapp.strategy.fedavgm.FedAvgM:26
#: flwr.serverapp.strategy.fedavgm.FedAvgM:31
#: flwr.serverapp.strategy.fedmedian.FedMedian:26
#: flwr.serverapp.strategy.fedmedian.FedMedian:31
#: flwr.serverapp.strategy.fedprox.FedProx:66
#: flwr.serverapp.strategy.fedprox.FedProx:71
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:26
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:31
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:24
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging:29
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:20
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic:25
#: flwr.serverapp.strategy.fedyogi.FedYogi:27
#: flwr.serverapp.strategy.fedyogi.FedYogi:32
#: flwr.serverapp.strategy.krum.Krum:28 flwr.serverapp.strategy.krum.Krum:33
#: flwr.serverapp.strategy.multikrum.MultiKrum:30
#: flwr.serverapp.strategy.multikrum.MultiKrum:35
#: flwr.serverapp.strategy.qfedavg.QFedAvg:37
#: flwr.serverapp.strategy.qfedavg.QFedAvg:42 of
msgid ""
"Function with signature (list[RecordDict], str) -> MetricRecord, used to "
"aggregate MetricRecords from training round replies. If `None`, defaults "
"to `aggregate_metricrecords`, which performs a weighted average using the"
" provided weight factor key."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:38 of
msgid ""
"Function with signature (list[RecordDict], int, int) -> list[RecordDict]."
" The inputs are: - a list of contents from reply messages, - the assumed "
"number of malicious nodes (`num_malicious_nodes`), - the number of nodes "
"to select (`num_nodes_to_select`).  The function should implement a "
"Byzantine-resilient selection rule that serves as the first step of "
"Bulyan. If None, defaults to `select_multikrum`, which selects nodes "
"according to the Multi-Krum algorithm."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:38 of
msgid ""
"Function with signature (list[RecordDict], int, int) -> list[RecordDict]."
" The inputs are: - a list of contents from reply messages, - the assumed "
"number of malicious nodes (`num_malicious_nodes`), - the number of nodes "
"to select (`num_nodes_to_select`)."
msgstr ""

#: flwr.serverapp.strategy.bulyan.Bulyan:44 of
msgid ""
"The function should implement a Byzantine-resilient selection rule that "
"serves as the first step of Bulyan. If None, defaults to "
"`select_multikrum`, which selects nodes according to the Multi-Krum "
"algorithm."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.Bulyan.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
msgid "Aggregate MetricRecords in the received Messages."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.Bulyan.aggregate_train>`\\ \\(server\\_round\\, "
"replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.bulyan.Bulyan.aggregate_train:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping.aggregate_train:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyServerSideAdaptiveClipping.aggregate_train:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping.aggregate_train:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping.aggregate_train:1
#: flwr.serverapp.strategy.fedadagrad.FedAdagrad.aggregate_train:1
#: flwr.serverapp.strategy.fedadam.FedAdam.aggregate_train:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_train:1
#: flwr.serverapp.strategy.fedavgm.FedAvgM.aggregate_train:1
#: flwr.serverapp.strategy.fedmedian.FedMedian.aggregate_train:1
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg.aggregate_train:1
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging.aggregate_train:1
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic.aggregate_train:1
#: flwr.serverapp.strategy.fedyogi.FedYogi.aggregate_train:1
#: flwr.serverapp.strategy.multikrum.MultiKrum.aggregate_train:1
#: flwr.serverapp.strategy.qfedavg.QFedAvg.aggregate_train:1 of
msgid "Aggregate ArrayRecords and MetricRecords in the received Messages."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.Bulyan.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.configure_evaluate:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.configure_evaluate:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.configure_evaluate:1
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic.configure_evaluate:1 of
#, fuzzy
msgid "Configure the next round of federated evaluation."
msgstr "연합 평가 구성"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.Bulyan.configure_train>`\\ \\(server\\_round\\, "
"arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.configure_train:1
#: flwr.serverapp.strategy.fedavgm.FedAvgM.configure_train:1
#: flwr.serverapp.strategy.fedopt.FedOpt.configure_train:1
#: flwr.serverapp.strategy.fedprox.FedProx.configure_train:1
#: flwr.serverapp.strategy.fedxgb_bagging.FedXgbBagging.configure_train:1
#: flwr.serverapp.strategy.fedxgb_cyclic.FedXgbCyclic.configure_train:1
#: flwr.serverapp.strategy.qfedavg.QFedAvg.configure_train:1 of
msgid "Configure the next round of federated training."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.Bulyan.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy.start:1 of
#, fuzzy
msgid "Execute the federated learning strategy."
msgstr "연합 학습"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.Bulyan.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#: flwr.serverapp.strategy.bulyan.Bulyan.summary:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping.summary:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyServerSideAdaptiveClipping.summary:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping.summary:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping.summary:1
#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.fedavg.FedAvg.summary:1
#: flwr.serverapp.strategy.fedavgm.FedAvgM.summary:1
#: flwr.serverapp.strategy.fedopt.FedOpt.summary:1
#: flwr.serverapp.strategy.fedprox.FedProx.summary:1
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg.summary:1
#: flwr.serverapp.strategy.krum.Krum.summary:1
#: flwr.serverapp.strategy.multikrum.MultiKrum.summary:1
#: flwr.serverapp.strategy.qfedavg.QFedAvg.summary:1
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy.summary:1 of
msgid "Log summary configuration of the strategy."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:3 of
msgid ""
"Runs the complete federated learning workflow for the specified number of"
" rounds, including training, evaluation, and optional centralized "
"evaluation."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:6 of
msgid ""
"The Grid instance used to send/receive Messages from nodes executing a "
"ClientApp."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:9 of
msgid "Initial model parameters (arrays) to be used for federated learning."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:11 of
#, fuzzy
msgid "Number of federated learning rounds to execute."
msgstr "연합 학습의 5단계"

#: flwr.serverapp.strategy.strategy.Strategy.start:13 of
msgid "Timeout in seconds for waiting for node responses."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:15 of
msgid ""
"Configuration to be sent to nodes during training rounds. If unset, an "
"empty ConfigRecord will be used."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:18 of
msgid ""
"Configuration to be sent to nodes during evaluation rounds. If unset, an "
"empty ConfigRecord will be used."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:21 of
msgid ""
"Optional function for centralized evaluation of the global model. Takes "
"server round number and array record, returns a MetricRecord or None. If "
"provided, will be called before the first round and after each round. "
"Defaults to None."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.start:27 of
msgid ""
"Results containing final model arrays and also training metrics, "
"evaluation metrics and global evaluation metrics (if provided) from all "
"rounds."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.rst:2
msgid "DifferentialPrivacyClientSideAdaptiveClipping"
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyServerSideAdaptiveClipping:1
#: of
#, fuzzy
msgid ""
"Bases: "
":py:class:`~flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase`"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:3
#: of
msgid "Use `adaptiveclipping_mod` modifier at the client side."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:5
#: of
msgid ""
"In comparison to `DifferentialPrivacyServerSideAdaptiveClipping`, which "
"performs clipping on the server-side, "
"`DifferentialPrivacyClientSideAdaptiveClipping` expects clipping to "
"happen on the client-side, usually by using the built-in "
"`adaptiveclipping_mod`."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:11
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:10
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:3
#: of
msgid "The strategy to which DP functionalities will be added by this wrapper."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:13
#: of
msgid "The noise multiplier for the Gaussian mechanism for model updates."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:15
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:17
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:10
#: of
msgid "The number of clients that are sampled on each round."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:17
#: of
msgid ""
"The initial value of clipping norm. Defaults to 0.1. Andrew et al. "
"recommends to set to 0.1."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:20
#: of
msgid "The desired quantile of updates which should be clipped. Defaults to 0.5."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:22
#: of
msgid ""
"The learning rate for the clipping norm adaptation. Defaults to 0.2. "
"Andrew et al. recommends to set to 0.2."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:25
#: of
msgid ""
"The stddev of the noise added to the count of updates currently below the"
" estimate. Andrew et al. recommends to set to `expected_num_records/20`"
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:32
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:22
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:15
#: of
#, fuzzy
msgid "Create a strategy::"
msgstr "새 페이지 만들기"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:36
#: of
#, fuzzy
msgid ""
"Wrap the strategy with the "
"`DifferentialPrivacyClientSideAdaptiveClipping` wrapper::"
msgstr "이 모드는 서버 측 전략 래퍼인 차분 프라이버시 클라이언트 측 적응형 클리핑과 함께 사용해야 합니다."

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping:42
#: of
msgid "On the client, add the `adaptiveclipping_mod` to the client-side mods::"
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.aggregate_evaluate>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.aggregate_train>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.configure_evaluate>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.configure_train>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyClientSideAdaptiveClipping.configure_train:1
#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyServerSideAdaptiveClipping.configure_train:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping.configure_train:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping.configure_train:1
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy.configure_train:1 of
msgid "Configure the next round of training."
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.start>`\\"
" \\(grid\\, initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`summary "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideAdaptiveClipping.summary>`\\"
" \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.rst:2
msgid "DifferentialPrivacyClientSideFixedClipping"
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:1
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:1
#: of
msgid ""
"Bases: "
":py:class:`~flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase`"
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:3
#: of
msgid "Use `fixedclipping_mod` modifier at the client side."
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:5
#: of
msgid ""
"In comparison to `DifferentialPrivacyServerSideFixedClipping`, which "
"performs clipping on the server-side, "
"`DifferentialPrivacyClientSideFixedClipping` expects clipping to happen "
"on the client-side, usually by using the built-in `fixedclipping_mod`."
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:12
#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:5
#: of
msgid ""
"The noise multiplier for the Gaussian mechanism for model updates. A "
"value of 1.0 or higher is recommended for strong privacy."
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:26
#: of
#, fuzzy
msgid ""
"Wrap the strategy with the `DifferentialPrivacyClientSideFixedClipping` "
"wrapper::"
msgstr "이 모드는 서버 측 전략 래퍼인 DifferentialPrivacyClientSideFixedClipping과 함께 사용해야 합니다."

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyClientSideFixedClipping:32
#: of
msgid "On the client, add the `fixedclipping_mod` to the client-side mods::"
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.aggregate_evaluate>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.aggregate_train>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.configure_evaluate>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.configure_train>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.start>`\\"
" \\(grid\\, initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`summary "
"<flwr.serverapp.strategy.DifferentialPrivacyClientSideFixedClipping.summary>`\\"
" \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.rst:2
msgid "DifferentialPrivacyServerSideAdaptiveClipping"
msgstr ""

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.aggregate_evaluate>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.aggregate_train>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.configure_evaluate>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.configure_train>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.start>`\\"
" \\(grid\\, initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.dp_adaptive_clipping.DifferentialPrivacyAdaptiveBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`summary "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideAdaptiveClipping.summary>`\\"
" \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.rst:2
msgid "DifferentialPrivacyServerSideFixedClipping"
msgstr ""

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyServerSideFixedClipping:19
#: of
#, fuzzy
msgid ""
"Wrap the strategy with the `DifferentialPrivacyServerSideFixedClipping` "
"wrapper::"
msgstr "이 모드는 서버 측 전략 래퍼인 DifferentialPrivacyClientSideFixedClipping과 함께 사용해야 합니다."

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.aggregate_evaluate>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.aggregate_train>`\\"
" \\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.configure_evaluate>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.configure_train>`\\"
" \\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.start>`\\"
" \\(grid\\, initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.dp_fixed_clipping.DifferentialPrivacyFixedClippingBase.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`summary "
"<flwr.serverapp.strategy.DifferentialPrivacyServerSideFixedClipping.summary>`\\"
" \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedAdagrad.rst:2
#: ../../source/ref-changelog.md:2172
msgid "FedAdagrad"
msgstr ""

#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:1
#: flwr.serverapp.strategy.fedadam.FedAdam:1
#: flwr.serverapp.strategy.fedyogi.FedYogi:1 of
#, fuzzy
msgid "Bases: :py:class:`~flwr.serverapp.strategy.fedopt.FedOpt`"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:3
#: flwr.serverapp.strategy.fedadam.FedAdam:3
#: flwr.serverapp.strategy.fedyogi.FedYogi:3 of
msgid "Implementation based on https://arxiv.org/abs/2003.00295v5"
msgstr ""

#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:19
#: flwr.serverapp.strategy.fedadam.FedAdam:19
#: flwr.serverapp.strategy.fedavg.FedAvg:19
#: flwr.serverapp.strategy.fedavgm.FedAvgM:19
#: flwr.serverapp.strategy.fedprox.FedProx:59
#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:19
#: flwr.serverapp.strategy.fedyogi.FedYogi:20
#: flwr.serverapp.strategy.multikrum.MultiKrum:23 of
msgid ""
"The key within each MetricRecord whose value is used as the weight when "
"computing weighted averages for both ArrayRecords and MetricRecords."
msgstr ""

#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:36
#: flwr.serverapp.strategy.fedadam.FedAdam:36 of
msgid "Server-side learning rate. Defaults to 1e-1."
msgstr ""

#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:38
#: flwr.serverapp.strategy.fedadam.FedAdam:38 of
msgid "Client-side learning rate. Defaults to 1e-1."
msgstr ""

#: flwr.serverapp.strategy.fedadagrad.FedAdagrad:40
#: flwr.serverapp.strategy.fedadam.FedAdam:44
#: flwr.serverapp.strategy.fedyogi.FedYogi:45 of
msgid "Controls the algorithm's degree of adaptability. Defaults to 1e-3."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedAdagrad.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedAdagrad.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedAdagrad.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedAdagrad.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedAdagrad.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedAdagrad.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedAdam.rst:2
msgid "FedAdam"
msgstr ""

#: flwr.serverapp.strategy.fedadam.FedAdam:40
#: flwr.serverapp.strategy.fedyogi.FedYogi:41 of
msgid "Momentum parameter. Defaults to 0.9."
msgstr ""

#: flwr.serverapp.strategy.fedadam.FedAdam:42
#: flwr.serverapp.strategy.fedyogi.FedYogi:43 of
msgid "Second moment parameter. Defaults to 0.99."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedAdam.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedAdam.aggregate_train>`\\ \\(server\\_round\\,"
" replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedAdam.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedAdam.configure_train>`\\ \\(server\\_round\\,"
" arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedAdam.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedAdam.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedAvg.rst:2
msgid "FedAvg"
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg:1 of
#, fuzzy
msgid "Bases: :py:class:`~flwr.serverapp.strategy.strategy.Strategy`"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: flwr.serverapp.strategy.fedavg.FedAvg:3 of
msgid "Implementation based on https://arxiv.org/abs/1602.05629"
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedAvg.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedAvg.aggregate_train>`\\ \\(server\\_round\\, "
"replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedAvg.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedAvg.configure_train>`\\ \\(server\\_round\\, "
"arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedAvg.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedAvg.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedAvgM.rst:2
msgid "FedAvgM"
msgstr ""

#: flwr.serverapp.strategy.fedavgm.FedAvgM:3 of
msgid "Implementation based on https://arxiv.org/abs/1909.06335"
msgstr ""

#: flwr.serverapp.strategy.fedavgm.FedAvgM:36 of
msgid "Server-side learning rate used in server-side optimization."
msgstr ""

#: flwr.serverapp.strategy.fedavgm.FedAvgM:38 of
msgid "Server-side momentum factor used for FedAvgM."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedAvgM.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedAvgM.aggregate_train>`\\ \\(server\\_round\\,"
" replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedAvgM.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedAvgM.configure_train>`\\ \\(server\\_round\\,"
" arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedAvgM.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedAvgM.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedMedian.rst:2
msgid "FedMedian"
msgstr ""

#: flwr.serverapp.strategy.fedmedian.FedMedian:3 of
msgid "Implementation based on https://arxiv.org/pdf/1803.01498v1"
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedMedian.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedMedian.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedMedian.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedMedian.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedMedian.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedMedian.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedProx.rst:2
msgid "FedProx"
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:3 of
msgid "Implementation based on https://arxiv.org/abs/1812.06127"
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:5 of
msgid ""
"FedProx extends FedAvg by introducing a proximal term into the client-"
"side optimization objective. The strategy itself behaves identically to "
"FedAvg on the server side, but each client **MUST** add a proximal "
"regularization term to its local loss function during training:"
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:10 of
#, python-brace-format
msgid ""
"\\frac{\\mu}{2} || w - w^t ||^2\n"
"\n"
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:13 of
msgid ""
"Where $w^t$ denotes the global parameters and $w$ denotes the local "
"weights being optimized."
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:16 of
msgid ""
"This strategy sends the proximal term inside the ``ConfigRecord`` as part"
" of the ``configure_train`` method under key ``\"proximal-mu\"``. The "
"client can then use this value to add the proximal term to the loss "
"function."
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:20 of
msgid "In PyTorch, for example, the loss would go from:"
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:25 of
msgid "To:"
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:39 of
msgid ""
"With ``global_params`` being a copy of the model parameters, created "
"**after** applying the received global weights but **before** local "
"training begins."
msgstr ""

#: flwr.serverapp.strategy.fedprox.FedProx:76 of
msgid ""
"The weight of the proximal term used in the optimization. 0.0 makes this "
"strategy equivalent to FedAvg, and the higher the coefficient, the more "
"regularization will be used (that is, the client parameters will need to "
"be closer to the server parameters during training)."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedProx.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedProx.aggregate_train>`\\ \\(server\\_round\\,"
" replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedProx.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedProx.configure_train>`\\ \\(server\\_round\\,"
" arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedProx.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedProx.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedTrimmedAvg.rst:2
msgid "FedTrimmedAvg"
msgstr ""

#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:3 of
msgid "Implemented based on: https://arxiv.org/abs/1803.01498"
msgstr ""

#: flwr.serverapp.strategy.fedtrimmedavg.FedTrimmedAvg:36 of
msgid "Fraction to cut off of both tails of the distribution."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedTrimmedAvg.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedTrimmedAvg.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedTrimmedAvg.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedTrimmedAvg.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedTrimmedAvg.start>`\\ "
"\\(grid\\, initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedTrimmedAvg.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:2
msgid "FedXgbBagging"
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedXgbBagging.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedXgbBagging.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedXgbBagging.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedXgbBagging.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedXgbBagging.start>`\\ "
"\\(grid\\, initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbBagging.rst:41:<autosummary>:1
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedXgbBagging.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`current_bst "
"<flwr.serverapp.strategy.FedXgbBagging.current_bst>`\\"
msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedXgbCyclic.rst:2
msgid "FedXgbCyclic"
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedXgbCyclic.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedXgbCyclic.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedXgbCyclic.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedXgbCyclic.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedXgbCyclic.start>`\\ \\(grid\\,"
" initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedXgbCyclic.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.FedYogi.rst:2
msgid "FedYogi"
msgstr ""

#: flwr.serverapp.strategy.fedyogi.FedYogi:37 of
msgid "Server-side learning rate. Defaults to 1e-2."
msgstr ""

#: flwr.serverapp.strategy.fedyogi.FedYogi:39 of
msgid "Client-side learning rate. Defaults to 0.0316."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.FedYogi.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.FedYogi.aggregate_train>`\\ \\(server\\_round\\,"
" replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.FedYogi.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.FedYogi.configure_train>`\\ \\(server\\_round\\,"
" arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.FedYogi.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.FedYogi.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.Krum.rst:2
msgid "Krum"
msgstr ""

#: flwr.serverapp.strategy.krum.Krum:1 of
#, fuzzy
msgid "Bases: :py:class:`~flwr.serverapp.strategy.multikrum.MultiKrum`"
msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#: flwr.serverapp.strategy.krum.Krum:3
#: flwr.serverapp.strategy.multikrum.MultiKrum:3 of
msgid "Implementation based on https://arxiv.org/abs/1703.02757"
msgstr ""

#: flwr.serverapp.strategy.krum.Krum:19
#: flwr.serverapp.strategy.multikrum.MultiKrum:19 of
msgid "Number of malicious nodes in the system. Defaults to 0."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.Krum.aggregate_evaluate>`\\ \\(server\\_round\\,"
" replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.Krum.aggregate_train>`\\ \\(server\\_round\\, "
"replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.Krum.configure_evaluate>`\\ \\(server\\_round\\,"
" arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.Krum.configure_train>`\\ \\(server\\_round\\, "
"arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.Krum.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.Krum.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.MultiKrum.rst:2
msgid "MultiKrum"
msgstr ""

#: flwr.serverapp.strategy.multikrum.MultiKrum:21 of
msgid "Number of nodes to select before averaging."
msgstr ""

#: flwr.serverapp.strategy.multikrum.MultiKrum:43 of
msgid ""
"MultiKrum is a generalization of Krum. If `num_nodes_to_select` is set to"
" 1, MultiKrum will reduce to classical Krum."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.MultiKrum.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.MultiKrum.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.MultiKrum.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.MultiKrum.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.MultiKrum.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.MultiKrum.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.QFedAvg.rst:2
msgid "QFedAvg"
msgstr ""

#: flwr.serverapp.strategy.qfedavg.QFedAvg:3 of
msgid "Implementation based on openreview.net/pdf?id=ByexElSYDr"
msgstr ""

#: flwr.serverapp.strategy.qfedavg.QFedAvg:5 of
msgid ""
"Local learning rate used by clients during training. This value is used "
"by the strategy to approximate the base Lipschitz constant L, via L = 1 /"
" client_learning_rate."
msgstr ""

#: flwr.serverapp.strategy.qfedavg.QFedAvg:9 of
msgid ""
"The parameter q that controls the degree of fairness of the algorithm. "
"Please tune this parameter based on your use case. When set to 0, "
"q-FedAvg is equivalent to FedAvg."
msgstr ""

#: flwr.serverapp.strategy.qfedavg.QFedAvg:13 of
msgid ""
"The key within the MetricRecord whose value is used as the training loss "
"when aggregating ArrayRecords following q-FedAvg."
msgstr ""

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.QFedAvg.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.QFedAvg.aggregate_train>`\\ \\(server\\_round\\,"
" replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.QFedAvg.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.QFedAvg.configure_train>`\\ \\(server\\_round\\,"
" arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.QFedAvg.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.fedavg.FedAvg.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.QFedAvg.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:2
msgid "Result"
msgstr ""

#: flwr.serverapp.strategy.result.Result:3 of
msgid ""
"This class encapsulates the results of a federated learning strategy "
"execution, including the final global model parameters and metrics "
"collected throughout the federated training and evaluation (both "
"federated and centralized) stages."
msgstr ""

#: flwr.serverapp.strategy.result.Result:9 of
msgid ""
"The final global model parameters. Contains the aggregated model "
"weights/parameters that resulted from the federated learning process."
msgstr ""

#: flwr.serverapp.strategy.result.Result of
#, fuzzy
msgid "type"
msgstr "이벤트 타입"

#: flwr.serverapp.strategy.result.Result:17 of
msgid ""
"Training metrics collected from ClientApps, indexed by round number. "
"Contains aggregated metrics (e.g., loss, accuracy) from the training "
"phase of each federated learning round."
msgstr ""

#: flwr.serverapp.strategy.result.Result:21
#: flwr.serverapp.strategy.result.Result:30
#: flwr.serverapp.strategy.result.Result:38 of
#, fuzzy
msgid "dict[int, MetricRecord]"
msgstr "메트릭 기록."

#: flwr.serverapp.strategy.result.Result:25 of
msgid ""
"Evaluation metrics collected from ClientApps, indexed by round number. "
"Contains aggregated metrics  (e.g. validation loss) from the evaluation "
"phase where ClientApps evaluate the global model on their local "
"validation/test data."
msgstr ""

#: flwr.serverapp.strategy.result.Result:34 of
msgid ""
"Evaluation metrics generated at the ServerApp, indexed by round number. "
"Contains metrics from centralized evaluation performed by the ServerApp "
"(e.g., when the server evaluates the global model on a held-out dataset)."
msgstr ""

#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:31:<autosummary>:1
#, fuzzy
msgid ":py:obj:`arrays <flwr.serverapp.strategy.Result.arrays>`\\"
msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`train_metrics_clientapp "
"<flwr.serverapp.strategy.Result.train_metrics_clientapp>`\\"
msgstr ""
":py:obj:`get_parameters_ins "
"<flwr.common.ServerMessage.get_parameters_ins>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`evaluate_metrics_clientapp "
"<flwr.serverapp.strategy.Result.evaluate_metrics_clientapp>`\\"
msgstr ":py:obj:`evaluate_ins <flwr.common.ServerMessage.evaluate_ins>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.Result.rst:31:<autosummary>:1
#, fuzzy
msgid ""
":py:obj:`evaluate_metrics_serverapp "
"<flwr.serverapp.strategy.Result.evaluate_metrics_serverapp>`\\"
msgstr ":py:obj:`evaluate_ins <flwr.common.ServerMessage.evaluate_ins>`\\"

#: ../../source/ref-api/flwr.serverapp.strategy.Strategy.rst:2
msgid "Strategy"
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_evaluate "
"<flwr.serverapp.strategy.Strategy.aggregate_evaluate>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid "Aggregate evaluation metrics from client nodes."
msgstr "종합 평가 결과"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`aggregate_train "
"<flwr.serverapp.strategy.Strategy.aggregate_train>`\\ "
"\\(server\\_round\\, replies\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train:1 of
msgid "Aggregate training results from client nodes."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_evaluate "
"<flwr.serverapp.strategy.Strategy.configure_evaluate>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate:1 of
msgid "Configure the next round of evaluation."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`configure_train "
"<flwr.serverapp.strategy.Strategy.configure_train>`\\ "
"\\(server\\_round\\, arrays\\, ...\\)"
msgstr ""
":py:obj:`configure <flwr.common.configure>`\\ \\(identifier\\[\\, "
"filename\\, host\\]\\)"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ""
":py:obj:`start <flwr.serverapp.strategy.Strategy.start>`\\ \\(grid\\, "
"initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
msgstr ""
":py:obj:`start_client <flwr.client.start_client>`\\ \\(\\*\\, "
"server\\_address\\[\\, client\\_fn\\, ...\\]\\)"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:1:<autosummary>:1
#: of
#, fuzzy
msgid ":py:obj:`summary <flwr.serverapp.strategy.Strategy.summary>`\\ \\(\\)"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:3
#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate:3
#: flwr.serverapp.strategy.strategy.Strategy.configure_train:3 of
msgid "The current round of federated learning."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:5 of
msgid ""
"Iterable of reply messages received from client nodes after evaluation. "
"MetricRecords in the messages are aggregated."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_evaluate:9 of
msgid ""
"Aggregated evaluation metrics from all participating clients, or None if "
"aggregation failed."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train:3 of
msgid "The current round of federated learning, starting from 1."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train:5 of
msgid ""
"Iterable of reply messages received from client nodes after training. "
"Each message contains ArrayRecords and MetricRecords that get aggregated."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.aggregate_train:9 of
msgid ""
"A tuple containing: - ArrayRecord: Aggregated ArrayRecord, or None if "
"aggregation failed - MetricRecord: Aggregated MetricRecord, or None if "
"aggregation failed"
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate:5 of
msgid ""
"Current global ArrayRecord (e.g. global model) to be sent to client nodes"
" for evaluation."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate:8 of
#, fuzzy
msgid "Configuration to be sent to clients nodes for evaluation."
msgstr "서버 측 평가 구성"

#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate:10
#: flwr.serverapp.strategy.strategy.Strategy.configure_train:10 of
msgid "The Grid instance used for node sampling and communication."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.configure_evaluate:13 of
msgid ""
"An iterable of messages to be sent to selected client nodes for "
"evaluation."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.configure_train:5 of
msgid ""
"Current global ArrayRecord (e.g. global model) to be sent to client nodes"
" for training."
msgstr ""

#: flwr.serverapp.strategy.strategy.Strategy.configure_train:8 of
#, fuzzy
msgid "Configuration to be sent to clients nodes for training."
msgstr "기본 제공 전략을 통한 구성"

#: flwr.serverapp.strategy.strategy.Strategy.configure_train:13 of
msgid "An iterable of messages to be sent to selected client nodes for training."
msgstr ""

#: ../../source/ref-changelog.md:1
msgid "Changelog"
msgstr ""

#: ../../source/ref-changelog.md:3
#, fuzzy
msgid "Unreleased"
msgstr "릴리즈 빌드"

#: ../../source/ref-changelog.md:5
msgid "v1.23.0 (2025-11-03)"
msgstr ""

#: ../../source/ref-changelog.md:7 ../../source/ref-changelog.md:69
#: ../../source/ref-changelog.md:109 ../../source/ref-changelog.md:179
#: ../../source/ref-changelog.md:251 ../../source/ref-changelog.md:319
#: ../../source/ref-changelog.md:377 ../../source/ref-changelog.md:462
#: ../../source/ref-changelog.md:526 ../../source/ref-changelog.md:552
#: ../../source/ref-changelog.md:588 ../../source/ref-changelog.md:678
#: ../../source/ref-changelog.md:747 ../../source/ref-changelog.md:779
#: ../../source/ref-changelog.md:880 ../../source/ref-changelog.md:950
#: ../../source/ref-changelog.md:982 ../../source/ref-changelog.md:1086
#: ../../source/ref-changelog.md:1184 ../../source/ref-changelog.md:1284
#: ../../source/ref-changelog.md:1348 ../../source/ref-changelog.md:1441
#: ../../source/ref-changelog.md:1539 ../../source/ref-changelog.md:1623
#: ../../source/ref-changelog.md:1687 ../../source/ref-changelog.md:1745
#: ../../source/ref-changelog.md:1814 ../../source/ref-changelog.md:1883
msgid "Thanks to our contributors"
msgstr ""

#: ../../source/ref-changelog.md:9 ../../source/ref-changelog.md:71
#: ../../source/ref-changelog.md:111 ../../source/ref-changelog.md:181
#: ../../source/ref-changelog.md:253 ../../source/ref-changelog.md:321
#: ../../source/ref-changelog.md:379 ../../source/ref-changelog.md:464
#: ../../source/ref-changelog.md:528 ../../source/ref-changelog.md:554
#: ../../source/ref-changelog.md:590 ../../source/ref-changelog.md:680
#: ../../source/ref-changelog.md:749 ../../source/ref-changelog.md:781
#: ../../source/ref-changelog.md:882 ../../source/ref-changelog.md:952
#: ../../source/ref-changelog.md:984 ../../source/ref-changelog.md:1088
#: ../../source/ref-changelog.md:1186 ../../source/ref-changelog.md:1286
#: ../../source/ref-changelog.md:1350 ../../source/ref-changelog.md:1443
#: ../../source/ref-changelog.md:1541 ../../source/ref-changelog.md:1625
#: ../../source/ref-changelog.md:1689 ../../source/ref-changelog.md:1747
msgid ""
"We would like to give our special thanks to all the contributors who made"
" the new version of Flower possible (in `git shortlog` order):"
msgstr ""

#: ../../source/ref-changelog.md:11
msgid ""
"`Adam Tupper`, `Alan Yi`, `Alireza Ghasemi`, `Charles Beauville`, `Chong "
"Shen Ng`, `Daniel Anoruo`, `Daniel J. Beutel`, `Daniel Nata Nugraha`, "
"`Heng Pan`, `Javier`, `Patrick Foley`, `Robert Steiner`, `Rohat Bozyil`, "
"`Yan Gao`, `combe4259`, `han97901`, `maviva` <!---TOKEN_v1.23.0-->"
msgstr ""

#: ../../source/ref-changelog.md:13 ../../source/ref-changelog.md:75
#: ../../source/ref-changelog.md:115 ../../source/ref-changelog.md:185
#: ../../source/ref-changelog.md:257 ../../source/ref-changelog.md:325
#: ../../source/ref-changelog.md:383 ../../source/ref-changelog.md:468
#: ../../source/ref-changelog.md:532 ../../source/ref-changelog.md:558
#: ../../source/ref-changelog.md:594 ../../source/ref-changelog.md:684
#: ../../source/ref-changelog.md:753 ../../source/ref-changelog.md:785
#: ../../source/ref-changelog.md:886 ../../source/ref-changelog.md:988
#: ../../source/ref-changelog.md:1092 ../../source/ref-changelog.md:1190
#: ../../source/ref-changelog.md:1290 ../../source/ref-changelog.md:1354
#: ../../source/ref-changelog.md:1447 ../../source/ref-changelog.md:1545
#: ../../source/ref-changelog.md:1629 ../../source/ref-changelog.md:1693
#: ../../source/ref-changelog.md:1751 ../../source/ref-changelog.md:1820
#: ../../source/ref-changelog.md:1945 ../../source/ref-changelog.md:1984
#: ../../source/ref-changelog.md:2056 ../../source/ref-changelog.md:2122
#: ../../source/ref-changelog.md:2167 ../../source/ref-changelog.md:2206
#: ../../source/ref-changelog.md:2239 ../../source/ref-changelog.md:2289
msgid "What's new?"
msgstr ""

#: ../../source/ref-changelog.md:15
msgid ""
"**Enable dynamic SuperNode management via Flower CLI** "
"([#5953](https://github.com/adap/flower/pull/5953), "
"[#5954](https://github.com/adap/flower/pull/5954), "
"[#5955](https://github.com/adap/flower/pull/5955), "
"[#5962](https://github.com/adap/flower/pull/5962), "
"[#5968](https://github.com/adap/flower/pull/5968), "
"[#5974](https://github.com/adap/flower/pull/5974), "
"[#5977](https://github.com/adap/flower/pull/5977), "
"[#5980](https://github.com/adap/flower/pull/5980), "
"[#5981](https://github.com/adap/flower/pull/5981), "
"[#5985](https://github.com/adap/flower/pull/5985), "
"[#5986](https://github.com/adap/flower/pull/5986), "
"[#5987](https://github.com/adap/flower/pull/5987), "
"[#5988](https://github.com/adap/flower/pull/5988), "
"[#5991](https://github.com/adap/flower/pull/5991), "
"[#5998](https://github.com/adap/flower/pull/5998), "
"[#6003](https://github.com/adap/flower/pull/6003), "
"[#6004](https://github.com/adap/flower/pull/6004), "
"[#6006](https://github.com/adap/flower/pull/6006), "
"[#6009](https://github.com/adap/flower/pull/6009), "
"[#6023](https://github.com/adap/flower/pull/6023), "
"[#6028](https://github.com/adap/flower/pull/6028), "
"[#6029](https://github.com/adap/flower/pull/6029), "
"[#6037](https://github.com/adap/flower/pull/6037), "
"[#6064](https://github.com/adap/flower/pull/6064), "
"[#6070](https://github.com/adap/flower/pull/6070))"
msgstr ""

#: ../../source/ref-changelog.md:17
msgid ""
"Revamps SuperNode authentication and introduce dynamic SuperNode "
"management through the Flower CLI. Users can now register, list, and "
"unregister SuperNodes directly via commands, such as `flwr supernode "
"register` which adds a SuperNode's public key to the SuperLink whitelist."
" SuperNodes can then be launched using the corresponding private key. See"
" the [SuperNode authentication "
"guide](https://flower.ai/docs/framework/v1.23.0/en/how-to-authenticate-"
"supernodes.html) for full details."
msgstr ""

#: ../../source/ref-changelog.md:19
msgid ""
"**Add migration guide for OpenFL to Flower** "
"([#5975](https://github.com/adap/flower/pull/5975))"
msgstr ""

#: ../../source/ref-changelog.md:21
msgid ""
"Adds a migration guide to support OpenFL users as the project approaches "
"archival. The guide explains how to transition existing OpenFL setups to "
"Flower, providing step-by-step migration instructions."
msgstr ""

#: ../../source/ref-changelog.md:23
msgid ""
"**Add quantum federated learning example with PennyLane** "
"([#5852](https://github.com/adap/flower/pull/5852))"
msgstr ""

#: ../../source/ref-changelog.md:25
msgid ""
"Introduces a new example demonstrating quantum federated learning using "
"PennyLane. This example showcases how Flower can be integrated with "
"quantum machine learning workflows—Flower is going quantum!"
msgstr ""

#: ../../source/ref-changelog.md:27
msgid ""
"**Replace** `flwr ls` **with** `flwr list` **(keep alias for "
"compatibility)** ([#5973](https://github.com/adap/flower/pull/5973))"
msgstr ""

#: ../../source/ref-changelog.md:29
msgid "The old `flwr ls` command remains available as an alias."
msgstr ""

#: ../../source/ref-changelog.md:31
msgid ""
"**Migrate examples and tutorials to Message API** "
"([#5950](https://github.com/adap/flower/pull/5950), "
"[#5957](https://github.com/adap/flower/pull/5957), "
"[#5963](https://github.com/adap/flower/pull/5963), "
"[#5966](https://github.com/adap/flower/pull/5966))"
msgstr ""

#: ../../source/ref-changelog.md:33
msgid ""
"Migrates the remaining examples and tutorials, including the 30-minute "
"Flower tutorial, `whisper`, `quickstart-pandas`, and `federated-kaplan-"
"meier-fitter`, to the new Message API for improved consistency and "
"maintainability."
msgstr ""

#: ../../source/ref-changelog.md:35
msgid ""
"**Refactor SuperNode lifecycle** "
"([#6051](https://github.com/adap/flower/pull/6051), "
"[#6052](https://github.com/adap/flower/pull/6052), "
"[#6060](https://github.com/adap/flower/pull/6060), "
"[#6061](https://github.com/adap/flower/pull/6061), "
"[#6063](https://github.com/adap/flower/pull/6063), "
"[#6069](https://github.com/adap/flower/pull/6069), "
"[#6073](https://github.com/adap/flower/pull/6073))"
msgstr ""

#: ../../source/ref-changelog.md:37
msgid ""
"Refactors the SuperNode lifecycle to align with the new management flow, "
"streamlining SuperNode registration, activation, deactivation, and "
"unregistration."
msgstr ""

#: ../../source/ref-changelog.md:39
msgid ""
"**Add deployment guide for multi-cluster OpenShift setups** "
"([#6001](https://github.com/adap/flower/pull/6001))"
msgstr ""

#: ../../source/ref-changelog.md:41
msgid ""
"**Introduce file-based ObjectStore** "
"([#6040](https://github.com/adap/flower/pull/6040), "
"[#6036](https://github.com/adap/flower/pull/6036), "
"[#6008](https://github.com/adap/flower/pull/6008), "
"[#6042](https://github.com/adap/flower/pull/6042))"
msgstr ""

#: ../../source/ref-changelog.md:43
msgid ""
"**Improve documentation** "
"([#5936](https://github.com/adap/flower/pull/5936), "
"[#5937](https://github.com/adap/flower/pull/5937), "
"[#5943](https://github.com/adap/flower/pull/5943), "
"[#5949](https://github.com/adap/flower/pull/5949), "
"[#5956](https://github.com/adap/flower/pull/5956), "
"[#5958](https://github.com/adap/flower/pull/5958), "
"[#5972](https://github.com/adap/flower/pull/5972), "
"[#5976](https://github.com/adap/flower/pull/5976), "
"[#5983](https://github.com/adap/flower/pull/5983), "
"[#5996](https://github.com/adap/flower/pull/5996), "
"[#5999](https://github.com/adap/flower/pull/5999), "
"[#6010](https://github.com/adap/flower/pull/6010), "
"[#6018](https://github.com/adap/flower/pull/6018), "
"[#6030](https://github.com/adap/flower/pull/6030))"
msgstr ""

#: ../../source/ref-changelog.md:45
msgid ""
"**Update dependencies and CI** "
"([#5932](https://github.com/adap/flower/pull/5932), "
"[#5941](https://github.com/adap/flower/pull/5941), "
"[#5944](https://github.com/adap/flower/pull/5944), "
"[#5964](https://github.com/adap/flower/pull/5964), "
"[#6014](https://github.com/adap/flower/pull/6014), "
"[#6020](https://github.com/adap/flower/pull/6020), "
"[#6021](https://github.com/adap/flower/pull/6021), "
"[#6022](https://github.com/adap/flower/pull/6022), "
"[#6024](https://github.com/adap/flower/pull/6024), "
"[#6026](https://github.com/adap/flower/pull/6026), "
"[#6032](https://github.com/adap/flower/pull/6032), "
"[#6035](https://github.com/adap/flower/pull/6035), "
"[#6055](https://github.com/adap/flower/pull/6055), "
"[#6065](https://github.com/adap/flower/pull/6065))"
msgstr ""

#: ../../source/ref-changelog.md:47
msgid "**Bugfix** ([#5979](https://github.com/adap/flower/pull/5979))"
msgstr ""

#: ../../source/ref-changelog.md:49
msgid ""
"**General improvements** "
"([#5773](https://github.com/adap/flower/pull/5773), "
"[#5938](https://github.com/adap/flower/pull/5938), "
"[#5939](https://github.com/adap/flower/pull/5939), "
"[#5942](https://github.com/adap/flower/pull/5942), "
"[#5948](https://github.com/adap/flower/pull/5948), "
"[#5951](https://github.com/adap/flower/pull/5951), "
"[#5959](https://github.com/adap/flower/pull/5959), "
"[#5984](https://github.com/adap/flower/pull/5984), "
"[#5989](https://github.com/adap/flower/pull/5989), "
"[#5992](https://github.com/adap/flower/pull/5992), "
"[#6007](https://github.com/adap/flower/pull/6007), "
"[#6011](https://github.com/adap/flower/pull/6011), "
"[#6033](https://github.com/adap/flower/pull/6033), "
"[#6038](https://github.com/adap/flower/pull/6038), "
"[#6041](https://github.com/adap/flower/pull/6041), "
"[#6046](https://github.com/adap/flower/pull/6046), "
"[#6047](https://github.com/adap/flower/pull/6047), "
"[#6048](https://github.com/adap/flower/pull/6048), "
"[#6050](https://github.com/adap/flower/pull/6050), "
"[#6054](https://github.com/adap/flower/pull/6054), "
"[#6057](https://github.com/adap/flower/pull/6057), "
"[#6058](https://github.com/adap/flower/pull/6058), "
"[#6074](https://github.com/adap/flower/pull/6074), "
"[#6075](https://github.com/adap/flower/pull/6075))"
msgstr ""

#: ../../source/ref-changelog.md:51 ../../source/ref-changelog.md:105
#: ../../source/ref-changelog.md:161 ../../source/ref-changelog.md:241
#: ../../source/ref-changelog.md:315 ../../source/ref-changelog.md:365
#: ../../source/ref-changelog.md:458 ../../source/ref-changelog.md:512
#: ../../source/ref-changelog.md:664 ../../source/ref-changelog.md:737
#: ../../source/ref-changelog.md:775 ../../source/ref-changelog.md:844
#: ../../source/ref-changelog.md:940 ../../source/ref-changelog.md:1043
#: ../../source/ref-changelog.md:1150
msgid ""
"As always, many parts of the Flower framework and quality infrastructure "
"were improved and updated."
msgstr ""

#: ../../source/ref-changelog.md:53 ../../source/ref-changelog.md:163
#: ../../source/ref-changelog.md:243 ../../source/ref-changelog.md:367
#: ../../source/ref-changelog.md:514 ../../source/ref-changelog.md:666
#: ../../source/ref-changelog.md:739 ../../source/ref-changelog.md:852
#: ../../source/ref-changelog.md:942 ../../source/ref-changelog.md:976
#: ../../source/ref-changelog.md:1056 ../../source/ref-changelog.md:1172
#: ../../source/ref-changelog.md:1268 ../../source/ref-changelog.md:1342
#: ../../source/ref-changelog.md:1417 ../../source/ref-changelog.md:1527
#: ../../source/ref-changelog.md:1617 ../../source/ref-changelog.md:1681
#: ../../source/ref-changelog.md:1739 ../../source/ref-changelog.md:1808
#: ../../source/ref-changelog.md:1870 ../../source/ref-changelog.md:1889
#: ../../source/ref-changelog.md:2038 ../../source/ref-changelog.md:2114
#: ../../source/ref-changelog.md:2151 ../../source/ref-changelog.md:2184
msgid "Incompatible changes"
msgstr ""

#: ../../source/ref-changelog.md:55
msgid ""
"**Remove CSV-based SuperNode authentication** "
"([#5997](https://github.com/adap/flower/pull/5997))"
msgstr ""

#: ../../source/ref-changelog.md:57
msgid ""
"Deprecates the legacy CSV-based SuperNode authentication mechanism in "
"favor of the new dynamic SuperNode management system. The `--auth-list-"
"public-keys` flag is no longer supported, as SuperNode whitelisting is "
"now handled through the Flower CLI. Please refer to the [Node "
"Authentication documentation](https://flower.ai/docs/framework/v1.23.0/en"
"/how-to-authenticate-supernodes.html) to learn how to use the new "
"mechanism."
msgstr ""

#: ../../source/ref-changelog.md:59
msgid ""
"**Rename user authentication to account authentication** "
"([#5965](https://github.com/adap/flower/pull/5965), "
"[#5969](https://github.com/adap/flower/pull/5969))"
msgstr ""

#: ../../source/ref-changelog.md:61
msgid ""
"Renames \"user authentication\" to \"account authentication\" across the "
"framework for improved clarity and consistency. This change also updates "
"the YAML key from `auth_type` to `authn_type` to align with `authz_type`."
msgstr ""

#: ../../source/ref-changelog.md:63
msgid ""
"**Deprecate `--auth-supernode-public-key` flag** "
"([#6002](https://github.com/adap/flower/pull/6002), "
"[#6076](https://github.com/adap/flower/pull/6076))"
msgstr ""

#: ../../source/ref-changelog.md:65
msgid ""
"The `--auth-supernode-public-key` flag in `flower-supernode` is "
"deprecated and no longer in use. The public key is now automatically "
"derived from the `--auth-supernode-private-key`, simplifying "
"configuration and reducing redundancy."
msgstr ""

#: ../../source/ref-changelog.md:67
msgid "v1.22.0 (2025-09-21)"
msgstr ""

#: ../../source/ref-changelog.md:73
msgid ""
"`Charles Beauville`, `Chong Shen Ng`, `Daniel J. Beutel`, `Dimitris "
"Stripelis`, `Heng Pan`, `Javier`, `Mohammad Naseri`, `Patrick Foley`, "
"`William Lindskog`, `Yan Gao` <!---TOKEN_v1.22.0-->"
msgstr ""

#: ../../source/ref-changelog.md:77
msgid ""
"**Migrate all strategies to Message API** "
"([#5845](https://github.com/adap/flower/pull/5845), "
"[#5850](https://github.com/adap/flower/pull/5850), "
"[#5851](https://github.com/adap/flower/pull/5851), "
"[#5867](https://github.com/adap/flower/pull/5867), "
"[#5884](https://github.com/adap/flower/pull/5884), "
"[#5894](https://github.com/adap/flower/pull/5894), "
"[#5904](https://github.com/adap/flower/pull/5904), "
"[#5905](https://github.com/adap/flower/pull/5905), "
"[#5908](https://github.com/adap/flower/pull/5908), "
"[#5913](https://github.com/adap/flower/pull/5913), "
"[#5914](https://github.com/adap/flower/pull/5914), "
"[#5915](https://github.com/adap/flower/pull/5915), "
"[#5917](https://github.com/adap/flower/pull/5917), "
"[#5919](https://github.com/adap/flower/pull/5919), "
"[#5920](https://github.com/adap/flower/pull/5920), "
"[#5931](https://github.com/adap/flower/pull/5931))"
msgstr ""

#: ../../source/ref-changelog.md:79
msgid ""
"Migrates and implements all federated learning strategies to support the "
"new Message API. Strategies updated or introduced include FedAvg, FedOpt "
"and its variants (FedAdam, FedYogi, FedAdagrad), FedProx, Krum, "
"MultiKrum, FedAvgM, FedMedian, FedTrimmedAvg, QFedAvg, and Bulyan. "
"Differential privacy strategies were also migrated, including both fixed "
"and adaptive clipping mechanisms on the server and client sides."
msgstr ""

#: ../../source/ref-changelog.md:81
msgid ""
"**Migrate `flwr new` templates to Message API** "
"([#5901](https://github.com/adap/flower/pull/5901), "
"[#5818](https://github.com/adap/flower/pull/5818), "
"[#5893](https://github.com/adap/flower/pull/5893), "
"[#5849](https://github.com/adap/flower/pull/5849), "
"[#5883](https://github.com/adap/flower/pull/5883))"
msgstr ""

#: ../../source/ref-changelog.md:83
msgid ""
"All `flwr new` templates have been updated to use the Message API. The "
"PyTorch template based on the legacy API is retained and explicitly "
"marked as legacy for those who prefer or require the older approach. A "
"new template for `XGBoost` is introduced."
msgstr ""

#: ../../source/ref-changelog.md:85
msgid ""
"**Revamp main tutorials to use the Message API** "
"([#5861](https://github.com/adap/flower/pull/5861))"
msgstr ""

#: ../../source/ref-changelog.md:87
msgid ""
"The primary tutorial series has been updated to showcase the Message API."
" The revamped content improves alignment with recent architectural "
"changes and enhances learning clarity. See the updated tutorial: [Get "
"started with Flower](https://flower.ai/docs/framework/tutorial-series-"
"get-started-with-flower-pytorch.html)."
msgstr ""

#: ../../source/ref-changelog.md:89
msgid ""
"**Upgrade tutorials and how-to guides to the Message API** "
"([#5862](https://github.com/adap/flower/pull/5862), "
"[#5877](https://github.com/adap/flower/pull/5877), "
"[#5891](https://github.com/adap/flower/pull/5891), "
"[#5895](https://github.com/adap/flower/pull/5895), "
"[#5896](https://github.com/adap/flower/pull/5896), "
"[#5897](https://github.com/adap/flower/pull/5897), "
"[#5898](https://github.com/adap/flower/pull/5898), "
"[#5906](https://github.com/adap/flower/pull/5906), "
"[#5912](https://github.com/adap/flower/pull/5912), "
"[#5916](https://github.com/adap/flower/pull/5916), "
"[#5921](https://github.com/adap/flower/pull/5921), "
"[#5922](https://github.com/adap/flower/pull/5922), "
"[#5923](https://github.com/adap/flower/pull/5923), "
"[#5924](https://github.com/adap/flower/pull/5924), "
"[#5927](https://github.com/adap/flower/pull/5927), "
"[#5928](https://github.com/adap/flower/pull/5928), "
"[#5925](https://github.com/adap/flower/pull/5925))"
msgstr ""

#: ../../source/ref-changelog.md:91
msgid ""
"All framework tutorials and how-to guides have been fully migrated to the"
" Message API. This includes quickstarts for JAX, TensorFlow, PyTorch "
"Lightning, MLX, FastAI, Hugging Face Transformers, and XGBoost, along "
"with comprehensive updates to guides covering strategy design, "
"differential privacy, checkpointing, client configuration, evaluation "
"aggregation, and stateful client implementation. These changes ensure all"
" learning resources are up-to-date, aligned with the current "
"architecture, and ready for developers building on the Message API."
msgstr ""

#: ../../source/ref-changelog.md:93
msgid ""
"**Migrate and update examples to support the Message API** "
"([#5827](https://github.com/adap/flower/pull/5827), "
"[#5830](https://github.com/adap/flower/pull/5830), "
"[#5833](https://github.com/adap/flower/pull/5833), "
"[#5834](https://github.com/adap/flower/pull/5834), "
"[#5839](https://github.com/adap/flower/pull/5839), "
"[#5840](https://github.com/adap/flower/pull/5840), "
"[#5841](https://github.com/adap/flower/pull/5841), "
"[#5860](https://github.com/adap/flower/pull/5860), "
"[#5868](https://github.com/adap/flower/pull/5868), "
"[#5869](https://github.com/adap/flower/pull/5869), "
"[#5875](https://github.com/adap/flower/pull/5875), "
"[#5876](https://github.com/adap/flower/pull/5876), "
"[#5879](https://github.com/adap/flower/pull/5879), "
"[#5880](https://github.com/adap/flower/pull/5880), "
"[#5882](https://github.com/adap/flower/pull/5882), "
"[#5887](https://github.com/adap/flower/pull/5887), "
"[#5888](https://github.com/adap/flower/pull/5888), "
"[#5889](https://github.com/adap/flower/pull/5889), "
"[#5892](https://github.com/adap/flower/pull/5892), "
"[#5907](https://github.com/adap/flower/pull/5907), "
"[#5911](https://github.com/adap/flower/pull/5911), "
"[#5930](https://github.com/adap/flower/pull/5930))"
msgstr ""

#: ../../source/ref-changelog.md:95
msgid ""
"Migrates a wide range of examples to the new Message API, ensuring "
"consistency with recent framework updates. Examples updated include "
"quickstarts (e.g., TensorFlow, PyTorch Lightning, Hugging Face, MONAI, "
"FastAI, MLX), advanced use cases (e.g., FlowerTune for ViT and LLMs, "
"FedRAG, FL-VAE), and specialized scenarios (e.g., XGBoost, tabular data, "
"embedded devices, authentication, and custom mods). Enhancements also "
"include updated variable naming, model-saving logic, readme improvements,"
" and import path corrections for better usability and alignment with the "
"new API."
msgstr ""

#: ../../source/ref-changelog.md:97
msgid ""
"**Introduce experimental `flwr pull` command** "
"([#5863](https://github.com/adap/flower/pull/5863))"
msgstr ""

#: ../../source/ref-changelog.md:99
msgid ""
"The `flwr pull` Flower CLI command is the foundation for future "
"functionality allowing for the retrieval of artifacts generated by a "
"`ServerApp` in a remote SuperLink."
msgstr ""

#: ../../source/ref-changelog.md:101
msgid ""
"**Improve CI/CD workflows** "
"([#5810](https://github.com/adap/flower/pull/5810), "
"[#5842](https://github.com/adap/flower/pull/5842), "
"[#5843](https://github.com/adap/flower/pull/5843), "
"[#5854](https://github.com/adap/flower/pull/5854), "
"[#5856](https://github.com/adap/flower/pull/5856), "
"[#5857](https://github.com/adap/flower/pull/5857), "
"[#5858](https://github.com/adap/flower/pull/5858), "
"[#5859](https://github.com/adap/flower/pull/5859), "
"[#5865](https://github.com/adap/flower/pull/5865), "
"[#5874](https://github.com/adap/flower/pull/5874), "
"[#5900](https://github.com/adap/flower/pull/5900), "
"[#5815](https://github.com/adap/flower/pull/5815))"
msgstr ""

#: ../../source/ref-changelog.md:103
msgid ""
"**General improvements** "
"([#5844](https://github.com/adap/flower/pull/5844), "
"[#5847](https://github.com/adap/flower/pull/5847), "
"[#5870](https://github.com/adap/flower/pull/5870), "
"[#5872](https://github.com/adap/flower/pull/5872), "
"[#5873](https://github.com/adap/flower/pull/5873), "
"[#5881](https://github.com/adap/flower/pull/5881), "
"[#5886](https://github.com/adap/flower/pull/5886), "
"[#5890](https://github.com/adap/flower/pull/5890), "
"[#5902](https://github.com/adap/flower/pull/5902), "
"[#5903](https://github.com/adap/flower/pull/5903), "
"[#5909](https://github.com/adap/flower/pull/5909), "
"[#5910](https://github.com/adap/flower/pull/5910), "
"[#5918](https://github.com/adap/flower/pull/5918))"
msgstr ""

#: ../../source/ref-changelog.md:107
msgid "v1.21.0 (2025-09-10)"
msgstr ""

#: ../../source/ref-changelog.md:113
msgid ""
"`Charles Beauville`, `Chong Shen Ng`, `Daniel J. Beutel`, `Daniel Nata "
"Nugraha`, `Dimitris Stripelis`, `Evram`, `Heng Pan`, `Javier`, `Robert "
"Steiner`, `Yan Gao` <!---TOKEN_v1.21.0-->"
msgstr ""

#: ../../source/ref-changelog.md:117
msgid ""
"**Introduce Message API strategies** "
"([#5710](https://github.com/adap/flower/pull/5710), "
"[#5766](https://github.com/adap/flower/pull/5766), "
"[#5770](https://github.com/adap/flower/pull/5770), "
"[#5771](https://github.com/adap/flower/pull/5771), "
"[#5774](https://github.com/adap/flower/pull/5774), "
"[#5779](https://github.com/adap/flower/pull/5779), "
"[#5787](https://github.com/adap/flower/pull/5787), "
"[#5794](https://github.com/adap/flower/pull/5794), "
"[#5798](https://github.com/adap/flower/pull/5798), "
"[#5804](https://github.com/adap/flower/pull/5804), "
"[#5807](https://github.com/adap/flower/pull/5807), "
"[#5813](https://github.com/adap/flower/pull/5813), "
"[#5824](https://github.com/adap/flower/pull/5824), "
"[#5831](https://github.com/adap/flower/pull/5831), "
"[#5838](https://github.com/adap/flower/pull/5838))"
msgstr ""

#: ../../source/ref-changelog.md:119
msgid ""
"Introduces a new abstract base class `Strategy` that operate on `Message`"
" replies, mirroring the design of those operating on `FitIns/FitRes` or "
"`EvaluateIns/EvaluteRes` while providing more versatility on the type of "
"payloads that can be federated with Flower. The first batch of "
"`Message`-based strategies are: `FedAvg`, `FedOpt`, `FedAdam`, "
"`FedAdagrad`, `FedYogi`, and fixed-clipping Differential Privacy "
"strategies. More will follow in subsequent releases. A [migration "
"guide](https://flower.ai/docs/framework/how-to-upgrade-to-message-"
"api.html) has been added to help users transition their existing Flower "
"Apps operating on the original `Strategy` and `NumPyClient` abstractions "
"to the Message API."
msgstr ""

#: ../../source/ref-changelog.md:121
msgid ""
"**Introduce Flower SuperExec** "
"([#5659](https://github.com/adap/flower/pull/5659), "
"[#5674](https://github.com/adap/flower/pull/5674), "
"[#5678](https://github.com/adap/flower/pull/5678), "
"[#5680](https://github.com/adap/flower/pull/5680), "
"[#5682](https://github.com/adap/flower/pull/5682), "
"[#5683](https://github.com/adap/flower/pull/5683), "
"[#5685](https://github.com/adap/flower/pull/5685), "
"[#5696](https://github.com/adap/flower/pull/5696), "
"[#5699](https://github.com/adap/flower/pull/5699), "
"[#5700](https://github.com/adap/flower/pull/5700), "
"[#5701](https://github.com/adap/flower/pull/5701), "
"[#5702](https://github.com/adap/flower/pull/5702), "
"[#5703](https://github.com/adap/flower/pull/5703), "
"[#5706](https://github.com/adap/flower/pull/5706), "
"[#5713](https://github.com/adap/flower/pull/5713), "
"[#5726](https://github.com/adap/flower/pull/5726), "
"[#5731](https://github.com/adap/flower/pull/5731), "
"[#5734](https://github.com/adap/flower/pull/5734), "
"[#5735](https://github.com/adap/flower/pull/5735), "
"[#5737](https://github.com/adap/flower/pull/5737), "
"[#5751](https://github.com/adap/flower/pull/5751), "
"[#5759](https://github.com/adap/flower/pull/5759), "
"[#5811](https://github.com/adap/flower/pull/5811), "
"[#5828](https://github.com/adap/flower/pull/5828))"
msgstr ""

#: ../../source/ref-changelog.md:123
msgid ""
"SuperExec is a new component responsible for scheduling, launching, and "
"managing app processes (e.g., `ServerApp`, `ClientApp`) within the Flower"
" deployment runtime. It is automatically spawned when running a SuperLink"
" or SuperNode in subprocess mode (default). This also introduces a token-"
"based mechanism that improves security by assigning a unique token to "
"each app execution. Supporting changes include new RPCs, protocol "
"updates, plugin abstractions, and Docker image support for SuperExec. For"
" more details, refer to the updated [Flower architecture "
"explainer](https://flower.ai/docs/framework/explanation-flower-"
"architecture.html). Documentation has been revised to reflect the "
"introduction of Flower SuperExec, including guides and tutorials such as "
"quickstart with Docker, GCP deployment, and network communication to "
"consistently use SuperExec."
msgstr ""

#: ../../source/ref-changelog.md:125
msgid ""
"**Update quickstart-pytorch to use Message API** "
"([#5785](https://github.com/adap/flower/pull/5785), "
"[#5786](https://github.com/adap/flower/pull/5786), "
"[#5802](https://github.com/adap/flower/pull/5802))"
msgstr ""

#: ../../source/ref-changelog.md:127
msgid ""
"The `quickstart-pytorch` [tutorial](https://flower.ai/docs/framework"
"/tutorial-quickstart-pytorch.html) has been migrated to the Message API, "
"using the new `FedAvg` strategy and the new `flwr new` template."
msgstr ""

#: ../../source/ref-changelog.md:129
msgid ""
"**New PyTorch template with Message API** "
"([#5784](https://github.com/adap/flower/pull/5784))"
msgstr ""

#: ../../source/ref-changelog.md:131
msgid ""
"A new PyTorch template using the Message API is now available through "
"`flwr new`."
msgstr ""

#: ../../source/ref-changelog.md:133
msgid ""
"**Add OpenShift deployment guide for Flower** "
"([#5781](https://github.com/adap/flower/pull/5781))"
msgstr ""

#: ../../source/ref-changelog.md:135
msgid ""
"Introduces a [guide](https://flower.ai/docs/framework/how-to-run-flower-"
"on-red-hat-openshift.html) for deploying Flower on Red Hat OpenShift, "
"including setup steps and configuration examples."
msgstr ""

#: ../../source/ref-changelog.md:137
msgid ""
"**Improve Helm documentation** "
"([#5711](https://github.com/adap/flower/pull/5711), "
"[#5733](https://github.com/adap/flower/pull/5733), "
"[#5748](https://github.com/adap/flower/pull/5748), "
"[#5758](https://github.com/adap/flower/pull/5758), "
"[#5765](https://github.com/adap/flower/pull/5765), "
"[#5816](https://github.com/adap/flower/pull/5816))"
msgstr ""

#: ../../source/ref-changelog.md:139
msgid ""
"Helm guide has been enhanced with additional configuration details and "
"updated formatting. Changes include adding a parameters section, "
"documenting how to set a custom `secretKey`, updating TLS instructions "
"for version 1.20, introducing audit logging configuration, and using "
"SuperExec."
msgstr ""

#: ../../source/ref-changelog.md:141
msgid ""
"**Improve documentation** "
"([#5159](https://github.com/adap/flower/pull/5159), "
"[#5655](https://github.com/adap/flower/pull/5655), "
"[#5668](https://github.com/adap/flower/pull/5668), "
"[#5692](https://github.com/adap/flower/pull/5692), "
"[#5723](https://github.com/adap/flower/pull/5723), "
"[#5738](https://github.com/adap/flower/pull/5738), "
"[#5739](https://github.com/adap/flower/pull/5739), "
"[#5740](https://github.com/adap/flower/pull/5740), "
"[#5753](https://github.com/adap/flower/pull/5753), "
"[#5764](https://github.com/adap/flower/pull/5764), "
"[#5769](https://github.com/adap/flower/pull/5769), "
"[#5775](https://github.com/adap/flower/pull/5775), "
"[#5782](https://github.com/adap/flower/pull/5782), "
"[#5788](https://github.com/adap/flower/pull/5788), "
"[#5795](https://github.com/adap/flower/pull/5795), "
"[#5809](https://github.com/adap/flower/pull/5809), "
"[#5812](https://github.com/adap/flower/pull/5812), "
"[#5817](https://github.com/adap/flower/pull/5817), "
"[#5819](https://github.com/adap/flower/pull/5819), "
"[#5825](https://github.com/adap/flower/pull/5825), "
"[#5836](https://github.com/adap/flower/pull/5836))"
msgstr ""

#: ../../source/ref-changelog.md:143
msgid ""
"Restructures the tutorial series, removes `flower-simulation` references,"
" and updates versioned docs to use the correct `flwr` versions. The "
"[framework documentation homepage](https://flower.ai/docs/framework/) now"
" defaults to the latest stable release instead of the `main` branch."
msgstr ""

#: ../../source/ref-changelog.md:145
msgid ""
"**Re-export user-facing API from `flwr.*app`** "
"([#5814](https://github.com/adap/flower/pull/5814), "
"[#5821](https://github.com/adap/flower/pull/5821), "
"[#5832](https://github.com/adap/flower/pull/5832), "
"[#5835](https://github.com/adap/flower/pull/5835))"
msgstr ""

#: ../../source/ref-changelog.md:147
msgid "The following classes are now re-exported:"
msgstr ""

#: ../../source/ref-changelog.md:149
#, fuzzy
msgid "From `flwr.serverapp`: `ServerApp`, `Grid`"
msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#: ../../source/ref-changelog.md:150
msgid "From `flwr.clientapp`: `ClientApp`, `arrays_size_mod`, `message_size_mod`"
msgstr ""

#: ../../source/ref-changelog.md:151
msgid ""
"From `flwr.app`: `Array`, `ArrayRecord`, `ConfigRecord`, `Context`, "
"`Message`, `MetricRecord`, `RecordDict`"
msgstr ""

#: ../../source/ref-changelog.md:153
msgid ""
"Importing these from `flwr.server`, `flwr.client`, or `flwr.common` is "
"**deprecated**. Please update your imports to use `flwr.serverapp`, "
"`flwr.clientapp`, or `flwr.app` instead to ensure forward compatibility."
msgstr ""

#: ../../source/ref-changelog.md:155
msgid ""
"**Add `--health-server-address` flag to Flower "
"SuperLink/SuperNode/SuperExec** "
"([#5792](https://github.com/adap/flower/pull/5792))"
msgstr ""

#: ../../source/ref-changelog.md:157
msgid ""
"**Update CI/CD workflows and dependencies** "
"([#5647](https://github.com/adap/flower/pull/5647), "
"[#5650](https://github.com/adap/flower/pull/5650), "
"[#5651](https://github.com/adap/flower/pull/5651), "
"[#5656](https://github.com/adap/flower/pull/5656), "
"[#5712](https://github.com/adap/flower/pull/5712), "
"[#5714](https://github.com/adap/flower/pull/5714), "
"[#5747](https://github.com/adap/flower/pull/5747), "
"[#5754](https://github.com/adap/flower/pull/5754), "
"[#5755](https://github.com/adap/flower/pull/5755), "
"[#5796](https://github.com/adap/flower/pull/5796), "
"[#5806](https://github.com/adap/flower/pull/5806), "
"[#5808](https://github.com/adap/flower/pull/5808), "
"[#5829](https://github.com/adap/flower/pull/5829))"
msgstr ""

#: ../../source/ref-changelog.md:159
msgid ""
"**General improvements** "
"([#5622](https://github.com/adap/flower/pull/5622), "
"[#5660](https://github.com/adap/flower/pull/5660), "
"[#5673](https://github.com/adap/flower/pull/5673), "
"[#5675](https://github.com/adap/flower/pull/5675), "
"[#5676](https://github.com/adap/flower/pull/5676), "
"[#5686](https://github.com/adap/flower/pull/5686), "
"[#5697](https://github.com/adap/flower/pull/5697), "
"[#5708](https://github.com/adap/flower/pull/5708), "
"[#5719](https://github.com/adap/flower/pull/5719), "
"[#5720](https://github.com/adap/flower/pull/5720), "
"[#5722](https://github.com/adap/flower/pull/5722), "
"[#5736](https://github.com/adap/flower/pull/5736), "
"[#5746](https://github.com/adap/flower/pull/5746), "
"[#5750](https://github.com/adap/flower/pull/5750), "
"[#5757](https://github.com/adap/flower/pull/5757), "
"[#5776](https://github.com/adap/flower/pull/5776), "
"[#5777](https://github.com/adap/flower/pull/5777), "
"[#5789](https://github.com/adap/flower/pull/5789), "
"[#5805](https://github.com/adap/flower/pull/5805), "
"[#5797](https://github.com/adap/flower/pull/5797), "
"[#5820](https://github.com/adap/flower/pull/5820))"
msgstr ""

#: ../../source/ref-changelog.md:165
msgid ""
"**Rename Exec API to Control API** "
"([#5663](https://github.com/adap/flower/pull/5663), "
"[#5665](https://github.com/adap/flower/pull/5665), "
"[#5667](https://github.com/adap/flower/pull/5667), "
"[#5671](https://github.com/adap/flower/pull/5671))"
msgstr ""

#: ../../source/ref-changelog.md:167
msgid ""
"The Exec API has been fully renamed to Control API to make its purpose "
"clearer and avoid confusion with SuperExec. This includes renaming "
"`exec.proto` to `control.proto`, updating documentation, and changing the"
" `--exec-api-address` flag to `--control-api-address`. For backward "
"compatibility, the old flag is still supported."
msgstr ""

#: ../../source/ref-changelog.md:169
msgid ""
"**Deprecate `flwr-*` commands** "
"([#5707](https://github.com/adap/flower/pull/5707), "
"[#5725](https://github.com/adap/flower/pull/5725), "
"[#5727](https://github.com/adap/flower/pull/5727), "
"[#5760](https://github.com/adap/flower/pull/5760))"
msgstr ""

#: ../../source/ref-changelog.md:171
msgid ""
"The long-running commands `flwr-serverapp`, `flwr-clientapp`, and `flwr-"
"simulation` are deprecated in favor of SuperExec. Invoking them now "
"launches the corresponding SuperExec process for backward compatibility."
msgstr ""

#: ../../source/ref-changelog.md:173
msgid ""
"**Remove `--executor*` flags** "
"([#5657](https://github.com/adap/flower/pull/5657), "
"[#5745](https://github.com/adap/flower/pull/5745), "
"[#5749](https://github.com/adap/flower/pull/5749))"
msgstr ""

#: ../../source/ref-changelog.md:175
msgid ""
"The `--executor`, `--executor-dir`, and `--executor-config` flags have "
"been deprecated and the executor code removed. Use the new `--simulation`"
" flag to run SuperLink with the simulation runtime."
msgstr ""

#: ../../source/ref-changelog.md:177
msgid "v1.20.0 (2025-07-29)"
msgstr ""

#: ../../source/ref-changelog.md:183
msgid ""
"`Charles Beauville`, `Chong Shen Ng`, `Daniel J. Beutel`, `Daniel Nata "
"Nugraha`, `Dimitris Stripelis`, `Heng Pan`, `Javier`, `Kumbham Ajay "
"Goud`, `Robert Steiner`, `William Lindskog`, `Yan Gao` <!---"
"TOKEN_v1.20.0-->"
msgstr ""

#: ../../source/ref-changelog.md:187
msgid ""
"**Send/receive arbitrarily large models** "
"([#5552](https://github.com/adap/flower/pull/5552), "
"[#5550](https://github.com/adap/flower/pull/5550), "
"[#5600](https://github.com/adap/flower/pull/5600), "
"[#5611](https://github.com/adap/flower/pull/5611), "
"[#5614](https://github.com/adap/flower/pull/5614), "
"[#5551](https://github.com/adap/flower/pull/5551))"
msgstr ""

#: ../../source/ref-changelog.md:189
msgid ""
"Flower 1.20 can send and receive arbitrarily large models like LLMs, way "
"beyond the 2GB limit imposed by gRPC. It does so by chunking messages "
"sent and received. The best part? This happens automatically without the "
"user having to do anything."
msgstr ""

#: ../../source/ref-changelog.md:191
msgid ""
"**Implement object-based messaging between SuperNode and ClientApp** "
"([#5540](https://github.com/adap/flower/pull/5540), "
"[#5577](https://github.com/adap/flower/pull/5577), "
"[#5581](https://github.com/adap/flower/pull/5581), "
"[#5582](https://github.com/adap/flower/pull/5582), "
"[#5583](https://github.com/adap/flower/pull/5583), "
"[#5584](https://github.com/adap/flower/pull/5584), "
"[#5585](https://github.com/adap/flower/pull/5585), "
"[#5586](https://github.com/adap/flower/pull/5586), "
"[#5587](https://github.com/adap/flower/pull/5587), "
"[#5589](https://github.com/adap/flower/pull/5589), "
"[#5590](https://github.com/adap/flower/pull/5590), "
"[#5592](https://github.com/adap/flower/pull/5592), "
"[#5595](https://github.com/adap/flower/pull/5595), "
"[#5597](https://github.com/adap/flower/pull/5597), "
"[#5598](https://github.com/adap/flower/pull/5598), "
"[#5599](https://github.com/adap/flower/pull/5599), "
"[#5602](https://github.com/adap/flower/pull/5602), "
"[#5604](https://github.com/adap/flower/pull/5604), "
"[#5605](https://github.com/adap/flower/pull/5605), "
"[#5606](https://github.com/adap/flower/pull/5606), "
"[#5607](https://github.com/adap/flower/pull/5607), "
"[#5609](https://github.com/adap/flower/pull/5609), "
"[#5613](https://github.com/adap/flower/pull/5613), "
"[#5616](https://github.com/adap/flower/pull/5616), "
"[#5624](https://github.com/adap/flower/pull/5624), "
"[#5645](https://github.com/adap/flower/pull/5645))"
msgstr ""

#: ../../source/ref-changelog.md:193
msgid ""
"Redesigns the messaging system to enable object-based communication "
"between the SuperNode and ClientApp, replacing the previous message-"
"coupled design. Introduces new RPCs and enhances the `ClientAppIo` and "
"Fleet APIs to faciliate better object storage in SuperNode and decouple "
"`ObjectStore` from `Message`, improving maintainability and "
"extensibility. Several refactorings improve modularity, naming "
"consistency, and model weight streaming."
msgstr ""

#: ../../source/ref-changelog.md:195
msgid ""
"**Refactor SuperNode to use NodeState exclusively** "
"([#5535](https://github.com/adap/flower/pull/5535), "
"[#5536](https://github.com/adap/flower/pull/5536), "
"[#5537](https://github.com/adap/flower/pull/5537), "
"[#5541](https://github.com/adap/flower/pull/5541), "
"[#5542](https://github.com/adap/flower/pull/5542), "
"[#5610](https://github.com/adap/flower/pull/5610), "
"[#5628](https://github.com/adap/flower/pull/5628))"
msgstr ""

#: ../../source/ref-changelog.md:197
msgid ""
"Refactors SuperNode to rely solely on `NodeState` for managing all "
"information, decoupling internal components for improved maintainability "
"and clearer state handling. RPCs of the `ClientAppIo` API have been "
"refactored accordingly, laying the groundwork for future concurrent "
"ClientApps support."
msgstr ""

#: ../../source/ref-changelog.md:199
msgid ""
"**Enforce maximum size limit for FAB files** "
"([#5493](https://github.com/adap/flower/pull/5493))"
msgstr ""

#: ../../source/ref-changelog.md:201
msgid ""
"Limits the size of FAB files to a maximum of 10MB to prevent oversized "
"artifacts. Developers can reduce FAB size by excluding unnecessary files "
"via the `.gitignore` file in the Flower app directory."
msgstr ""

#: ../../source/ref-changelog.md:203
msgid ""
"**Add CatBoost federated learning quickstart example** "
"([#5564](https://github.com/adap/flower/pull/5564))"
msgstr ""

#: ../../source/ref-changelog.md:205
msgid ""
"This example shows how to use CatBoost with Flower for federated binary "
"classification on the Adult Census Income dataset. It applies a tree-"
"based bagging aggregation method. View [the "
"example](https://flower.ai/docs/examples/quickstart-catboost.html) for "
"more details."
msgstr ""

#: ../../source/ref-changelog.md:207
msgid ""
"**Fix Windows path issue in FAB builds** "
"([#5608](https://github.com/adap/flower/pull/5608))"
msgstr ""

#: ../../source/ref-changelog.md:209
msgid ""
"Updates the way FAB files represent relative paths to their internal "
"files to ensure consistency across different operating systems. This "
"fixes an issue where a FAB built on Windows would fail integrity checks "
"when run on UNIX-based systems (e.g., Ubuntu)."
msgstr ""

#: ../../source/ref-changelog.md:211
msgid ""
"**Add explainer for `pyproject.toml` configuration** "
"([#5636](https://github.com/adap/flower/pull/5636))"
msgstr ""

#: ../../source/ref-changelog.md:213
msgid ""
"Adds a guide explaining how to configure a Flower app using its "
"`pyproject.toml` file. The documentation is available "
"[here](https://flower.ai/docs/framework/how-to-configure-pyproject-"
"toml.html)."
msgstr ""

#: ../../source/ref-changelog.md:215
msgid ""
"**Improve `flwr new` templates with TOML comments and README links** "
"([#5635](https://github.com/adap/flower/pull/5635))"
msgstr ""

#: ../../source/ref-changelog.md:217
msgid ""
"Adds comments to the generated `pyproject.toml` and a new section in the "
"`README.md`, both linking to the TOML explainer."
msgstr ""

#: ../../source/ref-changelog.md:219
msgid ""
"**Warn when running Ray backend on Windows and update simulation guide** "
"([#5579](https://github.com/adap/flower/pull/5579))"
msgstr ""

#: ../../source/ref-changelog.md:221
msgid ""
"Logs a warning when using the Ray backend for simulation on Windows. "
"Updates the simulation guide to include a corresponding note about "
"limited Windows support."
msgstr ""

#: ../../source/ref-changelog.md:223
msgid ""
"**Add Helm deployment guide** "
"([#5637](https://github.com/adap/flower/pull/5637))"
msgstr ""

#: ../../source/ref-changelog.md:225
msgid ""
"The documentation now includes a comprehensive guide for deploying Flower"
" SuperLink and SuperNode using Helm charts. For full instructions, refer "
"to the [Helm Guide](https://flower.ai/docs/framework/helm/index.html)."
msgstr ""

#: ../../source/ref-changelog.md:227
msgid ""
"**Add docs for user authentication and audit logging** "
"([#5630](https://github.com/adap/flower/pull/5630), "
"[#5643](https://github.com/adap/flower/pull/5643), "
"[#5649](https://github.com/adap/flower/pull/5649))"
msgstr ""

#: ../../source/ref-changelog.md:229
msgid ""
"Introduces documentation for configuring user authentication ([User "
"Authentication Guide](https://flower.ai/docs/framework/how-to-"
"authenticate-users.html)) and audit logging ([Audit Logging "
"Guide](https://flower.ai/docs/framework/how-to-configure-audit-"
"logging.html)) in Flower."
msgstr ""

#: ../../source/ref-changelog.md:231
msgid ""
"**Support gRPC health check by default** "
"([#5591](https://github.com/adap/flower/pull/5591))"
msgstr ""

#: ../../source/ref-changelog.md:233
msgid ""
"**Bugfixes** ([#5567](https://github.com/adap/flower/pull/5567), "
"[#5545](https://github.com/adap/flower/pull/5545), "
"[#5534](https://github.com/adap/flower/pull/5534))"
msgstr ""

#: ../../source/ref-changelog.md:235
msgid ""
"**Improve CI/CD** ([#5560](https://github.com/adap/flower/pull/5560), "
"[#5544](https://github.com/adap/flower/pull/5544), "
"[#5531](https://github.com/adap/flower/pull/5531), "
"[#5532](https://github.com/adap/flower/pull/5532), "
"[#5547](https://github.com/adap/flower/pull/5547), "
"[#5578](https://github.com/adap/flower/pull/5578))"
msgstr ""

#: ../../source/ref-changelog.md:237
msgid ""
"**Improve and update documentation** "
"([#5558](https://github.com/adap/flower/pull/5558), "
"[#5603](https://github.com/adap/flower/pull/5603), "
"[#5538](https://github.com/adap/flower/pull/5538), "
"[#5626](https://github.com/adap/flower/pull/5626), "
"[#5566](https://github.com/adap/flower/pull/5566), "
"[#5553](https://github.com/adap/flower/pull/5553), "
"[#5588](https://github.com/adap/flower/pull/5588), "
"[#5549](https://github.com/adap/flower/pull/5549), "
"[#5618](https://github.com/adap/flower/pull/5618), "
"[#5612](https://github.com/adap/flower/pull/5612), "
"[#5646](https://github.com/adap/flower/pull/5646))"
msgstr ""

#: ../../source/ref-changelog.md:239
msgid ""
"**General improvements** "
"([#5543](https://github.com/adap/flower/pull/5543), "
"[#5594](https://github.com/adap/flower/pull/5594), "
"[#5623](https://github.com/adap/flower/pull/5623), "
"[#5615](https://github.com/adap/flower/pull/5615), "
"[#5629](https://github.com/adap/flower/pull/5629), "
"[#5571](https://github.com/adap/flower/pull/5571), "
"[#5617](https://github.com/adap/flower/pull/5617), "
"[#5563](https://github.com/adap/flower/pull/5563), "
"[#5620](https://github.com/adap/flower/pull/5620), "
"[#5619](https://github.com/adap/flower/pull/5619), "
"[#5546](https://github.com/adap/flower/pull/5546), "
"[#5601](https://github.com/adap/flower/pull/5601), "
"[#5641](https://github.com/adap/flower/pull/5641), "
"[#5555](https://github.com/adap/flower/pull/5555), "
"[#5533](https://github.com/adap/flower/pull/5533), "
"[#5548](https://github.com/adap/flower/pull/5548), "
"[#5557](https://github.com/adap/flower/pull/5557), "
"[#5565](https://github.com/adap/flower/pull/5565), "
"[#5554](https://github.com/adap/flower/pull/5554), "
"[#5621](https://github.com/adap/flower/pull/5621), "
"[#5644](https://github.com/adap/flower/pull/5644), "
"[#5576](https://github.com/adap/flower/pull/5576), "
"[#5648](https://github.com/adap/flower/pull/5648))"
msgstr ""

#: ../../source/ref-changelog.md:245
msgid ""
"**Remove non-`grpc-bidi` transport support from deprecated "
"`start_client`** ([#5593](https://github.com/adap/flower/pull/5593))"
msgstr ""

#: ../../source/ref-changelog.md:247
msgid ""
"Drops support for non-`grpc-bidi` transport in the deprecated "
"`start_client` API. Pleaes use `flower-supernode` instead."
msgstr ""

#: ../../source/ref-changelog.md:249
msgid "v1.19.0 (2025-06-17)"
msgstr ""

#: ../../source/ref-changelog.md:255
msgid ""
"`Adam Tupper`, `Andrej Jovanović`, `Charles Beauville`, `Chong Shen Ng`, "
"`Daniel J. Beutel`, `Daniel Nata Nugraha`, `Dimitris Stripelis`, `Haoran "
"Jie`, `Heng Pan`, `Javier`, `Kevin Ta`, `Mohammad Naseri`, `Ragnar`, "
"`Robert Steiner`, `William Lindskog`, `ashley09`, `dennis-grinwald`, "
"`sukrucildirr` <!---TOKEN_v1.19.0-->"
msgstr ""

#: ../../source/ref-changelog.md:259
msgid ""
"**Revamp messaging system with content-addressable object model** "
"([#5513](https://github.com/adap/flower/pull/5513), "
"[#5477](https://github.com/adap/flower/pull/5477), "
"[#5424](https://github.com/adap/flower/pull/5424), "
"[#5379](https://github.com/adap/flower/pull/5379), "
"[#5353](https://github.com/adap/flower/pull/5353), "
"[#5372](https://github.com/adap/flower/pull/5372), "
"[#5507](https://github.com/adap/flower/pull/5507), "
"[#5364](https://github.com/adap/flower/pull/5364), "
"[#5517](https://github.com/adap/flower/pull/5517), "
"[#5514](https://github.com/adap/flower/pull/5514), "
"[#5342](https://github.com/adap/flower/pull/5342), "
"[#5393](https://github.com/adap/flower/pull/5393), "
"[#5508](https://github.com/adap/flower/pull/5508), "
"[#5504](https://github.com/adap/flower/pull/5504), "
"[#5335](https://github.com/adap/flower/pull/5335), "
"[#5341](https://github.com/adap/flower/pull/5341), "
"[#5430](https://github.com/adap/flower/pull/5430), "
"[#5308](https://github.com/adap/flower/pull/5308), "
"[#5487](https://github.com/adap/flower/pull/5487), "
"[#5509](https://github.com/adap/flower/pull/5509), "
"[#5438](https://github.com/adap/flower/pull/5438), "
"[#5369](https://github.com/adap/flower/pull/5369), "
"[#5354](https://github.com/adap/flower/pull/5354), "
"[#5486](https://github.com/adap/flower/pull/5486), "
"[#5380](https://github.com/adap/flower/pull/5380), "
"[#5496](https://github.com/adap/flower/pull/5496), "
"[#5399](https://github.com/adap/flower/pull/5399), "
"[#5489](https://github.com/adap/flower/pull/5489), "
"[#5446](https://github.com/adap/flower/pull/5446), "
"[#5432](https://github.com/adap/flower/pull/5432), "
"[#5456](https://github.com/adap/flower/pull/5456), "
"[#5442](https://github.com/adap/flower/pull/5442), "
"[#5462](https://github.com/adap/flower/pull/5462), "
"[#5429](https://github.com/adap/flower/pull/5429), "
"[#5497](https://github.com/adap/flower/pull/5497), "
"[#5435](https://github.com/adap/flower/pull/5435), "
"[#5371](https://github.com/adap/flower/pull/5371), "
"[#5450](https://github.com/adap/flower/pull/5450), "
"[#5384](https://github.com/adap/flower/pull/5384), "
"[#5488](https://github.com/adap/flower/pull/5488), "
"[#5434](https://github.com/adap/flower/pull/5434), "
"[#5425](https://github.com/adap/flower/pull/5425), "
"[#5475](https://github.com/adap/flower/pull/5475), "
"[#5458](https://github.com/adap/flower/pull/5458), "
"[#5494](https://github.com/adap/flower/pull/5494), "
"[#5449](https://github.com/adap/flower/pull/5449), "
"[#5492](https://github.com/adap/flower/pull/5492), "
"[#5426](https://github.com/adap/flower/pull/5426), "
"[#5445](https://github.com/adap/flower/pull/5445), "
"[#5467](https://github.com/adap/flower/pull/5467), "
"[#5474](https://github.com/adap/flower/pull/5474), "
"[#5527](https://github.com/adap/flower/pull/5527))"
msgstr ""

#: ../../source/ref-changelog.md:261
msgid ""
"Introduces a content-addressable messaging system that breaks messages "
"into a tree of uniquely identified, SHA256-hashed objects. This model "
"allows objects to be pushed and pulled efficiently, avoiding redundant "
"uploads and enabling scalable message streaming and broadcasting. Core "
"enhancements include the new `InflatableObject` abstraction and "
"`ObjectStore` for storing and retrieving message content, with `Array`, "
"`Message`, and `*Record` classes now inherit from `InflatableObject`. New"
" utilities and RPCs facilitate recursive object handling, ID "
"recomputation avoidance, and safe deletion. The framework's servicers, "
"REST, and gRPC layers were refactored to integrate this system, improving"
" real-world deployment scalability and communication efficiency."
msgstr ""

#: ../../source/ref-changelog.md:263
msgid ""
"**Improve user authorization and access control** "
"([#5428](https://github.com/adap/flower/pull/5428), "
"[#5505](https://github.com/adap/flower/pull/5505), "
"[#5506](https://github.com/adap/flower/pull/5506), "
"[#5422](https://github.com/adap/flower/pull/5422), "
"[#5510](https://github.com/adap/flower/pull/5510), "
"[#5421](https://github.com/adap/flower/pull/5421), "
"[#5420](https://github.com/adap/flower/pull/5420), "
"[#5448](https://github.com/adap/flower/pull/5448), "
"[#5447](https://github.com/adap/flower/pull/5447), "
"[#5503](https://github.com/adap/flower/pull/5503), "
"[#5501](https://github.com/adap/flower/pull/5501), "
"[#5502](https://github.com/adap/flower/pull/5502), "
"[#5511](https://github.com/adap/flower/pull/5511))"
msgstr ""

#: ../../source/ref-changelog.md:265
msgid ""
"Improves user authorization feature that integrates with the existing "
"authentication protocol. When authentication is enabled, commands like "
"`flwr ls`, `flwr log`, and `flwr stop` are restricted to displaying or "
"affecting only the runs submitted by the authenticated user. This is "
"enforced using the Flower Account ID. Additionally, fine-grained access "
"control can be enforced for CLI operations based on assigned roles "
"(RBAC)."
msgstr ""

#: ../../source/ref-changelog.md:267
msgid ""
"**Add Floco baseline for personalized federated learning** "
"([#4941](https://github.com/adap/flower/pull/4941))"
msgstr ""

#: ../../source/ref-changelog.md:269
msgid ""
"Introduces Floco, a method that enhances both personalized and global "
"model performance in non-IID cross-silo federated learning. It trains a "
"shared solution simplex across clients, promoting collaboration among "
"similar clients and reducing interference from dissimilar ones. Learn "
"more in [Floco Baseline "
"Documentation](https://flower.ai/docs/baselines/floco.html)."
msgstr ""

#: ../../source/ref-changelog.md:271
msgid ""
"**Add FEMNIST support to FedProx baseline** "
"([#5290](https://github.com/adap/flower/pull/5290))"
msgstr ""

#: ../../source/ref-changelog.md:273
msgid ""
"Adds FEMNIST dataset to FedProx with preprocessing matching the original "
"paper—subsampling 'a'-'j' and assigning 5 classes per device. More "
"details: [FedProx Baseline "
"Documentation](https://flower.ai/docs/baselines/fedprox.html)"
msgstr ""

#: ../../source/ref-changelog.md:275
msgid ""
"**Upgrade StatAvg baseline to new Flower App format** "
"([#4952](https://github.com/adap/flower/pull/4952))"
msgstr ""

#: ../../source/ref-changelog.md:277
msgid ""
"The StatAvg baseline is updated to use the new Flower App format. Changes"
" include removing Hydra, switching to `pyproject.toml` configs, using "
"`ClientApp` and `ServerApp`, and saving results via a custom `Server` "
"class. More details: [StatAvg Baseline "
"Documentation](https://flower.ai/docs/baselines/statavg.html)."
msgstr ""

#: ../../source/ref-changelog.md:279
msgid ""
"**Add guide for running Flower on Google Cloud Platform** "
"([#5327](https://github.com/adap/flower/pull/5327))"
msgstr ""

#: ../../source/ref-changelog.md:281
msgid ""
"The documentation now includes a detailed guide on deploying and running "
"Flower on Google Cloud Platform (GCP). It provides step-by-step "
"instructions for managing Flower workloads in a GCP environment. For more"
" information, refer to the [official "
"guide](https://flower.ai/docs/framework/how-to-run-flower-on-gcp.html)."
msgstr ""

#: ../../source/ref-changelog.md:283
msgid ""
"**Implement `ServerApp` heartbeat monitoring** "
"([#5228](https://github.com/adap/flower/pull/5228), "
"[#5370](https://github.com/adap/flower/pull/5370), "
"[#5358](https://github.com/adap/flower/pull/5358), "
"[#5332](https://github.com/adap/flower/pull/5332), "
"[#5322](https://github.com/adap/flower/pull/5322), "
"[#5324](https://github.com/adap/flower/pull/5324), "
"[#5230](https://github.com/adap/flower/pull/5230), "
"[#5325](https://github.com/adap/flower/pull/5325))"
msgstr ""

#: ../../source/ref-changelog.md:285
msgid ""
"Adds heartbeat support to `ServerApp` processes, enabling the `SuperLink`"
" to detect crashed or terminated processes and mark them as "
"`finished:failed` when no final status is received."
msgstr ""

#: ../../source/ref-changelog.md:287
msgid ""
"**Extend `NodeState` to improve SuperNode state management** "
"([#5470](https://github.com/adap/flower/pull/5470), "
"[#5473](https://github.com/adap/flower/pull/5473), "
"[#5402](https://github.com/adap/flower/pull/5402), "
"[#5521](https://github.com/adap/flower/pull/5521))"
msgstr ""

#: ../../source/ref-changelog.md:289
msgid ""
"Extends the `NodeState` interface and implementation to manage all "
"SuperNode state."
msgstr ""

#: ../../source/ref-changelog.md:291
msgid ""
"**Refactor SuperNode for improved robustness and maintainability** "
"([#5398](https://github.com/adap/flower/pull/5398), "
"[#5397](https://github.com/adap/flower/pull/5397), "
"[#5443](https://github.com/adap/flower/pull/5443), "
"[#5410](https://github.com/adap/flower/pull/5410), "
"[#5411](https://github.com/adap/flower/pull/5411), "
"[#5469](https://github.com/adap/flower/pull/5469), "
"[#5419](https://github.com/adap/flower/pull/5419))"
msgstr ""

#: ../../source/ref-changelog.md:293
msgid ""
"Ongoing refactoring of SuperNode improves modularity, simplifies client "
"execution, removes gRPC bidirectional streaming and unused code, and "
"centralizes connection logic. These changes align SuperNode's behavior "
"more closely with SuperLink to make Flower the best platform for robust "
"enterprise deployments.."
msgstr ""

#: ../../source/ref-changelog.md:295
msgid ""
"**Restructure Flower** "
"([#5465](https://github.com/adap/flower/pull/5465), "
"[#5476](https://github.com/adap/flower/pull/5476), "
"[#5460](https://github.com/adap/flower/pull/5460), "
"[#5409](https://github.com/adap/flower/pull/5409), "
"[#5408](https://github.com/adap/flower/pull/5408), "
"[#5396](https://github.com/adap/flower/pull/5396), "
"[#5389](https://github.com/adap/flower/pull/5389), "
"[#5392](https://github.com/adap/flower/pull/5392), "
"[#5461](https://github.com/adap/flower/pull/5461))"
msgstr ""

#: ../../source/ref-changelog.md:297
msgid ""
"Reorganizes infrastructure code into dedicated submodules to improve "
"maintainability and clarify the separation from user-facing components."
msgstr ""

#: ../../source/ref-changelog.md:299
msgid ""
"**Improve CI/CD workflows** "
"([#5498](https://github.com/adap/flower/pull/5498), "
"[#5265](https://github.com/adap/flower/pull/5265), "
"[#5266](https://github.com/adap/flower/pull/5266), "
"[#5328](https://github.com/adap/flower/pull/5328), "
"[#5500](https://github.com/adap/flower/pull/5500), "
"[#5346](https://github.com/adap/flower/pull/5346), "
"[#5318](https://github.com/adap/flower/pull/5318), "
"[#5256](https://github.com/adap/flower/pull/5256), "
"[#5298](https://github.com/adap/flower/pull/5298), "
"[#5257](https://github.com/adap/flower/pull/5257), "
"[#5483](https://github.com/adap/flower/pull/5483), "
"[#5440](https://github.com/adap/flower/pull/5440), "
"[#5304](https://github.com/adap/flower/pull/5304), "
"[#5313](https://github.com/adap/flower/pull/5313), "
"[#5381](https://github.com/adap/flower/pull/5381), "
"[#5385](https://github.com/adap/flower/pull/5385), "
"[#5316](https://github.com/adap/flower/pull/5316), "
"[#5260](https://github.com/adap/flower/pull/5260), "
"[#5349](https://github.com/adap/flower/pull/5349), "
"[#5319](https://github.com/adap/flower/pull/5319), "
"[#5296](https://github.com/adap/flower/pull/5296), "
"[#5294](https://github.com/adap/flower/pull/5294), "
"[#5317](https://github.com/adap/flower/pull/5317), "
"[#5482](https://github.com/adap/flower/pull/5482), "
"[#5282](https://github.com/adap/flower/pull/5282), "
"[#5223](https://github.com/adap/flower/pull/5223), "
"[#5225](https://github.com/adap/flower/pull/5225), "
"[#5326](https://github.com/adap/flower/pull/5326))"
msgstr ""

#: ../../source/ref-changelog.md:301
msgid ""
"Refines CI workflows, templates, and automation; improves Docker, "
"dependency, and version management; removes legacy jobs and adds "
"proactive maintainer tools."
msgstr ""

#: ../../source/ref-changelog.md:303
msgid ""
"**Improve documentation and examples** "
"([#5345](https://github.com/adap/flower/pull/5345), "
"[#5400](https://github.com/adap/flower/pull/5400), "
"[#5406](https://github.com/adap/flower/pull/5406), "
"[#5401](https://github.com/adap/flower/pull/5401), "
"[#5283](https://github.com/adap/flower/pull/5283), "
"[#5416](https://github.com/adap/flower/pull/5416), "
"[#5337](https://github.com/adap/flower/pull/5337), "
"[#5436](https://github.com/adap/flower/pull/5436), "
"[#5373](https://github.com/adap/flower/pull/5373), "
"[#5471](https://github.com/adap/flower/pull/5471), "
"[#5395](https://github.com/adap/flower/pull/5395), "
"[#5279](https://github.com/adap/flower/pull/5279), "
"[#5288](https://github.com/adap/flower/pull/5288), "
"[#5457](https://github.com/adap/flower/pull/5457), "
"[#5305](https://github.com/adap/flower/pull/5305), "
"[#5365](https://github.com/adap/flower/pull/5365), "
"[#5491](https://github.com/adap/flower/pull/5491), "
"[#5463](https://github.com/adap/flower/pull/5463), "
"[#5367](https://github.com/adap/flower/pull/5367), "
"[#5360](https://github.com/adap/flower/pull/5360), "
"[#5374](https://github.com/adap/flower/pull/5374), "
"[#5361](https://github.com/adap/flower/pull/5361), "
"[#5063](https://github.com/adap/flower/pull/5063))"
msgstr ""

#: ../../source/ref-changelog.md:305
msgid ""
"Adds documentation for the Flower Components Network Interface and "
"Communication Model, updates the Deployment Engine page, and clarifies "
"the distinctions between simulation and deployment. The `custom-mods` "
"example has also been revised."
msgstr ""

#: ../../source/ref-changelog.md:307
msgid ""
"**Build FAB in memory with new utility function** "
"([#5334](https://github.com/adap/flower/pull/5334))"
msgstr ""

#: ../../source/ref-changelog.md:309
msgid ""
"**Add logging for incoming and outgoing messages in size modifiers** "
"([#5437](https://github.com/adap/flower/pull/5437))"
msgstr ""

#: ../../source/ref-changelog.md:311
msgid ""
"**Bugfixes** ([#5340](https://github.com/adap/flower/pull/5340), "
"[#5366](https://github.com/adap/flower/pull/5366), "
"[#5478](https://github.com/adap/flower/pull/5478))"
msgstr ""

#: ../../source/ref-changelog.md:313
msgid ""
"**General improvements** "
"([#5516](https://github.com/adap/flower/pull/5516), "
"[#5499](https://github.com/adap/flower/pull/5499), "
"[#4927](https://github.com/adap/flower/pull/4927), "
"[#5310](https://github.com/adap/flower/pull/5310), "
"[#5343](https://github.com/adap/flower/pull/5343), "
"[#5359](https://github.com/adap/flower/pull/5359), "
"[#5413](https://github.com/adap/flower/pull/5413), "
"[#5299](https://github.com/adap/flower/pull/5299), "
"[#5433](https://github.com/adap/flower/pull/5433), "
"[#5390](https://github.com/adap/flower/pull/5390), "
"[#5427](https://github.com/adap/flower/pull/5427), "
"[#5350](https://github.com/adap/flower/pull/5350), "
"[#5394](https://github.com/adap/flower/pull/5394), "
"[#5295](https://github.com/adap/flower/pull/5295), "
"[#5315](https://github.com/adap/flower/pull/5315), "
"[#5468](https://github.com/adap/flower/pull/5468), "
"[#5412](https://github.com/adap/flower/pull/5412), "
"[#5348](https://github.com/adap/flower/pull/5348), "
"[#5444](https://github.com/adap/flower/pull/5444), "
"[#5522](https://github.com/adap/flower/pull/5522))"
msgstr ""

#: ../../source/ref-changelog.md:317
msgid "v1.18.0 (2025-04-23)"
msgstr ""

#: ../../source/ref-changelog.md:323
msgid ""
"`Alan Silva`, `Andrej Jovanović`, `Charles Beauville`, `Chong Shen Ng`, "
"`Chunhui XU`, `Daniel J. Beutel`, `Daniel Nata Nugraha`, `Dimitris "
"Stripelis`, `Guanheng Liu`, `Gustavo Bertoli`, `Heng Pan`, `Javier`, "
"`Khoa Nguyen`, `Mohammad Naseri`, `Pinji Chen`, `Robert Steiner`, "
"`Stephane Moroso`, `Taner Topal`, `William Lindskog`, `Yan Gao` <!---"
"TOKEN_v1.18.0-->"
msgstr ""

#: ../../source/ref-changelog.md:327
msgid ""
"**Add support for Python 3.12** "
"([#5238](https://github.com/adap/flower/pull/5238))"
msgstr ""

#: ../../source/ref-changelog.md:329
msgid ""
"Python 3.12 is officially supported (Python 3.12 was in preview support "
"since Flower 1.6). Python 3.13 support continues to be in preview until "
"all dependencies officially support Python 3.13."
msgstr ""

#: ../../source/ref-changelog.md:331
msgid ""
"**Enable TLS connection for `flwr` CLI using CA certificates** "
"([#5227](https://github.com/adap/flower/pull/5227), "
"[#5237](https://github.com/adap/flower/pull/5237), "
"[#5253](https://github.com/adap/flower/pull/5253), "
"[#5254](https://github.com/adap/flower/pull/5254))"
msgstr ""

#: ../../source/ref-changelog.md:333
msgid ""
"`flwr` CLI now supports secure TLS connections to SuperLink instances "
"with valid CA certificates. If no root certificates are provided, the CLI"
" automatically uses the default CA certificates bundled with gRPC."
msgstr ""

#: ../../source/ref-changelog.md:335
msgid ""
"**Add `--version` and `-V` flags to display `flwr` version** "
"([#5236](https://github.com/adap/flower/pull/5236))"
msgstr ""

#: ../../source/ref-changelog.md:337
msgid ""
"Users can run `flwr --version` or `flwr -V` to print the current Flower "
"version. The update also adds `-h` as a shorthand for CLI help."
msgstr ""

#: ../../source/ref-changelog.md:339
msgid ""
"**Use Hugging Face `flwrlabs` datasets in FlowerTune templates** "
"([#5205](https://github.com/adap/flower/pull/5205))"
msgstr ""

#: ../../source/ref-changelog.md:341
msgid ""
"FlowerTune templates switch to use datasets hosted under the `flwrlabs` "
"organization on Hugging Face."
msgstr ""

#: ../../source/ref-changelog.md:343
msgid ""
"**Upgrade FedBN baseline to support `flwr` CLI** "
"([#5115](https://github.com/adap/flower/pull/5115))"
msgstr ""

#: ../../source/ref-changelog.md:345
msgid ""
"Refactors the FedBN baseline to use the new Flower CLI, removes Hydra, "
"migrates configs, enables result saving, adds run instructions, and "
"ensures stateful clients."
msgstr ""

#: ../../source/ref-changelog.md:347
msgid ""
"**Fix bug in Shamir's secret sharing utilities affecting Secure "
"Aggregation** ([#5252](https://github.com/adap/flower/pull/5252))"
msgstr ""

#: ../../source/ref-changelog.md:349
msgid ""
"Refactors Shamir's secret sharing utilities to fix a bug impacting Secure"
" Aggregation. Thanks to [Pinji Chen](mailto:cpj24@mails.tsinghua.edu.cn) "
"and [Guanheng Liu](mailto:coolwind326@gmail.com) for their contributions."
msgstr ""

#: ../../source/ref-changelog.md:351
msgid ""
"**Ensure backward compatibility for `RecordDict`** "
"([#5239](https://github.com/adap/flower/pull/5239), "
"[#5270](https://github.com/adap/flower/pull/5270))"
msgstr ""

#: ../../source/ref-changelog.md:353
msgid ""
"The `RecordDict` (formerly `RecordSet`) now maintains full backward "
"compatibility. Legacy usages of `RecordSet` and its properties are "
"supported, with deprecation warnings logged when outdated references are "
"used. Users are encouraged to transition to the updated `RecordDict` "
"interface promptly to avoid future issues."
msgstr ""

#: ../../source/ref-changelog.md:355
msgid ""
"**Refactor and optimize CI/CD for repository restructuring** "
"([#5202](https://github.com/adap/flower/pull/5202), "
"[#5176](https://github.com/adap/flower/pull/5176), "
"[#5200](https://github.com/adap/flower/pull/5200), "
"[#5203](https://github.com/adap/flower/pull/5203), "
"[#5210](https://github.com/adap/flower/pull/5210), "
"[#5166](https://github.com/adap/flower/pull/5166), "
"[#5214](https://github.com/adap/flower/pull/5214), "
"[#5212](https://github.com/adap/flower/pull/5212), "
"[#5209](https://github.com/adap/flower/pull/5209), "
"[#5199](https://github.com/adap/flower/pull/5199), "
"[#5204](https://github.com/adap/flower/pull/5204), "
"[#5201](https://github.com/adap/flower/pull/5201), "
"[#5191](https://github.com/adap/flower/pull/5191), "
"[#5167](https://github.com/adap/flower/pull/5167), "
"[#5248](https://github.com/adap/flower/pull/5248), "
"[#5268](https://github.com/adap/flower/pull/5268), "
"[#5251](https://github.com/adap/flower/pull/5251))"
msgstr ""

#: ../../source/ref-changelog.md:357
msgid ""
"Improves CI/CD workflows to align with repository changes. Updates issue "
"templates, fixes Docker and docs jobs, enhances script compatibility, "
"adds checks, and bumps tool versions to streamline development and "
"deployment."
msgstr ""

#: ../../source/ref-changelog.md:359
msgid ""
"**Improve and clean up documentation** "
"([#5233](https://github.com/adap/flower/pull/5233), "
"[#5179](https://github.com/adap/flower/pull/5179), "
"[#5216](https://github.com/adap/flower/pull/5216), "
"[#5211](https://github.com/adap/flower/pull/5211), "
"[#5217](https://github.com/adap/flower/pull/5217), "
"[#5198](https://github.com/adap/flower/pull/5198), "
"[#5168](https://github.com/adap/flower/pull/5168), "
"[#5215](https://github.com/adap/flower/pull/5215), "
"[#5169](https://github.com/adap/flower/pull/5169), "
"[#5171](https://github.com/adap/flower/pull/5171), "
"[#5240](https://github.com/adap/flower/pull/5240), "
"[#5259](https://github.com/adap/flower/pull/5259))"
msgstr ""

#: ../../source/ref-changelog.md:361
msgid ""
"Removes outdated content, redundant CLI flags, and unnecessary sections; "
"updates Docker READMEs and virtual environment setup guide; and syncs "
"translation source texts."
msgstr ""

#: ../../source/ref-changelog.md:363
msgid ""
"**General Improvements** "
"([#5241](https://github.com/adap/flower/pull/5241), "
"[#5180](https://github.com/adap/flower/pull/5180), "
"[#5226](https://github.com/adap/flower/pull/5226), "
"[#5173](https://github.com/adap/flower/pull/5173), "
"[#5219](https://github.com/adap/flower/pull/5219), "
"[#5208](https://github.com/adap/flower/pull/5208), "
"[#5158](https://github.com/adap/flower/pull/5158), "
"[#5255](https://github.com/adap/flower/pull/5255), "
"[#5264](https://github.com/adap/flower/pull/5264), "
"[#5272](https://github.com/adap/flower/pull/5272))"
msgstr ""

#: ../../source/ref-changelog.md:369
msgid ""
"**Restructure repository (breaking change for contributors only)** "
"([#5206](https://github.com/adap/flower/pull/5206), "
"[#5194](https://github.com/adap/flower/pull/5194), "
"[#5192](https://github.com/adap/flower/pull/5192), "
"[#5185](https://github.com/adap/flower/pull/5185), "
"[#5184](https://github.com/adap/flower/pull/5184), "
"[#5177](https://github.com/adap/flower/pull/5177), "
"[#5183](https://github.com/adap/flower/pull/5183), "
"[#5207](https://github.com/adap/flower/pull/5207), "
"[#5267](https://github.com/adap/flower/pull/5267), "
"[#5274](https://github.com/adap/flower/pull/5274))"
msgstr ""

#: ../../source/ref-changelog.md:371
msgid ""
"Restructures the Flower repository by moving all framework-related code, "
"configs, and dev tools into the `framework/` subdirectory. This includes "
"relocating all files under `src/`, dev scripts, `pyproject.toml` and "
"other configs. Contributor documentation has been updated to reflect "
"these changes."
msgstr ""

#: ../../source/ref-changelog.md:373
msgid ""
"Switching to the new structure is straightforward and should require only"
" minimal adjustments for most contributors, though this is a breaking "
"change—refer to the [contributor "
"guide](https://flower.ai/docs/framework/v1.18.0/en/contribute.html) for "
"updated instructions."
msgstr ""

#: ../../source/ref-changelog.md:375
msgid "v1.17.0 (2025-03-24)"
msgstr ""

#: ../../source/ref-changelog.md:381
msgid ""
"`Aline Almeida`, `Charles Beauville`, `Chong Shen Ng`, `Daniel Hinjos "
"García`, `Daniel J. Beutel`, `Daniel Nata Nugraha`, `Dimitris Stripelis`,"
" `Heng Pan`, `Javier`, `Robert Steiner`, `Yan Gao` <!---TOKEN_v1.17.0-->"
msgstr ""

#: ../../source/ref-changelog.md:385
msgid ""
"**Allow registration of functions for custom message types** "
"([#5093](https://github.com/adap/flower/pull/5093))"
msgstr ""

#: ../../source/ref-changelog.md:387
msgid ""
"Enables support for custom message types in `ServerApp` by allowing the "
"`message_type` field to be set as `\"<action_type>.<action_name>\"`, "
"where `<action_type>` is one of `train`, `evaluate`, or `query`, and "
"`<action_name>` is a valid Python identifier. Developers can now register"
" handler functions for these custom message types using the decorator "
"`@app.<action_type>(\"<action_name>\")`. For example, the `my_echo_fn` "
"function is called when the `ServerApp` sends a message with "
"`message_type` set to `\"query.echo\"`, and the `get_mean_value` function"
" is called when it's `\"query.mean\"`:"
msgstr ""

#: ../../source/ref-changelog.md:409
msgid ""
"**Rename core Message API components for clarity and consistency** "
"([#5140](https://github.com/adap/flower/pull/5140), "
"[#5133](https://github.com/adap/flower/pull/5133), "
"[#5139](https://github.com/adap/flower/pull/5139), "
"[#5129](https://github.com/adap/flower/pull/5129), "
"[#5150](https://github.com/adap/flower/pull/5150), "
"[#5151](https://github.com/adap/flower/pull/5151), "
"[#5146](https://github.com/adap/flower/pull/5146), "
"[#5152](https://github.com/adap/flower/pull/5152))"
msgstr ""

#: ../../source/ref-changelog.md:411
msgid ""
"To improve clarity and ensure consistency across the Message API, the "
"following renamings have been made:"
msgstr ""

#: ../../source/ref-changelog.md:413
msgid "`Driver` → `Grid`"
msgstr ""

#: ../../source/ref-changelog.md:414
msgid "`RecordSet` → `RecordDict`"
msgstr ""

#: ../../source/ref-changelog.md:415
#, fuzzy
msgid "`ParametersRecord` → `ArrayRecord`"
msgstr "ParametersRecord"

#: ../../source/ref-changelog.md:416
msgid "`MetricsRecord` → `MetricRecord`"
msgstr ""

#: ../../source/ref-changelog.md:417
msgid "`ConfigsRecord` → `ConfigRecord`"
msgstr ""

#: ../../source/ref-changelog.md:419
msgid ""
"Backward compatibility is maintained for all the above changes, and "
"deprecation notices have been introduced to support a smooth transition."
msgstr ""

#: ../../source/ref-changelog.md:421
msgid ""
"**Enable seamless conversions between `ArrayRecord`/`Array` and "
"NumPy/PyTorch types** ([#4922](https://github.com/adap/flower/pull/4922),"
" [#4920](https://github.com/adap/flower/pull/4920))"
msgstr ""

#: ../../source/ref-changelog.md:423
msgid ""
"One-liner conversions are now supported between `Array` and "
"`numpy.ndarray` or `torch.Tensor`, and between `ArrayRecord` (formerly "
"`ParametersRecord`) and PyTorch `state_dict` or a list of "
"`numpy.ndarray`. This simplifies workflows involving model parameters and"
" tensor data structures. Example usage includes "
"`ArrayRecord(model.state_dict())` and "
"`array_record.to_torch_state_dict()`. Refer to the "
"[ArrayRecord](https://flower.ai/docs/framework/ref-"
"api/flwr.common.ArrayRecord.html) and "
"[Array](https://flower.ai/docs/framework/ref-api/flwr.common.Array.html) "
"documentation for details."
msgstr ""

#: ../../source/ref-changelog.md:425
msgid ""
"**Revamp message creation using `Message` constructor** "
"([#5137](https://github.com/adap/flower/pull/5137), "
"[#5153](https://github.com/adap/flower/pull/5153))"
msgstr ""

#: ../../source/ref-changelog.md:427
msgid ""
"Revamps the `Message` creation workflow by enabling direct instantiation "
"via the `Message(...)` constructor. This deprecates the previous APIs and"
" simplifies message creation:"
msgstr ""

#: ../../source/ref-changelog.md:429
msgid "`Driver.create_message(...)` → `Message(...)`"
msgstr ""

#: ../../source/ref-changelog.md:430
msgid ""
"`<some_message>.create_reply(...)` → `Message(..., "
"reply_to=<some_message>)`"
msgstr ""

#: ../../source/ref-changelog.md:432
msgid ""
"**Stabilize low-level Message API** "
"([#5120](https://github.com/adap/flower/pull/5120))"
msgstr ""

#: ../../source/ref-changelog.md:434
msgid ""
"With all the changes above, the stability of the low-level Message API "
"has been significantly improved. All preview feature warnings have been "
"removed, marking the completion of its transition out of experimental "
"status."
msgstr ""

#: ../../source/ref-changelog.md:436
msgid ""
"**Add node availability check to reduce wait time** "
"([#4968](https://github.com/adap/flower/pull/4968))"
msgstr ""

#: ../../source/ref-changelog.md:438
msgid ""
"Adds a node availability check to SuperLink. If the target SuperNode is "
"offline, SuperLink automatically generates an error reply message when "
"the ServerApp attempts to pull the reply. This mechanism helps avoid "
"unnecessary delays in each round caused by waiting for responses from "
"unavailable nodes."
msgstr ""

#: ../../source/ref-changelog.md:440
msgid ""
"**Enable extensible event logging for FleetServicer and ExecServicer** "
"([#4998](https://github.com/adap/flower/pull/4998), "
"[#4997](https://github.com/adap/flower/pull/4997), "
"[#4951](https://github.com/adap/flower/pull/4951), "
"[#4950](https://github.com/adap/flower/pull/4950), "
"[#5108](https://github.com/adap/flower/pull/5108))"
msgstr ""

#: ../../source/ref-changelog.md:442
msgid ""
"Introduces the necessary hooks and infrastructure to support RPC event "
"logging for `FleetServicer` and `ExecServicer`. This enables advanced "
"auditing and observability of RPC calls made by `flwr CLI` users and "
"SuperNodes, when appropriate event log plugins are available."
msgstr ""

#: ../../source/ref-changelog.md:444
msgid ""
"**Add CareQA benchmark for medical LLM evaluation** "
"([#4966](https://github.com/adap/flower/pull/4966))"
msgstr ""

#: ../../source/ref-changelog.md:446
msgid ""
"Adds the CareQA dataset as a new benchmark for evaluating medical "
"knowledge in LLMs. CareQA consists of 5,621 QA pairs from official "
"Spanish healthcare exams (2020–2024), translated to English and covering "
"multiple disciplines. This enhances the diversity of datasets used in the"
" Flower Medical LLM Leaderboard."
msgstr ""

#: ../../source/ref-changelog.md:448
msgid ""
"**Fix docstrings and improve handling of Ray nodes without CPU "
"resources** ([#5155](https://github.com/adap/flower/pull/5155), "
"[#5076](https://github.com/adap/flower/pull/5076), "
"[#5132](https://github.com/adap/flower/pull/5132))"
msgstr ""

#: ../../source/ref-changelog.md:450
msgid ""
"Fixes inaccurate or outdated docstrings in `RecordDict` and the "
"`FlowerClient` used in FlowerTune templates, improving documentation "
"clarity. Also adds handling for Ray nodes that report zero CPU resources,"
" preventing potential runtime issues."
msgstr ""

#: ../../source/ref-changelog.md:452
msgid ""
"**Improve documentation and examples** "
"([#5162](https://github.com/adap/flower/pull/5162), "
"[#5079](https://github.com/adap/flower/pull/5079), "
"[#5123](https://github.com/adap/flower/pull/5123), "
"[#5066](https://github.com/adap/flower/pull/5066), "
"[#5143](https://github.com/adap/flower/pull/5143), "
"[#5118](https://github.com/adap/flower/pull/5118), "
"[#5148](https://github.com/adap/flower/pull/5148), "
"[#5134](https://github.com/adap/flower/pull/5134), "
"[#5080](https://github.com/adap/flower/pull/5080), "
"[#5160](https://github.com/adap/flower/pull/5160), "
"[#5069](https://github.com/adap/flower/pull/5069), "
"[#5032](https://github.com/adap/flower/pull/5032))"
msgstr ""

#: ../../source/ref-changelog.md:454
msgid ""
"**Update CI/CD** ([#5125](https://github.com/adap/flower/pull/5125), "
"[#5062](https://github.com/adap/flower/pull/5062), "
"[#5056](https://github.com/adap/flower/pull/5056), "
"[#5048](https://github.com/adap/flower/pull/5048), "
"[#5065](https://github.com/adap/flower/pull/5065), "
"[#5061](https://github.com/adap/flower/pull/5061), "
"[#5057](https://github.com/adap/flower/pull/5057), "
"[#5064](https://github.com/adap/flower/pull/5064), "
"[#5144](https://github.com/adap/flower/pull/5144))"
msgstr ""

#: ../../source/ref-changelog.md:456
msgid ""
"**General Improvements** "
"([#5074](https://github.com/adap/flower/pull/5074), "
"[#5126](https://github.com/adap/flower/pull/5126), "
"[#5122](https://github.com/adap/flower/pull/5122), "
"[#5149](https://github.com/adap/flower/pull/5149), "
"[#5157](https://github.com/adap/flower/pull/5157))"
msgstr ""

#: ../../source/ref-changelog.md:460
msgid "v1.16.0 (2025-03-11)"
msgstr ""

#: ../../source/ref-changelog.md:466
msgid ""
"`Alan Silva`, `Andrej Jovanović`, `Charles Beauville`, `Chong Shen Ng`, "
"`Daniel J. Beutel`, `Dimitris Stripelis`, `Heng Pan`, `Javier`, `Kevin "
"Ta`, `Li Shaoyu`, `Mohammad Naseri`, `Taner Topal`, `Yan Gao` <!---"
"TOKEN_v1.16.0-->"
msgstr ""

#: ../../source/ref-changelog.md:470
msgid ""
"**Enhance `RecordSet` and `Array` for improved usability** "
"([#4963](https://github.com/adap/flower/pull/4963), "
"[#4980](https://github.com/adap/flower/pull/4980), "
"[#4918](https://github.com/adap/flower/pull/4918))"
msgstr ""

#: ../../source/ref-changelog.md:472
msgid ""
"`RecordSet` now supports dictionary-like access, allowing interactions "
"similar to built-in Python dictionaries. For example, instead of "
"`recordset.parameters_records[\"model\"]`, users can simply use "
"`recordset[\"model\"]`. This enhancement maintains backward compatibility"
" with existing `recordset.*_records` properties."
msgstr ""

#: ../../source/ref-changelog.md:474
msgid ""
"Additionally, the `Array` class now accepts `numpy.ndarray` instances "
"directly in its constructor, enabling instantiation with a NumPy array "
"via `Array(your_numpy_ndarray)`."
msgstr ""

#: ../../source/ref-changelog.md:476
msgid ""
"**Support function-specific Flower Mods for `ClientApp`** "
"([#4954](https://github.com/adap/flower/pull/4954), "
"[#4962](https://github.com/adap/flower/pull/4962))"
msgstr ""

#: ../../source/ref-changelog.md:478
msgid ""
"Flower Mods can now be applied to individual functions within the "
"`ClientApp` rather than affecting the entire application. This allows for"
" more granular control. The documentation has been updated to reflect "
"these changes — please refer to [How to Use Built-in "
"Mods](https://flower.ai/docs/framework/how-to-use-built-in-mods.html"
"#registering-function-specific-mods) for details."
msgstr ""

#: ../../source/ref-changelog.md:480
msgid ""
"**Introduce `@app.lifespan()` for lifecycle management** "
"([#4929](https://github.com/adap/flower/pull/4929), "
"[#4986](https://github.com/adap/flower/pull/4986))"
msgstr ""

#: ../../source/ref-changelog.md:482
msgid ""
"`ServerApp` and `ClientApp` now support `@app.lifespan()`, enabling "
"custom enter/exit handlers for resource setup and cleanup. Throughout the"
" entire FL training, these handlers in `ClientApp` may run multiple times"
" as instances are dynamically managed."
msgstr ""

#: ../../source/ref-changelog.md:484
msgid ""
"**Add FedRAG example** "
"([#4955](https://github.com/adap/flower/pull/4955), "
"[#5036](https://github.com/adap/flower/pull/5036), "
"[#5042](https://github.com/adap/flower/pull/5042))"
msgstr ""

#: ../../source/ref-changelog.md:486
msgid ""
"Adds a [FedRAG example](https://flower.ai/docs/examples/fedrag.html), "
"integrating Federated Learning with Retrieval Augmented Generation (RAG)."
" This approach allows Large Language Models (LLMs) to query distributed "
"data silos without centrally aggregating the corpora, enhancing "
"performance while preserving data privacy."
msgstr ""

#: ../../source/ref-changelog.md:488
msgid ""
"**Upgrade FedProx baseline to a Flower App** "
"([#4937](https://github.com/adap/flower/pull/4937))"
msgstr ""

#: ../../source/ref-changelog.md:490
msgid ""
"Updates FedProx to the a Flower App by removing Hydra, migrating configs "
"to `pyproject.toml`, using `ClientApp` and `ServerApp`, integrating "
"`flwr-datasets` with `DistributionPartitioner`, enabling result saving, "
"and updating `README.md`. This baseline now supports `flwr run`."
msgstr ""

#: ../../source/ref-changelog.md:492
msgid ""
"**Migrate framework to Message-based system** "
"([#4959](https://github.com/adap/flower/pull/4959), "
"[#4993](https://github.com/adap/flower/pull/4993), "
"[#4979](https://github.com/adap/flower/pull/4979), "
"[#4999](https://github.com/adap/flower/pull/4999))"
msgstr ""

#: ../../source/ref-changelog.md:494
msgid ""
"The Flower framework has been fully migrated from a "
"`TaskIns`/`TaskRes`-based system to a `Message`-based system, aligning "
"with the user-facing `Message` class. This includes adding validator "
"functions for `Message`, introducing `LinkState` methods that operate on "
"`Message`, updating `LinkState` to use `Message`-only methods, and "
"removing the `Task`-related code entirely."
msgstr ""

#: ../../source/ref-changelog.md:496
msgid ""
"**Introduce event logging extension points** "
"([#4948](https://github.com/adap/flower/pull/4948), "
"[#5013](https://github.com/adap/flower/pull/5013))"
msgstr ""

#: ../../source/ref-changelog.md:498
msgid ""
"Begins implementing an event logging system for SuperLink, allowing RPC "
"calls to be logged when enabled. These changes introduce initial "
"extension points."
msgstr ""

#: ../../source/ref-changelog.md:500
msgid ""
"**Increase default TTL and message size** "
"([#5011](https://github.com/adap/flower/pull/5011), "
"[#5028](https://github.com/adap/flower/pull/5028))"
msgstr ""

#: ../../source/ref-changelog.md:502
msgid ""
"The default TTL for messages is now 12 hours (up from 1 hour), and the "
"gRPC message size limit has increased from 512MB to 2GB. TTL sets a hard "
"limit on the time between the `ServerApp` sending an instruction and "
"receiving a reply from the `ClientApp`."
msgstr ""

#: ../../source/ref-changelog.md:504
msgid ""
"**Improve documentation** "
"([#4945](https://github.com/adap/flower/pull/4945), "
"[#4965](https://github.com/adap/flower/pull/4965), "
"[#4994](https://github.com/adap/flower/pull/4994), "
"[#4964](https://github.com/adap/flower/pull/4964), "
"[#4991](https://github.com/adap/flower/pull/4991), "
"[#5014](https://github.com/adap/flower/pull/5014), "
"[#4970](https://github.com/adap/flower/pull/4970), "
"[#4990](https://github.com/adap/flower/pull/4990), "
"[#4978](https://github.com/adap/flower/pull/4978), "
"[#4944](https://github.com/adap/flower/pull/4944), "
"[#5022](https://github.com/adap/flower/pull/5022), "
"[#5007](https://github.com/adap/flower/pull/5007), "
"[#4988](https://github.com/adap/flower/pull/4988), "
"[#5053](https://github.com/adap/flower/pull/5053))"
msgstr ""

#: ../../source/ref-changelog.md:506
msgid ""
"**Update CI/CD** ([#4943](https://github.com/adap/flower/pull/4943), "
"[#4942](https://github.com/adap/flower/pull/4942), "
"[#4953](https://github.com/adap/flower/pull/4953), "
"[#4985](https://github.com/adap/flower/pull/4985), "
"[#4984](https://github.com/adap/flower/pull/4984), "
"[#5025](https://github.com/adap/flower/pull/5025), "
"[#4987](https://github.com/adap/flower/pull/4987), "
"[#4912](https://github.com/adap/flower/pull/4912), "
"[#5049](https://github.com/adap/flower/pull/5049))"
msgstr ""

#: ../../source/ref-changelog.md:508
msgid ""
"**Bugfixes** ([#4969](https://github.com/adap/flower/pull/4969), "
"[#4974](https://github.com/adap/flower/pull/4974), "
"[#5017](https://github.com/adap/flower/pull/5017), "
"[#4995](https://github.com/adap/flower/pull/4995), "
"[#4971](https://github.com/adap/flower/pull/4971), "
"[#5037](https://github.com/adap/flower/pull/5037), "
"[#5038](https://github.com/adap/flower/pull/5038))"
msgstr ""

#: ../../source/ref-changelog.md:510
msgid ""
"**General Improvements** "
"([#4947](https://github.com/adap/flower/pull/4947), "
"[#4972](https://github.com/adap/flower/pull/4972), "
"[#4992](https://github.com/adap/flower/pull/4992), "
"[#5020](https://github.com/adap/flower/pull/5020), "
"[#5018](https://github.com/adap/flower/pull/5018), "
"[#4989](https://github.com/adap/flower/pull/4989), "
"[#4957](https://github.com/adap/flower/pull/4957), "
"[#5000](https://github.com/adap/flower/pull/5000), "
"[#5012](https://github.com/adap/flower/pull/5012), "
"[#5001](https://github.com/adap/flower/pull/5001))"
msgstr ""

#: ../../source/ref-changelog.md:516
msgid ""
"**Remove deprecated CLI commands** "
"([#4855](https://github.com/adap/flower/pull/4855))"
msgstr ""

#: ../../source/ref-changelog.md:518
msgid ""
"Removes deprecated CLI commands: `flower-server-app`, `flower-superexec`,"
" and `flower-client-app`. These commands are no longer available in the "
"framework."
msgstr ""

#: ../../source/ref-changelog.md:520
msgid ""
"**Bump minimum Python and `cryptography` versions** "
"([#4946](https://github.com/adap/flower/pull/4946))"
msgstr ""

#: ../../source/ref-changelog.md:522
msgid ""
"Bumps the minimum Python version from 3.9 to 3.9.2 and updates the "
"`cryptography` package from 43.0.1 to 44.0.1. This change ensures "
"compatibility with the latest security updates and features."
msgstr ""

#: ../../source/ref-changelog.md:524
msgid "v1.15.2 (2025-02-17)"
msgstr ""

#: ../../source/ref-changelog.md:530
msgid ""
"`Charles Beauville`, `Heng Pan`, `Javier`, `Leandro Collier`, `Stephane "
"Moroso`, `Yan Gao` <!---TOKEN_v1.15.2-->"
msgstr ""

#: ../../source/ref-changelog.md:534
msgid ""
"**Free processed messages in LinkState** "
"([#4934](https://github.com/adap/flower/pull/4934))"
msgstr ""

#: ../../source/ref-changelog.md:536
msgid ""
"When the ServerApp pulls the replies the SuperNodes sent to the "
"SuperLink, these should be removed from the LinkState. In some "
"situations, these weren't erased, which could lead to high memory "
"utilization by the SuperLink."
msgstr ""

#: ../../source/ref-changelog.md:538
msgid ""
"**Introduce Windows CI tests** "
"([#4908](https://github.com/adap/flower/pull/4908))"
msgstr ""

#: ../../source/ref-changelog.md:540
msgid ""
"We continue improving the experience of running Flower on Windows. Now, "
"an automated CI test is run to ensure compatibility."
msgstr ""

#: ../../source/ref-changelog.md:542
msgid ""
"**Update Ray version (Simulation Engine)** "
"([#4926](https://github.com/adap/flower/pull/4926))"
msgstr ""

#: ../../source/ref-changelog.md:544
msgid ""
"The Simulation Engine has been upgraded to a version of Ray that is "
"compatible with Python 3.12."
msgstr ""

#: ../../source/ref-changelog.md:546
msgid ""
"**Update Documentation** "
"([#4915](https://github.com/adap/flower/pull/4915), "
"[#4914](https://github.com/adap/flower/pull/4914))"
msgstr ""

#: ../../source/ref-changelog.md:548
msgid ""
"**Other quality improvements** "
"([#4935](https://github.com/adap/flower/pull/4935), "
"[#4936](https://github.com/adap/flower/pull/4936), "
"[#4928](https://github.com/adap/flower/pull/4928), "
"[#4924](https://github.com/adap/flower/pull/4924), "
"[#4939](https://github.com/adap/flower/pull/4939))"
msgstr ""

#: ../../source/ref-changelog.md:550
msgid "v1.15.1 (2025-02-05)"
msgstr ""

#: ../../source/ref-changelog.md:556
msgid ""
"`Dimitris Stripelis`, `Heng Pan`, `Javier`, `Taner Topal`, `Yan Gao` <!"
"---TOKEN_v1.15.1-->"
msgstr ""

#: ../../source/ref-changelog.md:560
msgid ""
"**Improve time drift compensation in automatic SuperNode authentication**"
" ([#4899](https://github.com/adap/flower/pull/4899))"
msgstr ""

#: ../../source/ref-changelog.md:562
msgid ""
"In addition to allowing for a time delay (positive time difference), "
"SuperLink now also accounts for time drift, which might result in "
"negative time differences between timestamps in SuperLink and SuperNode "
"during authentication."
msgstr ""

#: ../../source/ref-changelog.md:564
msgid ""
"**Rename constants for gRPC metadata** "
"([#4902](https://github.com/adap/flower/pull/4902))"
msgstr ""

#: ../../source/ref-changelog.md:566
msgid ""
"All metadata keys in gRPC messages that previously used underscores (`_`)"
" have been replaced with hyphens (`-`). Using underscores is not "
"recommended in setups where SuperLink may be deployed behind load "
"balancers or reverse proxies."
msgstr ""

#: ../../source/ref-changelog.md:568
msgid ""
"**Filtering out non-Fleet API requests at the `FleetServicer`** "
"([#4900](https://github.com/adap/flower/pull/4900))"
msgstr ""

#: ../../source/ref-changelog.md:570
msgid ""
"The Fleet API endpoint will now reject gRPC requests that are not part of"
" its API."
msgstr ""

#: ../../source/ref-changelog.md:572
msgid ""
"**Fix exit handlers mechanism for Windows** "
"([#4907](https://github.com/adap/flower/pull/4907))"
msgstr ""

#: ../../source/ref-changelog.md:574
msgid ""
"The `SIGQUIT` [Python "
"signal](https://docs.python.org/3/library/signal.html) is not supported "
"on Windows. This signal is now excluded when Flower is executed on "
"Windows."
msgstr ""

#: ../../source/ref-changelog.md:576
msgid ""
"**Updated Examples** ([#4895](https://github.com/adap/flower/pull/4895), "
"[#4158](https://github.com/adap/flower/pull/4158), "
"[#4879](https://github.com/adap/flower/pull/4879))"
msgstr ""

#: ../../source/ref-changelog.md:578
msgid ""
"Examples have been updated to the latest version of Flower. Some examples"
" have also had their dependencies upgraded. The [Federated Finetuning of "
"a Whisper model "
"example](https://github.com/adap/flower/tree/main/examples/whisper-"
"federated-finetuning) has been updated to use the new Flower execution "
"method: `flwr run`."
msgstr ""

#: ../../source/ref-changelog.md:580
msgid ""
"**Update FlowerTuneLLM Leaderboard evaluation scripts** "
"([#4910](https://github.com/adap/flower/pull/4910))"
msgstr ""

#: ../../source/ref-changelog.md:582
msgid ""
"We have updated the package versions used in the evaluation scripts. "
"There is still time to participate in the [Flower LLM "
"Leaderboard](https://flower.ai/benchmarks/llm-leaderboard/)!"
msgstr ""

#: ../../source/ref-changelog.md:584
msgid ""
"**Update Documentation** "
"([#4897](https://github.com/adap/flower/pull/4897), "
"[#4896](https://github.com/adap/flower/pull/4896), "
"[#4898](https://github.com/adap/flower/pull/4898), "
"[#4909](https://github.com/adap/flower/pull/4909))"
msgstr ""

#: ../../source/ref-changelog.md:586
msgid "v1.15.0 (2025-01-31)"
msgstr ""

#: ../../source/ref-changelog.md:592
msgid ""
"`Charles Beauville`, `Chong Shen Ng`, `Daniel J. Beutel`, `Daniel Nata "
"Nugraha`, `Haoran Jie`, `Heng Pan`, `Ivelin Ivanov`, `Javier`, `Kevin "
"Patel`, `Mohammad Naseri`, `Pavlos Bouzinis`, `Robert Steiner` <!---"
"TOKEN_v1.15.0-->"
msgstr ""

#: ../../source/ref-changelog.md:596
msgid ""
"**Enhance SuperNode authentication** "
"([#4767](https://github.com/adap/flower/pull/4767), "
"[#4791](https://github.com/adap/flower/pull/4791), "
"[#4765](https://github.com/adap/flower/pull/4765), "
"[#4857](https://github.com/adap/flower/pull/4857), "
"[#4867](https://github.com/adap/flower/pull/4867))"
msgstr ""

#: ../../source/ref-changelog.md:598
msgid ""
"Enhances the SuperNode authentication system, making it more efficient "
"and resilient against replay attacks. There's no longer a need to pass "
"`--auth-superlink-private-key` and `--auth-superlink-public-key` when "
"running the SuperLink. Additionally, Flower now enables automatic node "
"authentication by default, preventing impersonation even when node "
"authentication is not explicitly used. For more details, see the "
"[documentation](https://flower.ai/docs/framework/how-to-authenticate-"
"supernodes.html)."
msgstr ""

#: ../../source/ref-changelog.md:600
msgid ""
"**Add guide for running Flower with Deployment Engine** "
"([#4811](https://github.com/adap/flower/pull/4811), "
"[#4733](https://github.com/adap/flower/pull/4733))"
msgstr ""

#: ../../source/ref-changelog.md:602
msgid ""
"Introduces the [How to run Flower with Deployment "
"Engine](https://flower.ai/docs/framework/how-to-run-flower-with-"
"deployment-engine.html) guide, providing detailed instructions on "
"deploying Federated Learning in production environments using the Flower "
"Deployment Engine."
msgstr ""

#: ../../source/ref-changelog.md:604
msgid ""
"**Add Flower Network Communication reference documentation** "
"([#4805](https://github.com/adap/flower/pull/4805))"
msgstr ""

#: ../../source/ref-changelog.md:606
msgid ""
"Introduces the [*Flower Network "
"Communication*](https://flower.ai/docs/framework/ref-flower-network-"
"communication.html) documentation, which details the network connections "
"used in a deployed Flower federated AI system."
msgstr ""

#: ../../source/ref-changelog.md:608
msgid ""
"**Add LeRobot quickstart example** "
"([#4607](https://github.com/adap/flower/pull/4607), "
"[#4816](https://github.com/adap/flower/pull/4816))"
msgstr ""

#: ../../source/ref-changelog.md:610
msgid ""
"Introduces an example demonstrating federated training of a Diffusion "
"policy on the PushT dataset using LeRobot and Flower. The dataset is "
"partitioned with Flower Datasets, and the example runs best with a GPU. "
"More details: [Flower LeRobot Example](https://flower.ai/docs/examples"
"/quickstart-lerobot.html)."
msgstr ""

#: ../../source/ref-changelog.md:612
msgid ""
"**Add video tutorial to simulation documentation** "
"([#4768](https://github.com/adap/flower/pull/4768))"
msgstr ""

#: ../../source/ref-changelog.md:614
msgid ""
"The *Flower AI Simulation 2025* tutorial series is now available on "
"YouTube. You can watch all the videos "
"[here](https://www.youtube.com/playlist?list=PLNG4feLHqCWkdlSrEL2xbCtGa6QBxlUZb)"
" or via the embedded previews in the "
"[documentation](https://flower.ai/docs/framework/how-to-run-"
"simulations.html). The accompanying code for the tutorial can be found in"
" the [Flower GitHub "
"repository](https://github.com/adap/flower/tree/main/examples/flower-"
"simulation-step-by-step-pytorch)."
msgstr ""

#: ../../source/ref-changelog.md:616
msgid ""
"**Introduce StatAvg baseline** "
"([#3921](https://github.com/adap/flower/pull/3921))"
msgstr ""

#: ../../source/ref-changelog.md:618
msgid ""
"StatAvg mitigates non-IID feature distributions in federated learning by "
"sharing and aggregating data statistics before training. It is compatible"
" with any FL aggregation strategy. More details: [StatAvg "
"baseline](https://flower.ai/docs/baselines/statavg.html)."
msgstr ""

#: ../../source/ref-changelog.md:620
msgid ""
"**Allow setting log level via environment variable** "
"([#4860](https://github.com/adap/flower/pull/4860), "
"[#4880](https://github.com/adap/flower/pull/4880), "
"[#4886](https://github.com/adap/flower/pull/4886))"
msgstr ""

#: ../../source/ref-changelog.md:622
msgid ""
"Log level can now be configured using the `FLWR_LOG_LEVEL` environment "
"variable. For example, running `FLWR_LOG_LEVEL=DEBUG flower-superlink "
"--insecure` will set the log level to DEBUG. For more details, see the "
"[guide](https://flower.ai/docs/framework/how-to-configure-logging.html)."
msgstr ""

#: ../../source/ref-changelog.md:624
msgid ""
"**Enable dynamic overrides for federation configuration in CLI** "
"([#4841](https://github.com/adap/flower/pull/4841), "
"[#4843](https://github.com/adap/flower/pull/4843), "
"[#4838](https://github.com/adap/flower/pull/4838))"
msgstr ""

#: ../../source/ref-changelog.md:626
msgid ""
"Similar to how the `--run-config` flag allows overriding the run "
"configuration in `flwr run`, the new `--federation-config` flag enables "
"dynamic overrides for federation configurations. This flag is supported "
"in all `flwr` CLI commands except `flwr build`, `flwr install`, and `flwr"
" new`."
msgstr ""

#: ../../source/ref-changelog.md:628
msgid ""
"**Migrate TaskIns/TaskRes to Message-based communication** "
"([#4311](https://github.com/adap/flower/pull/4311), "
"[#4310](https://github.com/adap/flower/pull/4310), "
"[#4849](https://github.com/adap/flower/pull/4849), "
"[#4308](https://github.com/adap/flower/pull/4308), "
"[#4307](https://github.com/adap/flower/pull/4307), "
"[#4800](https://github.com/adap/flower/pull/4800), "
"[#4309](https://github.com/adap/flower/pull/4309), "
"[#4875](https://github.com/adap/flower/pull/4875), "
"[#4874](https://github.com/adap/flower/pull/4874), "
"[#4877](https://github.com/adap/flower/pull/4877), "
"[#4876](https://github.com/adap/flower/pull/4876))"
msgstr ""

#: ../../source/ref-changelog.md:630
msgid ""
"The Fleet API and the ServerAppIO API (formerly known as the Driver API) "
"now use message-based communication instead of TaskIns/TaskRes, making "
"interactions more intuitive and better aligned with their Python "
"counterparts. This migration introduces new RPCs, such as `PullMessages`,"
" `PushMessages`, and other message-based operations in the gRPC stack."
msgstr ""

#: ../../source/ref-changelog.md:632
msgid ""
"**Introduce exit codes** "
"([#4801](https://github.com/adap/flower/pull/4801), "
"[#4845](https://github.com/adap/flower/pull/4845))"
msgstr ""

#: ../../source/ref-changelog.md:634
msgid ""
"Improves system error and help messages by introducing a dedicated "
"`flwr_exit` function with standardized exit codes."
msgstr ""

#: ../../source/ref-changelog.md:636
msgid ""
"**Update gRPC-related dependencies** "
"([#4833](https://github.com/adap/flower/pull/4833), "
"[#4836](https://github.com/adap/flower/pull/4836), "
"[#4887](https://github.com/adap/flower/pull/4887))"
msgstr ""

#: ../../source/ref-changelog.md:638
msgid ""
"Increases the version numbers of gRPC-related dependencies. In rare "
"cases, if you encounter pip warnings about unresolved gRPC dependencies, "
"it may be due to residual dependencies from older Flower versions."
msgstr ""

#: ../../source/ref-changelog.md:640
msgid ""
"**Update** `app-pytorch` **example** "
"([#4842](https://github.com/adap/flower/pull/4842))"
msgstr ""

#: ../../source/ref-changelog.md:642
msgid ""
"The [app-pytorch example](https://flower.ai/docs/examples/app-"
"pytorch.html) is revamped to use the low-level API."
msgstr ""

#: ../../source/ref-changelog.md:644
msgid ""
"**Improve CLI-side user authentication** "
"([#4862](https://github.com/adap/flower/pull/4862), "
"[#4861](https://github.com/adap/flower/pull/4861), "
"[#4832](https://github.com/adap/flower/pull/4832), "
"[#4850](https://github.com/adap/flower/pull/4850), "
"[#4703](https://github.com/adap/flower/pull/4703), "
"[#4885](https://github.com/adap/flower/pull/4885))"
msgstr ""

#: ../../source/ref-changelog.md:646
msgid ""
"User authentication in the CLI is enhanced with better handling, "
"configuration options, and security enforcement."
msgstr ""

#: ../../source/ref-changelog.md:648
msgid ""
"**Ensure graceful exit for SuperLink and SuperNode** "
"([#4829](https://github.com/adap/flower/pull/4829), "
"[#4846](https://github.com/adap/flower/pull/4846), "
"[#4798](https://github.com/adap/flower/pull/4798), "
"[#4826](https://github.com/adap/flower/pull/4826), "
"[#4881](https://github.com/adap/flower/pull/4881), "
"[#4797](https://github.com/adap/flower/pull/4797))"
msgstr ""

#: ../../source/ref-changelog.md:650
msgid ""
"Ensures proper resource cleanup and prevents zombie subprocesses during "
"SuperLink and SuperNode shutdown."
msgstr ""

#: ../../source/ref-changelog.md:652
msgid ""
"**Improve documentation** "
"([#4380](https://github.com/adap/flower/pull/4380), "
"[#4853](https://github.com/adap/flower/pull/4853), "
"[#4214](https://github.com/adap/flower/pull/4214), "
"[#4215](https://github.com/adap/flower/pull/4215), "
"[#4863](https://github.com/adap/flower/pull/4863), "
"[#4825](https://github.com/adap/flower/pull/4825), "
"[#4759](https://github.com/adap/flower/pull/4759), "
"[#4851](https://github.com/adap/flower/pull/4851), "
"[#4779](https://github.com/adap/flower/pull/4779), "
"[#4813](https://github.com/adap/flower/pull/4813), "
"[#4812](https://github.com/adap/flower/pull/4812), "
"[#4761](https://github.com/adap/flower/pull/4761), "
"[#4859](https://github.com/adap/flower/pull/4859), "
"[#4754](https://github.com/adap/flower/pull/4754), "
"[#4839](https://github.com/adap/flower/pull/4839), "
"[#4216](https://github.com/adap/flower/pull/4216), "
"[#4852](https://github.com/adap/flower/pull/4852), "
"[#4869](https://github.com/adap/flower/pull/4869))"
msgstr ""

#: ../../source/ref-changelog.md:654
msgid ""
"Updates PyTorch device selection in the tutorial series notebook and adds"
" two molecular datasets to the `recommended-fl-datasets` table. "
"Additional improvements include metadata updates, translation updates, "
"and refinements to various documentation sections."
msgstr ""

#: ../../source/ref-changelog.md:656
msgid ""
"**Update Docker dependencies and documentation** "
"([#4763](https://github.com/adap/flower/pull/4763), "
"[#4804](https://github.com/adap/flower/pull/4804), "
"[#4762](https://github.com/adap/flower/pull/4762), "
"[#4803](https://github.com/adap/flower/pull/4803), "
"[#4753](https://github.com/adap/flower/pull/4753))"
msgstr ""

#: ../../source/ref-changelog.md:658
msgid ""
"**Update CI/CD** ([#4756](https://github.com/adap/flower/pull/4756), "
"[#4834](https://github.com/adap/flower/pull/4834), "
"[#4824](https://github.com/adap/flower/pull/4824), "
"[#3493](https://github.com/adap/flower/pull/3493), "
"[#4096](https://github.com/adap/flower/pull/4096), "
"[#4807](https://github.com/adap/flower/pull/4807), "
"[#3956](https://github.com/adap/flower/pull/3956), "
"[#3168](https://github.com/adap/flower/pull/3168), "
"[#4835](https://github.com/adap/flower/pull/4835), "
"[#4884](https://github.com/adap/flower/pull/4884))"
msgstr ""

#: ../../source/ref-changelog.md:660
msgid ""
"**Bugfixes** ([#4766](https://github.com/adap/flower/pull/4766), "
"[#4764](https://github.com/adap/flower/pull/4764), "
"[#4795](https://github.com/adap/flower/pull/4795), "
"[#4840](https://github.com/adap/flower/pull/4840), "
"[#4868](https://github.com/adap/flower/pull/4868), "
"[#4872](https://github.com/adap/flower/pull/4872), "
"[#4890](https://github.com/adap/flower/pull/4890))"
msgstr ""

#: ../../source/ref-changelog.md:662
msgid ""
"**General improvements** "
"([#4748](https://github.com/adap/flower/pull/4748), "
"[#4799](https://github.com/adap/flower/pull/4799), "
"[#4645](https://github.com/adap/flower/pull/4645), "
"[#4819](https://github.com/adap/flower/pull/4819), "
"[#4755](https://github.com/adap/flower/pull/4755), "
"[#4789](https://github.com/adap/flower/pull/4789), "
"[#4771](https://github.com/adap/flower/pull/4771), "
"[#4854](https://github.com/adap/flower/pull/4854), "
"[#4796](https://github.com/adap/flower/pull/4796), "
"[#4865](https://github.com/adap/flower/pull/4865), "
"[#4820](https://github.com/adap/flower/pull/4820), "
"[#4790](https://github.com/adap/flower/pull/4790), "
"[#4821](https://github.com/adap/flower/pull/4821), "
"[#4822](https://github.com/adap/flower/pull/4822), "
"[#4751](https://github.com/adap/flower/pull/4751), "
"[#4793](https://github.com/adap/flower/pull/4793), "
"[#4871](https://github.com/adap/flower/pull/4871), "
"[#4785](https://github.com/adap/flower/pull/4785), "
"[#4787](https://github.com/adap/flower/pull/4787), "
"[#4775](https://github.com/adap/flower/pull/4775), "
"[#4783](https://github.com/adap/flower/pull/4783), "
"[#4818](https://github.com/adap/flower/pull/4818), "
"[#4786](https://github.com/adap/flower/pull/4786), "
"[#4773](https://github.com/adap/flower/pull/4773), "
"[#4772](https://github.com/adap/flower/pull/4772), "
"[#4784](https://github.com/adap/flower/pull/4784), "
"[#4810](https://github.com/adap/flower/pull/4810), "
"[#4770](https://github.com/adap/flower/pull/4770), "
"[#4870](https://github.com/adap/flower/pull/4870), "
"[#4878](https://github.com/adap/flower/pull/4878), "
"[#4889](https://github.com/adap/flower/pull/4889), "
"[#4893](https://github.com/adap/flower/pull/4893))"
msgstr ""

#: ../../source/ref-changelog.md:668
msgid ""
"**Remove deprecated `app`/`--server` arguments from `flower-supernode`** "
"([#4864](https://github.com/adap/flower/pull/4864), "
"[#4891](https://github.com/adap/flower/pull/4891))"
msgstr ""

#: ../../source/ref-changelog.md:670
msgid ""
"The deprecated `app` and `--server` arguments in `flower-supernode` has "
"been removed. Please use `--superlink` instead of `--server`."
msgstr ""

#: ../../source/ref-changelog.md:672
msgid ""
"**Deprecate `--auth-superlink-private-key`/`--auth-superlink-public-key` "
"arguments from `flower-superlink`** "
"([#4848](https://github.com/adap/flower/pull/4848))"
msgstr ""

#: ../../source/ref-changelog.md:674
msgid ""
"The two arguments are no longer necessary for SuperNode authentication "
"following the recent improvement mentioned above."
msgstr ""

#: ../../source/ref-changelog.md:676
msgid "v1.14.0 (2024-12-20)"
msgstr ""

#: ../../source/ref-changelog.md:682
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Chong Shen Ng`, `Daniel Nata "
"Nugraha`, `Dimitris Stripelis`, `Heng Pan`, `Javier`, `Meng Yan`, "
"`Mohammad Naseri`, `Robert Steiner`, `Taner Topal`, `Vidit Khandelwal`, "
"`Yan Gao` <!---TOKEN_v1.14.0-->"
msgstr ""

#: ../../source/ref-changelog.md:686
msgid ""
"**Introduce `flwr stop` command** "
"([#4647](https://github.com/adap/flower/pull/4647), "
"[#4629](https://github.com/adap/flower/pull/4629), "
"[#4694](https://github.com/adap/flower/pull/4694), "
"[#4646](https://github.com/adap/flower/pull/4646), "
"[#4634](https://github.com/adap/flower/pull/4634), "
"[#4700](https://github.com/adap/flower/pull/4700), "
"[#4684](https://github.com/adap/flower/pull/4684), "
"[#4642](https://github.com/adap/flower/pull/4642), "
"[#4682](https://github.com/adap/flower/pull/4682), "
"[#4683](https://github.com/adap/flower/pull/4683), "
"[#4639](https://github.com/adap/flower/pull/4639), "
"[#4668](https://github.com/adap/flower/pull/4668), "
"[#4658](https://github.com/adap/flower/pull/4658), "
"[#4693](https://github.com/adap/flower/pull/4693), "
"[#4704](https://github.com/adap/flower/pull/4704), "
"[#4729](https://github.com/adap/flower/pull/4729))"
msgstr ""

#: ../../source/ref-changelog.md:688
msgid ""
"The `flwr stop` command is now available to stop a submitted run. You can"
" use it as follows:"
msgstr ""

#: ../../source/ref-changelog.md:690
msgid "`flwr stop <run-id>`"
msgstr ""

#: ../../source/ref-changelog.md:691
msgid "`flwr stop <run-id> [<app>] [<federation>]`"
msgstr ""

#: ../../source/ref-changelog.md:693
msgid ""
"This command instructs the SuperLink to terminate the specified run. "
"While the execution of `ServerApp` and `ClientApp` processes will not be "
"interrupted instantly, they will be informed of the stopped run and will "
"gracefully terminate when they next communicate with the SuperLink."
msgstr ""

#: ../../source/ref-changelog.md:695
msgid ""
"**Add JSON format output for CLI commands** "
"([#4610](https://github.com/adap/flower/pull/4610), "
"[#4613](https://github.com/adap/flower/pull/4613), "
"[#4710](https://github.com/adap/flower/pull/4710), "
"[#4621](https://github.com/adap/flower/pull/4621), "
"[#4612](https://github.com/adap/flower/pull/4612), "
"[#4619](https://github.com/adap/flower/pull/4619), "
"[#4611](https://github.com/adap/flower/pull/4611), "
"[#4620](https://github.com/adap/flower/pull/4620), "
"[#4712](https://github.com/adap/flower/pull/4712), "
"[#4633](https://github.com/adap/flower/pull/4633), "
"[#4632](https://github.com/adap/flower/pull/4632), "
"[#4711](https://github.com/adap/flower/pull/4711), "
"[#4714](https://github.com/adap/flower/pull/4714), "
"[#4734](https://github.com/adap/flower/pull/4734), "
"[#4738](https://github.com/adap/flower/pull/4738))"
msgstr ""

#: ../../source/ref-changelog.md:697
msgid ""
"The `flwr run`, `flwr ls`, and `flwr stop` commands now support JSON-"
"formatted output using the `--format json` flag. This makes it easier to "
"parse and integrate CLI output with other tools. Feel free to check the "
"[\"How to Use CLI JSON output\"](https://flower.ai/docs/framework/how-to-"
"use-cli-json-output.html) guide for details!"
msgstr ""

#: ../../source/ref-changelog.md:699
msgid ""
"**Document Microsoft Azure deployment** "
"([#4625](https://github.com/adap/flower/pull/4625))"
msgstr ""

#: ../../source/ref-changelog.md:701
msgid ""
"A new how-to guide shows a simple Flower deployment for [federated "
"learning on Microsoft Azure](https://flower.ai/docs/framework/how-to-run-"
"flower-on-azure.html) VM instances."
msgstr ""

#: ../../source/ref-changelog.md:703
msgid ""
"**Introduce OIDC user authentication infrastructure** "
"([#4630](https://github.com/adap/flower/pull/4630), "
"[#4244](https://github.com/adap/flower/pull/4244), "
"[#4602](https://github.com/adap/flower/pull/4602), "
"[#4618](https://github.com/adap/flower/pull/4618), "
"[#4717](https://github.com/adap/flower/pull/4717), "
"[#4719](https://github.com/adap/flower/pull/4719), "
"[#4745](https://github.com/adap/flower/pull/4745))"
msgstr ""

#: ../../source/ref-changelog.md:705
msgid ""
"Flower has supported SuperNode authentication since Flower 1.9. This "
"release adds initial extension points for user authentication via OpenID "
"Connect (OIDC)."
msgstr ""

#: ../../source/ref-changelog.md:707
msgid ""
"**Update FedRep baseline** "
"([#4681](https://github.com/adap/flower/pull/4681))"
msgstr ""

#: ../../source/ref-changelog.md:709
msgid ""
"We have started the process of migrating some baselines from using "
"`start_simulation` to be launched via `flwr run`. We chose `FedRep` as "
"the first baseline to migrate due to its very impressive results. New "
"baselines can be created following a `flwr run`-compatible format by "
"starting from the `flwr new` template for baselines. We welcome "
"contributions! Read more in the [how to contribute a "
"baseline](https://flower.ai/docs/baselines/how-to-contribute-"
"baselines.html) documentation."
msgstr ""

#: ../../source/ref-changelog.md:711
msgid ""
"**Revamp simulation series tutorial** "
"([#4663](https://github.com/adap/flower/pull/4663), "
"[#4696](https://github.com/adap/flower/pull/4696))"
msgstr ""

#: ../../source/ref-changelog.md:713
msgid ""
"We have updated the [Step-by-step Tutorial Series for "
"Simulations](https://github.com/adap/flower/tree/main/examples/flower-"
"simulation-step-by-step-pytorch). It now shows how to create and run "
"Flower Apps via `flwr run`. The videos walk you through the process of "
"creating custom strategies, effectively make use of metrics between "
"`ClientApp` and `ServerApp`, create _global model_ checkpoints, log "
"metrics to Weights & Biases, and more."
msgstr ""

#: ../../source/ref-changelog.md:715
msgid ""
"**Improve connection reliability** "
"([#4649](https://github.com/adap/flower/pull/4649), "
"[#4636](https://github.com/adap/flower/pull/4636), "
"[#4637](https://github.com/adap/flower/pull/4637))"
msgstr ""

#: ../../source/ref-changelog.md:717
msgid ""
"Connections between ServerApp\\<>SuperLink, ClientApp\\<>SuperNode, and "
"SuperLink\\<>Simulation are now more robust against network issues."
msgstr ""

#: ../../source/ref-changelog.md:719
msgid ""
"**Fix `flwr new` issue on Windows** "
"([#4653](https://github.com/adap/flower/pull/4653))"
msgstr ""

#: ../../source/ref-changelog.md:721
msgid ""
"The `flwr new` command now works correctly on Windows by setting UTF-8 "
"encoding, ensuring compatibility across all platforms when creating and "
"transferring files."
msgstr ""

#: ../../source/ref-changelog.md:723
msgid ""
"**Update examples and** `flwr new` **templates** "
"([#4725](https://github.com/adap/flower/pull/4725), "
"[#4724](https://github.com/adap/flower/pull/4724), "
"[#4589](https://github.com/adap/flower/pull/4589), "
"[#4690](https://github.com/adap/flower/pull/4690), "
"[#4708](https://github.com/adap/flower/pull/4708), "
"[#4689](https://github.com/adap/flower/pull/4689), "
"[#4740](https://github.com/adap/flower/pull/4740), "
"[#4741](https://github.com/adap/flower/pull/4741), "
"[#4744](https://github.com/adap/flower/pull/4744))"
msgstr ""

#: ../../source/ref-changelog.md:725
msgid ""
"Code examples and `flwr new` templates have been updated to improve "
"compatibility and usability. Notable changes include removing unnecessary"
" `numpy` dependencies, upgrading the `mlx` version, and enhancing the "
"authentication example. A link to previous tutorial versions has also "
"been added for reference."
msgstr ""

#: ../../source/ref-changelog.md:727
msgid ""
"**Improve documentation** "
"([#4713](https://github.com/adap/flower/pull/4713), "
"[#4624](https://github.com/adap/flower/pull/4624), "
"[#4606](https://github.com/adap/flower/pull/4606), "
"[#4596](https://github.com/adap/flower/pull/4596), "
"[#4695](https://github.com/adap/flower/pull/4695), "
"[#4654](https://github.com/adap/flower/pull/4654), "
"[#4656](https://github.com/adap/flower/pull/4656), "
"[#4603](https://github.com/adap/flower/pull/4603), "
"[#4727](https://github.com/adap/flower/pull/4727), "
"[#4723](https://github.com/adap/flower/pull/4723), "
"[#4598](https://github.com/adap/flower/pull/4598), "
"[#4661](https://github.com/adap/flower/pull/4661), "
"[#4655](https://github.com/adap/flower/pull/4655), "
"[#4659](https://github.com/adap/flower/pull/4659))"
msgstr ""

#: ../../source/ref-changelog.md:729
msgid ""
"Documentation has been improved with updated docstrings, typo fixes, and "
"new contributions guidance. Automated updates ensure source texts for "
"translations stay current."
msgstr ""

#: ../../source/ref-changelog.md:731
msgid ""
"**Update infrastructure and CI/CD** "
"([#4614](https://github.com/adap/flower/pull/4614), "
"[#4686](https://github.com/adap/flower/pull/4686), "
"[#4587](https://github.com/adap/flower/pull/4587), "
"[#4715](https://github.com/adap/flower/pull/4715), "
"[#4728](https://github.com/adap/flower/pull/4728), "
"[#4679](https://github.com/adap/flower/pull/4679), "
"[#4675](https://github.com/adap/flower/pull/4675), "
"[#4680](https://github.com/adap/flower/pull/4680), "
"[#4676](https://github.com/adap/flower/pull/4676))"
msgstr ""

#: ../../source/ref-changelog.md:733
msgid ""
"**Bugfixes** ([#4677](https://github.com/adap/flower/pull/4677), "
"[#4671](https://github.com/adap/flower/pull/4671), "
"[#4670](https://github.com/adap/flower/pull/4670), "
"[#4674](https://github.com/adap/flower/pull/4674), "
"[#4687](https://github.com/adap/flower/pull/4687), "
"[#4605](https://github.com/adap/flower/pull/4605), "
"[#4736](https://github.com/adap/flower/pull/4736))"
msgstr ""

#: ../../source/ref-changelog.md:735
msgid ""
"**General improvements** "
"([#4631](https://github.com/adap/flower/pull/4631), "
"[#4660](https://github.com/adap/flower/pull/4660), "
"[#4599](https://github.com/adap/flower/pull/4599), "
"[#4672](https://github.com/adap/flower/pull/4672), "
"[#4705](https://github.com/adap/flower/pull/4705), "
"[#4688](https://github.com/adap/flower/pull/4688), "
"[#4691](https://github.com/adap/flower/pull/4691), "
"[#4706](https://github.com/adap/flower/pull/4706), "
"[#4709](https://github.com/adap/flower/pull/4709), "
"[#4623](https://github.com/adap/flower/pull/4623), "
"[#4697](https://github.com/adap/flower/pull/4697), "
"[#4597](https://github.com/adap/flower/pull/4597), "
"[#4721](https://github.com/adap/flower/pull/4721), "
"[#4730](https://github.com/adap/flower/pull/4730), "
"[#4720](https://github.com/adap/flower/pull/4720), "
"[#4747](https://github.com/adap/flower/pull/4747), "
"[#4716](https://github.com/adap/flower/pull/4716), "
"[#4752](https://github.com/adap/flower/pull/4752))"
msgstr ""

#: ../../source/ref-changelog.md:741
msgid ""
"**Remove** `context` **property from** `Client` **and** `NumPyClient` "
"([#4652](https://github.com/adap/flower/pull/4652))"
msgstr ""

#: ../../source/ref-changelog.md:743
msgid ""
"Now that `Context` is available as an argument in `client_fn` and "
"`server_fn`, the `context` property is removed from `Client` and "
"`NumPyClient`. This feature has been deprecated for several releases and "
"is now removed."
msgstr ""

#: ../../source/ref-changelog.md:745
msgid "v1.13.1 (2024-11-26)"
msgstr ""

#: ../../source/ref-changelog.md:751
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Heng Pan`, `Javier`, `Robert "
"Steiner` <!---TOKEN_v1.13.1-->"
msgstr ""

#: ../../source/ref-changelog.md:755
msgid ""
"**Fix `SimulationEngine` Executor for SuperLink** "
"([#4563](https://github.com/adap/flower/pull/4563), "
"[#4568](https://github.com/adap/flower/pull/4568), "
"[#4570](https://github.com/adap/flower/pull/4570))"
msgstr ""

#: ../../source/ref-changelog.md:757
msgid ""
"Resolved an issue that prevented SuperLink from functioning correctly "
"when using the `SimulationEngine` executor."
msgstr ""

#: ../../source/ref-changelog.md:759
msgid ""
"**Improve FAB build and install** "
"([#4571](https://github.com/adap/flower/pull/4571))"
msgstr ""

#: ../../source/ref-changelog.md:761
msgid ""
"An updated FAB build and install process produces smaller FAB files and "
"doesn't rely on `pip install` any more. It also resolves an issue where "
"all files were unnecessarily included in the FAB file. The `flwr` CLI "
"commands now correctly pack only the necessary files, such as `.md`, "
"`.toml` and `.py`, ensuring more efficient and accurate packaging."
msgstr ""

#: ../../source/ref-changelog.md:763
msgid ""
"**Update** `embedded-devices` **example** "
"([#4381](https://github.com/adap/flower/pull/4381))"
msgstr ""

#: ../../source/ref-changelog.md:765
msgid "The example now uses the `flwr run` command and the Deployment Engine."
msgstr ""

#: ../../source/ref-changelog.md:767
msgid ""
"**Update Documentation** "
"([#4566](https://github.com/adap/flower/pull/4566), "
"[#4569](https://github.com/adap/flower/pull/4569), "
"[#4560](https://github.com/adap/flower/pull/4560), "
"[#4556](https://github.com/adap/flower/pull/4556), "
"[#4581](https://github.com/adap/flower/pull/4581), "
"[#4537](https://github.com/adap/flower/pull/4537), "
"[#4562](https://github.com/adap/flower/pull/4562), "
"[#4582](https://github.com/adap/flower/pull/4582))"
msgstr ""

#: ../../source/ref-changelog.md:769
msgid ""
"Enhanced documentation across various aspects, including updates to "
"translation workflows, Docker-related READMEs, and recommended datasets. "
"Improvements also include formatting fixes for dataset partitioning docs "
"and better references to resources in the datasets documentation index."
msgstr ""

#: ../../source/ref-changelog.md:771
msgid ""
"**Update Infrastructure and CI/CD** "
"([#4577](https://github.com/adap/flower/pull/4577), "
"[#4578](https://github.com/adap/flower/pull/4578), "
"[#4558](https://github.com/adap/flower/pull/4558), "
"[#4551](https://github.com/adap/flower/pull/4551), "
"[#3356](https://github.com/adap/flower/pull/3356), "
"[#4559](https://github.com/adap/flower/pull/4559), "
"[#4575](https://github.com/adap/flower/pull/4575))"
msgstr ""

#: ../../source/ref-changelog.md:773
msgid ""
"**General improvements** "
"([#4557](https://github.com/adap/flower/pull/4557), "
"[#4564](https://github.com/adap/flower/pull/4564), "
"[#4573](https://github.com/adap/flower/pull/4573), "
"[#4561](https://github.com/adap/flower/pull/4561), "
"[#4579](https://github.com/adap/flower/pull/4579), "
"[#4572](https://github.com/adap/flower/pull/4572))"
msgstr ""

#: ../../source/ref-changelog.md:777
msgid "v1.13.0 (2024-11-20)"
msgstr ""

#: ../../source/ref-changelog.md:783
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Chong Shen Ng`, `Daniel J. "
"Beutel`, `Daniel Nata Nugraha`, `Dimitris Stripelis`, `Heng Pan`, "
"`Javier`, `Mohammad Naseri`, `Robert Steiner`, `Waris Gill`, `William "
"Lindskog`, `Yan Gao`, `Yao Xu`, `wwjang` <!---TOKEN_v1.13.0-->"
msgstr ""

#: ../../source/ref-changelog.md:787
msgid ""
"**Introduce `flwr ls` command** "
"([#4460](https://github.com/adap/flower/pull/4460), "
"[#4459](https://github.com/adap/flower/pull/4459), "
"[#4477](https://github.com/adap/flower/pull/4477))"
msgstr ""

#: ../../source/ref-changelog.md:789
msgid ""
"The `flwr ls` command is now available to display details about all runs "
"(or one specific run). It supports the following usage options:"
msgstr ""

#: ../../source/ref-changelog.md:791
msgid "`flwr ls --runs [<app>] [<federation>]`: Lists all runs."
msgstr ""

#: ../../source/ref-changelog.md:792
msgid ""
"`flwr ls --run-id <run-id> [<app>] [<federation>]`: Displays details for "
"a specific run."
msgstr ""

#: ../../source/ref-changelog.md:794
msgid ""
"This command provides information including the run ID, FAB ID and "
"version, run status, elapsed time, and timestamps for when the run was "
"created, started running, and finished."
msgstr ""

#: ../../source/ref-changelog.md:796
msgid ""
"**Fuse SuperLink and SuperExec** "
"([#4358](https://github.com/adap/flower/pull/4358), "
"[#4403](https://github.com/adap/flower/pull/4403), "
"[#4406](https://github.com/adap/flower/pull/4406), "
"[#4357](https://github.com/adap/flower/pull/4357), "
"[#4359](https://github.com/adap/flower/pull/4359), "
"[#4354](https://github.com/adap/flower/pull/4354), "
"[#4229](https://github.com/adap/flower/pull/4229), "
"[#4283](https://github.com/adap/flower/pull/4283), "
"[#4352](https://github.com/adap/flower/pull/4352))"
msgstr ""

#: ../../source/ref-changelog.md:798
#, python-brace-format
msgid ""
"SuperExec has been integrated into SuperLink, enabling SuperLink to "
"directly manage ServerApp processes (`flwr-serverapp`). The `flwr` CLI "
"now targets SuperLink's Exec API. Additionally, SuperLink introduces two "
"isolation modes for running ServerApps: `subprocess` (default) and "
"`process`, which can be specified using the `--isolation "
"{subprocess,process}` flag."
msgstr ""

#: ../../source/ref-changelog.md:800
msgid ""
"**Introduce `flwr-serverapp` command** "
"([#4394](https://github.com/adap/flower/pull/4394), "
"[#4370](https://github.com/adap/flower/pull/4370), "
"[#4367](https://github.com/adap/flower/pull/4367), "
"[#4350](https://github.com/adap/flower/pull/4350), "
"[#4364](https://github.com/adap/flower/pull/4364), "
"[#4400](https://github.com/adap/flower/pull/4400), "
"[#4363](https://github.com/adap/flower/pull/4363), "
"[#4401](https://github.com/adap/flower/pull/4401), "
"[#4388](https://github.com/adap/flower/pull/4388), "
"[#4402](https://github.com/adap/flower/pull/4402))"
msgstr ""

#: ../../source/ref-changelog.md:802
msgid ""
"The `flwr-serverapp` command has been introduced as a CLI entry point "
"that runs a `ServerApp` process. This process communicates with SuperLink"
" to load and execute the `ServerApp` object, enabling isolated execution "
"and more flexible deployment."
msgstr ""

#: ../../source/ref-changelog.md:804
msgid ""
"**Improve simulation engine and introduce `flwr-simulation` command** "
"([#4433](https://github.com/adap/flower/pull/4433), "
"[#4486](https://github.com/adap/flower/pull/4486), "
"[#4448](https://github.com/adap/flower/pull/4448), "
"[#4427](https://github.com/adap/flower/pull/4427), "
"[#4438](https://github.com/adap/flower/pull/4438), "
"[#4421](https://github.com/adap/flower/pull/4421), "
"[#4430](https://github.com/adap/flower/pull/4430), "
"[#4462](https://github.com/adap/flower/pull/4462))"
msgstr ""

#: ../../source/ref-changelog.md:806
msgid ""
"The simulation engine has been significantly improved, resulting in "
"dramatically faster simulations. Additionally, the `flwr-simulation` "
"command has been introduced to enhance maintainability and provide a "
"dedicated entry point for running simulations."
msgstr ""

#: ../../source/ref-changelog.md:808
msgid ""
"**Improve SuperLink message management** "
"([#4378](https://github.com/adap/flower/pull/4378), "
"[#4369](https://github.com/adap/flower/pull/4369))"
msgstr ""

#: ../../source/ref-changelog.md:810
msgid ""
"SuperLink now validates the destination node ID of instruction messages "
"and checks the TTL (time-to-live) for reply messages. When pulling reply "
"messages, an error reply will be generated and returned if the "
"corresponding instruction message does not exist, has expired, or if the "
"reply message exists but has expired."
msgstr ""

#: ../../source/ref-changelog.md:812
msgid ""
"**Introduce FedDebug baseline** "
"([#3783](https://github.com/adap/flower/pull/3783))"
msgstr ""

#: ../../source/ref-changelog.md:814
msgid ""
"FedDebug is a framework that enhances debugging in Federated Learning by "
"enabling interactive inspection of the training process and automatically"
" identifying clients responsible for degrading the global model's "
"performance—all without requiring testing data or labels. Learn more in "
"the [FedDebug baseline "
"documentation](https://flower.ai/docs/baselines/feddebug.html)."
msgstr ""

#: ../../source/ref-changelog.md:816
msgid ""
"**Update documentation** "
"([#4511](https://github.com/adap/flower/pull/4511), "
"[#4010](https://github.com/adap/flower/pull/4010), "
"[#4396](https://github.com/adap/flower/pull/4396), "
"[#4499](https://github.com/adap/flower/pull/4499), "
"[#4269](https://github.com/adap/flower/pull/4269), "
"[#3340](https://github.com/adap/flower/pull/3340), "
"[#4482](https://github.com/adap/flower/pull/4482), "
"[#4387](https://github.com/adap/flower/pull/4387), "
"[#4342](https://github.com/adap/flower/pull/4342), "
"[#4492](https://github.com/adap/flower/pull/4492), "
"[#4474](https://github.com/adap/flower/pull/4474), "
"[#4500](https://github.com/adap/flower/pull/4500), "
"[#4514](https://github.com/adap/flower/pull/4514), "
"[#4236](https://github.com/adap/flower/pull/4236), "
"[#4112](https://github.com/adap/flower/pull/4112), "
"[#3367](https://github.com/adap/flower/pull/3367), "
"[#4501](https://github.com/adap/flower/pull/4501), "
"[#4373](https://github.com/adap/flower/pull/4373), "
"[#4409](https://github.com/adap/flower/pull/4409), "
"[#4356](https://github.com/adap/flower/pull/4356), "
"[#4520](https://github.com/adap/flower/pull/4520), "
"[#4524](https://github.com/adap/flower/pull/4524), "
"[#4525](https://github.com/adap/flower/pull/4525), "
"[#4526](https://github.com/adap/flower/pull/4526), "
"[#4527](https://github.com/adap/flower/pull/4527), "
"[#4528](https://github.com/adap/flower/pull/4528), "
"[#4545](https://github.com/adap/flower/pull/4545), "
"[#4522](https://github.com/adap/flower/pull/4522), "
"[#4534](https://github.com/adap/flower/pull/4534), "
"[#4513](https://github.com/adap/flower/pull/4513), "
"[#4529](https://github.com/adap/flower/pull/4529), "
"[#4441](https://github.com/adap/flower/pull/4441), "
"[#4530](https://github.com/adap/flower/pull/4530), "
"[#4470](https://github.com/adap/flower/pull/4470), "
"[#4553](https://github.com/adap/flower/pull/4553), "
"[#4531](https://github.com/adap/flower/pull/4531), "
"[#4554](https://github.com/adap/flower/pull/4554), "
"[#4555](https://github.com/adap/flower/pull/4555), "
"[#4552](https://github.com/adap/flower/pull/4552), "
"[#4533](https://github.com/adap/flower/pull/4533))"
msgstr ""

#: ../../source/ref-changelog.md:818
msgid ""
"Many documentation pages and tutorials have been updated to improve "
"clarity, fix typos, incorporate user feedback, and stay aligned with the "
"latest features in the framework. Key updates include adding a guide for "
"designing stateful `ClientApp` objects, updating the comprehensive guide "
"for setting up and running Flower's `Simulation Engine`, updating the "
"XGBoost, scikit-learn, and JAX quickstart tutorials to use `flwr run`, "
"updating DP guide, removing outdated pages, updating Docker docs, and "
"marking legacy functions as deprecated. The [Secure Aggregation "
"Protocols](https://flower.ai/docs/framework/contributor-ref-secure-"
"aggregation-protocols.html) page has also been updated."
msgstr ""

#: ../../source/ref-changelog.md:820
msgid ""
"**Update examples and templates** "
"([#4510](https://github.com/adap/flower/pull/4510), "
"[#4368](https://github.com/adap/flower/pull/4368), "
"[#4121](https://github.com/adap/flower/pull/4121), "
"[#4329](https://github.com/adap/flower/pull/4329), "
"[#4382](https://github.com/adap/flower/pull/4382), "
"[#4248](https://github.com/adap/flower/pull/4248), "
"[#4395](https://github.com/adap/flower/pull/4395), "
"[#4386](https://github.com/adap/flower/pull/4386), "
"[#4408](https://github.com/adap/flower/pull/4408))"
msgstr ""

#: ../../source/ref-changelog.md:822
msgid ""
"Multiple examples and templates have been updated to enhance usability "
"and correctness. The updates include the `30-minute-tutorial`, "
"`quickstart-jax`, `quickstart-pytorch`, `advanced-tensorflow` examples, "
"and the FlowerTune template."
msgstr ""

#: ../../source/ref-changelog.md:824
msgid ""
"**Improve Docker support** "
"([#4506](https://github.com/adap/flower/pull/4506), "
"[#4424](https://github.com/adap/flower/pull/4424), "
"[#4224](https://github.com/adap/flower/pull/4224), "
"[#4413](https://github.com/adap/flower/pull/4413), "
"[#4414](https://github.com/adap/flower/pull/4414), "
"[#4336](https://github.com/adap/flower/pull/4336), "
"[#4420](https://github.com/adap/flower/pull/4420), "
"[#4407](https://github.com/adap/flower/pull/4407), "
"[#4422](https://github.com/adap/flower/pull/4422), "
"[#4532](https://github.com/adap/flower/pull/4532), "
"[#4540](https://github.com/adap/flower/pull/4540))"
msgstr ""

#: ../../source/ref-changelog.md:826
msgid ""
"Docker images and configurations have been updated, including updating "
"Docker Compose files to version 1.13.0, refactoring the Docker build "
"matrix for better maintainability, updating `docker/build-push-action` to"
" 6.9.0, and improving Docker documentation."
msgstr ""

#: ../../source/ref-changelog.md:828
msgid ""
"**Allow app installation without internet access** "
"([#4479](https://github.com/adap/flower/pull/4479), "
"[#4475](https://github.com/adap/flower/pull/4475))"
msgstr ""

#: ../../source/ref-changelog.md:830
msgid ""
"The `flwr build` command now includes a wheel file in the FAB, enabling "
"Flower app installation in environments without internet access via `flwr"
" install`."
msgstr ""

#: ../../source/ref-changelog.md:832
msgid ""
"**Improve `flwr log` command** "
"([#4391](https://github.com/adap/flower/pull/4391), "
"[#4411](https://github.com/adap/flower/pull/4411), "
"[#4390](https://github.com/adap/flower/pull/4390), "
"[#4397](https://github.com/adap/flower/pull/4397))"
msgstr ""

#: ../../source/ref-changelog.md:834
msgid ""
"**Refactor SuperNode for better maintainability and efficiency** "
"([#4439](https://github.com/adap/flower/pull/4439), "
"[#4348](https://github.com/adap/flower/pull/4348), "
"[#4512](https://github.com/adap/flower/pull/4512), "
"[#4485](https://github.com/adap/flower/pull/4485))"
msgstr ""

#: ../../source/ref-changelog.md:836
msgid ""
"**Support NumPy `2.0`** "
"([#4440](https://github.com/adap/flower/pull/4440))"
msgstr ""

#: ../../source/ref-changelog.md:838
msgid ""
"**Update infrastructure and CI/CD** "
"([#4466](https://github.com/adap/flower/pull/4466), "
"[#4419](https://github.com/adap/flower/pull/4419), "
"[#4338](https://github.com/adap/flower/pull/4338), "
"[#4334](https://github.com/adap/flower/pull/4334), "
"[#4456](https://github.com/adap/flower/pull/4456), "
"[#4446](https://github.com/adap/flower/pull/4446), "
"[#4415](https://github.com/adap/flower/pull/4415))"
msgstr ""

#: ../../source/ref-changelog.md:840
msgid ""
"**Bugfixes** ([#4404](https://github.com/adap/flower/pull/4404), "
"[#4518](https://github.com/adap/flower/pull/4518), "
"[#4452](https://github.com/adap/flower/pull/4452), "
"[#4376](https://github.com/adap/flower/pull/4376), "
"[#4493](https://github.com/adap/flower/pull/4493), "
"[#4436](https://github.com/adap/flower/pull/4436), "
"[#4410](https://github.com/adap/flower/pull/4410), "
"[#4442](https://github.com/adap/flower/pull/4442), "
"[#4375](https://github.com/adap/flower/pull/4375), "
"[#4515](https://github.com/adap/flower/pull/4515))"
msgstr ""

#: ../../source/ref-changelog.md:842
msgid ""
"**General improvements** "
"([#4454](https://github.com/adap/flower/pull/4454), "
"[#4365](https://github.com/adap/flower/pull/4365), "
"[#4423](https://github.com/adap/flower/pull/4423), "
"[#4516](https://github.com/adap/flower/pull/4516), "
"[#4509](https://github.com/adap/flower/pull/4509), "
"[#4498](https://github.com/adap/flower/pull/4498), "
"[#4371](https://github.com/adap/flower/pull/4371), "
"[#4449](https://github.com/adap/flower/pull/4449), "
"[#4488](https://github.com/adap/flower/pull/4488), "
"[#4478](https://github.com/adap/flower/pull/4478), "
"[#4392](https://github.com/adap/flower/pull/4392), "
"[#4483](https://github.com/adap/flower/pull/4483), "
"[#4517](https://github.com/adap/flower/pull/4517), "
"[#4330](https://github.com/adap/flower/pull/4330), "
"[#4458](https://github.com/adap/flower/pull/4458), "
"[#4347](https://github.com/adap/flower/pull/4347), "
"[#4429](https://github.com/adap/flower/pull/4429), "
"[#4463](https://github.com/adap/flower/pull/4463), "
"[#4496](https://github.com/adap/flower/pull/4496), "
"[#4508](https://github.com/adap/flower/pull/4508), "
"[#4444](https://github.com/adap/flower/pull/4444), "
"[#4417](https://github.com/adap/flower/pull/4417), "
"[#4504](https://github.com/adap/flower/pull/4504), "
"[#4418](https://github.com/adap/flower/pull/4418), "
"[#4480](https://github.com/adap/flower/pull/4480), "
"[#4455](https://github.com/adap/flower/pull/4455), "
"[#4468](https://github.com/adap/flower/pull/4468), "
"[#4385](https://github.com/adap/flower/pull/4385), "
"[#4487](https://github.com/adap/flower/pull/4487), "
"[#4393](https://github.com/adap/flower/pull/4393), "
"[#4489](https://github.com/adap/flower/pull/4489), "
"[#4389](https://github.com/adap/flower/pull/4389), "
"[#4507](https://github.com/adap/flower/pull/4507), "
"[#4469](https://github.com/adap/flower/pull/4469), "
"[#4340](https://github.com/adap/flower/pull/4340), "
"[#4353](https://github.com/adap/flower/pull/4353), "
"[#4494](https://github.com/adap/flower/pull/4494), "
"[#4461](https://github.com/adap/flower/pull/4461), "
"[#4362](https://github.com/adap/flower/pull/4362), "
"[#4473](https://github.com/adap/flower/pull/4473), "
"[#4405](https://github.com/adap/flower/pull/4405), "
"[#4416](https://github.com/adap/flower/pull/4416), "
"[#4453](https://github.com/adap/flower/pull/4453), "
"[#4491](https://github.com/adap/flower/pull/4491), "
"[#4539](https://github.com/adap/flower/pull/4539), "
"[#4542](https://github.com/adap/flower/pull/4542), "
"[#4538](https://github.com/adap/flower/pull/4538), "
"[#4543](https://github.com/adap/flower/pull/4543), "
"[#4541](https://github.com/adap/flower/pull/4541), "
"[#4550](https://github.com/adap/flower/pull/4550), "
"[#4481](https://github.com/adap/flower/pull/4481))"
msgstr ""

#: ../../source/ref-changelog.md:846 ../../source/ref-changelog.md:1045
#: ../../source/ref-changelog.md:1162 ../../source/ref-changelog.md:1254
#: ../../source/ref-changelog.md:2233
msgid "Deprecations"
msgstr ""

#: ../../source/ref-changelog.md:848
#, fuzzy
msgid "**Deprecate Python 3.9**"
msgstr "**PR 만들기**"

#: ../../source/ref-changelog.md:850
msgid ""
"Flower is deprecating support for Python 3.9 as several of its "
"dependencies are phasing out compatibility with this version. While no "
"immediate changes have been made, users are encouraged to plan for "
"upgrading to a supported Python version."
msgstr ""

#: ../../source/ref-changelog.md:854
msgid ""
"**Remove `flower-superexec` command** "
"([#4351](https://github.com/adap/flower/pull/4351))"
msgstr ""

#: ../../source/ref-changelog.md:856
msgid ""
"The `flower-superexec` command, previously used to launch SuperExec, is "
"no longer functional as SuperExec has been merged into SuperLink. "
"Starting an additional SuperExec is no longer necessary when SuperLink is"
" initiated."
msgstr ""

#: ../../source/ref-changelog.md:858
msgid ""
"**Remove `flower-server-app` command** "
"([#4490](https://github.com/adap/flower/pull/4490))"
msgstr ""

#: ../../source/ref-changelog.md:860
msgid ""
"The `flower-server-app` command has been removed. To start a Flower app, "
"please use the `flwr run` command instead."
msgstr ""

#: ../../source/ref-changelog.md:862
msgid ""
"**Remove `app` argument from `flower-supernode` command** "
"([#4497](https://github.com/adap/flower/pull/4497))"
msgstr ""

#: ../../source/ref-changelog.md:864
msgid ""
"The usage of `flower-supernode <app-dir>` has been removed. SuperNode "
"will now load the FAB delivered by SuperLink, and it is no longer "
"possible to directly specify an app directory."
msgstr ""

#: ../../source/ref-changelog.md:866
msgid ""
"**Remove support for non-app simulations** "
"([#4431](https://github.com/adap/flower/pull/4431))"
msgstr ""

#: ../../source/ref-changelog.md:868
msgid ""
"The simulation engine (via `flower-simulation`) now exclusively supports "
"passing an app."
msgstr ""

#: ../../source/ref-changelog.md:870
msgid ""
"**Rename CLI arguments for `flower-superlink` command** "
"([#4412](https://github.com/adap/flower/pull/4412))"
msgstr ""

#: ../../source/ref-changelog.md:872
msgid ""
"The `--driver-api-address` argument has been renamed to `--serverappio-"
"api-address` in the `flower-superlink` command to reflect the renaming of"
" the `Driver` service to the `ServerAppIo` service."
msgstr ""

#: ../../source/ref-changelog.md:874
msgid ""
"**Rename CLI arguments for `flwr-serverapp` and `flwr-clientapp` "
"commands** ([#4495](https://github.com/adap/flower/pull/4495))"
msgstr ""

#: ../../source/ref-changelog.md:876
msgid ""
"The CLI arguments have been renamed for clarity and consistency. "
"Specifically, `--superlink` for `flwr-serverapp` is now `--serverappio-"
"api-address`, and `--supernode` for `flwr-clientapp` is now "
"`--clientappio-api-address`."
msgstr ""

#: ../../source/ref-changelog.md:878
msgid "v1.12.0 (2024-10-14)"
msgstr ""

#: ../../source/ref-changelog.md:884
msgid ""
"`Adam Narozniak`, `Audris`, `Charles Beauville`, `Chong Shen Ng`, `Daniel"
" J. Beutel`, `Daniel Nata Nugraha`, `Heng Pan`, `Javier`, `Jiahao Tan`, "
"`Julian Rußmeyer`, `Mohammad Naseri`, `Ray Sun`, `Robert Steiner`, `Yan "
"Gao`, `xiliguguagua` <!---TOKEN_v1.12.0-->"
msgstr ""

#: ../../source/ref-changelog.md:888
msgid ""
"**Introduce SuperExec log streaming** "
"([#3577](https://github.com/adap/flower/pull/3577), "
"[#3584](https://github.com/adap/flower/pull/3584), "
"[#4242](https://github.com/adap/flower/pull/4242), "
"[#3611](https://github.com/adap/flower/pull/3611), "
"[#3613](https://github.com/adap/flower/pull/3613))"
msgstr ""

#: ../../source/ref-changelog.md:890
msgid ""
"Flower now supports log streaming from a remote SuperExec using the `flwr"
" log` command. This new feature allows you to monitor logs from SuperExec"
" in real time via `flwr log <run-id>` (or `flwr log <run-id> <app-dir> "
"<federation>`)."
msgstr ""

#: ../../source/ref-changelog.md:892
msgid ""
"**Improve `flwr new` templates** "
"([#4291](https://github.com/adap/flower/pull/4291), "
"[#4292](https://github.com/adap/flower/pull/4292), "
"[#4293](https://github.com/adap/flower/pull/4293), "
"[#4294](https://github.com/adap/flower/pull/4294), "
"[#4295](https://github.com/adap/flower/pull/4295))"
msgstr ""

#: ../../source/ref-changelog.md:894
msgid ""
"The `flwr new` command templates for MLX, NumPy, sklearn, JAX, and "
"PyTorch have been updated to improve usability and consistency across "
"frameworks."
msgstr ""

#: ../../source/ref-changelog.md:896
msgid ""
"**Migrate ID handling to use unsigned 64-bit integers** "
"([#4170](https://github.com/adap/flower/pull/4170), "
"[#4237](https://github.com/adap/flower/pull/4237), "
"[#4243](https://github.com/adap/flower/pull/4243))"
msgstr ""

#: ../../source/ref-changelog.md:898
msgid ""
"Node IDs, run IDs, and related fields have been migrated from signed "
"64-bit integers (`sint64`) to unsigned 64-bit integers (`uint64`). To "
"support this change, the `uint64` type is fully supported in all "
"communications. You may now use `uint64` values in config and metric "
"dictionaries. For Python users, that means using `int` values larger than"
" the maximum value of `sint64` but less than the maximum value of "
"`uint64`."
msgstr ""

#: ../../source/ref-changelog.md:900
msgid ""
"**Add Flower architecture explanation** "
"([#3270](https://github.com/adap/flower/pull/3270))"
msgstr ""

#: ../../source/ref-changelog.md:902
msgid ""
"A new [Flower architecture explainer](https://flower.ai/docs/framework"
"/explanation-flower-architecture.html) page introduces Flower components "
"step-by-step. Check out the `EXPLANATIONS` section of the Flower "
"documentation if you're interested."
msgstr ""

#: ../../source/ref-changelog.md:904
msgid ""
"**Introduce FedRep baseline** "
"([#3790](https://github.com/adap/flower/pull/3790))"
msgstr ""

#: ../../source/ref-changelog.md:906
msgid ""
"FedRep is a federated learning algorithm that learns shared data "
"representations across clients while allowing each to maintain "
"personalized local models, balancing collaboration and individual "
"adaptation. Read all the details in the paper: \"Exploiting Shared "
"Representations for Personalized Federated Learning\" "
"([arxiv](https://arxiv.org/abs/2102.07078))"
msgstr ""

#: ../../source/ref-changelog.md:908
msgid ""
"**Improve FlowerTune template and LLM evaluation pipelines** "
"([#4286](https://github.com/adap/flower/pull/4286), "
"[#3769](https://github.com/adap/flower/pull/3769), "
"[#4272](https://github.com/adap/flower/pull/4272), "
"[#4257](https://github.com/adap/flower/pull/4257), "
"[#4220](https://github.com/adap/flower/pull/4220), "
"[#4282](https://github.com/adap/flower/pull/4282), "
"[#4171](https://github.com/adap/flower/pull/4171), "
"[#4228](https://github.com/adap/flower/pull/4228), "
"[#4258](https://github.com/adap/flower/pull/4258), "
"[#4296](https://github.com/adap/flower/pull/4296), "
"[#4287](https://github.com/adap/flower/pull/4287), "
"[#4217](https://github.com/adap/flower/pull/4217), "
"[#4249](https://github.com/adap/flower/pull/4249), "
"[#4324](https://github.com/adap/flower/pull/4324), "
"[#4219](https://github.com/adap/flower/pull/4219), "
"[#4327](https://github.com/adap/flower/pull/4327))"
msgstr ""

#: ../../source/ref-changelog.md:910
msgid ""
"Refined evaluation pipelines, metrics, and documentation for the upcoming"
" FlowerTune LLM Leaderboard across multiple domains including Finance, "
"Medical, and general NLP. Stay tuned for the official launch—we welcome "
"all federated learning and LLM enthusiasts to participate in this "
"exciting challenge!"
msgstr ""

#: ../../source/ref-changelog.md:912
msgid ""
"**Enhance Docker Support and Documentation** "
"([#4191](https://github.com/adap/flower/pull/4191), "
"[#4251](https://github.com/adap/flower/pull/4251), "
"[#4190](https://github.com/adap/flower/pull/4190), "
"[#3928](https://github.com/adap/flower/pull/3928), "
"[#4298](https://github.com/adap/flower/pull/4298), "
"[#4192](https://github.com/adap/flower/pull/4192), "
"[#4136](https://github.com/adap/flower/pull/4136), "
"[#4187](https://github.com/adap/flower/pull/4187), "
"[#4261](https://github.com/adap/flower/pull/4261), "
"[#4177](https://github.com/adap/flower/pull/4177), "
"[#4176](https://github.com/adap/flower/pull/4176), "
"[#4189](https://github.com/adap/flower/pull/4189), "
"[#4297](https://github.com/adap/flower/pull/4297), "
"[#4226](https://github.com/adap/flower/pull/4226))"
msgstr ""

#: ../../source/ref-changelog.md:914
msgid ""
"Upgraded Ubuntu base image to 24.04, added SBOM and gcc to Docker images,"
" and comprehensively updated [Docker "
"documentation](https://flower.ai/docs/framework/docker/index.html) "
"including quickstart guides and distributed Docker Compose instructions."
msgstr ""

#: ../../source/ref-changelog.md:916
msgid ""
"**Introduce Flower glossary** "
"([#4165](https://github.com/adap/flower/pull/4165), "
"[#4235](https://github.com/adap/flower/pull/4235))"
msgstr ""

#: ../../source/ref-changelog.md:918
msgid ""
"Added the [Federated Learning glossary](https://flower.ai/glossary/) to "
"the Flower repository, located under the `flower/glossary/` directory. "
"This resource aims to provide clear definitions and explanations of key "
"FL concepts. Community contributions are highly welcomed to help expand "
"and refine this knowledge base — this is probably the easiest way to "
"become a Flower contributor!"
msgstr ""

#: ../../source/ref-changelog.md:920
msgid ""
"**Implement Message Time-to-Live (TTL)** "
"([#3620](https://github.com/adap/flower/pull/3620), "
"[#3596](https://github.com/adap/flower/pull/3596), "
"[#3615](https://github.com/adap/flower/pull/3615), "
"[#3609](https://github.com/adap/flower/pull/3609), "
"[#3635](https://github.com/adap/flower/pull/3635))"
msgstr ""

#: ../../source/ref-changelog.md:922
msgid ""
"Added comprehensive TTL support for messages in Flower's SuperLink. "
"Messages are now automatically expired and cleaned up based on "
"configurable TTL values, available through the low-level API (and used by"
" default in the high-level API)."
msgstr ""

#: ../../source/ref-changelog.md:924
msgid ""
"**Improve FAB handling** "
"([#4303](https://github.com/adap/flower/pull/4303), "
"[#4264](https://github.com/adap/flower/pull/4264), "
"[#4305](https://github.com/adap/flower/pull/4305), "
"[#4304](https://github.com/adap/flower/pull/4304))"
msgstr ""

#: ../../source/ref-changelog.md:926
msgid ""
"An 8-character hash is now appended to the FAB file name. The `flwr "
"install` command installs FABs with a more flattened folder structure, "
"reducing it from 3 levels to 1."
msgstr ""

#: ../../source/ref-changelog.md:928
msgid ""
"**Update documentation** "
"([#3341](https://github.com/adap/flower/pull/3341), "
"[#3338](https://github.com/adap/flower/pull/3338), "
"[#3927](https://github.com/adap/flower/pull/3927), "
"[#4152](https://github.com/adap/flower/pull/4152), "
"[#4151](https://github.com/adap/flower/pull/4151), "
"[#3993](https://github.com/adap/flower/pull/3993))"
msgstr ""

#: ../../source/ref-changelog.md:930
msgid ""
"Updated quickstart tutorials (PyTorch Lightning, TensorFlow, Hugging "
"Face, Fastai) to use the new `flwr run` command and removed default title"
" from documentation base template. A new blockchain example has been "
"added to FAQ."
msgstr ""

#: ../../source/ref-changelog.md:932
msgid ""
"**Update example projects** "
"([#3716](https://github.com/adap/flower/pull/3716), "
"[#4007](https://github.com/adap/flower/pull/4007), "
"[#4130](https://github.com/adap/flower/pull/4130), "
"[#4234](https://github.com/adap/flower/pull/4234), "
"[#4206](https://github.com/adap/flower/pull/4206), "
"[#4188](https://github.com/adap/flower/pull/4188), "
"[#4247](https://github.com/adap/flower/pull/4247), "
"[#4331](https://github.com/adap/flower/pull/4331))"
msgstr ""

#: ../../source/ref-changelog.md:934
msgid ""
"Refreshed multiple example projects including vertical FL, PyTorch "
"(advanced), Pandas, Secure Aggregation, and XGBoost examples. Optimized "
"Hugging Face quickstart with a smaller language model and removed legacy "
"simulation examples."
msgstr ""

#: ../../source/ref-changelog.md:936
msgid ""
"**Update translations** "
"([#4070](https://github.com/adap/flower/pull/4070), "
"[#4316](https://github.com/adap/flower/pull/4316), "
"[#4252](https://github.com/adap/flower/pull/4252), "
"[#4256](https://github.com/adap/flower/pull/4256), "
"[#4210](https://github.com/adap/flower/pull/4210), "
"[#4263](https://github.com/adap/flower/pull/4263), "
"[#4259](https://github.com/adap/flower/pull/4259))"
msgstr ""

#: ../../source/ref-changelog.md:938
msgid ""
"**General improvements** "
"([#4239](https://github.com/adap/flower/pull/4239), "
"[4276](https://github.com/adap/flower/pull/4276), "
"[4204](https://github.com/adap/flower/pull/4204), "
"[4184](https://github.com/adap/flower/pull/4184), "
"[4227](https://github.com/adap/flower/pull/4227), "
"[4183](https://github.com/adap/flower/pull/4183), "
"[4202](https://github.com/adap/flower/pull/4202), "
"[4250](https://github.com/adap/flower/pull/4250), "
"[4267](https://github.com/adap/flower/pull/4267), "
"[4246](https://github.com/adap/flower/pull/4246), "
"[4240](https://github.com/adap/flower/pull/4240), "
"[4265](https://github.com/adap/flower/pull/4265), "
"[4238](https://github.com/adap/flower/pull/4238), "
"[4275](https://github.com/adap/flower/pull/4275), "
"[4318](https://github.com/adap/flower/pull/4318), "
"[#4178](https://github.com/adap/flower/pull/4178), "
"[#4315](https://github.com/adap/flower/pull/4315), "
"[#4241](https://github.com/adap/flower/pull/4241), "
"[#4289](https://github.com/adap/flower/pull/4289), "
"[#4290](https://github.com/adap/flower/pull/4290), "
"[#4181](https://github.com/adap/flower/pull/4181), "
"[#4208](https://github.com/adap/flower/pull/4208), "
"[#4225](https://github.com/adap/flower/pull/4225), "
"[#4314](https://github.com/adap/flower/pull/4314), "
"[#4174](https://github.com/adap/flower/pull/4174), "
"[#4203](https://github.com/adap/flower/pull/4203), "
"[#4274](https://github.com/adap/flower/pull/4274), "
"[#3154](https://github.com/adap/flower/pull/3154), "
"[#4201](https://github.com/adap/flower/pull/4201), "
"[#4268](https://github.com/adap/flower/pull/4268), "
"[#4254](https://github.com/adap/flower/pull/4254), "
"[#3990](https://github.com/adap/flower/pull/3990), "
"[#4212](https://github.com/adap/flower/pull/4212), "
"[#2938](https://github.com/adap/flower/pull/2938), "
"[#4205](https://github.com/adap/flower/pull/4205), "
"[#4222](https://github.com/adap/flower/pull/4222), "
"[#4313](https://github.com/adap/flower/pull/4313), "
"[#3936](https://github.com/adap/flower/pull/3936), "
"[#4278](https://github.com/adap/flower/pull/4278), "
"[#4319](https://github.com/adap/flower/pull/4319), "
"[#4332](https://github.com/adap/flower/pull/4332), "
"[#4333](https://github.com/adap/flower/pull/4333))"
msgstr ""

#: ../../source/ref-changelog.md:944
msgid ""
"**Drop Python 3.8 support and update minimum version to 3.9** "
"([#4180](https://github.com/adap/flower/pull/4180), "
"[#4213](https://github.com/adap/flower/pull/4213), "
"[#4193](https://github.com/adap/flower/pull/4193), "
"[#4199](https://github.com/adap/flower/pull/4199), "
"[#4196](https://github.com/adap/flower/pull/4196), "
"[#4195](https://github.com/adap/flower/pull/4195), "
"[#4198](https://github.com/adap/flower/pull/4198), "
"[#4194](https://github.com/adap/flower/pull/4194))"
msgstr ""

#: ../../source/ref-changelog.md:946
msgid ""
"Python 3.8 support was deprecated in Flower 1.9, and this release removes"
" support. Flower now requires Python 3.9 or later (Python 3.11 is "
"recommended). CI and documentation were updated to use Python 3.9 as the "
"minimum supported version. Flower now supports Python 3.9 to 3.12."
msgstr ""

#: ../../source/ref-changelog.md:948
msgid "v1.11.1 (2024-09-11)"
msgstr ""

#: ../../source/ref-changelog.md:954
msgid ""
"`Charles Beauville`, `Chong Shen Ng`, `Daniel J. Beutel`, `Heng Pan`, "
"`Javier`, `Robert Steiner`, `Yan Gao` <!---TOKEN_v1.11.1-->"
msgstr ""

#: ../../source/ref-changelog.md:956
#, fuzzy
msgid "Improvements"
msgstr "선택적 개선 사항"

#: ../../source/ref-changelog.md:958
msgid ""
"**Implement** `keys/values/items` **methods for** `TypedDict` "
"([#4146](https://github.com/adap/flower/pull/4146))"
msgstr ""

#: ../../source/ref-changelog.md:960
msgid ""
"**Fix parsing of** `--executor-config` **if present** "
"([#4125](https://github.com/adap/flower/pull/4125))"
msgstr ""

#: ../../source/ref-changelog.md:962
msgid ""
"**Adjust framework name in templates docstrings** "
"([#4127](https://github.com/adap/flower/pull/4127))"
msgstr ""

#: ../../source/ref-changelog.md:964
msgid ""
"**Update** `flwr new` **Hugging Face template** "
"([#4169](https://github.com/adap/flower/pull/4169))"
msgstr ""

#: ../../source/ref-changelog.md:966
msgid ""
"**Fix** `flwr new` **FlowerTune template** "
"([#4123](https://github.com/adap/flower/pull/4123))"
msgstr ""

#: ../../source/ref-changelog.md:968
msgid ""
"**Add buffer time after** `ServerApp` **thread initialization** "
"([#4119](https://github.com/adap/flower/pull/4119))"
msgstr ""

#: ../../source/ref-changelog.md:970
msgid ""
"**Handle unsuitable resources for simulation** "
"([#4143](https://github.com/adap/flower/pull/4143))"
msgstr ""

#: ../../source/ref-changelog.md:972
msgid ""
"**Update example READMEs** "
"([#4117](https://github.com/adap/flower/pull/4117))"
msgstr ""

#: ../../source/ref-changelog.md:974
msgid ""
"**Update SuperNode authentication docs** "
"([#4160](https://github.com/adap/flower/pull/4160))"
msgstr ""

#: ../../source/ref-changelog.md:980
msgid "v1.11.0 (2024-08-30)"
msgstr ""

#: ../../source/ref-changelog.md:986
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Chong Shen Ng`, `Daniel J. "
"Beutel`, `Daniel Nata Nugraha`, `Danny`, `Edoardo Gabrielli`, `Heng Pan`,"
" `Javier`, `Meng Yan`, `Michal Danilowski`, `Mohammad Naseri`, `Robert "
"Steiner`, `Steve Laskaridis`, `Taner Topal`, `Yan Gao` <!---"
"TOKEN_v1.11.0-->"
msgstr ""

#: ../../source/ref-changelog.md:990
msgid ""
"**Deliver Flower App Bundle (FAB) to SuperLink and SuperNodes** "
"([#4006](https://github.com/adap/flower/pull/4006), "
"[#3945](https://github.com/adap/flower/pull/3945), "
"[#3999](https://github.com/adap/flower/pull/3999), "
"[#4027](https://github.com/adap/flower/pull/4027), "
"[#3851](https://github.com/adap/flower/pull/3851), "
"[#3946](https://github.com/adap/flower/pull/3946), "
"[#4003](https://github.com/adap/flower/pull/4003), "
"[#4029](https://github.com/adap/flower/pull/4029), "
"[#3942](https://github.com/adap/flower/pull/3942), "
"[#3957](https://github.com/adap/flower/pull/3957), "
"[#4020](https://github.com/adap/flower/pull/4020), "
"[#4044](https://github.com/adap/flower/pull/4044), "
"[#3852](https://github.com/adap/flower/pull/3852), "
"[#4019](https://github.com/adap/flower/pull/4019), "
"[#4031](https://github.com/adap/flower/pull/4031), "
"[#4036](https://github.com/adap/flower/pull/4036), "
"[#4049](https://github.com/adap/flower/pull/4049), "
"[#4017](https://github.com/adap/flower/pull/4017), "
"[#3943](https://github.com/adap/flower/pull/3943), "
"[#3944](https://github.com/adap/flower/pull/3944), "
"[#4011](https://github.com/adap/flower/pull/4011), "
"[#3619](https://github.com/adap/flower/pull/3619))"
msgstr ""

#: ../../source/ref-changelog.md:992
msgid ""
"Dynamic code updates are here! `flwr run` can now ship and install the "
"latest version of your `ServerApp` and `ClientApp` to an already-running "
"federation (SuperLink and SuperNodes)."
msgstr ""

#: ../../source/ref-changelog.md:994
msgid ""
"How does it work? `flwr run` bundles your Flower app into a single FAB "
"(Flower App Bundle) file. It then ships this FAB file, via the SuperExec,"
" to both the SuperLink and those SuperNodes that need it. This allows you"
" to keep SuperExec, SuperLink and SuperNodes running as permanent "
"infrastructure, and then ship code updates (including completely new "
"projects!) dynamically."
msgstr ""

#: ../../source/ref-changelog.md:996
msgid "`flwr run` is all you need."
msgstr ""

#: ../../source/ref-changelog.md:998
msgid ""
"**Introduce isolated** `ClientApp` **execution** "
"([#3970](https://github.com/adap/flower/pull/3970), "
"[#3976](https://github.com/adap/flower/pull/3976), "
"[#4002](https://github.com/adap/flower/pull/4002), "
"[#4001](https://github.com/adap/flower/pull/4001), "
"[#4034](https://github.com/adap/flower/pull/4034), "
"[#4037](https://github.com/adap/flower/pull/4037), "
"[#3977](https://github.com/adap/flower/pull/3977), "
"[#4042](https://github.com/adap/flower/pull/4042), "
"[#3978](https://github.com/adap/flower/pull/3978), "
"[#4039](https://github.com/adap/flower/pull/4039), "
"[#4033](https://github.com/adap/flower/pull/4033), "
"[#3971](https://github.com/adap/flower/pull/3971), "
"[#4035](https://github.com/adap/flower/pull/4035), "
"[#3973](https://github.com/adap/flower/pull/3973), "
"[#4032](https://github.com/adap/flower/pull/4032))"
msgstr ""

#: ../../source/ref-changelog.md:1000
msgid ""
"The SuperNode can now run your `ClientApp` in a fully isolated way. In an"
" enterprise deployment, this allows you to set strict limits on what the "
"`ClientApp` can and cannot do."
msgstr ""

#: ../../source/ref-changelog.md:1002
msgid "`flower-supernode` supports three `--isolation` modes:"
msgstr ""

#: ../../source/ref-changelog.md:1004
msgid ""
"Unset: The SuperNode runs the `ClientApp` in the same process (as in "
"previous versions of Flower). This is the default mode."
msgstr ""

#: ../../source/ref-changelog.md:1005
msgid ""
"`--isolation=subprocess`: The SuperNode starts a subprocess to run the "
"`ClientApp`."
msgstr ""

#: ../../source/ref-changelog.md:1006
msgid ""
"`--isolation=process`: The SuperNode expects an externally-managed "
"process to run the `ClientApp`. This external process is not managed by "
"the SuperNode, so it has to be started beforehand and terminated "
"manually. The common way to use this isolation mode is via the new "
"`flwr/clientapp` Docker image."
msgstr ""

#: ../../source/ref-changelog.md:1008
msgid ""
"**Improve Docker support for enterprise deployments** "
"([#4050](https://github.com/adap/flower/pull/4050), "
"[#4090](https://github.com/adap/flower/pull/4090), "
"[#3784](https://github.com/adap/flower/pull/3784), "
"[#3998](https://github.com/adap/flower/pull/3998), "
"[#4094](https://github.com/adap/flower/pull/4094), "
"[#3722](https://github.com/adap/flower/pull/3722))"
msgstr ""

#: ../../source/ref-changelog.md:1010
msgid ""
"Flower 1.11 ships many Docker improvements that are especially useful for"
" enterprise deployments:"
msgstr ""

#: ../../source/ref-changelog.md:1012
msgid "`flwr/supernode` comes with a new Alpine Docker image."
msgstr ""

#: ../../source/ref-changelog.md:1013
msgid ""
"`flwr/clientapp` is a new image to be used with the `--isolation=process`"
" option. In this mode, SuperNode and `ClientApp` run in two different "
"Docker containers. `flwr/supernode` (preferably the Alpine version) runs "
"the long-running SuperNode with `--isolation=process`. `flwr/clientapp` "
"runs the `ClientApp`. This is the recommended way to deploy Flower in "
"enterprise settings."
msgstr ""

#: ../../source/ref-changelog.md:1014
msgid ""
"New all-in-one Docker Compose enables you to easily start a full Flower "
"Deployment Engine on a single machine."
msgstr ""

#: ../../source/ref-changelog.md:1015
msgid ""
"Completely new Docker documentation: "
"https://flower.ai/docs/framework/docker/index.html"
msgstr ""

#: ../../source/ref-changelog.md:1017
msgid ""
"**Improve SuperNode authentication** "
"([#4043](https://github.com/adap/flower/pull/4043), "
"[#4047](https://github.com/adap/flower/pull/4047), "
"[#4074](https://github.com/adap/flower/pull/4074))"
msgstr ""

#: ../../source/ref-changelog.md:1019
msgid ""
"SuperNode auth has been improved in several ways, including improved "
"logging, improved testing, and improved error handling."
msgstr ""

#: ../../source/ref-changelog.md:1021
msgid ""
"**Update** `flwr new` **templates** "
"([#3933](https://github.com/adap/flower/pull/3933), "
"[#3894](https://github.com/adap/flower/pull/3894), "
"[#3930](https://github.com/adap/flower/pull/3930), "
"[#3931](https://github.com/adap/flower/pull/3931), "
"[#3997](https://github.com/adap/flower/pull/3997), "
"[#3979](https://github.com/adap/flower/pull/3979), "
"[#3965](https://github.com/adap/flower/pull/3965), "
"[#4013](https://github.com/adap/flower/pull/4013), "
"[#4064](https://github.com/adap/flower/pull/4064))"
msgstr ""

#: ../../source/ref-changelog.md:1023
msgid ""
"All `flwr new` templates have been updated to show the latest recommended"
" use of Flower APIs."
msgstr ""

#: ../../source/ref-changelog.md:1025
msgid ""
"**Improve Simulation Engine** "
"([#4095](https://github.com/adap/flower/pull/4095), "
"[#3913](https://github.com/adap/flower/pull/3913), "
"[#4059](https://github.com/adap/flower/pull/4059), "
"[#3954](https://github.com/adap/flower/pull/3954), "
"[#4071](https://github.com/adap/flower/pull/4071), "
"[#3985](https://github.com/adap/flower/pull/3985), "
"[#3988](https://github.com/adap/flower/pull/3988))"
msgstr ""

#: ../../source/ref-changelog.md:1027
msgid ""
"The Flower Simulation Engine comes with several updates, including "
"improved run config support, verbose logging, simulation backend "
"configuration via `flwr run`, and more."
msgstr ""

#: ../../source/ref-changelog.md:1029
msgid ""
"**Improve** `RecordSet` "
"([#4052](https://github.com/adap/flower/pull/4052), "
"[#3218](https://github.com/adap/flower/pull/3218), "
"[#4016](https://github.com/adap/flower/pull/4016))"
msgstr ""

#: ../../source/ref-changelog.md:1031
msgid ""
"`RecordSet` is the core object to exchange model parameters, "
"configuration values and metrics between `ClientApp` and `ServerApp`. "
"This release ships several smaller improvements to `RecordSet` and "
"related `*Record` types."
msgstr ""

#: ../../source/ref-changelog.md:1033
msgid ""
"**Update documentation** "
"([#3972](https://github.com/adap/flower/pull/3972), "
"[#3925](https://github.com/adap/flower/pull/3925), "
"[#4061](https://github.com/adap/flower/pull/4061), "
"[#3984](https://github.com/adap/flower/pull/3984), "
"[#3917](https://github.com/adap/flower/pull/3917), "
"[#3900](https://github.com/adap/flower/pull/3900), "
"[#4066](https://github.com/adap/flower/pull/4066), "
"[#3765](https://github.com/adap/flower/pull/3765), "
"[#4021](https://github.com/adap/flower/pull/4021), "
"[#3906](https://github.com/adap/flower/pull/3906), "
"[#4063](https://github.com/adap/flower/pull/4063), "
"[#4076](https://github.com/adap/flower/pull/4076), "
"[#3920](https://github.com/adap/flower/pull/3920), "
"[#3916](https://github.com/adap/flower/pull/3916))"
msgstr ""

#: ../../source/ref-changelog.md:1035
msgid ""
"Many parts of the documentation, including the main tutorial, have been "
"migrated to show new Flower APIs and other new Flower features like the "
"improved Docker support."
msgstr ""

#: ../../source/ref-changelog.md:1037
msgid ""
"**Migrate code example to use new Flower APIs** "
"([#3758](https://github.com/adap/flower/pull/3758), "
"[#3701](https://github.com/adap/flower/pull/3701), "
"[#3919](https://github.com/adap/flower/pull/3919), "
"[#3918](https://github.com/adap/flower/pull/3918), "
"[#3934](https://github.com/adap/flower/pull/3934), "
"[#3893](https://github.com/adap/flower/pull/3893), "
"[#3833](https://github.com/adap/flower/pull/3833), "
"[#3922](https://github.com/adap/flower/pull/3922), "
"[#3846](https://github.com/adap/flower/pull/3846), "
"[#3777](https://github.com/adap/flower/pull/3777), "
"[#3874](https://github.com/adap/flower/pull/3874), "
"[#3873](https://github.com/adap/flower/pull/3873), "
"[#3935](https://github.com/adap/flower/pull/3935), "
"[#3754](https://github.com/adap/flower/pull/3754), "
"[#3980](https://github.com/adap/flower/pull/3980), "
"[#4089](https://github.com/adap/flower/pull/4089), "
"[#4046](https://github.com/adap/flower/pull/4046), "
"[#3314](https://github.com/adap/flower/pull/3314), "
"[#3316](https://github.com/adap/flower/pull/3316), "
"[#3295](https://github.com/adap/flower/pull/3295), "
"[#3313](https://github.com/adap/flower/pull/3313))"
msgstr ""

#: ../../source/ref-changelog.md:1039
msgid "Many code examples have been migrated to use new Flower APIs."
msgstr ""

#: ../../source/ref-changelog.md:1041
msgid ""
"**Update Flower framework, framework internals and quality "
"infrastructure** ([#4018](https://github.com/adap/flower/pull/4018), "
"[#4053](https://github.com/adap/flower/pull/4053), "
"[#4098](https://github.com/adap/flower/pull/4098), "
"[#4067](https://github.com/adap/flower/pull/4067), "
"[#4105](https://github.com/adap/flower/pull/4105), "
"[#4048](https://github.com/adap/flower/pull/4048), "
"[#4107](https://github.com/adap/flower/pull/4107), "
"[#4069](https://github.com/adap/flower/pull/4069), "
"[#3915](https://github.com/adap/flower/pull/3915), "
"[#4101](https://github.com/adap/flower/pull/4101), "
"[#4108](https://github.com/adap/flower/pull/4108), "
"[#3914](https://github.com/adap/flower/pull/3914), "
"[#4068](https://github.com/adap/flower/pull/4068), "
"[#4041](https://github.com/adap/flower/pull/4041), "
"[#4040](https://github.com/adap/flower/pull/4040), "
"[#3986](https://github.com/adap/flower/pull/3986), "
"[#4026](https://github.com/adap/flower/pull/4026), "
"[#3961](https://github.com/adap/flower/pull/3961), "
"[#3975](https://github.com/adap/flower/pull/3975), "
"[#3983](https://github.com/adap/flower/pull/3983), "
"[#4091](https://github.com/adap/flower/pull/4091), "
"[#3982](https://github.com/adap/flower/pull/3982), "
"[#4079](https://github.com/adap/flower/pull/4079), "
"[#4073](https://github.com/adap/flower/pull/4073), "
"[#4060](https://github.com/adap/flower/pull/4060), "
"[#4106](https://github.com/adap/flower/pull/4106), "
"[#4080](https://github.com/adap/flower/pull/4080), "
"[#3974](https://github.com/adap/flower/pull/3974), "
"[#3996](https://github.com/adap/flower/pull/3996), "
"[#3991](https://github.com/adap/flower/pull/3991), "
"[#3981](https://github.com/adap/flower/pull/3981), "
"[#4093](https://github.com/adap/flower/pull/4093), "
"[#4100](https://github.com/adap/flower/pull/4100), "
"[#3939](https://github.com/adap/flower/pull/3939), "
"[#3955](https://github.com/adap/flower/pull/3955), "
"[#3940](https://github.com/adap/flower/pull/3940), "
"[#4038](https://github.com/adap/flower/pull/4038))"
msgstr ""

#: ../../source/ref-changelog.md:1047
msgid ""
"**Deprecate accessing `Context` via `Client.context`** "
"([#3797](https://github.com/adap/flower/pull/3797))"
msgstr ""

#: ../../source/ref-changelog.md:1049
msgid ""
"Now that both `client_fn` and `server_fn` receive a `Context` object, "
"accessing `Context` via `Client.context` is deprecated. `Client.context` "
"will be removed in a future release. If you need to access `Context` in "
"your `Client` implementation, pass it manually when creating the `Client`"
" instance in `client_fn`:"
msgstr ""

#: ../../source/ref-changelog.md:1058
msgid ""
"**Update CLIs to accept an app directory instead of** `ClientApp` **and**"
" `ServerApp` ([#3952](https://github.com/adap/flower/pull/3952), "
"[#4077](https://github.com/adap/flower/pull/4077), "
"[#3850](https://github.com/adap/flower/pull/3850))"
msgstr ""

#: ../../source/ref-changelog.md:1060
msgid ""
"The CLI commands `flower-supernode` and `flower-server-app` now accept an"
" app directory as argument (instead of references to a `ClientApp` or "
"`ServerApp`). An app directory is any directory containing a "
"`pyproject.toml` file (with the appropriate Flower config fields set). "
"The easiest way to generate a compatible project structure is to use "
"`flwr new`."
msgstr ""

#: ../../source/ref-changelog.md:1062
msgid ""
"**Disable** `flower-client-app` **CLI command** "
"([#4022](https://github.com/adap/flower/pull/4022))"
msgstr ""

#: ../../source/ref-changelog.md:1064
msgid "`flower-client-app` has been disabled. Use `flower-supernode` instead."
msgstr ""

#: ../../source/ref-changelog.md:1066
msgid ""
"**Use spaces instead of commas for separating config args** "
"([#4000](https://github.com/adap/flower/pull/4000))"
msgstr ""

#: ../../source/ref-changelog.md:1068
msgid ""
"When passing configs (run config, node config) to Flower, you now need to"
" separate key-value pairs using spaces instead of commas. For example:"
msgstr ""

#: ../../source/ref-changelog.md:1074
msgid "Previously, you could pass configs using commas, like this:"
msgstr ""

#: ../../source/ref-changelog.md:1080
msgid ""
"**Remove** `flwr example` **CLI command** "
"([#4084](https://github.com/adap/flower/pull/4084))"
msgstr ""

#: ../../source/ref-changelog.md:1082
msgid ""
"The experimental `flwr example` CLI command has been removed. Use `flwr "
"new` to generate a project and then run it using `flwr run`."
msgstr ""

#: ../../source/ref-changelog.md:1084
msgid "v1.10.0 (2024-07-24)"
msgstr ""

#: ../../source/ref-changelog.md:1090
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Chong Shen Ng`, `Daniel J. "
"Beutel`, `Daniel Nata Nugraha`, `Danny`, `Gustavo Bertoli`, `Heng Pan`, "
"`Ikko Eltociear Ashimine`, `Javier`, `Jiahao Tan`, `Mohammad Naseri`, "
"`Robert Steiner`, `Sebastian van der Voort`, `Taner Topal`, `Yan Gao` <!"
"---TOKEN_v1.10.0-->"
msgstr ""

#: ../../source/ref-changelog.md:1094
msgid ""
"**Introduce** `flwr run` **(beta)** "
"([#3810](https://github.com/adap/flower/pull/3810), "
"[#3826](https://github.com/adap/flower/pull/3826), "
"[#3880](https://github.com/adap/flower/pull/3880), "
"[#3807](https://github.com/adap/flower/pull/3807), "
"[#3800](https://github.com/adap/flower/pull/3800), "
"[#3814](https://github.com/adap/flower/pull/3814), "
"[#3811](https://github.com/adap/flower/pull/3811), "
"[#3809](https://github.com/adap/flower/pull/3809), "
"[#3819](https://github.com/adap/flower/pull/3819))"
msgstr ""

#: ../../source/ref-changelog.md:1096
msgid ""
"Flower 1.10 ships the first beta release of the new `flwr run` command. "
"`flwr run` can run different projects using `flwr run path/to/project`, "
"it enables you to easily switch between different federations using `flwr"
" run . federation` and it runs your Flower project using either local "
"simulation or the new (experimental) SuperExec service. This allows "
"Flower to scale federatated learning from fast local simulation to large-"
"scale production deployment, seamlessly. All projects generated with "
"`flwr new` are immediately runnable using `flwr run`. Give it a try: use "
"`flwr new` to generate a project and then run it using `flwr run`."
msgstr ""

#: ../../source/ref-changelog.md:1098
msgid ""
"**Introduce run config** "
"([#3751](https://github.com/adap/flower/pull/3751), "
"[#3750](https://github.com/adap/flower/pull/3750), "
"[#3845](https://github.com/adap/flower/pull/3845), "
"[#3824](https://github.com/adap/flower/pull/3824), "
"[#3746](https://github.com/adap/flower/pull/3746), "
"[#3728](https://github.com/adap/flower/pull/3728), "
"[#3730](https://github.com/adap/flower/pull/3730), "
"[#3725](https://github.com/adap/flower/pull/3725), "
"[#3729](https://github.com/adap/flower/pull/3729), "
"[#3580](https://github.com/adap/flower/pull/3580), "
"[#3578](https://github.com/adap/flower/pull/3578), "
"[#3576](https://github.com/adap/flower/pull/3576), "
"[#3798](https://github.com/adap/flower/pull/3798), "
"[#3732](https://github.com/adap/flower/pull/3732), "
"[#3815](https://github.com/adap/flower/pull/3815))"
msgstr ""

#: ../../source/ref-changelog.md:1100
msgid ""
"The new run config feature allows you to run your Flower project in "
"different configurations without having to change a single line of code. "
"You can now build a configurable `ServerApp` and `ClientApp` that read "
"configuration values at runtime. This enables you to specify config "
"values like `learning-rate=0.01` in `pyproject.toml` (under the "
"`[tool.flwr.app.config]` key). These config values can then be easily "
"overridden via `flwr run --run-config learning-rate=0.02`, and read from "
"`Context` using `lr = context.run_config[\"learning-rate\"]`. Create a "
"new project using `flwr new` to see run config in action."
msgstr ""

#: ../../source/ref-changelog.md:1102
msgid ""
"**Generalize** `client_fn` **signature to** `client_fn(context: Context) "
"-> Client` ([#3779](https://github.com/adap/flower/pull/3779), "
"[#3697](https://github.com/adap/flower/pull/3697), "
"[#3694](https://github.com/adap/flower/pull/3694), "
"[#3696](https://github.com/adap/flower/pull/3696))"
msgstr ""

#: ../../source/ref-changelog.md:1104
msgid ""
"The `client_fn` signature has been generalized to `client_fn(context: "
"Context) -> Client`. It now receives a `Context` object instead of the "
"(now depreacated) `cid: str`. `Context` allows accessing `node_id`, "
"`node_config` and `run_config`, among other things. This enables you to "
"build a configurable `ClientApp` that leverages the new run config "
"system."
msgstr ""

#: ../../source/ref-changelog.md:1106
msgid ""
"The previous signature `client_fn(cid: str)` is now deprecated and "
"support for it will be removed in a future release. Use "
"`client_fn(context: Context) -> Client` everywhere."
msgstr ""

#: ../../source/ref-changelog.md:1108
msgid ""
"**Introduce new** `server_fn(context)` "
"([#3773](https://github.com/adap/flower/pull/3773), "
"[#3796](https://github.com/adap/flower/pull/3796), "
"[#3771](https://github.com/adap/flower/pull/3771))"
msgstr ""

#: ../../source/ref-changelog.md:1110
msgid ""
"In addition to the new `client_fn(context:Context)`, a new "
"`server_fn(context: Context) -> ServerAppComponents` can now be passed to"
" `ServerApp` (instead of passing, for example, `Strategy`, directly). "
"This enables you to leverage the full `Context` on the server-side to "
"build a configurable `ServerApp`."
msgstr ""

#: ../../source/ref-changelog.md:1112
msgid ""
"**Relaunch all** `flwr new` **templates** "
"([#3877](https://github.com/adap/flower/pull/3877), "
"[#3821](https://github.com/adap/flower/pull/3821), "
"[#3587](https://github.com/adap/flower/pull/3587), "
"[#3795](https://github.com/adap/flower/pull/3795), "
"[#3875](https://github.com/adap/flower/pull/3875), "
"[#3859](https://github.com/adap/flower/pull/3859), "
"[#3760](https://github.com/adap/flower/pull/3760))"
msgstr ""

#: ../../source/ref-changelog.md:1114
msgid ""
"All `flwr new` templates have been significantly updated to showcase new "
"Flower features and best practices. This includes using `flwr run` and "
"the new run config feature. You can now easily create a new project using"
" `flwr new` and, after following the instructions to install it, `flwr "
"run` it."
msgstr ""

#: ../../source/ref-changelog.md:1116
msgid ""
"**Introduce** `flower-supernode` **(preview)** "
"([#3353](https://github.com/adap/flower/pull/3353))"
msgstr ""

#: ../../source/ref-changelog.md:1118
msgid ""
"The new `flower-supernode` CLI is here to replace `flower-client-app`. "
"`flower-supernode` brings full multi-app support to the Flower client-"
"side. It also allows to pass `--node-config` to the SuperNode, which is "
"accessible in your `ClientApp` via `Context` (using the new "
"`client_fn(context: Context)` signature)."
msgstr ""

#: ../../source/ref-changelog.md:1120
msgid ""
"**Introduce node config** "
"([#3782](https://github.com/adap/flower/pull/3782), "
"[#3780](https://github.com/adap/flower/pull/3780), "
"[#3695](https://github.com/adap/flower/pull/3695), "
"[#3886](https://github.com/adap/flower/pull/3886))"
msgstr ""

#: ../../source/ref-changelog.md:1122
msgid ""
"A new node config feature allows you to pass a static configuration to "
"the SuperNode. This configuration is read-only and available to every "
"`ClientApp` running on that SuperNode. A `ClientApp` can access the node "
"config via `Context` (`context.node_config`)."
msgstr ""

#: ../../source/ref-changelog.md:1124
msgid ""
"**Introduce SuperExec (experimental)** "
"([#3605](https://github.com/adap/flower/pull/3605), "
"[#3723](https://github.com/adap/flower/pull/3723), "
"[#3731](https://github.com/adap/flower/pull/3731), "
"[#3589](https://github.com/adap/flower/pull/3589), "
"[#3604](https://github.com/adap/flower/pull/3604), "
"[#3622](https://github.com/adap/flower/pull/3622), "
"[#3838](https://github.com/adap/flower/pull/3838), "
"[#3720](https://github.com/adap/flower/pull/3720), "
"[#3606](https://github.com/adap/flower/pull/3606), "
"[#3602](https://github.com/adap/flower/pull/3602), "
"[#3603](https://github.com/adap/flower/pull/3603), "
"[#3555](https://github.com/adap/flower/pull/3555), "
"[#3808](https://github.com/adap/flower/pull/3808), "
"[#3724](https://github.com/adap/flower/pull/3724), "
"[#3658](https://github.com/adap/flower/pull/3658), "
"[#3629](https://github.com/adap/flower/pull/3629))"
msgstr ""

#: ../../source/ref-changelog.md:1126
msgid ""
"This is the first experimental release of Flower SuperExec, a new service"
" that executes your runs. It's not ready for production deployment just "
"yet, but don't hesitate to give it a try if you're interested."
msgstr ""

#: ../../source/ref-changelog.md:1128
msgid ""
"**Add new federated learning with tabular data example** "
"([#3568](https://github.com/adap/flower/pull/3568))"
msgstr ""

#: ../../source/ref-changelog.md:1130
msgid ""
"A new code example exemplifies a federated learning setup using the "
"Flower framework on the Adult Census Income tabular dataset."
msgstr ""

#: ../../source/ref-changelog.md:1132
msgid ""
"**Create generic adapter layer (preview)** "
"([#3538](https://github.com/adap/flower/pull/3538), "
"[#3536](https://github.com/adap/flower/pull/3536), "
"[#3540](https://github.com/adap/flower/pull/3540))"
msgstr ""

#: ../../source/ref-changelog.md:1134
msgid ""
"A new generic gRPC adapter layer allows 3rd-party frameworks to integrate"
" with Flower in a transparent way. This makes Flower more modular and "
"allows for integration into other federated learning solutions and "
"platforms."
msgstr ""

#: ../../source/ref-changelog.md:1136
msgid ""
"**Refactor Flower Simulation Engine** "
"([#3581](https://github.com/adap/flower/pull/3581), "
"[#3471](https://github.com/adap/flower/pull/3471), "
"[#3804](https://github.com/adap/flower/pull/3804), "
"[#3468](https://github.com/adap/flower/pull/3468), "
"[#3839](https://github.com/adap/flower/pull/3839), "
"[#3806](https://github.com/adap/flower/pull/3806), "
"[#3861](https://github.com/adap/flower/pull/3861), "
"[#3543](https://github.com/adap/flower/pull/3543), "
"[#3472](https://github.com/adap/flower/pull/3472), "
"[#3829](https://github.com/adap/flower/pull/3829), "
"[#3469](https://github.com/adap/flower/pull/3469))"
msgstr ""

#: ../../source/ref-changelog.md:1138
msgid ""
"The Simulation Engine was significantly refactored. This results in "
"faster and more stable simulations. It is also the foundation for "
"upcoming changes that aim to provide the next level of performance and "
"configurability in federated learning simulations."
msgstr ""

#: ../../source/ref-changelog.md:1140
msgid ""
"**Optimize Docker containers** "
"([#3591](https://github.com/adap/flower/pull/3591))"
msgstr ""

#: ../../source/ref-changelog.md:1142
msgid ""
"Flower Docker containers were optimized and updated to use that latest "
"Flower framework features."
msgstr ""

#: ../../source/ref-changelog.md:1144
msgid ""
"**Improve logging** ([#3776](https://github.com/adap/flower/pull/3776), "
"[#3789](https://github.com/adap/flower/pull/3789))"
msgstr ""

#: ../../source/ref-changelog.md:1146
msgid ""
"Improved logging aims to be more concise and helpful to show you the "
"details you actually care about."
msgstr ""

#: ../../source/ref-changelog.md:1148
msgid ""
"**Refactor framework internals** "
"([#3621](https://github.com/adap/flower/pull/3621), "
"[#3792](https://github.com/adap/flower/pull/3792), "
"[#3772](https://github.com/adap/flower/pull/3772), "
"[#3805](https://github.com/adap/flower/pull/3805), "
"[#3583](https://github.com/adap/flower/pull/3583), "
"[#3825](https://github.com/adap/flower/pull/3825), "
"[#3597](https://github.com/adap/flower/pull/3597), "
"[#3802](https://github.com/adap/flower/pull/3802), "
"[#3569](https://github.com/adap/flower/pull/3569))"
msgstr ""

#: ../../source/ref-changelog.md:1152
#, fuzzy
msgid "Documentation improvements"
msgstr "선택적 개선 사항"

#: ../../source/ref-changelog.md:1154
msgid ""
"**Add 🇰🇷 Korean translations** "
"([#3680](https://github.com/adap/flower/pull/3680))"
msgstr ""

#: ../../source/ref-changelog.md:1156
msgid ""
"**Update translations** "
"([#3586](https://github.com/adap/flower/pull/3586), "
"[#3679](https://github.com/adap/flower/pull/3679), "
"[#3570](https://github.com/adap/flower/pull/3570), "
"[#3681](https://github.com/adap/flower/pull/3681), "
"[#3617](https://github.com/adap/flower/pull/3617), "
"[#3674](https://github.com/adap/flower/pull/3674), "
"[#3671](https://github.com/adap/flower/pull/3671), "
"[#3572](https://github.com/adap/flower/pull/3572), "
"[#3631](https://github.com/adap/flower/pull/3631))"
msgstr ""

#: ../../source/ref-changelog.md:1158
msgid ""
"**Update documentation** "
"([#3864](https://github.com/adap/flower/pull/3864), "
"[#3688](https://github.com/adap/flower/pull/3688), "
"[#3562](https://github.com/adap/flower/pull/3562), "
"[#3641](https://github.com/adap/flower/pull/3641), "
"[#3384](https://github.com/adap/flower/pull/3384), "
"[#3634](https://github.com/adap/flower/pull/3634), "
"[#3823](https://github.com/adap/flower/pull/3823), "
"[#3793](https://github.com/adap/flower/pull/3793), "
"[#3707](https://github.com/adap/flower/pull/3707))"
msgstr ""

#: ../../source/ref-changelog.md:1160
msgid ""
"Updated documentation includes new install instructions for different "
"shells, a new Flower Code Examples documentation landing page, new `flwr`"
" CLI docs and an updated federated XGBoost code example."
msgstr ""

#: ../../source/ref-changelog.md:1164
msgid "**Deprecate** `client_fn(cid: str)`"
msgstr ""

#: ../../source/ref-changelog.md:1166
msgid ""
"`client_fn` used to have a signature `client_fn(cid: str) -> Client`. "
"This signature is now deprecated. Use the new signature "
"`client_fn(context: Context) -> Client` instead. The new argument "
"`context` allows accessing `node_id`, `node_config`, `run_config` and "
"other `Context` features. When running using the simulation engine (or "
"using `flower-supernode` with a custom `--node-config partition-id=...`),"
" `context.node_config[\"partition-id\"]` will return an `int` partition "
"ID that can be used with Flower Datasets to load a different partition of"
" the dataset on each simulated or deployed SuperNode."
msgstr ""

#: ../../source/ref-changelog.md:1168
msgid ""
"**Deprecate passing** `Server/ServerConfig/Strategy/ClientManager` **to**"
" `ServerApp` **directly**"
msgstr ""

#: ../../source/ref-changelog.md:1170
msgid ""
"Creating `ServerApp` using `ServerApp(config=config, strategy=strategy)` "
"is now deprecated. Instead of passing "
"`Server/ServerConfig/Strategy/ClientManager` to `ServerApp` directly, "
"pass them wrapped in a `server_fn(context: Context) -> "
"ServerAppComponents` function, like this: "
"`ServerApp(server_fn=server_fn)`. `ServerAppComponents` can hold "
"references to `Server/ServerConfig/Strategy/ClientManager`. In addition "
"to that, `server_fn` allows you to access `Context` (for example, to read"
" the `run_config`)."
msgstr ""

#: ../../source/ref-changelog.md:1174
msgid ""
"**Remove support for `client_ids` in `start_simulation`** "
"([#3699](https://github.com/adap/flower/pull/3699))"
msgstr ""

#: ../../source/ref-changelog.md:1176
msgid ""
"The (rarely used) feature that allowed passing custom `client_ids` to the"
" `start_simulation` function was removed. This removal is part of a "
"bigger effort to refactor the simulation engine and unify how the Flower "
"internals work in simulation and deployment."
msgstr ""

#: ../../source/ref-changelog.md:1178
msgid ""
"**Remove `flower-driver-api` and `flower-fleet-api`** "
"([#3418](https://github.com/adap/flower/pull/3418))"
msgstr ""

#: ../../source/ref-changelog.md:1180
msgid ""
"The two deprecated CLI commands `flower-driver-api` and `flower-fleet-"
"api` were removed in an effort to streamline the SuperLink developer "
"experience. Use `flower-superlink` instead."
msgstr ""

#: ../../source/ref-changelog.md:1182
msgid "v1.9.0 (2024-06-10)"
msgstr ""

#: ../../source/ref-changelog.md:1188
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Chong Shen Ng`, `Daniel J. "
"Beutel`, `Daniel Nata Nugraha`, `Heng Pan`, `Javier`, `Mahdi Beitollahi`,"
" `Robert Steiner`, `Taner Topal`, `Yan Gao`, `bapic`, `mohammadnaseri` <!"
"---TOKEN_v1.9.0-->"
msgstr ""

#: ../../source/ref-changelog.md:1192
msgid ""
"**Introduce built-in authentication (preview)** "
"([#2946](https://github.com/adap/flower/pull/2946), "
"[#3388](https://github.com/adap/flower/pull/3388), "
"[#2948](https://github.com/adap/flower/pull/2948), "
"[#2917](https://github.com/adap/flower/pull/2917), "
"[#3386](https://github.com/adap/flower/pull/3386), "
"[#3308](https://github.com/adap/flower/pull/3308), "
"[#3001](https://github.com/adap/flower/pull/3001), "
"[#3409](https://github.com/adap/flower/pull/3409), "
"[#2999](https://github.com/adap/flower/pull/2999), "
"[#2979](https://github.com/adap/flower/pull/2979), "
"[#3389](https://github.com/adap/flower/pull/3389), "
"[#3503](https://github.com/adap/flower/pull/3503), "
"[#3366](https://github.com/adap/flower/pull/3366), "
"[#3357](https://github.com/adap/flower/pull/3357))"
msgstr ""

#: ../../source/ref-changelog.md:1194
msgid ""
"Flower 1.9 introduces the first build-in version of client node "
"authentication. In previous releases, users often wrote glue code to "
"connect Flower to external authentication systems. With this release, the"
" SuperLink can authenticate SuperNodes using a built-in authentication "
"system. A new [how-to guide](https://flower.ai/docs/framework/how-to-"
"authenticate-supernodes.html) and a new [code "
"example](https://github.com/adap/flower/tree/main/examples/flower-"
"authentication) help you to get started."
msgstr ""

#: ../../source/ref-changelog.md:1196
msgid ""
"This is the first preview release of the Flower-native authentication "
"system. Many additional features are on the roadmap for upcoming Flower "
"releases - stay tuned."
msgstr ""

#: ../../source/ref-changelog.md:1198
msgid ""
"**Introduce end-to-end Docker support** "
"([#3483](https://github.com/adap/flower/pull/3483), "
"[#3266](https://github.com/adap/flower/pull/3266), "
"[#3390](https://github.com/adap/flower/pull/3390), "
"[#3283](https://github.com/adap/flower/pull/3283), "
"[#3285](https://github.com/adap/flower/pull/3285), "
"[#3391](https://github.com/adap/flower/pull/3391), "
"[#3403](https://github.com/adap/flower/pull/3403), "
"[#3458](https://github.com/adap/flower/pull/3458), "
"[#3533](https://github.com/adap/flower/pull/3533), "
"[#3453](https://github.com/adap/flower/pull/3453), "
"[#3486](https://github.com/adap/flower/pull/3486), "
"[#3290](https://github.com/adap/flower/pull/3290))"
msgstr ""

#: ../../source/ref-changelog.md:1200
msgid ""
"Full Flower Next Docker support is here! With the release of Flower 1.9, "
"Flower provides stable Docker images for the Flower SuperLink, the Flower"
" SuperNode, and the Flower `ServerApp`. This set of images enables you to"
" run all Flower components in Docker. Check out the new [how-to "
"guide](https://flower.ai/docs/framework/how-to-run-flower-using-"
"docker.html) to get stated."
msgstr ""

#: ../../source/ref-changelog.md:1202
msgid ""
"**Re-architect Flower Next simulation engine** "
"([#3307](https://github.com/adap/flower/pull/3307), "
"[#3355](https://github.com/adap/flower/pull/3355), "
"[#3272](https://github.com/adap/flower/pull/3272), "
"[#3273](https://github.com/adap/flower/pull/3273), "
"[#3417](https://github.com/adap/flower/pull/3417), "
"[#3281](https://github.com/adap/flower/pull/3281), "
"[#3343](https://github.com/adap/flower/pull/3343), "
"[#3326](https://github.com/adap/flower/pull/3326))"
msgstr ""

#: ../../source/ref-changelog.md:1204
msgid ""
"Flower Next simulations now use a new in-memory `Driver` that improves "
"the reliability of simulations, especially in notebook environments. This"
" is a significant step towards a complete overhaul of the Flower Next "
"simulation architecture."
msgstr ""

#: ../../source/ref-changelog.md:1206
msgid ""
"**Upgrade simulation engine** "
"([#3354](https://github.com/adap/flower/pull/3354), "
"[#3378](https://github.com/adap/flower/pull/3378), "
"[#3262](https://github.com/adap/flower/pull/3262), "
"[#3435](https://github.com/adap/flower/pull/3435), "
"[#3501](https://github.com/adap/flower/pull/3501), "
"[#3482](https://github.com/adap/flower/pull/3482), "
"[#3494](https://github.com/adap/flower/pull/3494))"
msgstr ""

#: ../../source/ref-changelog.md:1208
msgid ""
"The Flower Next simulation engine comes with improved and configurable "
"logging. The Ray-based simulation backend in Flower 1.9 was updated to "
"use Ray 2.10."
msgstr ""

#: ../../source/ref-changelog.md:1210
msgid ""
"**Introduce FedPFT baseline** "
"([#3268](https://github.com/adap/flower/pull/3268))"
msgstr ""

#: ../../source/ref-changelog.md:1212
msgid ""
"FedPFT allows you to perform one-shot Federated Learning by leveraging "
"widely available foundational models, dramatically reducing communication"
" costs while delivering high performing models. This is work led by Mahdi"
" Beitollahi from Huawei Noah's Ark Lab (Montreal, Canada). Read all the "
"details in their paper: \"Parametric Feature Transfer: One-shot Federated"
" Learning with Foundation Models\" "
"([arxiv](https://arxiv.org/abs/2402.01862))"
msgstr ""

#: ../../source/ref-changelog.md:1214
msgid ""
"**Launch additional** `flwr new` **templates for Apple MLX, Hugging Face "
"Transformers, scikit-learn and TensorFlow** "
"([#3291](https://github.com/adap/flower/pull/3291), "
"[#3139](https://github.com/adap/flower/pull/3139), "
"[#3284](https://github.com/adap/flower/pull/3284), "
"[#3251](https://github.com/adap/flower/pull/3251), "
"[#3376](https://github.com/adap/flower/pull/3376), "
"[#3287](https://github.com/adap/flower/pull/3287))"
msgstr ""

#: ../../source/ref-changelog.md:1216
msgid ""
"The `flwr` CLI's `flwr new` command is starting to become everone's "
"favorite way of creating new Flower projects. This release introduces "
"additional `flwr new` templates for Apple MLX, Hugging Face Transformers,"
" scikit-learn and TensorFlow. In addition to that, existing templates "
"also received updates."
msgstr ""

#: ../../source/ref-changelog.md:1218
msgid ""
"**Refine** `RecordSet` **API** "
"([#3209](https://github.com/adap/flower/pull/3209), "
"[#3331](https://github.com/adap/flower/pull/3331), "
"[#3334](https://github.com/adap/flower/pull/3334), "
"[#3335](https://github.com/adap/flower/pull/3335), "
"[#3375](https://github.com/adap/flower/pull/3375), "
"[#3368](https://github.com/adap/flower/pull/3368))"
msgstr ""

#: ../../source/ref-changelog.md:1220
msgid ""
"`RecordSet` is part of the Flower Next low-level API preview release. In "
"Flower 1.9, `RecordSet` received a number of usability improvements that "
"make it easier to build `RecordSet`-based `ServerApp`s and `ClientApp`s."
msgstr ""

#: ../../source/ref-changelog.md:1222
msgid ""
"**Beautify logging** ([#3379](https://github.com/adap/flower/pull/3379), "
"[#3430](https://github.com/adap/flower/pull/3430), "
"[#3461](https://github.com/adap/flower/pull/3461), "
"[#3360](https://github.com/adap/flower/pull/3360), "
"[#3433](https://github.com/adap/flower/pull/3433))"
msgstr ""

#: ../../source/ref-changelog.md:1224
msgid ""
"Logs received a substantial update. Not only are logs now much nicer to "
"look at, but they are also more configurable."
msgstr ""

#: ../../source/ref-changelog.md:1226
msgid ""
"**Improve reliability** "
"([#3564](https://github.com/adap/flower/pull/3564), "
"[#3561](https://github.com/adap/flower/pull/3561), "
"[#3566](https://github.com/adap/flower/pull/3566), "
"[#3462](https://github.com/adap/flower/pull/3462), "
"[#3225](https://github.com/adap/flower/pull/3225), "
"[#3514](https://github.com/adap/flower/pull/3514), "
"[#3535](https://github.com/adap/flower/pull/3535), "
"[#3372](https://github.com/adap/flower/pull/3372))"
msgstr ""

#: ../../source/ref-changelog.md:1228
msgid ""
"Flower 1.9 includes reliability improvements across many parts of the "
"system. One example is a much improved SuperNode shutdown procedure."
msgstr ""

#: ../../source/ref-changelog.md:1230
msgid ""
"**Update Swift and C++ SDKs** "
"([#3321](https://github.com/adap/flower/pull/3321), "
"[#2763](https://github.com/adap/flower/pull/2763))"
msgstr ""

#: ../../source/ref-changelog.md:1232
msgid ""
"In the C++ SDK, communication-related code is now separate from main "
"client logic. A new abstract class `Communicator` has been introduced "
"alongside a gRPC implementation of it."
msgstr ""

#: ../../source/ref-changelog.md:1234
msgid ""
"**Improve testing, tooling and CI/CD infrastructure** "
"([#3294](https://github.com/adap/flower/pull/3294), "
"[#3282](https://github.com/adap/flower/pull/3282), "
"[#3311](https://github.com/adap/flower/pull/3311), "
"[#2878](https://github.com/adap/flower/pull/2878), "
"[#3333](https://github.com/adap/flower/pull/3333), "
"[#3255](https://github.com/adap/flower/pull/3255), "
"[#3349](https://github.com/adap/flower/pull/3349), "
"[#3400](https://github.com/adap/flower/pull/3400), "
"[#3401](https://github.com/adap/flower/pull/3401), "
"[#3399](https://github.com/adap/flower/pull/3399), "
"[#3346](https://github.com/adap/flower/pull/3346), "
"[#3398](https://github.com/adap/flower/pull/3398), "
"[#3397](https://github.com/adap/flower/pull/3397), "
"[#3347](https://github.com/adap/flower/pull/3347), "
"[#3502](https://github.com/adap/flower/pull/3502), "
"[#3387](https://github.com/adap/flower/pull/3387), "
"[#3542](https://github.com/adap/flower/pull/3542), "
"[#3396](https://github.com/adap/flower/pull/3396), "
"[#3496](https://github.com/adap/flower/pull/3496), "
"[#3465](https://github.com/adap/flower/pull/3465), "
"[#3473](https://github.com/adap/flower/pull/3473), "
"[#3484](https://github.com/adap/flower/pull/3484), "
"[#3521](https://github.com/adap/flower/pull/3521), "
"[#3363](https://github.com/adap/flower/pull/3363), "
"[#3497](https://github.com/adap/flower/pull/3497), "
"[#3464](https://github.com/adap/flower/pull/3464), "
"[#3495](https://github.com/adap/flower/pull/3495), "
"[#3478](https://github.com/adap/flower/pull/3478), "
"[#3271](https://github.com/adap/flower/pull/3271))"
msgstr ""

#: ../../source/ref-changelog.md:1236
msgid ""
"As always, the Flower tooling, testing, and CI/CD infrastructure has "
"received many updates."
msgstr ""

#: ../../source/ref-changelog.md:1238
msgid ""
"**Improve documentation** "
"([#3530](https://github.com/adap/flower/pull/3530), "
"[#3539](https://github.com/adap/flower/pull/3539), "
"[#3425](https://github.com/adap/flower/pull/3425), "
"[#3520](https://github.com/adap/flower/pull/3520), "
"[#3286](https://github.com/adap/flower/pull/3286), "
"[#3516](https://github.com/adap/flower/pull/3516), "
"[#3523](https://github.com/adap/flower/pull/3523), "
"[#3545](https://github.com/adap/flower/pull/3545), "
"[#3498](https://github.com/adap/flower/pull/3498), "
"[#3439](https://github.com/adap/flower/pull/3439), "
"[#3440](https://github.com/adap/flower/pull/3440), "
"[#3382](https://github.com/adap/flower/pull/3382), "
"[#3559](https://github.com/adap/flower/pull/3559), "
"[#3432](https://github.com/adap/flower/pull/3432), "
"[#3278](https://github.com/adap/flower/pull/3278), "
"[#3371](https://github.com/adap/flower/pull/3371), "
"[#3519](https://github.com/adap/flower/pull/3519), "
"[#3267](https://github.com/adap/flower/pull/3267), "
"[#3204](https://github.com/adap/flower/pull/3204), "
"[#3274](https://github.com/adap/flower/pull/3274))"
msgstr ""

#: ../../source/ref-changelog.md:1240
msgid ""
"As always, the Flower documentation has received many updates. Notable "
"new pages include:"
msgstr ""

#: ../../source/ref-changelog.md:1242
msgid ""
"[How-to upgrate to Flower Next (Flower Next migration "
"guide)](https://flower.ai/docs/framework/how-to-upgrade-to-flower-"
"next.html)"
msgstr ""

#: ../../source/ref-changelog.md:1244
msgid ""
"[How-to run Flower using Docker](https://flower.ai/docs/framework/how-to-"
"run-flower-using-docker.html)"
msgstr ""

#: ../../source/ref-changelog.md:1246
msgid ""
"[Flower Mods reference](https://flower.ai/docs/framework/ref-"
"api/flwr.client.mod.html#module-flwr.client.mod)"
msgstr ""

#: ../../source/ref-changelog.md:1248
msgid ""
"**General updates to Flower Examples** "
"([#3205](https://github.com/adap/flower/pull/3205), "
"[#3226](https://github.com/adap/flower/pull/3226), "
"[#3211](https://github.com/adap/flower/pull/3211), "
"[#3252](https://github.com/adap/flower/pull/3252), "
"[#3427](https://github.com/adap/flower/pull/3427), "
"[#3410](https://github.com/adap/flower/pull/3410), "
"[#3426](https://github.com/adap/flower/pull/3426), "
"[#3228](https://github.com/adap/flower/pull/3228), "
"[#3342](https://github.com/adap/flower/pull/3342), "
"[#3200](https://github.com/adap/flower/pull/3200), "
"[#3202](https://github.com/adap/flower/pull/3202), "
"[#3394](https://github.com/adap/flower/pull/3394), "
"[#3488](https://github.com/adap/flower/pull/3488), "
"[#3329](https://github.com/adap/flower/pull/3329), "
"[#3526](https://github.com/adap/flower/pull/3526), "
"[#3392](https://github.com/adap/flower/pull/3392), "
"[#3474](https://github.com/adap/flower/pull/3474), "
"[#3269](https://github.com/adap/flower/pull/3269))"
msgstr ""

#: ../../source/ref-changelog.md:1250
msgid "As always, Flower code examples have received many updates."
msgstr ""

#: ../../source/ref-changelog.md:1252
msgid ""
"**General improvements** "
"([#3532](https://github.com/adap/flower/pull/3532), "
"[#3318](https://github.com/adap/flower/pull/3318), "
"[#3565](https://github.com/adap/flower/pull/3565), "
"[#3296](https://github.com/adap/flower/pull/3296), "
"[#3305](https://github.com/adap/flower/pull/3305), "
"[#3246](https://github.com/adap/flower/pull/3246), "
"[#3224](https://github.com/adap/flower/pull/3224), "
"[#3475](https://github.com/adap/flower/pull/3475), "
"[#3297](https://github.com/adap/flower/pull/3297), "
"[#3317](https://github.com/adap/flower/pull/3317), "
"[#3429](https://github.com/adap/flower/pull/3429), "
"[#3196](https://github.com/adap/flower/pull/3196), "
"[#3534](https://github.com/adap/flower/pull/3534), "
"[#3240](https://github.com/adap/flower/pull/3240), "
"[#3365](https://github.com/adap/flower/pull/3365), "
"[#3407](https://github.com/adap/flower/pull/3407), "
"[#3563](https://github.com/adap/flower/pull/3563), "
"[#3344](https://github.com/adap/flower/pull/3344), "
"[#3330](https://github.com/adap/flower/pull/3330), "
"[#3436](https://github.com/adap/flower/pull/3436), "
"[#3300](https://github.com/adap/flower/pull/3300), "
"[#3327](https://github.com/adap/flower/pull/3327), "
"[#3254](https://github.com/adap/flower/pull/3254), "
"[#3253](https://github.com/adap/flower/pull/3253), "
"[#3419](https://github.com/adap/flower/pull/3419), "
"[#3289](https://github.com/adap/flower/pull/3289), "
"[#3208](https://github.com/adap/flower/pull/3208), "
"[#3245](https://github.com/adap/flower/pull/3245), "
"[#3319](https://github.com/adap/flower/pull/3319), "
"[#3203](https://github.com/adap/flower/pull/3203), "
"[#3423](https://github.com/adap/flower/pull/3423), "
"[#3352](https://github.com/adap/flower/pull/3352), "
"[#3292](https://github.com/adap/flower/pull/3292), "
"[#3261](https://github.com/adap/flower/pull/3261))"
msgstr ""

#: ../../source/ref-changelog.md:1256
msgid "**Deprecate Python 3.8 support**"
msgstr ""

#: ../../source/ref-changelog.md:1258
msgid ""
"Python 3.8 will stop receiving security fixes in [October "
"2024](https://devguide.python.org/versions/). Support for Python 3.8 is "
"now deprecated and will be removed in an upcoming release."
msgstr ""

#: ../../source/ref-changelog.md:1260
msgid ""
"**Deprecate (experimental)** `flower-driver-api` **and** `flower-fleet-"
"api` ([#3416](https://github.com/adap/flower/pull/3416), "
"[#3420](https://github.com/adap/flower/pull/3420))"
msgstr ""

#: ../../source/ref-changelog.md:1262
msgid ""
"Flower 1.9 deprecates the two (experimental) commands `flower-driver-api`"
" and `flower-fleet-api`. Both commands will be removed in an upcoming "
"release. Use `flower-superlink` instead."
msgstr ""

#: ../../source/ref-changelog.md:1264
msgid ""
"**Deprecate** `--server` **in favor of** `--superlink` "
"([#3518](https://github.com/adap/flower/pull/3518))"
msgstr ""

#: ../../source/ref-changelog.md:1266
msgid ""
"The commands `flower-server-app` and `flower-client-app` should use "
"`--superlink` instead of the now deprecated `--server`. Support for "
"`--server` will be removed in a future release."
msgstr ""

#: ../../source/ref-changelog.md:1270
msgid ""
"**Replace** `flower-superlink` **CLI option** `--certificates` **with** "
"`--ssl-ca-certfile` **,** `--ssl-certfile` **and** `--ssl-keyfile` "
"([#3512](https://github.com/adap/flower/pull/3512), "
"[#3408](https://github.com/adap/flower/pull/3408))"
msgstr ""

#: ../../source/ref-changelog.md:1272
msgid ""
"SSL-related `flower-superlink` CLI arguments were restructured in an "
"incompatible way. Instead of passing a single `--certificates` flag with "
"three values, you now need to pass three flags (`--ssl-ca-certfile`, "
"`--ssl-certfile` and `--ssl-keyfile`) with one value each. Check out the "
"[SSL connections](https://flower.ai/docs/framework/how-to-enable-ssl-"
"connections.html) documentation page for details."
msgstr ""

#: ../../source/ref-changelog.md:1274
msgid ""
"**Remove SuperLink** `--vce` **option** "
"([#3513](https://github.com/adap/flower/pull/3513))"
msgstr ""

#: ../../source/ref-changelog.md:1276
msgid ""
"Instead of separately starting a SuperLink and a `ServerApp` for "
"simulation, simulations must now be started using the single `flower-"
"simulation` command."
msgstr ""

#: ../../source/ref-changelog.md:1278
msgid ""
"**Merge** `--grpc-rere` **and** `--rest` **SuperLink options** "
"([#3527](https://github.com/adap/flower/pull/3527))"
msgstr ""

#: ../../source/ref-changelog.md:1280
msgid ""
"To simplify the usage of `flower-superlink`, previously separate sets of "
"CLI options for gRPC and REST were merged into one unified set of "
"options. Consult the [Flower CLI reference "
"documentation](https://flower.ai/docs/framework/ref-api-cli.html) for "
"details."
msgstr ""

#: ../../source/ref-changelog.md:1282
msgid "v1.8.0 (2024-04-03)"
msgstr ""

#: ../../source/ref-changelog.md:1288
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Daniel J. Beutel`, `Daniel Nata "
"Nugraha`, `Danny`, `Gustavo Bertoli`, `Heng Pan`, `Ikko Eltociear "
"Ashimine`, `Jack Cook`, `Javier`, `Raj Parekh`, `Robert Steiner`, "
"`Sebastian van der Voort`, `Taner Topal`, `Yan Gao`, `mohammadnaseri`, "
"`tabdar-khan` <!---TOKEN_v1.8.0-->"
msgstr ""

#: ../../source/ref-changelog.md:1292
msgid ""
"**Introduce Flower Next high-level API (stable)** "
"([#3002](https://github.com/adap/flower/pull/3002), "
"[#2934](https://github.com/adap/flower/pull/2934), "
"[#2958](https://github.com/adap/flower/pull/2958), "
"[#3173](https://github.com/adap/flower/pull/3173), "
"[#3174](https://github.com/adap/flower/pull/3174), "
"[#2923](https://github.com/adap/flower/pull/2923), "
"[#2691](https://github.com/adap/flower/pull/2691), "
"[#3079](https://github.com/adap/flower/pull/3079), "
"[#2961](https://github.com/adap/flower/pull/2961), "
"[#2924](https://github.com/adap/flower/pull/2924), "
"[#3166](https://github.com/adap/flower/pull/3166), "
"[#3031](https://github.com/adap/flower/pull/3031), "
"[#3057](https://github.com/adap/flower/pull/3057), "
"[#3000](https://github.com/adap/flower/pull/3000), "
"[#3113](https://github.com/adap/flower/pull/3113), "
"[#2957](https://github.com/adap/flower/pull/2957), "
"[#3183](https://github.com/adap/flower/pull/3183), "
"[#3180](https://github.com/adap/flower/pull/3180), "
"[#3035](https://github.com/adap/flower/pull/3035), "
"[#3189](https://github.com/adap/flower/pull/3189), "
"[#3185](https://github.com/adap/flower/pull/3185), "
"[#3190](https://github.com/adap/flower/pull/3190), "
"[#3191](https://github.com/adap/flower/pull/3191), "
"[#3195](https://github.com/adap/flower/pull/3195), "
"[#3197](https://github.com/adap/flower/pull/3197))"
msgstr ""

#: ../../source/ref-changelog.md:1294
msgid ""
"The Flower Next high-level API is stable! Flower Next is the future of "
"Flower - all new features (like Flower Mods) will be built on top of it. "
"You can start to migrate your existing projects to Flower Next by using "
"`ServerApp` and `ClientApp` (check out `quickstart-pytorch` or "
"`quickstart-tensorflow`, a detailed migration guide will follow shortly)."
" Flower Next allows you to run multiple projects concurrently (we call "
"this multi-run) and execute the same project in either simulation "
"environments or deployment environments without having to change a single"
" line of code. The best part? It's fully compatible with existing Flower "
"projects that use `Strategy`, `NumPyClient` & co."
msgstr ""

#: ../../source/ref-changelog.md:1296
msgid ""
"**Introduce Flower Next low-level API (preview)** "
"([#3062](https://github.com/adap/flower/pull/3062), "
"[#3034](https://github.com/adap/flower/pull/3034), "
"[#3069](https://github.com/adap/flower/pull/3069))"
msgstr ""

#: ../../source/ref-changelog.md:1298
msgid ""
"In addition to the Flower Next *high-level* API that uses `Strategy`, "
"`NumPyClient` & co, Flower 1.8 also comes with a preview version of the "
"new Flower Next *low-level* API. The low-level API allows for granular "
"control of every aspect of the learning process by sending/receiving "
"individual messages to/from client nodes. The new `ServerApp` supports "
"registering a custom `main` function that allows writing custom training "
"loops for methods like async FL, cyclic training, or federated analytics."
" The new `ClientApp` supports registering `train`, `evaluate` and `query`"
" functions that can access the raw message received from the `ServerApp`."
" New abstractions like `RecordSet`, `Message` and `Context` further "
"enable sending multiple models, multiple sets of config values and "
"metrics, stateful computations on the client node and implementations of "
"custom SMPC protocols, to name just a few."
msgstr ""

#: ../../source/ref-changelog.md:1300
msgid ""
"**Introduce Flower Mods (preview)** "
"([#3054](https://github.com/adap/flower/pull/3054), "
"[#2911](https://github.com/adap/flower/pull/2911), "
"[#3083](https://github.com/adap/flower/pull/3083))"
msgstr ""

#: ../../source/ref-changelog.md:1302
msgid ""
"Flower Modifiers (we call them Mods) can intercept messages and analyze, "
"edit or handle them directly. Mods can be used to develop pluggable "
"modules that work across different projects. Flower 1.8 already includes "
"mods to log the size of a message, the number of parameters sent over the"
" network, differential privacy with fixed clipping and adaptive clipping,"
" local differential privacy and secure aggregation protocols SecAgg and "
"SecAgg+. The Flower Mods API is released as a preview, but researchers "
"can already use it to experiment with arbirtrary SMPC protocols."
msgstr ""

#: ../../source/ref-changelog.md:1304
msgid ""
"**Fine-tune LLMs with LLM FlowerTune** "
"([#3029](https://github.com/adap/flower/pull/3029), "
"[#3089](https://github.com/adap/flower/pull/3089), "
"[#3092](https://github.com/adap/flower/pull/3092), "
"[#3100](https://github.com/adap/flower/pull/3100), "
"[#3114](https://github.com/adap/flower/pull/3114), "
"[#3162](https://github.com/adap/flower/pull/3162), "
"[#3172](https://github.com/adap/flower/pull/3172))"
msgstr ""

#: ../../source/ref-changelog.md:1306
msgid ""
"We are introducing LLM FlowerTune, an introductory example that "
"demonstrates federated LLM fine-tuning of pre-trained Llama2 models on "
"the Alpaca-GPT4 dataset. The example is built to be easily adapted to use"
" different models and/or datasets. Read our blog post [LLM FlowerTune: "
"Federated LLM Fine-tuning with Flower](https://flower.ai/blog/2024-03-14"
"-llm-flowertune-federated-llm-finetuning-with-flower/) for more details."
msgstr ""

#: ../../source/ref-changelog.md:1308
msgid ""
"**Introduce built-in Differential Privacy (preview)** "
"([#2798](https://github.com/adap/flower/pull/2798), "
"[#2959](https://github.com/adap/flower/pull/2959), "
"[#3038](https://github.com/adap/flower/pull/3038), "
"[#3147](https://github.com/adap/flower/pull/3147), "
"[#2909](https://github.com/adap/flower/pull/2909), "
"[#2893](https://github.com/adap/flower/pull/2893), "
"[#2892](https://github.com/adap/flower/pull/2892), "
"[#3039](https://github.com/adap/flower/pull/3039), "
"[#3074](https://github.com/adap/flower/pull/3074))"
msgstr ""

#: ../../source/ref-changelog.md:1310
msgid ""
"Built-in Differential Privacy is here! Flower supports both central and "
"local differential privacy (DP). Central DP can be configured with either"
" fixed or adaptive clipping. The clipping can happen either on the "
"server-side or the client-side. Local DP does both clipping and noising "
"on the client-side. A new documentation page [explains Differential "
"Privacy approaches](https://flower.ai/docs/framework/explanation-"
"differential-privacy.html) and a new how-to guide describes [how to use "
"the new Differential Privacy components](https://flower.ai/docs/framework"
"/how-to-use-differential-privacy.html) in Flower."
msgstr ""

#: ../../source/ref-changelog.md:1312
msgid ""
"**Introduce built-in Secure Aggregation (preview)** "
"([#3120](https://github.com/adap/flower/pull/3120), "
"[#3110](https://github.com/adap/flower/pull/3110), "
"[#3108](https://github.com/adap/flower/pull/3108))"
msgstr ""

#: ../../source/ref-changelog.md:1314
msgid ""
"Built-in Secure Aggregation is here! Flower now supports different secure"
" aggregation protocols out-of-the-box. The best part? You can add secure "
"aggregation to your Flower projects with only a few lines of code. In "
"this initial release, we inlcude support for SecAgg and SecAgg+, but more"
" protocols will be implemented shortly. We'll also add detailed docs that"
" explain secure aggregation and how to use it in Flower. You can already "
"check out the new code example that shows how to use Flower to easily "
"combine Federated Learning, Differential Privacy and Secure Aggregation "
"in the same project."
msgstr ""

#: ../../source/ref-changelog.md:1316
msgid ""
"**Introduce** `flwr` **CLI (preview)** "
"([#2942](https://github.com/adap/flower/pull/2942), "
"[#3055](https://github.com/adap/flower/pull/3055), "
"[#3111](https://github.com/adap/flower/pull/3111), "
"[#3130](https://github.com/adap/flower/pull/3130), "
"[#3136](https://github.com/adap/flower/pull/3136), "
"[#3094](https://github.com/adap/flower/pull/3094), "
"[#3059](https://github.com/adap/flower/pull/3059), "
"[#3049](https://github.com/adap/flower/pull/3049), "
"[#3142](https://github.com/adap/flower/pull/3142))"
msgstr ""

#: ../../source/ref-changelog.md:1318
msgid ""
"A new `flwr` CLI command allows creating new Flower projects (`flwr new`)"
" and then running them using the Simulation Engine (`flwr run`)."
msgstr ""

#: ../../source/ref-changelog.md:1320
msgid ""
"**Introduce Flower Next Simulation Engine** "
"([#3024](https://github.com/adap/flower/pull/3024), "
"[#3061](https://github.com/adap/flower/pull/3061), "
"[#2997](https://github.com/adap/flower/pull/2997), "
"[#2783](https://github.com/adap/flower/pull/2783), "
"[#3184](https://github.com/adap/flower/pull/3184), "
"[#3075](https://github.com/adap/flower/pull/3075), "
"[#3047](https://github.com/adap/flower/pull/3047), "
"[#2998](https://github.com/adap/flower/pull/2998), "
"[#3009](https://github.com/adap/flower/pull/3009), "
"[#3008](https://github.com/adap/flower/pull/3008))"
msgstr ""

#: ../../source/ref-changelog.md:1322
msgid ""
"The Flower Simulation Engine can now run Flower Next projects. For "
"notebook environments, there's also a new `run_simulation` function that "
"can run `ServerApp` and `ClientApp`."
msgstr ""

#: ../../source/ref-changelog.md:1324
msgid ""
"**Handle SuperNode connection errors** "
"([#2969](https://github.com/adap/flower/pull/2969))"
msgstr ""

#: ../../source/ref-changelog.md:1326
msgid ""
"A SuperNode will now try to reconnect indefinitely to the SuperLink in "
"case of connection errors. The arguments `--max-retries` and `--max-wait-"
"time` can now be passed to the `flower-client-app` command. `--max-"
"retries` will define the number of tentatives the client should make "
"before it gives up trying to reconnect to the SuperLink, and, `--max-"
"wait-time` defines the time before the SuperNode gives up trying to "
"reconnect to the SuperLink."
msgstr ""

#: ../../source/ref-changelog.md:1328
msgid ""
"**General updates to Flower Baselines** "
"([#2904](https://github.com/adap/flower/pull/2904), "
"[#2482](https://github.com/adap/flower/pull/2482), "
"[#2985](https://github.com/adap/flower/pull/2985), "
"[#2968](https://github.com/adap/flower/pull/2968))"
msgstr ""

#: ../../source/ref-changelog.md:1330
msgid ""
"There's a new [FedStar](https://flower.ai/docs/baselines/fedstar.html) "
"baseline. Several other baselined have been updated as well."
msgstr ""

#: ../../source/ref-changelog.md:1332
msgid ""
"**Improve documentation and translations** "
"([#3050](https://github.com/adap/flower/pull/3050), "
"[#3044](https://github.com/adap/flower/pull/3044), "
"[#3043](https://github.com/adap/flower/pull/3043), "
"[#2986](https://github.com/adap/flower/pull/2986), "
"[#3041](https://github.com/adap/flower/pull/3041), "
"[#3046](https://github.com/adap/flower/pull/3046), "
"[#3042](https://github.com/adap/flower/pull/3042), "
"[#2978](https://github.com/adap/flower/pull/2978), "
"[#2952](https://github.com/adap/flower/pull/2952), "
"[#3167](https://github.com/adap/flower/pull/3167), "
"[#2953](https://github.com/adap/flower/pull/2953), "
"[#3045](https://github.com/adap/flower/pull/3045), "
"[#2654](https://github.com/adap/flower/pull/2654), "
"[#3082](https://github.com/adap/flower/pull/3082), "
"[#2990](https://github.com/adap/flower/pull/2990), "
"[#2989](https://github.com/adap/flower/pull/2989))"
msgstr ""

#: ../../source/ref-changelog.md:1334
msgid ""
"As usual, we merged many smaller and larger improvements to the "
"documentation. A special thank you goes to [Sebastian van der "
"Voort](https://github.com/svdvoort) for landing a big documentation PR!"
msgstr ""

#: ../../source/ref-changelog.md:1336
msgid ""
"**General updates to Flower Examples** "
"([3134](https://github.com/adap/flower/pull/3134), "
"[2996](https://github.com/adap/flower/pull/2996), "
"[2930](https://github.com/adap/flower/pull/2930), "
"[2967](https://github.com/adap/flower/pull/2967), "
"[2467](https://github.com/adap/flower/pull/2467), "
"[2910](https://github.com/adap/flower/pull/2910), "
"[#2918](https://github.com/adap/flower/pull/2918), "
"[#2773](https://github.com/adap/flower/pull/2773), "
"[#3063](https://github.com/adap/flower/pull/3063), "
"[#3116](https://github.com/adap/flower/pull/3116), "
"[#3117](https://github.com/adap/flower/pull/3117))"
msgstr ""

#: ../../source/ref-changelog.md:1338
msgid ""
"Two new examples show federated training of a Vision Transformer (ViT) "
"and federated learning in a medical context using the popular MONAI "
"library. `quickstart-pytorch` and `quickstart-tensorflow` demonstrate the"
" new Flower Next `ServerApp` and `ClientApp`. Many other examples "
"received considerable updates as well."
msgstr ""

#: ../../source/ref-changelog.md:1340
msgid ""
"**General improvements** "
"([#3171](https://github.com/adap/flower/pull/3171), "
"[3099](https://github.com/adap/flower/pull/3099), "
"[3003](https://github.com/adap/flower/pull/3003), "
"[3145](https://github.com/adap/flower/pull/3145), "
"[3017](https://github.com/adap/flower/pull/3017), "
"[3085](https://github.com/adap/flower/pull/3085), "
"[3012](https://github.com/adap/flower/pull/3012), "
"[3119](https://github.com/adap/flower/pull/3119), "
"[2991](https://github.com/adap/flower/pull/2991), "
"[2970](https://github.com/adap/flower/pull/2970), "
"[2980](https://github.com/adap/flower/pull/2980), "
"[3086](https://github.com/adap/flower/pull/3086), "
"[2932](https://github.com/adap/flower/pull/2932), "
"[2928](https://github.com/adap/flower/pull/2928), "
"[2941](https://github.com/adap/flower/pull/2941), "
"[2933](https://github.com/adap/flower/pull/2933), "
"[3181](https://github.com/adap/flower/pull/3181), "
"[2973](https://github.com/adap/flower/pull/2973), "
"[2992](https://github.com/adap/flower/pull/2992), "
"[2915](https://github.com/adap/flower/pull/2915), "
"[3040](https://github.com/adap/flower/pull/3040), "
"[3022](https://github.com/adap/flower/pull/3022), "
"[3032](https://github.com/adap/flower/pull/3032), "
"[2902](https://github.com/adap/flower/pull/2902), "
"[2931](https://github.com/adap/flower/pull/2931), "
"[3005](https://github.com/adap/flower/pull/3005), "
"[3132](https://github.com/adap/flower/pull/3132), "
"[3115](https://github.com/adap/flower/pull/3115), "
"[2944](https://github.com/adap/flower/pull/2944), "
"[3064](https://github.com/adap/flower/pull/3064), "
"[3106](https://github.com/adap/flower/pull/3106), "
"[2974](https://github.com/adap/flower/pull/2974), "
"[3178](https://github.com/adap/flower/pull/3178), "
"[2993](https://github.com/adap/flower/pull/2993), "
"[3186](https://github.com/adap/flower/pull/3186), "
"[3091](https://github.com/adap/flower/pull/3091), "
"[3125](https://github.com/adap/flower/pull/3125), "
"[3093](https://github.com/adap/flower/pull/3093), "
"[3013](https://github.com/adap/flower/pull/3013), "
"[3033](https://github.com/adap/flower/pull/3033), "
"[3133](https://github.com/adap/flower/pull/3133), "
"[3068](https://github.com/adap/flower/pull/3068), "
"[2916](https://github.com/adap/flower/pull/2916), "
"[2975](https://github.com/adap/flower/pull/2975), "
"[2984](https://github.com/adap/flower/pull/2984), "
"[2846](https://github.com/adap/flower/pull/2846), "
"[3077](https://github.com/adap/flower/pull/3077), "
"[3143](https://github.com/adap/flower/pull/3143), "
"[2921](https://github.com/adap/flower/pull/2921), "
"[3101](https://github.com/adap/flower/pull/3101), "
"[2927](https://github.com/adap/flower/pull/2927), "
"[2995](https://github.com/adap/flower/pull/2995), "
"[2972](https://github.com/adap/flower/pull/2972), "
"[2912](https://github.com/adap/flower/pull/2912), "
"[3065](https://github.com/adap/flower/pull/3065), "
"[3028](https://github.com/adap/flower/pull/3028), "
"[2922](https://github.com/adap/flower/pull/2922), "
"[2982](https://github.com/adap/flower/pull/2982), "
"[2914](https://github.com/adap/flower/pull/2914), "
"[3179](https://github.com/adap/flower/pull/3179), "
"[3080](https://github.com/adap/flower/pull/3080), "
"[2994](https://github.com/adap/flower/pull/2994), "
"[3187](https://github.com/adap/flower/pull/3187), "
"[2926](https://github.com/adap/flower/pull/2926), "
"[3018](https://github.com/adap/flower/pull/3018), "
"[3144](https://github.com/adap/flower/pull/3144), "
"[3011](https://github.com/adap/flower/pull/3011), "
"[#3152](https://github.com/adap/flower/pull/3152), "
"[#2836](https://github.com/adap/flower/pull/2836), "
"[#2929](https://github.com/adap/flower/pull/2929), "
"[#2943](https://github.com/adap/flower/pull/2943), "
"[#2955](https://github.com/adap/flower/pull/2955), "
"[#2954](https://github.com/adap/flower/pull/2954))"
msgstr ""

#: ../../source/ref-changelog.md:1346
msgid "v1.7.0 (2024-02-05)"
msgstr ""

#: ../../source/ref-changelog.md:1352
msgid ""
"`Aasheesh Singh`, `Adam Narozniak`, `Aml Hassan Esmil`, `Charles "
"Beauville`, `Daniel J. Beutel`, `Daniel Nata Nugraha`, `Edoardo "
"Gabrielli`, `Gustavo Bertoli`, `HelinLin`, `Heng Pan`, `Javier`, `M S "
"Chaitanya Kumar`, `Mohammad Naseri`, `Nikos Vlachakis`, `Pritam Neog`, "
"`Robert Kuska`, `Robert Steiner`, `Taner Topal`, `Yahia Salaheldin "
"Shaaban`, `Yan Gao`, `Yasar Abbas` <!---TOKEN_v1.7.0-->"
msgstr ""

#: ../../source/ref-changelog.md:1356
msgid ""
"**Introduce stateful clients (experimental)** "
"([#2770](https://github.com/adap/flower/pull/2770), "
"[#2686](https://github.com/adap/flower/pull/2686), "
"[#2696](https://github.com/adap/flower/pull/2696), "
"[#2643](https://github.com/adap/flower/pull/2643), "
"[#2769](https://github.com/adap/flower/pull/2769))"
msgstr ""

#: ../../source/ref-changelog.md:1358
msgid ""
"Subclasses of `Client` and `NumPyClient` can now store local state that "
"remains on the client. Let's start with the highlight first: this new "
"feature is compatible with both simulated clients (via "
"`start_simulation`) and networked clients (via `start_client`). It's also"
" the first preview of new abstractions like `Context` and `RecordSet`. "
"Clients can access state of type `RecordSet` via `state: RecordSet = "
"self.context.state`. Changes to this `RecordSet` are preserved across "
"different rounds of execution to enable stateful computations in a "
"unified way across simulation and deployment."
msgstr ""

#: ../../source/ref-changelog.md:1360
msgid ""
"**Improve performance** "
"([#2293](https://github.com/adap/flower/pull/2293))"
msgstr ""

#: ../../source/ref-changelog.md:1362
msgid ""
"Flower is faster than ever. All `FedAvg`-derived strategies now use in-"
"place aggregation to reduce memory consumption. The Flower client "
"serialization/deserialization has been rewritten from the ground up, "
"which results in significant speedups, especially when the client-side "
"training time is short."
msgstr ""

#: ../../source/ref-changelog.md:1364
msgid ""
"**Support Federated Learning with Apple MLX and Flower** "
"([#2693](https://github.com/adap/flower/pull/2693))"
msgstr ""

#: ../../source/ref-changelog.md:1366
msgid ""
"Flower has official support for federated learning using [Apple "
"MLX](https://ml-explore.github.io/mlx) via the new `quickstart-mlx` code "
"example."
msgstr ""

#: ../../source/ref-changelog.md:1368
msgid ""
"**Introduce new XGBoost cyclic strategy** "
"([#2666](https://github.com/adap/flower/pull/2666), "
"[#2668](https://github.com/adap/flower/pull/2668))"
msgstr ""

#: ../../source/ref-changelog.md:1370
msgid ""
"A new strategy called `FedXgbCyclic` supports a client-by-client style of"
" training (often called cyclic). The `xgboost-comprehensive` code example"
" shows how to use it in a full project. In addition to that, `xgboost-"
"comprehensive` now also supports simulation mode. With this, Flower "
"offers best-in-class XGBoost support."
msgstr ""

#: ../../source/ref-changelog.md:1372
msgid ""
"**Support Python 3.11** "
"([#2394](https://github.com/adap/flower/pull/2394))"
msgstr ""

#: ../../source/ref-changelog.md:1374
msgid ""
"Framework tests now run on Python 3.8, 3.9, 3.10, and 3.11. This will "
"ensure better support for users using more recent Python versions."
msgstr ""

#: ../../source/ref-changelog.md:1376
msgid ""
"**Update gRPC and ProtoBuf dependencies** "
"([#2814](https://github.com/adap/flower/pull/2814))"
msgstr ""

#: ../../source/ref-changelog.md:1378
msgid ""
"The `grpcio` and `protobuf` dependencies were updated to their latest "
"versions for improved security and performance."
msgstr ""

#: ../../source/ref-changelog.md:1380
msgid ""
"**Introduce Docker image for Flower server** "
"([#2700](https://github.com/adap/flower/pull/2700), "
"[#2688](https://github.com/adap/flower/pull/2688), "
"[#2705](https://github.com/adap/flower/pull/2705), "
"[#2695](https://github.com/adap/flower/pull/2695), "
"[#2747](https://github.com/adap/flower/pull/2747), "
"[#2746](https://github.com/adap/flower/pull/2746), "
"[#2680](https://github.com/adap/flower/pull/2680), "
"[#2682](https://github.com/adap/flower/pull/2682), "
"[#2701](https://github.com/adap/flower/pull/2701))"
msgstr ""

#: ../../source/ref-changelog.md:1382
msgid ""
"The Flower server can now be run using an official Docker image. A new "
"how-to guide explains [how to run Flower using "
"Docker](https://flower.ai/docs/framework/how-to-run-flower-using-"
"docker.html). An official Flower client Docker image will follow."
msgstr ""

#: ../../source/ref-changelog.md:1384
msgid ""
"**Introduce** `flower-via-docker-compose` **example** "
"([#2626](https://github.com/adap/flower/pull/2626))"
msgstr ""

#: ../../source/ref-changelog.md:1386
msgid ""
"**Introduce** `quickstart-sklearn-tabular` **example** "
"([#2719](https://github.com/adap/flower/pull/2719))"
msgstr ""

#: ../../source/ref-changelog.md:1388
msgid ""
"**Introduce** `custom-metrics` **example** "
"([#1958](https://github.com/adap/flower/pull/1958))"
msgstr ""

#: ../../source/ref-changelog.md:1390
msgid ""
"**Update code examples to use Flower Datasets** "
"([#2450](https://github.com/adap/flower/pull/2450), "
"[#2456](https://github.com/adap/flower/pull/2456), "
"[#2318](https://github.com/adap/flower/pull/2318), "
"[#2712](https://github.com/adap/flower/pull/2712))"
msgstr ""

#: ../../source/ref-changelog.md:1392
msgid ""
"Several code examples were updated to use [Flower "
"Datasets](https://flower.ai/docs/datasets/)."
msgstr ""

#: ../../source/ref-changelog.md:1394
msgid ""
"**General updates to Flower Examples** "
"([#2381](https://github.com/adap/flower/pull/2381), "
"[#2805](https://github.com/adap/flower/pull/2805), "
"[#2782](https://github.com/adap/flower/pull/2782), "
"[#2806](https://github.com/adap/flower/pull/2806), "
"[#2829](https://github.com/adap/flower/pull/2829), "
"[#2825](https://github.com/adap/flower/pull/2825), "
"[#2816](https://github.com/adap/flower/pull/2816), "
"[#2726](https://github.com/adap/flower/pull/2726), "
"[#2659](https://github.com/adap/flower/pull/2659), "
"[#2655](https://github.com/adap/flower/pull/2655))"
msgstr ""

#: ../../source/ref-changelog.md:1396
msgid "Many Flower code examples received substantial updates."
msgstr ""

#: ../../source/ref-changelog.md:1398 ../../source/ref-changelog.md:1489
msgid "**Update Flower Baselines**"
msgstr ""

#: ../../source/ref-changelog.md:1400
msgid ""
"HFedXGBoost ([#2226](https://github.com/adap/flower/pull/2226), "
"[#2771](https://github.com/adap/flower/pull/2771))"
msgstr ""

#: ../../source/ref-changelog.md:1401
msgid "FedVSSL ([#2412](https://github.com/adap/flower/pull/2412))"
msgstr ""

#: ../../source/ref-changelog.md:1402
msgid "FedNova ([#2179](https://github.com/adap/flower/pull/2179))"
msgstr ""

#: ../../source/ref-changelog.md:1403
msgid "HeteroFL ([#2439](https://github.com/adap/flower/pull/2439))"
msgstr ""

#: ../../source/ref-changelog.md:1404
msgid "FedAvgM ([#2246](https://github.com/adap/flower/pull/2246))"
msgstr ""

#: ../../source/ref-changelog.md:1405
msgid "FedPara ([#2722](https://github.com/adap/flower/pull/2722))"
msgstr ""

#: ../../source/ref-changelog.md:1407
msgid ""
"**Improve documentation** "
"([#2674](https://github.com/adap/flower/pull/2674), "
"[#2480](https://github.com/adap/flower/pull/2480), "
"[#2826](https://github.com/adap/flower/pull/2826), "
"[#2727](https://github.com/adap/flower/pull/2727), "
"[#2761](https://github.com/adap/flower/pull/2761), "
"[#2900](https://github.com/adap/flower/pull/2900))"
msgstr ""

#: ../../source/ref-changelog.md:1409
msgid ""
"**Improved testing and development infrastructure** "
"([#2797](https://github.com/adap/flower/pull/2797), "
"[#2676](https://github.com/adap/flower/pull/2676), "
"[#2644](https://github.com/adap/flower/pull/2644), "
"[#2656](https://github.com/adap/flower/pull/2656), "
"[#2848](https://github.com/adap/flower/pull/2848), "
"[#2675](https://github.com/adap/flower/pull/2675), "
"[#2735](https://github.com/adap/flower/pull/2735), "
"[#2767](https://github.com/adap/flower/pull/2767), "
"[#2732](https://github.com/adap/flower/pull/2732), "
"[#2744](https://github.com/adap/flower/pull/2744), "
"[#2681](https://github.com/adap/flower/pull/2681), "
"[#2699](https://github.com/adap/flower/pull/2699), "
"[#2745](https://github.com/adap/flower/pull/2745), "
"[#2734](https://github.com/adap/flower/pull/2734), "
"[#2731](https://github.com/adap/flower/pull/2731), "
"[#2652](https://github.com/adap/flower/pull/2652), "
"[#2720](https://github.com/adap/flower/pull/2720), "
"[#2721](https://github.com/adap/flower/pull/2721), "
"[#2717](https://github.com/adap/flower/pull/2717), "
"[#2864](https://github.com/adap/flower/pull/2864), "
"[#2694](https://github.com/adap/flower/pull/2694), "
"[#2709](https://github.com/adap/flower/pull/2709), "
"[#2658](https://github.com/adap/flower/pull/2658), "
"[#2796](https://github.com/adap/flower/pull/2796), "
"[#2692](https://github.com/adap/flower/pull/2692), "
"[#2657](https://github.com/adap/flower/pull/2657), "
"[#2813](https://github.com/adap/flower/pull/2813), "
"[#2661](https://github.com/adap/flower/pull/2661), "
"[#2398](https://github.com/adap/flower/pull/2398))"
msgstr ""

#: ../../source/ref-changelog.md:1411
msgid ""
"The Flower testing and development infrastructure has received "
"substantial updates. This makes Flower 1.7 the most tested release ever."
msgstr ""

#: ../../source/ref-changelog.md:1413
msgid ""
"**Update dependencies** "
"([#2753](https://github.com/adap/flower/pull/2753), "
"[#2651](https://github.com/adap/flower/pull/2651), "
"[#2739](https://github.com/adap/flower/pull/2739), "
"[#2837](https://github.com/adap/flower/pull/2837), "
"[#2788](https://github.com/adap/flower/pull/2788), "
"[#2811](https://github.com/adap/flower/pull/2811), "
"[#2774](https://github.com/adap/flower/pull/2774), "
"[#2790](https://github.com/adap/flower/pull/2790), "
"[#2751](https://github.com/adap/flower/pull/2751), "
"[#2850](https://github.com/adap/flower/pull/2850), "
"[#2812](https://github.com/adap/flower/pull/2812), "
"[#2872](https://github.com/adap/flower/pull/2872), "
"[#2736](https://github.com/adap/flower/pull/2736), "
"[#2756](https://github.com/adap/flower/pull/2756), "
"[#2857](https://github.com/adap/flower/pull/2857), "
"[#2757](https://github.com/adap/flower/pull/2757), "
"[#2810](https://github.com/adap/flower/pull/2810), "
"[#2740](https://github.com/adap/flower/pull/2740), "
"[#2789](https://github.com/adap/flower/pull/2789))"
msgstr ""

#: ../../source/ref-changelog.md:1415
msgid ""
"**General improvements** "
"([#2803](https://github.com/adap/flower/pull/2803), "
"[#2847](https://github.com/adap/flower/pull/2847), "
"[#2877](https://github.com/adap/flower/pull/2877), "
"[#2690](https://github.com/adap/flower/pull/2690), "
"[#2889](https://github.com/adap/flower/pull/2889), "
"[#2874](https://github.com/adap/flower/pull/2874), "
"[#2819](https://github.com/adap/flower/pull/2819), "
"[#2689](https://github.com/adap/flower/pull/2689), "
"[#2457](https://github.com/adap/flower/pull/2457), "
"[#2870](https://github.com/adap/flower/pull/2870), "
"[#2669](https://github.com/adap/flower/pull/2669), "
"[#2876](https://github.com/adap/flower/pull/2876), "
"[#2885](https://github.com/adap/flower/pull/2885), "
"[#2858](https://github.com/adap/flower/pull/2858), "
"[#2867](https://github.com/adap/flower/pull/2867), "
"[#2351](https://github.com/adap/flower/pull/2351), "
"[#2886](https://github.com/adap/flower/pull/2886), "
"[#2860](https://github.com/adap/flower/pull/2860), "
"[#2828](https://github.com/adap/flower/pull/2828), "
"[#2869](https://github.com/adap/flower/pull/2869), "
"[#2875](https://github.com/adap/flower/pull/2875), "
"[#2733](https://github.com/adap/flower/pull/2733), "
"[#2488](https://github.com/adap/flower/pull/2488), "
"[#2646](https://github.com/adap/flower/pull/2646), "
"[#2879](https://github.com/adap/flower/pull/2879), "
"[#2821](https://github.com/adap/flower/pull/2821), "
"[#2855](https://github.com/adap/flower/pull/2855), "
"[#2800](https://github.com/adap/flower/pull/2800), "
"[#2807](https://github.com/adap/flower/pull/2807), "
"[#2801](https://github.com/adap/flower/pull/2801), "
"[#2804](https://github.com/adap/flower/pull/2804), "
"[#2851](https://github.com/adap/flower/pull/2851), "
"[#2787](https://github.com/adap/flower/pull/2787), "
"[#2852](https://github.com/adap/flower/pull/2852), "
"[#2672](https://github.com/adap/flower/pull/2672), "
"[#2759](https://github.com/adap/flower/pull/2759))"
msgstr ""

#: ../../source/ref-changelog.md:1419
msgid ""
"**Deprecate** `start_numpy_client` "
"([#2563](https://github.com/adap/flower/pull/2563), "
"[#2718](https://github.com/adap/flower/pull/2718))"
msgstr ""

#: ../../source/ref-changelog.md:1421
msgid ""
"Until now, clients of type `NumPyClient` needed to be started via "
"`start_numpy_client`. In our efforts to consolidate framework APIs, we "
"have introduced changes, and now all client types should start via "
"`start_client`. To continue using `NumPyClient` clients, you simply need "
"to first call the `.to_client()` method and then pass returned `Client` "
"object to `start_client`. The examples and the documentation have been "
"updated accordingly."
msgstr ""

#: ../../source/ref-changelog.md:1423
msgid ""
"**Deprecate legacy DP wrappers** "
"([#2749](https://github.com/adap/flower/pull/2749))"
msgstr ""

#: ../../source/ref-changelog.md:1425
msgid ""
"Legacy DP wrapper classes are deprecated, but still functional. This is "
"in preparation for an all-new pluggable version of differential privacy "
"support in Flower."
msgstr ""

#: ../../source/ref-changelog.md:1427
msgid ""
"**Make optional arg** `--callable` **in** `flower-client` **a required "
"positional arg** ([#2673](https://github.com/adap/flower/pull/2673))"
msgstr ""

#: ../../source/ref-changelog.md:1429
msgid ""
"**Rename** `certificates` **to** `root_certificates` **in** `Driver` "
"([#2890](https://github.com/adap/flower/pull/2890))"
msgstr ""

#: ../../source/ref-changelog.md:1431
msgid ""
"**Drop experimental** `Task` **fields** "
"([#2866](https://github.com/adap/flower/pull/2866), "
"[#2865](https://github.com/adap/flower/pull/2865))"
msgstr ""

#: ../../source/ref-changelog.md:1433
msgid ""
"Experimental fields `sa`, `legacy_server_message` and "
"`legacy_client_message` were removed from `Task` message. The removed "
"fields are superseded by the new `RecordSet` abstraction."
msgstr ""

#: ../../source/ref-changelog.md:1435
msgid ""
"**Retire MXNet examples** "
"([#2724](https://github.com/adap/flower/pull/2724))"
msgstr ""

#: ../../source/ref-changelog.md:1437
msgid ""
"The development of the MXNet fremework has ended and the project is now "
"[archived on GitHub](https://github.com/apache/mxnet). Existing MXNet "
"examples won't receive updates."
msgstr ""

#: ../../source/ref-changelog.md:1439
msgid "v1.6.0 (2023-11-28)"
msgstr ""

#: ../../source/ref-changelog.md:1445
msgid ""
"`Aashish Kolluri`, `Adam Narozniak`, `Alessio Mora`, `Barathwaja S`, "
"`Charles Beauville`, `Daniel J. Beutel`, `Daniel Nata Nugraha`, `Gabriel "
"Mota`, `Heng Pan`, `Ivan Agarský`, `JS.KIM`, `Javier`, `Marius Schlegel`,"
" `Navin Chandra`, `Nic Lane`, `Peterpan828`, `Qinbin Li`, `Shaz-hash`, "
"`Steve Laskaridis`, `Taner Topal`, `William Lindskog`, `Yan Gao`, "
"`cnxdeveloper`, `k3nfalt` <!---TOKEN_v1.6.0-->"
msgstr ""

#: ../../source/ref-changelog.md:1449
msgid ""
"**Add experimental support for Python 3.12** "
"([#2565](https://github.com/adap/flower/pull/2565))"
msgstr ""

#: ../../source/ref-changelog.md:1451
msgid ""
"**Add new XGBoost examples** "
"([#2612](https://github.com/adap/flower/pull/2612), "
"[#2554](https://github.com/adap/flower/pull/2554), "
"[#2617](https://github.com/adap/flower/pull/2617), "
"[#2618](https://github.com/adap/flower/pull/2618), "
"[#2619](https://github.com/adap/flower/pull/2619), "
"[#2567](https://github.com/adap/flower/pull/2567))"
msgstr ""

#: ../../source/ref-changelog.md:1453
msgid ""
"We have added a new `xgboost-quickstart` example alongside a new "
"`xgboost-comprehensive` example that goes more in-depth."
msgstr ""

#: ../../source/ref-changelog.md:1455
msgid ""
"**Add Vertical FL example** "
"([#2598](https://github.com/adap/flower/pull/2598))"
msgstr ""

#: ../../source/ref-changelog.md:1457
msgid ""
"We had many questions about Vertical Federated Learning using Flower, so "
"we decided to add an simple example for it on the [Titanic "
"dataset](https://www.kaggle.com/competitions/titanic/data) alongside a "
"tutorial (in the README)."
msgstr ""

#: ../../source/ref-changelog.md:1459
msgid ""
"**Support custom** `ClientManager` **in** `start_driver()` "
"([#2292](https://github.com/adap/flower/pull/2292))"
msgstr ""

#: ../../source/ref-changelog.md:1461
msgid ""
"**Update REST API to support create and delete nodes** "
"([#2283](https://github.com/adap/flower/pull/2283))"
msgstr ""

#: ../../source/ref-changelog.md:1463
msgid ""
"**Update the Android SDK** "
"([#2187](https://github.com/adap/flower/pull/2187))"
msgstr ""

#: ../../source/ref-changelog.md:1465
msgid "Add gRPC request-response capability to the Android SDK."
msgstr ""

#: ../../source/ref-changelog.md:1467
msgid ""
"**Update the C++ SDK** "
"([#2537](https://github.com/adap/flower/pull/2537), "
"[#2528](https://github.com/adap/flower/pull/2528), "
"[#2523](https://github.com/adap/flower/pull/2523), "
"[#2522](https://github.com/adap/flower/pull/2522))"
msgstr ""

#: ../../source/ref-changelog.md:1469
msgid "Add gRPC request-response capability to the C++ SDK."
msgstr ""

#: ../../source/ref-changelog.md:1471
msgid ""
"**Make HTTPS the new default** "
"([#2591](https://github.com/adap/flower/pull/2591), "
"[#2636](https://github.com/adap/flower/pull/2636))"
msgstr ""

#: ../../source/ref-changelog.md:1473
msgid ""
"Flower is moving to HTTPS by default. The new `flower-server` requires "
"passing `--certificates`, but users can enable `--insecure` to use HTTP "
"for prototyping. The same applies to `flower-client`, which can either "
"use user-provided credentials or gRPC-bundled certificates to connect to "
"an HTTPS-enabled server or requires opt-out via passing `--insecure` to "
"enable insecure HTTP connections."
msgstr ""

#: ../../source/ref-changelog.md:1475
msgid ""
"For backward compatibility, `start_client()` and `start_numpy_client()` "
"will still start in insecure mode by default. In a future release, "
"insecure connections will require user opt-in by passing `insecure=True`."
msgstr ""

#: ../../source/ref-changelog.md:1477
msgid ""
"**Unify client API** ([#2303](https://github.com/adap/flower/pull/2303), "
"[#2390](https://github.com/adap/flower/pull/2390), "
"[#2493](https://github.com/adap/flower/pull/2493))"
msgstr ""

#: ../../source/ref-changelog.md:1479
msgid ""
"Using the `client_fn`, Flower clients can interchangeably run as "
"standalone processes (i.e. via `start_client`) or in simulation (i.e. via"
" `start_simulation`) without requiring changes to how the client class is"
" defined and instantiated. The `to_client()` function is introduced to "
"convert a `NumPyClient` to a `Client`."
msgstr ""

#: ../../source/ref-changelog.md:1481
msgid ""
"**Add new** `Bulyan` **strategy** "
"([#1817](https://github.com/adap/flower/pull/1817), "
"[#1891](https://github.com/adap/flower/pull/1891))"
msgstr ""

#: ../../source/ref-changelog.md:1483
msgid ""
"The new `Bulyan` strategy implements Bulyan by [El Mhamdi et al., "
"2018](https://arxiv.org/abs/1802.07927)"
msgstr ""

#: ../../source/ref-changelog.md:1485
msgid ""
"**Add new** `XGB Bagging` **strategy** "
"([#2611](https://github.com/adap/flower/pull/2611))"
msgstr ""

#: ../../source/ref-changelog.md:1487
msgid ""
"**Introduce `WorkloadState`** "
"([#2564](https://github.com/adap/flower/pull/2564), "
"[#2632](https://github.com/adap/flower/pull/2632))"
msgstr ""

#: ../../source/ref-changelog.md:1491
msgid ""
"FedProx ([#2210](https://github.com/adap/flower/pull/2210), "
"[#2286](https://github.com/adap/flower/pull/2286), "
"[#2509](https://github.com/adap/flower/pull/2509))"
msgstr ""

#: ../../source/ref-changelog.md:1493
msgid ""
"Baselines Docs ([#2290](https://github.com/adap/flower/pull/2290), "
"[#2400](https://github.com/adap/flower/pull/2400))"
msgstr ""

#: ../../source/ref-changelog.md:1495
msgid ""
"FedMLB ([#2340](https://github.com/adap/flower/pull/2340), "
"[#2507](https://github.com/adap/flower/pull/2507))"
msgstr ""

#: ../../source/ref-changelog.md:1497
msgid ""
"TAMUNA ([#2254](https://github.com/adap/flower/pull/2254), "
"[#2508](https://github.com/adap/flower/pull/2508))"
msgstr ""

#: ../../source/ref-changelog.md:1499
msgid "FedMeta [#2438](https://github.com/adap/flower/pull/2438)"
msgstr ""

#: ../../source/ref-changelog.md:1501
msgid "FjORD [#2431](https://github.com/adap/flower/pull/2431)"
msgstr ""

#: ../../source/ref-changelog.md:1503
msgid "MOON [#2421](https://github.com/adap/flower/pull/2421)"
msgstr ""

#: ../../source/ref-changelog.md:1505
msgid "DepthFL [#2295](https://github.com/adap/flower/pull/2295)"
msgstr ""

#: ../../source/ref-changelog.md:1507
msgid "FedPer [#2266](https://github.com/adap/flower/pull/2266)"
msgstr ""

#: ../../source/ref-changelog.md:1509
msgid "FedWav2vec [#2551](https://github.com/adap/flower/pull/2551)"
msgstr ""

#: ../../source/ref-changelog.md:1511
msgid "niid-Bench [#2428](https://github.com/adap/flower/pull/2428)"
msgstr ""

#: ../../source/ref-changelog.md:1513
msgid ""
"FedBN ([#2608](https://github.com/adap/flower/pull/2608), "
"[#2615](https://github.com/adap/flower/pull/2615))"
msgstr ""

#: ../../source/ref-changelog.md:1515
msgid ""
"**General updates to Flower Examples** "
"([#2384](https://github.com/adap/flower/pull/2384), "
"[#2425](https://github.com/adap/flower/pull/2425), "
"[#2526](https://github.com/adap/flower/pull/2526), "
"[#2302](https://github.com/adap/flower/pull/2302), "
"[#2545](https://github.com/adap/flower/pull/2545))"
msgstr ""

#: ../../source/ref-changelog.md:1517
msgid ""
"**General updates to Flower Baselines** "
"([#2301](https://github.com/adap/flower/pull/2301), "
"[#2305](https://github.com/adap/flower/pull/2305), "
"[#2307](https://github.com/adap/flower/pull/2307), "
"[#2327](https://github.com/adap/flower/pull/2327), "
"[#2435](https://github.com/adap/flower/pull/2435), "
"[#2462](https://github.com/adap/flower/pull/2462), "
"[#2463](https://github.com/adap/flower/pull/2463), "
"[#2461](https://github.com/adap/flower/pull/2461), "
"[#2469](https://github.com/adap/flower/pull/2469), "
"[#2466](https://github.com/adap/flower/pull/2466), "
"[#2471](https://github.com/adap/flower/pull/2471), "
"[#2472](https://github.com/adap/flower/pull/2472), "
"[#2470](https://github.com/adap/flower/pull/2470))"
msgstr ""

#: ../../source/ref-changelog.md:1519
msgid ""
"**General updates to the simulation engine** "
"([#2331](https://github.com/adap/flower/pull/2331), "
"[#2447](https://github.com/adap/flower/pull/2447), "
"[#2448](https://github.com/adap/flower/pull/2448), "
"[#2294](https://github.com/adap/flower/pull/2294))"
msgstr ""

#: ../../source/ref-changelog.md:1521
msgid ""
"**General updates to Flower SDKs** "
"([#2288](https://github.com/adap/flower/pull/2288), "
"[#2429](https://github.com/adap/flower/pull/2429), "
"[#2555](https://github.com/adap/flower/pull/2555), "
"[#2543](https://github.com/adap/flower/pull/2543), "
"[#2544](https://github.com/adap/flower/pull/2544), "
"[#2597](https://github.com/adap/flower/pull/2597), "
"[#2623](https://github.com/adap/flower/pull/2623))"
msgstr ""

#: ../../source/ref-changelog.md:1523
msgid ""
"**General improvements** "
"([#2309](https://github.com/adap/flower/pull/2309), "
"[#2310](https://github.com/adap/flower/pull/2310), "
"[#2313](https://github.com/adap/flower/pull/2313), "
"[#2316](https://github.com/adap/flower/pull/2316), "
"[#2317](https://github.com/adap/flower/pull/2317), "
"[#2349](https://github.com/adap/flower/pull/2349), "
"[#2360](https://github.com/adap/flower/pull/2360), "
"[#2402](https://github.com/adap/flower/pull/2402), "
"[#2446](https://github.com/adap/flower/pull/2446), "
"[#2561](https://github.com/adap/flower/pull/2561), "
"[#2273](https://github.com/adap/flower/pull/2273), "
"[#2267](https://github.com/adap/flower/pull/2267), "
"[#2274](https://github.com/adap/flower/pull/2274), "
"[#2275](https://github.com/adap/flower/pull/2275), "
"[#2432](https://github.com/adap/flower/pull/2432), "
"[#2251](https://github.com/adap/flower/pull/2251), "
"[#2321](https://github.com/adap/flower/pull/2321), "
"[#1936](https://github.com/adap/flower/pull/1936), "
"[#2408](https://github.com/adap/flower/pull/2408), "
"[#2413](https://github.com/adap/flower/pull/2413), "
"[#2401](https://github.com/adap/flower/pull/2401), "
"[#2531](https://github.com/adap/flower/pull/2531), "
"[#2534](https://github.com/adap/flower/pull/2534), "
"[#2535](https://github.com/adap/flower/pull/2535), "
"[#2521](https://github.com/adap/flower/pull/2521), "
"[#2553](https://github.com/adap/flower/pull/2553), "
"[#2596](https://github.com/adap/flower/pull/2596))"
msgstr ""

#: ../../source/ref-changelog.md:1525 ../../source/ref-changelog.md:1615
#: ../../source/ref-changelog.md:1679 ../../source/ref-changelog.md:1733
#: ../../source/ref-changelog.md:1800
msgid "Flower received many improvements under the hood, too many to list here."
msgstr ""

#: ../../source/ref-changelog.md:1529
msgid ""
"**Remove support for Python 3.7** "
"([#2280](https://github.com/adap/flower/pull/2280), "
"[#2299](https://github.com/adap/flower/pull/2299), "
"[#2304](https://github.com/adap/flower/pull/2304), "
"[#2306](https://github.com/adap/flower/pull/2306), "
"[#2355](https://github.com/adap/flower/pull/2355), "
"[#2356](https://github.com/adap/flower/pull/2356))"
msgstr ""

#: ../../source/ref-changelog.md:1531
msgid ""
"Python 3.7 support was deprecated in Flower 1.5, and this release removes"
" support. Flower now requires Python 3.8."
msgstr ""

#: ../../source/ref-changelog.md:1533
msgid ""
"**Remove experimental argument** `rest` **from** `start_client` "
"([#2324](https://github.com/adap/flower/pull/2324))"
msgstr ""

#: ../../source/ref-changelog.md:1535
msgid ""
"The (still experimental) argument `rest` was removed from `start_client` "
"and `start_numpy_client`. Use `transport=\"rest\"` to opt into the "
"experimental REST API instead."
msgstr ""

#: ../../source/ref-changelog.md:1537
msgid "v1.5.0 (2023-08-31)"
msgstr ""

#: ../../source/ref-changelog.md:1543
msgid ""
"`Adam Narozniak`, `Anass Anhari`, `Charles Beauville`, `Dana-Farber`, "
"`Daniel J. Beutel`, `Daniel Nata Nugraha`, `Edoardo Gabrielli`, `Gustavo "
"Bertoli`, `Heng Pan`, `Javier`, `Mahdi`, `Steven Hé (Sīchàng)`, `Taner "
"Topal`, `achiverram28`, `danielnugraha`, `eunchung`, `ruthgal` <!---"
"TOKEN_v1.5.0-->"
msgstr ""

#: ../../source/ref-changelog.md:1547
msgid ""
"**Introduce new simulation engine** "
"([#1969](https://github.com/adap/flower/pull/1969), "
"[#2221](https://github.com/adap/flower/pull/2221), "
"[#2248](https://github.com/adap/flower/pull/2248))"
msgstr ""

#: ../../source/ref-changelog.md:1549
msgid ""
"The new simulation engine has been rewritten from the ground up, yet it "
"remains fully backwards compatible. It offers much improved stability and"
" memory handling, especially when working with GPUs. Simulations "
"transparently adapt to different settings to scale simulation in CPU-"
"only, CPU+GPU, multi-GPU, or multi-node multi-GPU environments."
msgstr ""

#: ../../source/ref-changelog.md:1551
msgid ""
"Comprehensive documentation includes a new [how-to run "
"simulations](https://flower.ai/docs/framework/how-to-run-"
"simulations.html) guide, new [simulation-"
"pytorch](https://flower.ai/docs/examples/simulation-pytorch.html) and "
"[simulation-tensorflow](https://flower.ai/docs/examples/simulation-"
"tensorflow.html) notebooks, and a new [YouTube tutorial "
"series](https://www.youtube.com/watch?v=cRebUIGB5RU&list=PLNG4feLHqCWlnj8a_E1A_n5zr2-8pafTB)."
msgstr ""

#: ../../source/ref-changelog.md:1553
msgid ""
"**Restructure Flower Docs** "
"([#1824](https://github.com/adap/flower/pull/1824), "
"[#1865](https://github.com/adap/flower/pull/1865), "
"[#1884](https://github.com/adap/flower/pull/1884), "
"[#1887](https://github.com/adap/flower/pull/1887), "
"[#1919](https://github.com/adap/flower/pull/1919), "
"[#1922](https://github.com/adap/flower/pull/1922), "
"[#1920](https://github.com/adap/flower/pull/1920), "
"[#1923](https://github.com/adap/flower/pull/1923), "
"[#1924](https://github.com/adap/flower/pull/1924), "
"[#1962](https://github.com/adap/flower/pull/1962), "
"[#2006](https://github.com/adap/flower/pull/2006), "
"[#2133](https://github.com/adap/flower/pull/2133), "
"[#2203](https://github.com/adap/flower/pull/2203), "
"[#2215](https://github.com/adap/flower/pull/2215), "
"[#2122](https://github.com/adap/flower/pull/2122), "
"[#2223](https://github.com/adap/flower/pull/2223), "
"[#2219](https://github.com/adap/flower/pull/2219), "
"[#2232](https://github.com/adap/flower/pull/2232), "
"[#2233](https://github.com/adap/flower/pull/2233), "
"[#2234](https://github.com/adap/flower/pull/2234), "
"[#2235](https://github.com/adap/flower/pull/2235), "
"[#2237](https://github.com/adap/flower/pull/2237), "
"[#2238](https://github.com/adap/flower/pull/2238), "
"[#2242](https://github.com/adap/flower/pull/2242), "
"[#2231](https://github.com/adap/flower/pull/2231), "
"[#2243](https://github.com/adap/flower/pull/2243), "
"[#2227](https://github.com/adap/flower/pull/2227))"
msgstr ""

#: ../../source/ref-changelog.md:1555
msgid ""
"Much effort went into a completely restructured Flower docs experience. "
"The documentation on [flower.ai/docs](https://flower.ai/docs) is now "
"divided into Flower Framework, Flower Baselines, Flower Android SDK, "
"Flower iOS SDK, and code example projects."
msgstr ""

#: ../../source/ref-changelog.md:1557
msgid ""
"**Introduce Flower Swift SDK** "
"([#1858](https://github.com/adap/flower/pull/1858), "
"[#1897](https://github.com/adap/flower/pull/1897))"
msgstr ""

#: ../../source/ref-changelog.md:1559
msgid ""
"This is the first preview release of the Flower Swift SDK. Flower support"
" on iOS is improving, and alongside the Swift SDK and code example, there"
" is now also an iOS quickstart tutorial."
msgstr ""

#: ../../source/ref-changelog.md:1561
msgid ""
"**Introduce Flower Android SDK** "
"([#2131](https://github.com/adap/flower/pull/2131))"
msgstr ""

#: ../../source/ref-changelog.md:1563
msgid ""
"This is the first preview release of the Flower Kotlin SDK. Flower "
"support on Android is improving, and alongside the Kotlin SDK and code "
"example, there is now also an Android quickstart tutorial."
msgstr ""

#: ../../source/ref-changelog.md:1565
msgid ""
"**Introduce new end-to-end testing infrastructure** "
"([#1842](https://github.com/adap/flower/pull/1842), "
"[#2071](https://github.com/adap/flower/pull/2071), "
"[#2072](https://github.com/adap/flower/pull/2072), "
"[#2068](https://github.com/adap/flower/pull/2068), "
"[#2067](https://github.com/adap/flower/pull/2067), "
"[#2069](https://github.com/adap/flower/pull/2069), "
"[#2073](https://github.com/adap/flower/pull/2073), "
"[#2070](https://github.com/adap/flower/pull/2070), "
"[#2074](https://github.com/adap/flower/pull/2074), "
"[#2082](https://github.com/adap/flower/pull/2082), "
"[#2084](https://github.com/adap/flower/pull/2084), "
"[#2093](https://github.com/adap/flower/pull/2093), "
"[#2109](https://github.com/adap/flower/pull/2109), "
"[#2095](https://github.com/adap/flower/pull/2095), "
"[#2140](https://github.com/adap/flower/pull/2140), "
"[#2137](https://github.com/adap/flower/pull/2137), "
"[#2165](https://github.com/adap/flower/pull/2165))"
msgstr ""

#: ../../source/ref-changelog.md:1567
msgid ""
"A new testing infrastructure ensures that new changes stay compatible "
"with existing framework integrations or strategies."
msgstr ""

#: ../../source/ref-changelog.md:1569
msgid "**Deprecate Python 3.7**"
msgstr ""

#: ../../source/ref-changelog.md:1571
msgid ""
"Since Python 3.7 reached its end of life (EOL) on 2023-06-27, support for"
" Python 3.7 is now deprecated and will be removed in an upcoming release."
msgstr ""

#: ../../source/ref-changelog.md:1573
msgid ""
"**Add new** `FedTrimmedAvg` **strategy** "
"([#1769](https://github.com/adap/flower/pull/1769), "
"[#1853](https://github.com/adap/flower/pull/1853))"
msgstr ""

#: ../../source/ref-changelog.md:1575
msgid ""
"The new `FedTrimmedAvg` strategy implements Trimmed Mean by [Dong Yin, "
"2018](https://arxiv.org/abs/1803.01498)."
msgstr ""

#: ../../source/ref-changelog.md:1577
msgid ""
"**Introduce start_driver** "
"([#1697](https://github.com/adap/flower/pull/1697))"
msgstr ""

#: ../../source/ref-changelog.md:1579
msgid ""
"In addition to `start_server` and using the raw Driver API, there is a "
"new `start_driver` function that allows for running `start_server` "
"scripts as a Flower driver with only a single-line code change. Check out"
" the `mt-pytorch` code example to see a working example using "
"`start_driver`."
msgstr ""

#: ../../source/ref-changelog.md:1581
msgid ""
"**Add parameter aggregation to** `mt-pytorch` **code example** "
"([#1785](https://github.com/adap/flower/pull/1785))"
msgstr ""

#: ../../source/ref-changelog.md:1583
msgid ""
"The `mt-pytorch` example shows how to aggregate parameters when writing a"
" driver script. The included `driver.py` and `server.py` have been "
"aligned to demonstrate both the low-level way and the high-level way of "
"building server-side logic."
msgstr ""

#: ../../source/ref-changelog.md:1585
msgid ""
"**Migrate experimental REST API to Starlette** "
"([2171](https://github.com/adap/flower/pull/2171))"
msgstr ""

#: ../../source/ref-changelog.md:1587
msgid ""
"The (experimental) REST API used to be implemented in "
"[FastAPI](https://fastapi.tiangolo.com/), but it has now been migrated to"
" use [Starlette](https://www.starlette.io/) directly."
msgstr ""

#: ../../source/ref-changelog.md:1589
msgid ""
"Please note: The REST request-response API is still experimental and will"
" likely change significantly over time."
msgstr ""

#: ../../source/ref-changelog.md:1591
msgid ""
"**Introduce experimental gRPC request-response API** "
"([#1867](https://github.com/adap/flower/pull/1867), "
"[#1901](https://github.com/adap/flower/pull/1901))"
msgstr ""

#: ../../source/ref-changelog.md:1593
msgid ""
"In addition to the existing gRPC API (based on bidirectional streaming) "
"and the experimental REST API, there is now a new gRPC API that uses a "
"request-response model to communicate with client nodes."
msgstr ""

#: ../../source/ref-changelog.md:1595
msgid ""
"Please note: The gRPC request-response API is still experimental and will"
" likely change significantly over time."
msgstr ""

#: ../../source/ref-changelog.md:1597
msgid ""
"**Replace the experimental** `start_client(rest=True)` **with the new** "
"`start_client(transport=\"rest\")` "
"([#1880](https://github.com/adap/flower/pull/1880))"
msgstr ""

#: ../../source/ref-changelog.md:1599
msgid ""
"The (experimental) `start_client` argument `rest` was deprecated in "
"favour of a new argument `transport`. `start_client(transport=\"rest\")` "
"will yield the same behaviour as `start_client(rest=True)` did before. "
"All code should migrate to the new argument `transport`. The deprecated "
"argument `rest` will be removed in a future release."
msgstr ""

#: ../../source/ref-changelog.md:1601
msgid ""
"**Add a new gRPC option** "
"([#2197](https://github.com/adap/flower/pull/2197))"
msgstr ""

#: ../../source/ref-changelog.md:1603
msgid ""
"We now start a gRPC server with the `grpc.keepalive_permit_without_calls`"
" option set to 0 by default. This prevents the clients from sending "
"keepalive pings when there is no outstanding stream."
msgstr ""

#: ../../source/ref-changelog.md:1605
msgid ""
"**Improve example notebooks** "
"([#2005](https://github.com/adap/flower/pull/2005))"
msgstr ""

#: ../../source/ref-changelog.md:1607
msgid "There's a new 30min Federated Learning PyTorch tutorial!"
msgstr ""

#: ../../source/ref-changelog.md:1609
msgid ""
"**Example updates** ([#1772](https://github.com/adap/flower/pull/1772), "
"[#1873](https://github.com/adap/flower/pull/1873), "
"[#1981](https://github.com/adap/flower/pull/1981), "
"[#1988](https://github.com/adap/flower/pull/1988), "
"[#1984](https://github.com/adap/flower/pull/1984), "
"[#1982](https://github.com/adap/flower/pull/1982), "
"[#2112](https://github.com/adap/flower/pull/2112), "
"[#2144](https://github.com/adap/flower/pull/2144), "
"[#2174](https://github.com/adap/flower/pull/2174), "
"[#2225](https://github.com/adap/flower/pull/2225), "
"[#2183](https://github.com/adap/flower/pull/2183))"
msgstr ""

#: ../../source/ref-changelog.md:1611
msgid ""
"Many examples have received significant updates, including simplified "
"advanced-tensorflow and advanced-pytorch examples, improved macOS "
"compatibility of TensorFlow examples, and code examples for simulation. A"
" major upgrade is that all code examples now have a `requirements.txt` "
"(in addition to `pyproject.toml`)."
msgstr ""

#: ../../source/ref-changelog.md:1613
msgid ""
"**General improvements** "
"([#1872](https://github.com/adap/flower/pull/1872), "
"[#1866](https://github.com/adap/flower/pull/1866), "
"[#1837](https://github.com/adap/flower/pull/1837), "
"[#1477](https://github.com/adap/flower/pull/1477), "
"[#2171](https://github.com/adap/flower/pull/2171))"
msgstr ""

#: ../../source/ref-changelog.md:1621
msgid "v1.4.0 (2023-04-21)"
msgstr ""

#: ../../source/ref-changelog.md:1627
msgid ""
"`Adam Narozniak`, `Alexander Viala Bellander`, `Charles Beauville`, "
"`Chenyang Ma (Danny)`, `Daniel J. Beutel`, `Edoardo`, `Gautam Jajoo`, "
"`Iacob-Alexandru-Andrei`, `JDRanpariya`, `Jean Charle Yaacoub`, `Kunal "
"Sarkhel`, `L. Jiang`, `Lennart Behme`, `Max Kapsecker`, `Michał`, `Nic "
"Lane`, `Nikolaos Episkopos`, `Ragy`, `Saurav Maheshkar`, `Semo Yang`, "
"`Steve Laskaridis`, `Steven Hé (Sīchàng)`, `Taner Topal`"
msgstr ""

#: ../../source/ref-changelog.md:1631
msgid ""
"**Introduce support for XGBoost (**`FedXgbNnAvg` **strategy and "
"example)** ([#1694](https://github.com/adap/flower/pull/1694), "
"[#1709](https://github.com/adap/flower/pull/1709), "
"[#1715](https://github.com/adap/flower/pull/1715), "
"[#1717](https://github.com/adap/flower/pull/1717), "
"[#1763](https://github.com/adap/flower/pull/1763), "
"[#1795](https://github.com/adap/flower/pull/1795))"
msgstr ""

#: ../../source/ref-changelog.md:1633
msgid ""
"XGBoost is a tree-based ensemble machine learning algorithm that uses "
"gradient boosting to improve model accuracy. We added a new `FedXgbNnAvg`"
" "
"[strategy](https://github.com/adap/flower/tree/main/src/py/flwr/server/strategy/fedxgb_nn_avg.py),"
" and a [code example](https://github.com/adap/flower/tree/main/examples"
"/xgboost-quickstart) that demonstrates the usage of this new strategy in "
"an XGBoost project."
msgstr ""

#: ../../source/ref-changelog.md:1635
msgid ""
"**Introduce iOS SDK (preview)** "
"([#1621](https://github.com/adap/flower/pull/1621), "
"[#1764](https://github.com/adap/flower/pull/1764))"
msgstr ""

#: ../../source/ref-changelog.md:1637
msgid ""
"This is a major update for anyone wanting to implement Federated Learning"
" on iOS mobile devices. We now have a swift iOS SDK present under "
"[src/swift/flwr](https://github.com/adap/flower/tree/main/src/swift/flwr)"
" that will facilitate greatly the app creating process. To showcase its "
"use, the [iOS "
"example](https://github.com/adap/flower/tree/main/examples/ios) has also "
"been updated!"
msgstr ""

#: ../../source/ref-changelog.md:1639
msgid ""
"**Introduce new \"What is Federated Learning?\" tutorial** "
"([#1657](https://github.com/adap/flower/pull/1657), "
"[#1721](https://github.com/adap/flower/pull/1721))"
msgstr ""

#: ../../source/ref-changelog.md:1641
msgid ""
"A new [entry-level tutorial](https://flower.ai/docs/framework/tutorial-"
"what-is-federated-learning.html) in our documentation explains the basics"
" of Fedetated Learning. It enables anyone who's unfamiliar with Federated"
" Learning to start their journey with Flower. Forward it to anyone who's "
"interested in Federated Learning!"
msgstr ""

#: ../../source/ref-changelog.md:1643
msgid ""
"**Introduce new Flower Baseline: FedProx MNIST** "
"([#1513](https://github.com/adap/flower/pull/1513), "
"[#1680](https://github.com/adap/flower/pull/1680), "
"[#1681](https://github.com/adap/flower/pull/1681), "
"[#1679](https://github.com/adap/flower/pull/1679))"
msgstr ""

#: ../../source/ref-changelog.md:1645
msgid ""
"This new baseline replicates the MNIST+CNN task from the paper [Federated"
" Optimization in Heterogeneous Networks (Li et al., "
"2018)](https://arxiv.org/abs/1812.06127). It uses the `FedProx` strategy,"
" which aims at making convergence more robust in heterogeneous settings."
msgstr ""

#: ../../source/ref-changelog.md:1647
msgid ""
"**Introduce new Flower Baseline: FedAvg FEMNIST** "
"([#1655](https://github.com/adap/flower/pull/1655))"
msgstr ""

#: ../../source/ref-changelog.md:1649
msgid ""
"This new baseline replicates an experiment evaluating the performance of "
"the FedAvg algorithm on the FEMNIST dataset from the paper [LEAF: A "
"Benchmark for Federated Settings (Caldas et al., "
"2018)](https://arxiv.org/abs/1812.01097)."
msgstr ""

#: ../../source/ref-changelog.md:1651
msgid ""
"**Introduce (experimental) REST API** "
"([#1594](https://github.com/adap/flower/pull/1594), "
"[#1690](https://github.com/adap/flower/pull/1690), "
"[#1695](https://github.com/adap/flower/pull/1695), "
"[#1712](https://github.com/adap/flower/pull/1712), "
"[#1802](https://github.com/adap/flower/pull/1802), "
"[#1770](https://github.com/adap/flower/pull/1770), "
"[#1733](https://github.com/adap/flower/pull/1733))"
msgstr ""

#: ../../source/ref-changelog.md:1653
msgid ""
"A new REST API has been introduced as an alternative to the gRPC-based "
"communication stack. In this initial version, the REST API only supports "
"anonymous clients."
msgstr ""

#: ../../source/ref-changelog.md:1655
msgid ""
"Please note: The REST API is still experimental and will likely change "
"significantly over time."
msgstr ""

#: ../../source/ref-changelog.md:1657
msgid ""
"**Improve the (experimental) Driver API** "
"([#1663](https://github.com/adap/flower/pull/1663), "
"[#1666](https://github.com/adap/flower/pull/1666), "
"[#1667](https://github.com/adap/flower/pull/1667), "
"[#1664](https://github.com/adap/flower/pull/1664), "
"[#1675](https://github.com/adap/flower/pull/1675), "
"[#1676](https://github.com/adap/flower/pull/1676), "
"[#1693](https://github.com/adap/flower/pull/1693), "
"[#1662](https://github.com/adap/flower/pull/1662), "
"[#1794](https://github.com/adap/flower/pull/1794))"
msgstr ""

#: ../../source/ref-changelog.md:1659
msgid ""
"The Driver API is still an experimental feature, but this release "
"introduces some major upgrades. One of the main improvements is the "
"introduction of an SQLite database to store server state on disk (instead"
" of in-memory). Another improvement is that tasks (instructions or "
"results) that have been delivered will now be deleted. This greatly "
"improves the memory efficiency of a long-running Flower server."
msgstr ""

#: ../../source/ref-changelog.md:1661
msgid ""
"**Fix spilling issues related to Ray during simulations** "
"([#1698](https://github.com/adap/flower/pull/1698))"
msgstr ""

#: ../../source/ref-changelog.md:1663
msgid ""
"While running long simulations, `ray` was sometimes spilling huge amounts"
" of data that would make the training unable to continue. This is now "
"fixed! 🎉"
msgstr ""

#: ../../source/ref-changelog.md:1665
msgid ""
"**Add new example using** `TabNet` **and Flower** "
"([#1725](https://github.com/adap/flower/pull/1725))"
msgstr ""

#: ../../source/ref-changelog.md:1667
msgid ""
"TabNet is a powerful and flexible framework for training machine learning"
" models on tabular data. We now have a federated example using Flower: "
"[quickstart-tabnet](https://github.com/adap/flower/tree/main/examples"
"/quickstart-tabnet)."
msgstr ""

#: ../../source/ref-changelog.md:1669
msgid ""
"**Add new how-to guide for monitoring simulations** "
"([#1649](https://github.com/adap/flower/pull/1649))"
msgstr ""

#: ../../source/ref-changelog.md:1671
msgid ""
"We now have a documentation guide to help users monitor their performance"
" during simulations."
msgstr ""

#: ../../source/ref-changelog.md:1673
msgid ""
"**Add training metrics to** `History` **object during simulations** "
"([#1696](https://github.com/adap/flower/pull/1696))"
msgstr ""

#: ../../source/ref-changelog.md:1675
msgid ""
"The `fit_metrics_aggregation_fn` can be used to aggregate training "
"metrics, but previous releases did not save the results in the `History` "
"object. This is now the case!"
msgstr ""

#: ../../source/ref-changelog.md:1677
msgid ""
"**General improvements** "
"([#1646](https://github.com/adap/flower/pull/1646), "
"[#1647](https://github.com/adap/flower/pull/1647), "
"[#1471](https://github.com/adap/flower/pull/1471), "
"[#1648](https://github.com/adap/flower/pull/1648), "
"[#1651](https://github.com/adap/flower/pull/1651), "
"[#1652](https://github.com/adap/flower/pull/1652), "
"[#1653](https://github.com/adap/flower/pull/1653), "
"[#1659](https://github.com/adap/flower/pull/1659), "
"[#1665](https://github.com/adap/flower/pull/1665), "
"[#1670](https://github.com/adap/flower/pull/1670), "
"[#1672](https://github.com/adap/flower/pull/1672), "
"[#1677](https://github.com/adap/flower/pull/1677), "
"[#1684](https://github.com/adap/flower/pull/1684), "
"[#1683](https://github.com/adap/flower/pull/1683), "
"[#1686](https://github.com/adap/flower/pull/1686), "
"[#1682](https://github.com/adap/flower/pull/1682), "
"[#1685](https://github.com/adap/flower/pull/1685), "
"[#1692](https://github.com/adap/flower/pull/1692), "
"[#1705](https://github.com/adap/flower/pull/1705), "
"[#1708](https://github.com/adap/flower/pull/1708), "
"[#1711](https://github.com/adap/flower/pull/1711), "
"[#1713](https://github.com/adap/flower/pull/1713), "
"[#1714](https://github.com/adap/flower/pull/1714), "
"[#1718](https://github.com/adap/flower/pull/1718), "
"[#1716](https://github.com/adap/flower/pull/1716), "
"[#1723](https://github.com/adap/flower/pull/1723), "
"[#1735](https://github.com/adap/flower/pull/1735), "
"[#1678](https://github.com/adap/flower/pull/1678), "
"[#1750](https://github.com/adap/flower/pull/1750), "
"[#1753](https://github.com/adap/flower/pull/1753), "
"[#1736](https://github.com/adap/flower/pull/1736), "
"[#1766](https://github.com/adap/flower/pull/1766), "
"[#1760](https://github.com/adap/flower/pull/1760), "
"[#1775](https://github.com/adap/flower/pull/1775), "
"[#1776](https://github.com/adap/flower/pull/1776), "
"[#1777](https://github.com/adap/flower/pull/1777), "
"[#1779](https://github.com/adap/flower/pull/1779), "
"[#1784](https://github.com/adap/flower/pull/1784), "
"[#1773](https://github.com/adap/flower/pull/1773), "
"[#1755](https://github.com/adap/flower/pull/1755), "
"[#1789](https://github.com/adap/flower/pull/1789), "
"[#1788](https://github.com/adap/flower/pull/1788), "
"[#1798](https://github.com/adap/flower/pull/1798), "
"[#1799](https://github.com/adap/flower/pull/1799), "
"[#1739](https://github.com/adap/flower/pull/1739), "
"[#1800](https://github.com/adap/flower/pull/1800), "
"[#1804](https://github.com/adap/flower/pull/1804), "
"[#1805](https://github.com/adap/flower/pull/1805))"
msgstr ""

#: ../../source/ref-changelog.md:1685
msgid "v1.3.0 (2023-02-06)"
msgstr ""

#: ../../source/ref-changelog.md:1691
msgid ""
"`Adam Narozniak`, `Alexander Viala Bellander`, `Charles Beauville`, "
"`Daniel J. Beutel`, `JDRanpariya`, `Lennart Behme`, `Taner Topal`"
msgstr ""

#: ../../source/ref-changelog.md:1695
msgid ""
"**Add support for** `workload_id` **and** `group_id` **in Driver API** "
"([#1595](https://github.com/adap/flower/pull/1595))"
msgstr ""

#: ../../source/ref-changelog.md:1697
msgid ""
"The (experimental) Driver API now supports a `workload_id` that can be "
"used to identify which workload a task belongs to. It also supports a new"
" `group_id` that can be used, for example, to indicate the current "
"training round. Both the `workload_id` and `group_id` enable client nodes"
" to decide whether they want to handle a task or not."
msgstr ""

#: ../../source/ref-changelog.md:1699
msgid ""
"**Make Driver API and Fleet API address configurable** "
"([#1637](https://github.com/adap/flower/pull/1637))"
msgstr ""

#: ../../source/ref-changelog.md:1701
msgid ""
"The (experimental) long-running Flower server (Driver API and Fleet API) "
"can now configure the server address of both Driver API (via `--driver-"
"api-address`) and Fleet API (via `--fleet-api-address`) when starting:"
msgstr ""

#: ../../source/ref-changelog.md:1703
msgid ""
"`flower-server --driver-api-address \"0.0.0.0:8081\" --fleet-api-address "
"\"0.0.0.0:8086\"`"
msgstr ""

#: ../../source/ref-changelog.md:1705
msgid "Both IPv4 and IPv6 addresses are supported."
msgstr ""

#: ../../source/ref-changelog.md:1707
msgid ""
"**Add new example of Federated Learning using fastai and Flower** "
"([#1598](https://github.com/adap/flower/pull/1598))"
msgstr ""

#: ../../source/ref-changelog.md:1709
msgid ""
"A new code example (`quickstart-fastai`) demonstrates federated learning "
"with [fastai](https://www.fast.ai/) and Flower. You can find it here: "
"[quickstart-fastai](https://github.com/adap/flower/tree/main/examples"
"/quickstart-fastai)."
msgstr ""

#: ../../source/ref-changelog.md:1711
msgid ""
"**Make Android example compatible with** `flwr >= 1.0.0` **and the latest"
" versions of Android** "
"([#1603](https://github.com/adap/flower/pull/1603))"
msgstr ""

#: ../../source/ref-changelog.md:1713
msgid ""
"The Android code example has received a substantial update: the project "
"is compatible with Flower 1.0 (and later), the UI received a full "
"refresh, and the project is updated to be compatible with newer Android "
"tooling."
msgstr ""

#: ../../source/ref-changelog.md:1715
msgid ""
"**Add new `FedProx` strategy** "
"([#1619](https://github.com/adap/flower/pull/1619))"
msgstr ""

#: ../../source/ref-changelog.md:1717
msgid ""
"This "
"[strategy](https://github.com/adap/flower/blob/main/src/py/flwr/server/strategy/fedprox.py)"
" is almost identical to "
"[`FedAvg`](https://github.com/adap/flower/blob/main/src/py/flwr/server/strategy/fedavg.py),"
" but helps users replicate what is described in this "
"[paper](https://arxiv.org/abs/1812.06127). It essentially adds a "
"parameter called `proximal_mu` to regularize the local models with "
"respect to the global models."
msgstr ""

#: ../../source/ref-changelog.md:1719
msgid ""
"**Add new metrics to telemetry events** "
"([#1640](https://github.com/adap/flower/pull/1640))"
msgstr ""

#: ../../source/ref-changelog.md:1721
msgid ""
"An updated event structure allows, for example, the clustering of events "
"within the same workload."
msgstr ""

#: ../../source/ref-changelog.md:1723
msgid ""
"**Add new custom strategy tutorial section** "
"[#1623](https://github.com/adap/flower/pull/1623)"
msgstr ""

#: ../../source/ref-changelog.md:1725
msgid ""
"The Flower tutorial now has a new section that covers implementing a "
"custom strategy from scratch: [Open in "
"Colab](https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
"/tutorial-build-a-strategy-from-scratch-pytorch.ipynb)"
msgstr ""

#: ../../source/ref-changelog.md:1727
msgid ""
"**Add new custom serialization tutorial section** "
"([#1622](https://github.com/adap/flower/pull/1622))"
msgstr ""

#: ../../source/ref-changelog.md:1729
msgid ""
"The Flower tutorial now has a new section that covers custom "
"serialization: [Open in "
"Colab](https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
"/tutorial-customize-the-client-pytorch.ipynb)"
msgstr ""

#: ../../source/ref-changelog.md:1731
msgid ""
"**General improvements** "
"([#1638](https://github.com/adap/flower/pull/1638), "
"[#1634](https://github.com/adap/flower/pull/1634), "
"[#1636](https://github.com/adap/flower/pull/1636), "
"[#1635](https://github.com/adap/flower/pull/1635), "
"[#1633](https://github.com/adap/flower/pull/1633), "
"[#1632](https://github.com/adap/flower/pull/1632), "
"[#1631](https://github.com/adap/flower/pull/1631), "
"[#1630](https://github.com/adap/flower/pull/1630), "
"[#1627](https://github.com/adap/flower/pull/1627), "
"[#1593](https://github.com/adap/flower/pull/1593), "
"[#1616](https://github.com/adap/flower/pull/1616), "
"[#1615](https://github.com/adap/flower/pull/1615), "
"[#1607](https://github.com/adap/flower/pull/1607), "
"[#1609](https://github.com/adap/flower/pull/1609), "
"[#1608](https://github.com/adap/flower/pull/1608), "
"[#1590](https://github.com/adap/flower/pull/1590), "
"[#1580](https://github.com/adap/flower/pull/1580), "
"[#1599](https://github.com/adap/flower/pull/1599), "
"[#1600](https://github.com/adap/flower/pull/1600), "
"[#1601](https://github.com/adap/flower/pull/1601), "
"[#1597](https://github.com/adap/flower/pull/1597), "
"[#1591](https://github.com/adap/flower/pull/1591), "
"[#1588](https://github.com/adap/flower/pull/1588), "
"[#1589](https://github.com/adap/flower/pull/1589), "
"[#1587](https://github.com/adap/flower/pull/1587), "
"[#1573](https://github.com/adap/flower/pull/1573), "
"[#1581](https://github.com/adap/flower/pull/1581), "
"[#1578](https://github.com/adap/flower/pull/1578), "
"[#1574](https://github.com/adap/flower/pull/1574), "
"[#1572](https://github.com/adap/flower/pull/1572), "
"[#1586](https://github.com/adap/flower/pull/1586))"
msgstr ""

#: ../../source/ref-changelog.md:1735
msgid ""
"**Updated documentation** "
"([#1629](https://github.com/adap/flower/pull/1629), "
"[#1628](https://github.com/adap/flower/pull/1628), "
"[#1620](https://github.com/adap/flower/pull/1620), "
"[#1618](https://github.com/adap/flower/pull/1618), "
"[#1617](https://github.com/adap/flower/pull/1617), "
"[#1613](https://github.com/adap/flower/pull/1613), "
"[#1614](https://github.com/adap/flower/pull/1614))"
msgstr ""

#: ../../source/ref-changelog.md:1737 ../../source/ref-changelog.md:1804
msgid ""
"As usual, the documentation has improved quite a bit. It is another step "
"in our effort to make the Flower documentation the best documentation of "
"any project. Stay tuned and as always, feel free to provide feedback!"
msgstr ""

#: ../../source/ref-changelog.md:1743
msgid "v1.2.0 (2023-01-13)"
msgstr ""

#: ../../source/ref-changelog.md:1749
msgid ""
"`Adam Narozniak`, `Charles Beauville`, `Daniel J. Beutel`, `Edoardo`, `L."
" Jiang`, `Ragy`, `Taner Topal`, `dannymcy`"
msgstr ""

#: ../../source/ref-changelog.md:1753
msgid ""
"**Introduce new Flower Baseline: FedAvg MNIST** "
"([#1497](https://github.com/adap/flower/pull/1497), "
"[#1552](https://github.com/adap/flower/pull/1552))"
msgstr ""

#: ../../source/ref-changelog.md:1755
msgid ""
"Over the coming weeks, we will be releasing a number of new reference "
"implementations useful especially to FL newcomers. They will typically "
"revisit well known papers from the literature, and be suitable for "
"integration in your own application or for experimentation, in order to "
"deepen your knowledge of FL in general. Today's release is the first in "
"this series. [Read more.](https://flower.ai/blog/2023-01-12-fl-starter-"
"pack-fedavg-mnist-cnn/)"
msgstr ""

#: ../../source/ref-changelog.md:1757
msgid ""
"**Improve GPU support in simulations** "
"([#1555](https://github.com/adap/flower/pull/1555))"
msgstr ""

#: ../../source/ref-changelog.md:1759
msgid ""
"The Ray-based Virtual Client Engine (`start_simulation`) has been updated"
" to improve GPU support. The update includes some of the hard-earned "
"lessons from scaling simulations in GPU cluster environments. New "
"defaults make running GPU-based simulations substantially more robust."
msgstr ""

#: ../../source/ref-changelog.md:1761
msgid ""
"**Improve GPU support in Jupyter Notebook tutorials** "
"([#1527](https://github.com/adap/flower/pull/1527), "
"[#1558](https://github.com/adap/flower/pull/1558))"
msgstr ""

#: ../../source/ref-changelog.md:1763
msgid ""
"Some users reported that Jupyter Notebooks have not always been easy to "
"use on GPU instances. We listened and made improvements to all of our "
"Jupyter notebooks! Check out the updated notebooks here:"
msgstr ""

#: ../../source/ref-changelog.md:1765
msgid ""
"[An Introduction to Federated Learning](https://flower.ai/docs/framework"
"/tutorial-get-started-with-flower-pytorch.html)"
msgstr ""

#: ../../source/ref-changelog.md:1766
msgid ""
"[Strategies in Federated Learning](https://flower.ai/docs/framework"
"/tutorial-use-a-federated-learning-strategy-pytorch.html)"
msgstr ""

#: ../../source/ref-changelog.md:1767
msgid ""
"[Building a Strategy](https://flower.ai/docs/framework/tutorial-build-a"
"-strategy-from-scratch-pytorch.html)"
msgstr ""

#: ../../source/ref-changelog.md:1768
msgid ""
"[Client and NumPyClient](https://flower.ai/docs/framework/tutorial-"
"customize-the-client-pytorch.html)"
msgstr ""

#: ../../source/ref-changelog.md:1770
msgid ""
"**Introduce optional telemetry** "
"([#1533](https://github.com/adap/flower/pull/1533), "
"[#1544](https://github.com/adap/flower/pull/1544), "
"[#1584](https://github.com/adap/flower/pull/1584))"
msgstr ""

#: ../../source/ref-changelog.md:1772
msgid ""
"After a [request for "
"feedback](https://github.com/adap/flower/issues/1534) from the community,"
" the Flower open-source project introduces optional collection of "
"*anonymous* usage metrics to make well-informed decisions to improve "
"Flower. Doing this enables the Flower team to understand how Flower is "
"used and what challenges users might face."
msgstr ""

#: ../../source/ref-changelog.md:1774
msgid ""
"**Flower is a friendly framework for collaborative AI and data science.**"
" Staying true to this statement, Flower makes it easy to disable "
"telemetry for users who do not want to share anonymous usage metrics. "
"[Read more.](https://flower.ai/docs/telemetry.html)."
msgstr ""

#: ../../source/ref-changelog.md:1776
msgid ""
"**Introduce (experimental) Driver API** "
"([#1520](https://github.com/adap/flower/pull/1520), "
"[#1525](https://github.com/adap/flower/pull/1525), "
"[#1545](https://github.com/adap/flower/pull/1545), "
"[#1546](https://github.com/adap/flower/pull/1546), "
"[#1550](https://github.com/adap/flower/pull/1550), "
"[#1551](https://github.com/adap/flower/pull/1551), "
"[#1567](https://github.com/adap/flower/pull/1567))"
msgstr ""

#: ../../source/ref-changelog.md:1778
msgid ""
"Flower now has a new (experimental) Driver API which will enable fully "
"programmable, async, and multi-tenant Federated Learning and Federated "
"Analytics applications. Phew, that's a lot! Going forward, the Driver API"
" will be the abstraction that many upcoming features will be built on - "
"and you can start building those things now, too."
msgstr ""

#: ../../source/ref-changelog.md:1780
msgid ""
"The Driver API also enables a new execution mode in which the server runs"
" indefinitely. Multiple individual workloads can run concurrently and "
"start and stop their execution independent of the server. This is "
"especially useful for users who want to deploy Flower in production."
msgstr ""

#: ../../source/ref-changelog.md:1782
msgid ""
"To learn more, check out the `mt-pytorch` code example. We look forward "
"to you feedback!"
msgstr ""

#: ../../source/ref-changelog.md:1784
msgid ""
"Please note: *The Driver API is still experimental and will likely change"
" significantly over time.*"
msgstr ""

#: ../../source/ref-changelog.md:1786
msgid ""
"**Add new Federated Analytics with Pandas example** "
"([#1469](https://github.com/adap/flower/pull/1469), "
"[#1535](https://github.com/adap/flower/pull/1535))"
msgstr ""

#: ../../source/ref-changelog.md:1788
msgid ""
"A new code example (`quickstart-pandas`) demonstrates federated analytics"
" with Pandas and Flower. You can find it here: [quickstart-"
"pandas](https://github.com/adap/flower/tree/main/examples/quickstart-"
"pandas)."
msgstr ""

#: ../../source/ref-changelog.md:1790
msgid ""
"**Add new strategies: Krum and MultiKrum** "
"([#1481](https://github.com/adap/flower/pull/1481))"
msgstr ""

#: ../../source/ref-changelog.md:1792
msgid ""
"Edoardo, a computer science student at the Sapienza University of Rome, "
"contributed a new `Krum` strategy that enables users to easily use Krum "
"and MultiKrum in their workloads."
msgstr ""

#: ../../source/ref-changelog.md:1794
msgid ""
"**Update C++ example to be compatible with Flower v1.2.0** "
"([#1495](https://github.com/adap/flower/pull/1495))"
msgstr ""

#: ../../source/ref-changelog.md:1796
msgid ""
"The C++ code example has received a substantial update to make it "
"compatible with the latest version of Flower."
msgstr ""

#: ../../source/ref-changelog.md:1798
msgid ""
"**General improvements** "
"([#1491](https://github.com/adap/flower/pull/1491), "
"[#1504](https://github.com/adap/flower/pull/1504), "
"[#1506](https://github.com/adap/flower/pull/1506), "
"[#1514](https://github.com/adap/flower/pull/1514), "
"[#1522](https://github.com/adap/flower/pull/1522), "
"[#1523](https://github.com/adap/flower/pull/1523), "
"[#1526](https://github.com/adap/flower/pull/1526), "
"[#1528](https://github.com/adap/flower/pull/1528), "
"[#1547](https://github.com/adap/flower/pull/1547), "
"[#1549](https://github.com/adap/flower/pull/1549), "
"[#1560](https://github.com/adap/flower/pull/1560), "
"[#1564](https://github.com/adap/flower/pull/1564), "
"[#1566](https://github.com/adap/flower/pull/1566))"
msgstr ""

#: ../../source/ref-changelog.md:1802
msgid ""
"**Updated documentation** "
"([#1494](https://github.com/adap/flower/pull/1494), "
"[#1496](https://github.com/adap/flower/pull/1496), "
"[#1500](https://github.com/adap/flower/pull/1500), "
"[#1503](https://github.com/adap/flower/pull/1503), "
"[#1505](https://github.com/adap/flower/pull/1505), "
"[#1524](https://github.com/adap/flower/pull/1524), "
"[#1518](https://github.com/adap/flower/pull/1518), "
"[#1519](https://github.com/adap/flower/pull/1519), "
"[#1515](https://github.com/adap/flower/pull/1515))"
msgstr ""

#: ../../source/ref-changelog.md:1806
msgid ""
"One highlight is the new [first time contributor "
"guide](https://flower.ai/docs/first-time-contributors.html): if you've "
"never contributed on GitHub before, this is the perfect place to start!"
msgstr ""

#: ../../source/ref-changelog.md:1812
msgid "v1.1.0 (2022-10-31)"
msgstr ""

#: ../../source/ref-changelog.md:1816
msgid ""
"We would like to give our **special thanks** to all the contributors who "
"made the new version of Flower possible (in `git shortlog` order):"
msgstr ""

#: ../../source/ref-changelog.md:1818
msgid ""
"`Akis Linardos`, `Christopher S`, `Daniel J. Beutel`, `George`, `Jan "
"Schlicht`, `Mohammad Fares`, `Pedro Porto Buarque de Gusmão`, `Philipp "
"Wiesner`, `Rob Luke`, `Taner Topal`, `VasundharaAgarwal`, "
"`danielnugraha`, `edogab33`"
msgstr ""

#: ../../source/ref-changelog.md:1822
msgid ""
"**Introduce Differential Privacy wrappers (preview)** "
"([#1357](https://github.com/adap/flower/pull/1357), "
"[#1460](https://github.com/adap/flower/pull/1460))"
msgstr ""

#: ../../source/ref-changelog.md:1824
msgid ""
"The first (experimental) preview of pluggable Differential Privacy "
"wrappers enables easy configuration and usage of differential privacy "
"(DP). The pluggable DP wrappers enable framework-agnostic **and** "
"strategy-agnostic usage of both client-side DP and server-side DP. Head "
"over to the Flower docs, a new explainer goes into more detail."
msgstr ""

#: ../../source/ref-changelog.md:1826
msgid ""
"**New iOS CoreML code example** "
"([#1289](https://github.com/adap/flower/pull/1289))"
msgstr ""

#: ../../source/ref-changelog.md:1828
msgid ""
"Flower goes iOS! A massive new code example shows how Flower clients can "
"be built for iOS. The code example contains both Flower iOS SDK "
"components that can be used for many tasks, and one task example running "
"on CoreML."
msgstr ""

#: ../../source/ref-changelog.md:1830
msgid ""
"**New FedMedian strategy** "
"([#1461](https://github.com/adap/flower/pull/1461))"
msgstr ""

#: ../../source/ref-changelog.md:1832
msgid ""
"The new `FedMedian` strategy implements Federated Median (FedMedian) by "
"[Yin et al., 2018](https://arxiv.org/pdf/1803.01498v1.pdf)."
msgstr ""

#: ../../source/ref-changelog.md:1834
msgid ""
"**Log** `Client` **exceptions in Virtual Client Engine** "
"([#1493](https://github.com/adap/flower/pull/1493))"
msgstr ""

#: ../../source/ref-changelog.md:1836
msgid ""
"All `Client` exceptions happening in the VCE are now logged by default "
"and not just exposed to the configured `Strategy` (via the `failures` "
"argument)."
msgstr ""

#: ../../source/ref-changelog.md:1838
msgid ""
"**Improve Virtual Client Engine internals** "
"([#1401](https://github.com/adap/flower/pull/1401), "
"[#1453](https://github.com/adap/flower/pull/1453))"
msgstr ""

#: ../../source/ref-changelog.md:1840
msgid ""
"Some internals of the Virtual Client Engine have been revamped. The VCE "
"now uses Ray 2.0 under the hood, the value type of the `client_resources`"
" dictionary changed to `float` to allow fractions of resources to be "
"allocated."
msgstr ""

#: ../../source/ref-changelog.md:1842
msgid ""
"**Support optional** `Client`**/**`NumPyClient` **methods in Virtual "
"Client Engine**"
msgstr ""

#: ../../source/ref-changelog.md:1844
msgid ""
"The Virtual Client Engine now has full support for optional `Client` (and"
" `NumPyClient`) methods."
msgstr ""

#: ../../source/ref-changelog.md:1846
msgid ""
"**Provide type information to packages using** `flwr` "
"([#1377](https://github.com/adap/flower/pull/1377))"
msgstr ""

#: ../../source/ref-changelog.md:1848
msgid ""
"The package `flwr` is now bundled with a `py.typed` file indicating that "
"the package is typed. This enables typing support for projects or "
"packages that use `flwr` by enabling them to improve their code using "
"static type checkers like `mypy`."
msgstr ""

#: ../../source/ref-changelog.md:1850
msgid ""
"**Updated code example** "
"([#1344](https://github.com/adap/flower/pull/1344), "
"[#1347](https://github.com/adap/flower/pull/1347))"
msgstr ""

#: ../../source/ref-changelog.md:1852
msgid ""
"The code examples covering scikit-learn and PyTorch Lightning have been "
"updated to work with the latest version of Flower."
msgstr ""

#: ../../source/ref-changelog.md:1854
msgid ""
"**Updated documentation** "
"([#1355](https://github.com/adap/flower/pull/1355), "
"[#1379](https://github.com/adap/flower/pull/1379), "
"[#1380](https://github.com/adap/flower/pull/1380), "
"[#1381](https://github.com/adap/flower/pull/1381), "
"[#1332](https://github.com/adap/flower/pull/1332), "
"[#1391](https://github.com/adap/flower/pull/1391), "
"[#1403](https://github.com/adap/flower/pull/1403), "
"[#1364](https://github.com/adap/flower/pull/1364), "
"[#1409](https://github.com/adap/flower/pull/1409), "
"[#1419](https://github.com/adap/flower/pull/1419), "
"[#1444](https://github.com/adap/flower/pull/1444), "
"[#1448](https://github.com/adap/flower/pull/1448), "
"[#1417](https://github.com/adap/flower/pull/1417), "
"[#1449](https://github.com/adap/flower/pull/1449), "
"[#1465](https://github.com/adap/flower/pull/1465), "
"[#1467](https://github.com/adap/flower/pull/1467))"
msgstr ""

#: ../../source/ref-changelog.md:1856
msgid ""
"There have been so many documentation updates that it doesn't even make "
"sense to list them individually."
msgstr ""

#: ../../source/ref-changelog.md:1858
msgid ""
"**Restructured documentation** "
"([#1387](https://github.com/adap/flower/pull/1387))"
msgstr ""

#: ../../source/ref-changelog.md:1860
msgid ""
"The documentation has been restructured to make it easier to navigate. "
"This is just the first step in a larger effort to make the Flower "
"documentation the best documentation of any project ever. Stay tuned!"
msgstr ""

#: ../../source/ref-changelog.md:1862
msgid ""
"**Open in Colab button** "
"([#1389](https://github.com/adap/flower/pull/1389))"
msgstr ""

#: ../../source/ref-changelog.md:1864
msgid ""
"The four parts of the Flower Federated Learning Tutorial now come with a "
"new `Open in Colab` button. No need to install anything on your local "
"machine, you can now use and learn about Flower in your browser, it's "
"only a single click away."
msgstr ""

#: ../../source/ref-changelog.md:1866
msgid ""
"**Improved tutorial** ([#1468](https://github.com/adap/flower/pull/1468),"
" [#1470](https://github.com/adap/flower/pull/1470), "
"[#1472](https://github.com/adap/flower/pull/1472), "
"[#1473](https://github.com/adap/flower/pull/1473), "
"[#1474](https://github.com/adap/flower/pull/1474), "
"[#1475](https://github.com/adap/flower/pull/1475))"
msgstr ""

#: ../../source/ref-changelog.md:1868
msgid ""
"The Flower Federated Learning Tutorial has two brand-new parts covering "
"custom strategies (still WIP) and the distinction between `Client` and "
"`NumPyClient`. The existing parts one and two have also been improved "
"(many small changes and fixes)."
msgstr ""

#: ../../source/ref-changelog.md:1874
msgid "v1.0.0 (2022-07-28)"
msgstr ""

#: ../../source/ref-changelog.md:1876
msgid "Highlights"
msgstr ""

#: ../../source/ref-changelog.md:1878
msgid "Stable **Virtual Client Engine** (accessible via `start_simulation`)"
msgstr ""

#: ../../source/ref-changelog.md:1879
msgid "All `Client`/`NumPyClient` methods are now optional"
msgstr ""

#: ../../source/ref-changelog.md:1880
msgid "Configurable `get_parameters`"
msgstr ""

#: ../../source/ref-changelog.md:1881
msgid ""
"Tons of small API cleanups resulting in a more coherent developer "
"experience"
msgstr ""

#: ../../source/ref-changelog.md:1885
msgid ""
"We would like to give our **special thanks** to all the contributors who "
"made Flower 1.0 possible (in reverse [GitHub "
"Contributors](https://github.com/adap/flower/graphs/contributors) order):"
msgstr ""

#: ../../source/ref-changelog.md:1887
msgid ""
"[@rtaiello](https://github.com/rtaiello), "
"[@g-pichler](https://github.com/g-pichler), [@rob-"
"luke](https://github.com/rob-luke), [@andreea-zaharia](https://github.com"
"/andreea-zaharia), [@kinshukdua](https://github.com/kinshukdua), "
"[@nfnt](https://github.com/nfnt), "
"[@tatiana-s](https://github.com/tatiana-s), "
"[@TParcollet](https://github.com/TParcollet), "
"[@vballoli](https://github.com/vballoli), "
"[@negedng](https://github.com/negedng), "
"[@RISHIKESHAVAN](https://github.com/RISHIKESHAVAN), "
"[@hei411](https://github.com/hei411), "
"[@SebastianSpeitel](https://github.com/SebastianSpeitel), "
"[@AmitChaulwar](https://github.com/AmitChaulwar), "
"[@Rubiel1](https://github.com/Rubiel1), [@FANTOME-PAN](https://github.com"
"/FANTOME-PAN), [@Rono-BC](https://github.com/Rono-BC), "
"[@lbhm](https://github.com/lbhm), "
"[@sishtiaq](https://github.com/sishtiaq), "
"[@remde](https://github.com/remde), [@Jueun-Park](https://github.com"
"/Jueun-Park), [@architjen](https://github.com/architjen), "
"[@PratikGarai](https://github.com/PratikGarai), "
"[@mrinaald](https://github.com/mrinaald), "
"[@zliel](https://github.com/zliel), "
"[@MeiruiJiang](https://github.com/MeiruiJiang), "
"[@sancarlim](https://github.com/sancarlim), "
"[@gubertoli](https://github.com/gubertoli), "
"[@Vingt100](https://github.com/Vingt100), "
"[@MakGulati](https://github.com/MakGulati), "
"[@cozek](https://github.com/cozek), "
"[@jafermarq](https://github.com/jafermarq), "
"[@sisco0](https://github.com/sisco0), "
"[@akhilmathurs](https://github.com/akhilmathurs), "
"[@CanTuerk](https://github.com/CanTuerk), "
"[@mariaboerner1987](https://github.com/mariaboerner1987), "
"[@pedropgusmao](https://github.com/pedropgusmao), "
"[@tanertopal](https://github.com/tanertopal), "
"[@danieljanes](https://github.com/danieljanes)."
msgstr ""

#: ../../source/ref-changelog.md:1891
msgid ""
"**All arguments must be passed as keyword arguments** "
"([#1338](https://github.com/adap/flower/pull/1338))"
msgstr ""

#: ../../source/ref-changelog.md:1893
msgid ""
"Pass all arguments as keyword arguments, positional arguments are not "
"longer supported. Code that uses positional arguments (e.g., "
"`start_client(\"127.0.0.1:8080\", FlowerClient())`) must add the keyword "
"for each positional argument (e.g., "
"`start_client(server_address=\"127.0.0.1:8080\", "
"client=FlowerClient())`)."
msgstr ""

#: ../../source/ref-changelog.md:1895
msgid ""
"**Introduce configuration object** `ServerConfig` **in** `start_server` "
"**and** `start_simulation` "
"([#1317](https://github.com/adap/flower/pull/1317))"
msgstr ""

#: ../../source/ref-changelog.md:1897
#, python-brace-format
msgid ""
"Instead of a config dictionary `{\"num_rounds\": 3, \"round_timeout\": "
"600.0}`, `start_server` and `start_simulation` now expect a configuration"
" object of type `flwr.server.ServerConfig`. `ServerConfig` takes the same"
" arguments that as the previous config dict, but it makes writing type-"
"safe code easier and the default parameters values more transparent."
msgstr ""

#: ../../source/ref-changelog.md:1899
msgid ""
"**Enhance Strategy evaluation API for clarity and consistency** "
"([#1334](https://github.com/adap/flower/pull/1334))"
msgstr ""

#: ../../source/ref-changelog.md:1901
msgid ""
"The following built-in strategy parameters were renamed to improve "
"readability and consistency with other API's:"
msgstr ""

#: ../../source/ref-changelog.md:1903
msgid "`fraction_eval` --> `fraction_evaluate`"
msgstr ""

#: ../../source/ref-changelog.md:1904
msgid "`min_eval_clients` --> `min_evaluate_clients`"
msgstr ""

#: ../../source/ref-changelog.md:1905
msgid "`eval_fn` --> `evaluate_fn`"
msgstr ""

#: ../../source/ref-changelog.md:1907
msgid ""
"The `Strategy` method `evaluate` now receives the current round of "
"federated learning/evaluation as the first parameter."
msgstr ""

#: ../../source/ref-changelog.md:1909
msgid ""
"The `evaluate_fn` passed to built-in strategies like `FedAvg` now takes "
"three parameters: (1) The current round of federated learning/evaluation "
"(`server_round`), (2) the model parameters to evaluate (`parameters`), "
"and (3) a config dictionary (`config`)."
msgstr ""

#: ../../source/ref-changelog.md:1911
msgid ""
"**Update default arguments of built-in strategies** "
"([#1278](https://github.com/adap/flower/pull/1278))"
msgstr ""

#: ../../source/ref-changelog.md:1913
msgid ""
"All built-in strategies now use `fraction_fit=1.0` and "
"`fraction_evaluate=1.0`, which means they select *all* currently "
"available clients for training and evaluation. Projects that relied on "
"the previous default values can get the previous behaviour by "
"initializing the strategy in the following way:"
msgstr ""

#: ../../source/ref-changelog.md:1915
msgid "`strategy = FedAvg(fraction_fit=0.1, fraction_evaluate=0.1)`"
msgstr ""

#: ../../source/ref-changelog.md:1917
msgid ""
"**Rename** `rnd` **to** `server_round` "
"([#1321](https://github.com/adap/flower/pull/1321))"
msgstr ""

#: ../../source/ref-changelog.md:1919
msgid ""
"Several Flower methods and functions (`evaluate_fn`, `configure_fit`, "
"`aggregate_fit`, `configure_evaluate`, `aggregate_evaluate`) receive the "
"current round of federated learning/evaluation as their first parameter. "
"To improve reaability and avoid confusion with *random*, this parameter "
"has been renamed from `rnd` to `server_round`."
msgstr ""

#: ../../source/ref-changelog.md:1921
msgid ""
"**Move** `flwr.dataset` **to** `flwr_baselines` "
"([#1273](https://github.com/adap/flower/pull/1273))"
msgstr ""

#: ../../source/ref-changelog.md:1923
msgid "The experimental package `flwr.dataset` was migrated to Flower Baselines."
msgstr ""

#: ../../source/ref-changelog.md:1925
msgid ""
"**Remove experimental strategies** "
"([#1280](https://github.com/adap/flower/pull/1280))"
msgstr ""

#: ../../source/ref-changelog.md:1927
msgid ""
"Remove unmaintained experimental strategies (`FastAndSlow`, `FedFSv0`, "
"`FedFSv1`)."
msgstr ""

#: ../../source/ref-changelog.md:1929
msgid ""
"**Rename** `Weights` **to** `NDArrays` "
"([#1296](https://github.com/adap/flower/pull/1296))"
msgstr ""

#: ../../source/ref-changelog.md:1931
msgid ""
"`flwr.common.Weights` was renamed to `flwr.common.NDArrays` to better "
"capture what this type is all about."
msgstr ""

#: ../../source/ref-changelog.md:1933
msgid ""
"**Remove antiquated** `force_final_distributed_eval` **from** "
"`start_server` ([#1315](https://github.com/adap/flower/pull/1315))"
msgstr ""

#: ../../source/ref-changelog.md:1935
msgid ""
"The `start_server` parameter `force_final_distributed_eval` has long been"
" a historic artefact, in this release it is finally gone for good."
msgstr ""

#: ../../source/ref-changelog.md:1937
msgid ""
"**Make** `get_parameters` **configurable** "
"([#1242](https://github.com/adap/flower/pull/1242))"
msgstr ""

#: ../../source/ref-changelog.md:1939
msgid ""
"The `get_parameters` method now accepts a configuration dictionary, just "
"like `get_properties`, `fit`, and `evaluate`."
msgstr ""

#: ../../source/ref-changelog.md:1941
msgid ""
"**Update** `start_simulation` **to align with** `start_server` "
"([#1281](https://github.com/adap/flower/pull/1281))"
msgstr ""

#: ../../source/ref-changelog.md:1943
msgid ""
"The `start_simulation` function now accepts a configuration dictionary "
"`config` instead of the `num_rounds` integer. This improves the "
"consistency between `start_simulation` and `start_server` and makes "
"transitioning between the two easier. Additionally, `start_simulation` "
"now accepts a full `Server` instance. This enables users to heavily "
"customize the execution of eperiments and opens the door to running, for "
"example, async FL using the Virtual Client Engine."
msgstr ""

#: ../../source/ref-changelog.md:1947
msgid ""
"**Support Python 3.10** "
"([#1320](https://github.com/adap/flower/pull/1320))"
msgstr ""

#: ../../source/ref-changelog.md:1949
msgid ""
"The previous Flower release introduced experimental support for Python "
"3.10, this release declares Python 3.10 support as stable."
msgstr ""

#: ../../source/ref-changelog.md:1951
msgid ""
"**Make all** `Client` **and** `NumPyClient` **methods optional** "
"([#1260](https://github.com/adap/flower/pull/1260), "
"[#1277](https://github.com/adap/flower/pull/1277))"
msgstr ""

#: ../../source/ref-changelog.md:1953
msgid ""
"The `Client`/`NumPyClient` methods `get_properties`, `get_parameters`, "
"`fit`, and `evaluate` are all optional. This enables writing clients that"
" implement, for example, only `fit`, but no other method. No need to "
"implement `evaluate` when using centralized evaluation!"
msgstr ""

#: ../../source/ref-changelog.md:1955
msgid ""
"Similar to `start_server`, `start_simulation` now accepts a full `Server`"
" instance. This enables users to heavily customize the execution of "
"eperiments and opens the door to running, for example, async FL using the"
" Virtual Client Engine."
msgstr ""

#: ../../source/ref-changelog.md:1957
msgid ""
"**Update code examples** "
"([#1291](https://github.com/adap/flower/pull/1291), "
"[#1286](https://github.com/adap/flower/pull/1286), "
"[#1282](https://github.com/adap/flower/pull/1282))"
msgstr ""

#: ../../source/ref-changelog.md:1959
msgid ""
"Many code examples received small or even large maintenance updates, "
"among them are"
msgstr ""

#: ../../source/ref-changelog.md:1961
msgid "`scikit-learn`"
msgstr ""

#: ../../source/ref-changelog.md:1962
msgid "`simulation_pytorch`"
msgstr ""

#: ../../source/ref-changelog.md:1963
msgid "`quickstart_pytorch`"
msgstr ""

#: ../../source/ref-changelog.md:1964
msgid "`quickstart_simulation`"
msgstr ""

#: ../../source/ref-changelog.md:1965
msgid "`quickstart_tensorflow`"
msgstr ""

#: ../../source/ref-changelog.md:1966
msgid "`advanced_tensorflow`"
msgstr ""

#: ../../source/ref-changelog.md:1968
msgid ""
"**Remove the obsolete simulation example** "
"([#1328](https://github.com/adap/flower/pull/1328))"
msgstr ""

#: ../../source/ref-changelog.md:1970
msgid ""
"Removes the obsolete `simulation` example and renames "
"`quickstart_simulation` to `simulation_tensorflow` so it fits withs the "
"naming of `simulation_pytorch`"
msgstr ""

#: ../../source/ref-changelog.md:1972
msgid ""
"**Update documentation** "
"([#1223](https://github.com/adap/flower/pull/1223), "
"[#1209](https://github.com/adap/flower/pull/1209), "
"[#1251](https://github.com/adap/flower/pull/1251), "
"[#1257](https://github.com/adap/flower/pull/1257), "
"[#1267](https://github.com/adap/flower/pull/1267), "
"[#1268](https://github.com/adap/flower/pull/1268), "
"[#1300](https://github.com/adap/flower/pull/1300), "
"[#1304](https://github.com/adap/flower/pull/1304), "
"[#1305](https://github.com/adap/flower/pull/1305), "
"[#1307](https://github.com/adap/flower/pull/1307))"
msgstr ""

#: ../../source/ref-changelog.md:1974
msgid ""
"One substantial documentation update fixes multiple smaller rendering "
"issues, makes titles more succinct to improve navigation, removes a "
"deprecated library, updates documentation dependencies, includes the "
"`flwr.common` module in the API reference, includes support for markdown-"
"based documentation, migrates the changelog from `.rst` to `.md`, and "
"fixes a number of smaller details!"
msgstr ""

#: ../../source/ref-changelog.md:1976 ../../source/ref-changelog.md:2030
#: ../../source/ref-changelog.md:2104 ../../source/ref-changelog.md:2143
msgid "**Minor updates**"
msgstr ""

#: ../../source/ref-changelog.md:1978
msgid ""
"Add round number to fit and evaluate log messages "
"([#1266](https://github.com/adap/flower/pull/1266))"
msgstr ""

#: ../../source/ref-changelog.md:1979
msgid ""
"Update developer tooling "
"([#1231](https://github.com/adap/flower/pull/1231), "
"[#1276](https://github.com/adap/flower/pull/1276), "
"[#1301](https://github.com/adap/flower/pull/1301), "
"[#1310](https://github.com/adap/flower/pull/1310))"
msgstr ""

#: ../../source/ref-changelog.md:1980
msgid ""
"Rename ProtoBuf messages to improve consistency "
"([#1214](https://github.com/adap/flower/pull/1214), "
"[#1258](https://github.com/adap/flower/pull/1258), "
"[#1259](https://github.com/adap/flower/pull/1259))"
msgstr ""

#: ../../source/ref-changelog.md:1982
msgid "v0.19.0 (2022-05-18)"
msgstr ""

#: ../../source/ref-changelog.md:1986
msgid ""
"**Flower Baselines (preview): FedOpt, FedBN, FedAvgM** "
"([#919](https://github.com/adap/flower/pull/919), "
"[#1127](https://github.com/adap/flower/pull/1127), "
"[#914](https://github.com/adap/flower/pull/914))"
msgstr ""

#: ../../source/ref-changelog.md:1988
msgid ""
"The first preview release of Flower Baselines has arrived! We're "
"kickstarting Flower Baselines with implementations of FedOpt (FedYogi, "
"FedAdam, FedAdagrad), FedBN, and FedAvgM. Check the documentation on how "
"to use [Flower Baselines](https://flower.ai/docs/using-baselines.html). "
"With this first preview release we're also inviting the community to "
"[contribute their own baselines](https://flower.ai/docs/baselines/how-to-"
"contribute-baselines.html)."
msgstr ""

#: ../../source/ref-changelog.md:1990
msgid ""
"**C++ client SDK (preview) and code example** "
"([#1111](https://github.com/adap/flower/pull/1111))"
msgstr ""

#: ../../source/ref-changelog.md:1992
msgid ""
"Preview support for Flower clients written in C++. The C++ preview "
"includes a Flower client SDK and a quickstart code example that "
"demonstrates a simple C++ client using the SDK."
msgstr ""

#: ../../source/ref-changelog.md:1994
msgid ""
"**Add experimental support for Python 3.10 and Python 3.11** "
"([#1135](https://github.com/adap/flower/pull/1135))"
msgstr ""

#: ../../source/ref-changelog.md:1996
msgid ""
"Python 3.10 is the latest stable release of Python and Python 3.11 is due"
" to be released in October. This Flower release adds experimental support"
" for both Python versions."
msgstr ""

#: ../../source/ref-changelog.md:1998
msgid ""
"**Aggregate custom metrics through user-provided functions** "
"([#1144](https://github.com/adap/flower/pull/1144))"
msgstr ""

#: ../../source/ref-changelog.md:2000
msgid ""
"Custom metrics (e.g., `accuracy`) can now be aggregated without having to"
" customize the strategy. Built-in strategies support two new arguments, "
"`fit_metrics_aggregation_fn` and `evaluate_metrics_aggregation_fn`, that "
"allow passing custom metric aggregation functions."
msgstr ""

#: ../../source/ref-changelog.md:2002
msgid ""
"**User-configurable round timeout** "
"([#1162](https://github.com/adap/flower/pull/1162))"
msgstr ""

#: ../../source/ref-changelog.md:2004
msgid ""
"A new configuration value allows the round timeout to be set for "
"`start_server` and `start_simulation`. If the `config` dictionary "
"contains a `round_timeout` key (with a `float` value in seconds), the "
"server will wait *at least* `round_timeout` seconds before it closes the "
"connection."
msgstr ""

#: ../../source/ref-changelog.md:2006
msgid ""
"**Enable both federated evaluation and centralized evaluation to be used "
"at the same time in all built-in strategies** "
"([#1091](https://github.com/adap/flower/pull/1091))"
msgstr ""

#: ../../source/ref-changelog.md:2008
msgid ""
"Built-in strategies can now perform both federated evaluation (i.e., "
"client-side) and centralized evaluation (i.e., server-side) in the same "
"round. Federated evaluation can be disabled by setting `fraction_eval` to"
" `0.0`."
msgstr ""

#: ../../source/ref-changelog.md:2010
msgid ""
"**Two new Jupyter Notebook tutorials** "
"([#1141](https://github.com/adap/flower/pull/1141))"
msgstr ""

#: ../../source/ref-changelog.md:2012
msgid ""
"Two Jupyter Notebook tutorials (compatible with Google Colab) explain "
"basic and intermediate Flower features:"
msgstr ""

#: ../../source/ref-changelog.md:2014
msgid ""
"*An Introduction to Federated Learning*: [Open in "
"Colab](https://colab.research.google.com/github/adap/flower/blob/main/tutorials/Flower-1"
"-Intro-to-FL-PyTorch.ipynb)"
msgstr ""

#: ../../source/ref-changelog.md:2016
msgid ""
"*Using Strategies in Federated Learning*: [Open in "
"Colab](https://colab.research.google.com/github/adap/flower/blob/main/tutorials/Flower-2"
"-Strategies-in-FL-PyTorch.ipynb)"
msgstr ""

#: ../../source/ref-changelog.md:2018
msgid ""
"**New FedAvgM strategy (Federated Averaging with Server Momentum)** "
"([#1076](https://github.com/adap/flower/pull/1076))"
msgstr ""

#: ../../source/ref-changelog.md:2020
msgid ""
"The new `FedAvgM` strategy implements Federated Averaging with Server "
"Momentum [Hsu et al., 2019]."
msgstr ""

#: ../../source/ref-changelog.md:2022
msgid ""
"**New advanced PyTorch code example** "
"([#1007](https://github.com/adap/flower/pull/1007))"
msgstr ""

#: ../../source/ref-changelog.md:2024
msgid ""
"A new code example (`advanced_pytorch`) demonstrates advanced Flower "
"concepts with PyTorch."
msgstr ""

#: ../../source/ref-changelog.md:2026
msgid ""
"**New JAX code example** "
"([#906](https://github.com/adap/flower/pull/906), "
"[#1143](https://github.com/adap/flower/pull/1143))"
msgstr ""

#: ../../source/ref-changelog.md:2028
msgid ""
"A new code example (`jax_from_centralized_to_federated`) shows federated "
"learning with JAX and Flower."
msgstr ""

#: ../../source/ref-changelog.md:2032
msgid ""
"New option to keep Ray running if Ray was already initialized in "
"`start_simulation` ([#1177](https://github.com/adap/flower/pull/1177))"
msgstr ""

#: ../../source/ref-changelog.md:2033
msgid ""
"Add support for custom `ClientManager` as a `start_simulation` parameter "
"([#1171](https://github.com/adap/flower/pull/1171))"
msgstr ""

#: ../../source/ref-changelog.md:2034
msgid ""
"New documentation for [implementing "
"strategies](https://flower.ai/docs/framework/how-to-implement-"
"strategies.html) ([#1097](https://github.com/adap/flower/pull/1097), "
"[#1175](https://github.com/adap/flower/pull/1175))"
msgstr ""

#: ../../source/ref-changelog.md:2035
msgid ""
"New mobile-friendly documentation theme "
"([#1174](https://github.com/adap/flower/pull/1174))"
msgstr ""

#: ../../source/ref-changelog.md:2036
msgid ""
"Limit version range for (optional) `ray` dependency to include only "
"compatible releases (`>=1.9.2,<1.12.0`) "
"([#1205](https://github.com/adap/flower/pull/1205))"
msgstr ""

#: ../../source/ref-changelog.md:2040
msgid ""
"**Remove deprecated DefaultStrategy strategy** "
"([#1142](https://github.com/adap/flower/pull/1142))"
msgstr ""

#: ../../source/ref-changelog.md:2042
msgid ""
"Removes the deprecated `DefaultStrategy` strategy, along with deprecated "
"support for the `eval_fn` accuracy return value and passing initial "
"parameters as NumPy ndarrays."
msgstr ""

#: ../../source/ref-changelog.md:2044
msgid ""
"**Remove deprecated support for Python 3.6** "
"([#871](https://github.com/adap/flower/pull/871))"
msgstr ""

#: ../../source/ref-changelog.md:2046
msgid ""
"**Remove deprecated KerasClient** "
"([#857](https://github.com/adap/flower/pull/857))"
msgstr ""

#: ../../source/ref-changelog.md:2048
msgid ""
"**Remove deprecated no-op extra installs** "
"([#973](https://github.com/adap/flower/pull/973))"
msgstr ""

#: ../../source/ref-changelog.md:2050
msgid ""
"**Remove deprecated proto fields from** `FitRes` **and** `EvaluateRes` "
"([#870](https://github.com/adap/flower/pull/870))"
msgstr ""

#: ../../source/ref-changelog.md:2052
msgid ""
"**Remove deprecated QffedAvg strategy (replaced by QFedAvg)** "
"([#1107](https://github.com/adap/flower/pull/1107))"
msgstr ""

#: ../../source/ref-changelog.md:2054
msgid "v0.18.0 (2022-02-28)"
msgstr ""

#: ../../source/ref-changelog.md:2058
msgid ""
"**Improved Virtual Client Engine compatibility with Jupyter Notebook / "
"Google Colab** ([#866](https://github.com/adap/flower/pull/866), "
"[#872](https://github.com/adap/flower/pull/872), "
"[#1036](https://github.com/adap/flower/pull/1036))"
msgstr ""

#: ../../source/ref-changelog.md:2060
msgid ""
"Simulations (using the Virtual Client Engine through `start_simulation`) "
"now work more smoothly on Jupyter Notebooks (incl. Google Colab) after "
"installing Flower with the `simulation` extra (`pip install "
"'flwr[simulation]'`)."
msgstr ""

#: ../../source/ref-changelog.md:2062
msgid ""
"**New Jupyter Notebook code example** "
"([#833](https://github.com/adap/flower/pull/833))"
msgstr ""

#: ../../source/ref-changelog.md:2064
msgid ""
"A new code example (`quickstart_simulation`) demonstrates Flower "
"simulations using the Virtual Client Engine through Jupyter Notebook "
"(incl. Google Colab)."
msgstr ""

#: ../../source/ref-changelog.md:2066
msgid ""
"**Client properties (feature preview)** "
"([#795](https://github.com/adap/flower/pull/795))"
msgstr ""

#: ../../source/ref-changelog.md:2068
msgid ""
"Clients can implement a new method `get_properties` to enable server-side"
" strategies to query client properties."
msgstr ""

#: ../../source/ref-changelog.md:2070
msgid ""
"**Experimental Android support with TFLite** "
"([#865](https://github.com/adap/flower/pull/865))"
msgstr ""

#: ../../source/ref-changelog.md:2072
msgid ""
"Android support has finally arrived in `main`! Flower is both client-"
"agnostic and framework-agnostic by design. One can integrate arbitrary "
"client platforms and with this release, using Flower on Android has "
"become a lot easier."
msgstr ""

#: ../../source/ref-changelog.md:2074
msgid ""
"The example uses TFLite on the client side, along with a new "
"`FedAvgAndroid` strategy. The Android client and `FedAvgAndroid` are "
"still experimental, but they are a first step towards a fully-fledged "
"Android SDK and a unified `FedAvg` implementation that integrated the new"
" functionality from `FedAvgAndroid`."
msgstr ""

#: ../../source/ref-changelog.md:2076
msgid ""
"**Make gRPC keepalive time user-configurable and decrease default "
"keepalive time** ([#1069](https://github.com/adap/flower/pull/1069))"
msgstr ""

#: ../../source/ref-changelog.md:2078
msgid ""
"The default gRPC keepalive time has been reduced to increase the "
"compatibility of Flower with more cloud environments (for example, "
"Microsoft Azure). Users can configure the keepalive time to customize the"
" gRPC stack based on specific requirements."
msgstr ""

#: ../../source/ref-changelog.md:2080
msgid ""
"**New differential privacy example using Opacus and PyTorch** "
"([#805](https://github.com/adap/flower/pull/805))"
msgstr ""

#: ../../source/ref-changelog.md:2082
msgid ""
"A new code example (`opacus`) demonstrates differentially-private "
"federated learning with Opacus, PyTorch, and Flower."
msgstr ""

#: ../../source/ref-changelog.md:2084
msgid ""
"**New Hugging Face Transformers code example** "
"([#863](https://github.com/adap/flower/pull/863))"
msgstr ""

#: ../../source/ref-changelog.md:2086
msgid ""
"A new code example (`quickstart_huggingface`) demonstrates usage of "
"Hugging Face Transformers with Flower."
msgstr ""

#: ../../source/ref-changelog.md:2088
msgid ""
"**New MLCube code example** "
"([#779](https://github.com/adap/flower/pull/779), "
"[#1034](https://github.com/adap/flower/pull/1034), "
"[#1065](https://github.com/adap/flower/pull/1065), "
"[#1090](https://github.com/adap/flower/pull/1090))"
msgstr ""

#: ../../source/ref-changelog.md:2090
msgid ""
"A new code example (`quickstart_mlcube`) demonstrates usage of MLCube "
"with Flower."
msgstr ""

#: ../../source/ref-changelog.md:2092
msgid ""
"**SSL-enabled server and client** "
"([#842](https://github.com/adap/flower/pull/842), "
"[#844](https://github.com/adap/flower/pull/844), "
"[#845](https://github.com/adap/flower/pull/845), "
"[#847](https://github.com/adap/flower/pull/847), "
"[#993](https://github.com/adap/flower/pull/993), "
"[#994](https://github.com/adap/flower/pull/994))"
msgstr ""

#: ../../source/ref-changelog.md:2094
msgid ""
"SSL enables secure encrypted connections between clients and servers. "
"This release open-sources the Flower secure gRPC implementation to make "
"encrypted communication channels accessible to all Flower users. The "
"`advanced_tensorflow` code example now uses secure gRPC connection."
msgstr ""

#: ../../source/ref-changelog.md:2096
msgid ""
"**Updated** `FedAdam` **and** `FedYogi` **strategies** "
"([#885](https://github.com/adap/flower/pull/885), "
"[#895](https://github.com/adap/flower/pull/895))"
msgstr ""

#: ../../source/ref-changelog.md:2098
msgid ""
"`FedAdam` and `FedAdam` match the latest version of the Adaptive "
"Federated Optimization paper."
msgstr ""

#: ../../source/ref-changelog.md:2100
msgid ""
"**Initialize** `start_simulation` **with a list of client IDs** "
"([#860](https://github.com/adap/flower/pull/860))"
msgstr ""

#: ../../source/ref-changelog.md:2102
msgid ""
"`start_simulation` can now be called with a list of client IDs "
"(`clients_ids`, type: `List[str]`). Those IDs will be passed to the "
"`client_fn` whenever a client needs to be initialized, which can make it "
"easier to load data partitions that are not accessible through `int` "
"identifiers."
msgstr ""

#: ../../source/ref-changelog.md:2106
msgid ""
"Update `num_examples` calculation in PyTorch code examples in "
"([#909](https://github.com/adap/flower/pull/909))"
msgstr ""

#: ../../source/ref-changelog.md:2107
msgid ""
"Expose Flower version through `flwr.__version__` "
"([#952](https://github.com/adap/flower/pull/952))"
msgstr ""

#: ../../source/ref-changelog.md:2108
msgid ""
"`start_server` in `app.py` now returns a `History` object containing "
"metrics from training ([#974](https://github.com/adap/flower/pull/974))"
msgstr ""

#: ../../source/ref-changelog.md:2109
msgid ""
"Make `max_workers` (used by `ThreadPoolExecutor`) configurable "
"([#978](https://github.com/adap/flower/pull/978))"
msgstr ""

#: ../../source/ref-changelog.md:2110
msgid ""
"Increase sleep time after server start to three seconds in all code "
"examples ([#1086](https://github.com/adap/flower/pull/1086))"
msgstr ""

#: ../../source/ref-changelog.md:2111
msgid ""
"Added a new FAQ section to the documentation "
"([#948](https://github.com/adap/flower/pull/948))"
msgstr ""

#: ../../source/ref-changelog.md:2112
msgid ""
"And many more under-the-hood changes, library updates, documentation "
"changes, and tooling improvements!"
msgstr ""

#: ../../source/ref-changelog.md:2116
msgid ""
"**Removed** `flwr_example` **and** `flwr_experimental` **from release "
"build** ([#869](https://github.com/adap/flower/pull/869))"
msgstr ""

#: ../../source/ref-changelog.md:2118
msgid ""
"The packages `flwr_example` and `flwr_experimental` have been deprecated "
"since Flower 0.12.0 and they are not longer included in Flower release "
"builds. The associated extras (`baseline`, `examples-pytorch`, `examples-"
"tensorflow`, `http-logger`, `ops`) are now no-op and will be removed in "
"an upcoming release."
msgstr ""

#: ../../source/ref-changelog.md:2120
msgid "v0.17.0 (2021-09-24)"
msgstr ""

#: ../../source/ref-changelog.md:2124
msgid ""
"**Experimental virtual client engine** "
"([#781](https://github.com/adap/flower/pull/781) "
"[#790](https://github.com/adap/flower/pull/790))"
msgstr ""

#: ../../source/ref-changelog.md:2126
msgid ""
"One of Flower's goals is to enable research at scale. This release "
"enables a first (experimental) peek at a major new feature, codenamed the"
" virtual client engine. Virtual clients enable simulations that scale to "
"a (very) large number of clients on a single machine or compute cluster. "
"The easiest way to test the new functionality is to look at the two new "
"code examples called `quickstart_simulation` and `simulation_pytorch`."
msgstr ""

#: ../../source/ref-changelog.md:2128
msgid ""
"The feature is still experimental, so there's no stability guarantee for "
"the API. It's also not quite ready for prime time and comes with a few "
"known caveats. However, those who are curious are encouraged to try it "
"out and share their thoughts."
msgstr ""

#: ../../source/ref-changelog.md:2130
msgid ""
"**New built-in strategies** "
"([#828](https://github.com/adap/flower/pull/828) "
"[#822](https://github.com/adap/flower/pull/822))"
msgstr ""

#: ../../source/ref-changelog.md:2132
msgid ""
"FedYogi - Federated learning strategy using Yogi on server-side. "
"Implementation based on https://arxiv.org/abs/2003.00295"
msgstr ""

#: ../../source/ref-changelog.md:2133
msgid ""
"FedAdam - Federated learning strategy using Adam on server-side. "
"Implementation based on https://arxiv.org/abs/2003.00295"
msgstr ""

#: ../../source/ref-changelog.md:2135
msgid ""
"**New PyTorch Lightning code example** "
"([#617](https://github.com/adap/flower/pull/617))"
msgstr ""

#: ../../source/ref-changelog.md:2137
msgid ""
"**New Variational Auto-Encoder code example** "
"([#752](https://github.com/adap/flower/pull/752))"
msgstr ""

#: ../../source/ref-changelog.md:2139
msgid ""
"**New scikit-learn code example** "
"([#748](https://github.com/adap/flower/pull/748))"
msgstr ""

#: ../../source/ref-changelog.md:2141
msgid ""
"**New experimental TensorBoard strategy** "
"([#789](https://github.com/adap/flower/pull/789))"
msgstr ""

#: ../../source/ref-changelog.md:2145
msgid ""
"Improved advanced TensorFlow code example "
"([#769](https://github.com/adap/flower/pull/769))"
msgstr ""

#: ../../source/ref-changelog.md:2146
msgid ""
"Warning when `min_available_clients` is misconfigured "
"([#830](https://github.com/adap/flower/pull/830))"
msgstr ""

#: ../../source/ref-changelog.md:2147
msgid ""
"Improved gRPC server docs "
"([#841](https://github.com/adap/flower/pull/841))"
msgstr ""

#: ../../source/ref-changelog.md:2148
msgid ""
"Improved error message in `NumPyClient` "
"([#851](https://github.com/adap/flower/pull/851))"
msgstr ""

#: ../../source/ref-changelog.md:2149
msgid ""
"Improved PyTorch quickstart code example "
"([#852](https://github.com/adap/flower/pull/852))"
msgstr ""

#: ../../source/ref-changelog.md:2153
msgid ""
"**Disabled final distributed evaluation** "
"([#800](https://github.com/adap/flower/pull/800))"
msgstr ""

#: ../../source/ref-changelog.md:2155
msgid ""
"Prior behaviour was to perform a final round of distributed evaluation on"
" all connected clients, which is often not required (e.g., when using "
"server-side evaluation). The prior behaviour can be enabled by passing "
"`force_final_distributed_eval=True` to `start_server`."
msgstr ""

#: ../../source/ref-changelog.md:2157
msgid ""
"**Renamed q-FedAvg strategy** "
"([#802](https://github.com/adap/flower/pull/802))"
msgstr ""

#: ../../source/ref-changelog.md:2159
msgid ""
"The strategy named `QffedAvg` was renamed to `QFedAvg` to better reflect "
"the notation given in the original paper (q-FFL is the optimization "
"objective, q-FedAvg is the proposed solver). Note the original (now "
"deprecated) `QffedAvg` class is still available for compatibility reasons"
" (it will be removed in a future release)."
msgstr ""

#: ../../source/ref-changelog.md:2161
msgid ""
"**Deprecated and renamed code example** `simulation_pytorch` **to** "
"`simulation_pytorch_legacy` "
"([#791](https://github.com/adap/flower/pull/791))"
msgstr ""

#: ../../source/ref-changelog.md:2163
msgid ""
"This example has been replaced by a new example. The new example is based"
" on the experimental virtual client engine, which will become the new "
"default way of doing most types of large-scale simulations in Flower. The"
" existing example was kept for reference purposes, but it might be "
"removed in the future."
msgstr ""

#: ../../source/ref-changelog.md:2165
msgid "v0.16.0 (2021-05-11)"
msgstr ""

#: ../../source/ref-changelog.md:2169
msgid ""
"**New built-in strategies** "
"([#549](https://github.com/adap/flower/pull/549))"
msgstr ""

#: ../../source/ref-changelog.md:2171
msgid "(abstract) FedOpt"
msgstr ""

#: ../../source/ref-changelog.md:2174
msgid ""
"**Migration warnings for deprecated functionality** "
"([#690](https://github.com/adap/flower/pull/690))"
msgstr ""

#: ../../source/ref-changelog.md:2176
msgid ""
"Earlier versions of Flower were often migrated to new APIs, while "
"maintaining compatibility with legacy APIs. This release introduces "
"detailed warning messages if usage of deprecated APIs is detected. The "
"new warning messages often provide details on how to migrate to more "
"recent APIs, thus easing the transition from one release to another."
msgstr ""

#: ../../source/ref-changelog.md:2178
msgid ""
"Improved docs and docstrings "
"([#691](https://github.com/adap/flower/pull/691) "
"[#692](https://github.com/adap/flower/pull/692) "
"[#713](https://github.com/adap/flower/pull/713))"
msgstr ""

#: ../../source/ref-changelog.md:2180
msgid "MXNet example and documentation"
msgstr ""

#: ../../source/ref-changelog.md:2182
msgid ""
"FedBN implementation in example PyTorch: From Centralized To Federated "
"([#696](https://github.com/adap/flower/pull/696) "
"[#702](https://github.com/adap/flower/pull/702) "
"[#705](https://github.com/adap/flower/pull/705))"
msgstr ""

#: ../../source/ref-changelog.md:2186
msgid ""
"**Custom metrics for server and strategies** "
"([#717](https://github.com/adap/flower/pull/717))"
msgstr ""

#: ../../source/ref-changelog.md:2188
msgid ""
"The Flower server is now fully task-agnostic, all remaining instances of "
"task-specific metrics (such as `accuracy`) have been replaced by custom "
"metrics dictionaries. Flower 0.15 introduced the capability to pass a "
"dictionary containing custom metrics from client to server. As of this "
"release, custom metrics replace task-specific metrics on the server."
msgstr ""

#: ../../source/ref-changelog.md:2190
msgid ""
"Custom metric dictionaries are now used in two user-facing APIs: they are"
" returned from Strategy methods `aggregate_fit`/`aggregate_evaluate` and "
"they enable evaluation functions passed to built-in strategies (via "
"`eval_fn`) to return more than two evaluation metrics. Strategies can "
"even return *aggregated* metrics dictionaries for the server to keep "
"track of."
msgstr ""

#: ../../source/ref-changelog.md:2192
#, python-brace-format
msgid ""
"Strategy implementations should migrate their `aggregate_fit` and "
"`aggregate_evaluate` methods to the new return type (e.g., by simply "
"returning an empty `{}`), server-side evaluation functions should migrate"
" from `return loss, accuracy` to `return loss, {\"accuracy\": accuracy}`."
msgstr ""

#: ../../source/ref-changelog.md:2194
msgid ""
"Flower 0.15-style return types are deprecated (but still supported), "
"compatibility will be removed in a future release."
msgstr ""

#: ../../source/ref-changelog.md:2196
msgid ""
"Deprecated `flwr.server.Server.evaluate`, use "
"`flwr.server.Server.evaluate_round` instead"
msgstr ""

#: ../../source/ref-changelog.md:2198
msgid ""
"**Serialization-agnostic server** "
"([#721](https://github.com/adap/flower/pull/721))"
msgstr ""

#: ../../source/ref-changelog.md:2200
msgid ""
"The Flower server is now fully serialization-agnostic. Prior usage of "
"class `Weights` (which represents parameters as deserialized NumPy "
"ndarrays) was replaced by class `Parameters` (e.g., in `Strategy`). "
"`Parameters` objects are fully serialization-agnostic and represents "
"parameters as byte arrays, the `tensor_type` attributes indicates how "
"these byte arrays should be interpreted (e.g., for "
"serialization/deserialization)."
msgstr ""

#: ../../source/ref-changelog.md:2202
msgid ""
"Built-in strategies implement this approach by handling serialization and"
" deserialization to/from `Weights` internally. Custom/3rd-party Strategy "
"implementations should update to the slightly changed Strategy method "
"definitions. Strategy authors can consult [PR "
"#721](https://github.com/adap/flower/pull/721) to see how strategies can "
"easily migrate to the new format."
msgstr ""

#: ../../source/ref-changelog.md:2204
msgid "v0.15.0 (2021-03-12)"
msgstr ""

#: ../../source/ref-changelog.md:2208
msgid ""
"**Server-side parameter initialization** "
"([#658](https://github.com/adap/flower/pull/658))"
msgstr ""

#: ../../source/ref-changelog.md:2210
msgid ""
"Model parameters can now be initialized on the server-side. Server-side "
"parameter initialization works via a new `Strategy` method called "
"`initialize_parameters`."
msgstr ""

#: ../../source/ref-changelog.md:2212
msgid ""
"Built-in strategies support a new constructor argument called "
"`initial_parameters` to set the initial parameters. Built-in strategies "
"will provide these initial parameters to the server on startup and then "
"delete them to free the memory afterwards."
msgstr ""

#: ../../source/ref-changelog.md:2231
msgid ""
"If no initial parameters are provided to the strategy, the server will "
"continue to use the current behaviour (namely, it will ask one of the "
"connected clients for its parameters and use these as the initial global "
"parameters)."
msgstr ""

#: ../../source/ref-changelog.md:2235
msgid ""
"Deprecate `flwr.server.strategy.DefaultStrategy` (migrate to "
"`flwr.server.strategy.FedAvg`, which is equivalent)"
msgstr ""

#: ../../source/ref-changelog.md:2237
msgid "v0.14.0 (2021-02-18)"
msgstr ""

#: ../../source/ref-changelog.md:2241
msgid ""
"**Generalized** `Client.fit` **and** `Client.evaluate` **return values** "
"([#610](https://github.com/adap/flower/pull/610) "
"[#572](https://github.com/adap/flower/pull/572) "
"[#633](https://github.com/adap/flower/pull/633))"
msgstr ""

#: ../../source/ref-changelog.md:2243
msgid ""
"Clients can now return an additional dictionary mapping `str` keys to "
"values of the following types: `bool`, `bytes`, `float`, `int`, `str`. "
"This means one can return almost arbitrary values from `fit`/`evaluate` "
"and make use of them on the server side!"
msgstr ""

#: ../../source/ref-changelog.md:2245
msgid ""
"This improvement also allowed for more consistent return types between "
"`fit` and `evaluate`: `evaluate` should now return a tuple `(float, int, "
"dict)` representing the loss, number of examples, and a dictionary "
"holding arbitrary problem-specific values like accuracy."
msgstr ""

#: ../../source/ref-changelog.md:2247
msgid ""
"In case you wondered: this feature is compatible with existing projects, "
"the additional dictionary return value is optional. New code should "
"however migrate to the new return types to be compatible with upcoming "
"Flower releases (`fit`: `List[np.ndarray], int, Dict[str, Scalar]`, "
"`evaluate`: `float, int, Dict[str, Scalar]`). See the example below for "
"details."
msgstr ""

#: ../../source/ref-changelog.md:2249
msgid ""
"*Code example:* note the additional dictionary return values in both "
"`FlwrClient.fit` and `FlwrClient.evaluate`:"
msgstr ""

#: ../../source/ref-changelog.md:2264
msgid ""
"**Generalized** `config` **argument in** `Client.fit` **and** "
"`Client.evaluate` ([#595](https://github.com/adap/flower/pull/595))"
msgstr ""

#: ../../source/ref-changelog.md:2266
msgid ""
"The `config` argument used to be of type `Dict[str, str]`, which means "
"that dictionary values were expected to be strings. The new release "
"generalizes this to enable values of the following types: `bool`, "
"`bytes`, `float`, `int`, `str`."
msgstr ""

#: ../../source/ref-changelog.md:2268
msgid ""
"This means one can now pass almost arbitrary values to `fit`/`evaluate` "
"using the `config` dictionary. Yay, no more `str(epochs)` on the server-"
"side and `int(config[\"epochs\"])` on the client side!"
msgstr ""

#: ../../source/ref-changelog.md:2270
msgid ""
"*Code example:* note that the `config` dictionary now contains non-`str` "
"values in both `Client.fit` and `Client.evaluate`:"
msgstr ""

#: ../../source/ref-changelog.md:2287
msgid "v0.13.0 (2021-01-08)"
msgstr ""

#: ../../source/ref-changelog.md:2291
msgid ""
"New example: PyTorch From Centralized To Federated "
"([#531](https://github.com/adap/flower/pull/531))"
msgstr ""

#: ../../source/ref-changelog.md:2292
msgid "Improved documentation"
msgstr ""

#: ../../source/ref-changelog.md:2293
msgid "New documentation theme ([#551](https://github.com/adap/flower/pull/551))"
msgstr ""

#: ../../source/ref-changelog.md:2294
msgid "New API reference ([#554](https://github.com/adap/flower/pull/554))"
msgstr ""

#: ../../source/ref-changelog.md:2295
msgid ""
"Updated examples documentation "
"([#534](https://github.com/adap/flower/pull/534))"
msgstr ""

#: ../../source/ref-changelog.md:2296
msgid ""
"Removed obsolete documentation "
"([#548](https://github.com/adap/flower/pull/548))"
msgstr ""

#: ../../source/ref-changelog.md:2298
msgid "Bugfix:"
msgstr ""

#: ../../source/ref-changelog.md:2300
msgid ""
"`Server.fit` does not disconnect clients when finished, disconnecting the"
" clients is now handled in `flwr.server.start_server` "
"([#553](https://github.com/adap/flower/pull/553) "
"[#540](https://github.com/adap/flower/issues/540))."
msgstr ""

#: ../../source/ref-changelog.md:2302
msgid "v0.12.0 (2020-12-07)"
msgstr ""

#: ../../source/ref-changelog.md:2304 ../../source/ref-changelog.md:2320
msgid "Important changes:"
msgstr ""

#: ../../source/ref-changelog.md:2306
msgid ""
"Added an example for embedded devices "
"([#507](https://github.com/adap/flower/pull/507))"
msgstr ""

#: ../../source/ref-changelog.md:2307
msgid ""
"Added a new NumPyClient (in addition to the existing KerasClient) "
"([#504](https://github.com/adap/flower/pull/504) "
"[#508](https://github.com/adap/flower/pull/508))"
msgstr ""

#: ../../source/ref-changelog.md:2308
msgid ""
"Deprecated `flwr_example` package and started to migrate examples into "
"the top-level `examples` directory "
"([#494](https://github.com/adap/flower/pull/494) "
"[#512](https://github.com/adap/flower/pull/512))"
msgstr ""

#: ../../source/ref-changelog.md:2310
msgid "v0.11.0 (2020-11-30)"
msgstr ""

#: ../../source/ref-changelog.md:2312
msgid "Incompatible changes:"
msgstr ""

#: ../../source/ref-changelog.md:2314
msgid ""
"Renamed strategy methods "
"([#486](https://github.com/adap/flower/pull/486)) to unify the naming of "
"Flower's public APIs. Other public methods/functions (e.g., every method "
"in `Client`, but also `Strategy.evaluate`) do not use the `on_` prefix, "
"which is why we're removing it from the four methods in Strategy. To "
"migrate rename the following `Strategy` methods accordingly:"
msgstr ""

#: ../../source/ref-changelog.md:2315
msgid "`on_configure_evaluate` => `configure_evaluate`"
msgstr ""

#: ../../source/ref-changelog.md:2316
msgid "`on_aggregate_evaluate` => `aggregate_evaluate`"
msgstr ""

#: ../../source/ref-changelog.md:2317
msgid "`on_configure_fit` => `configure_fit`"
msgstr ""

#: ../../source/ref-changelog.md:2318
msgid "`on_aggregate_fit` => `aggregate_fit`"
msgstr ""

#: ../../source/ref-changelog.md:2322
msgid ""
"Deprecated `DefaultStrategy` "
"([#479](https://github.com/adap/flower/pull/479)). To migrate use "
"`FedAvg` instead."
msgstr ""

#: ../../source/ref-changelog.md:2323
msgid ""
"Simplified examples and baselines "
"([#484](https://github.com/adap/flower/pull/484))."
msgstr ""

#: ../../source/ref-changelog.md:2324
msgid ""
"Removed presently unused `on_conclude_round` from strategy interface "
"([#483](https://github.com/adap/flower/pull/483))."
msgstr ""

#: ../../source/ref-changelog.md:2325
msgid ""
"Set minimal Python version to 3.6.1 instead of 3.6.9 "
"([#471](https://github.com/adap/flower/pull/471))."
msgstr ""

#: ../../source/ref-changelog.md:2326
msgid ""
"Improved `Strategy` docstrings "
"([#470](https://github.com/adap/flower/pull/470))."
msgstr ""

#: ../../source/ref-example-projects.rst:3
msgid "Example projects"
msgstr ""

#: ../../source/ref-example-projects.rst:5
msgid ""
"Flower comes with a number of usage examples. The examples demonstrate "
"how Flower can be used to federate different kinds of existing machine "
"learning pipelines, usually leveraging popular machine learning "
"frameworks such as `PyTorch <https://pytorch.org/>`_ or `TensorFlow "
"<https://www.tensorflow.org/>`_."
msgstr ""

#: ../../source/ref-example-projects.rst:10
msgid "The following examples are available as standalone projects."
msgstr ""

#: ../../source/ref-example-projects.rst:14
#, fuzzy
msgid "Quickstart TensorFlow/Keras"
msgstr "빠른 시작 튜토리얼"

#: ../../source/ref-example-projects.rst:16
msgid ""
"The TensorFlow/Keras quickstart example shows CIFAR-10 image "
"classification with MobileNetV2:"
msgstr ""

#: ../../source/ref-example-projects.rst:19
msgid ""
"`Quickstart TensorFlow (Code) "
"<https://github.com/adap/flower/tree/main/examples/quickstart-"
"tensorflow>`_"
msgstr ""

#: ../../source/ref-example-projects.rst:21
msgid ":doc:`Quickstart TensorFlow (Tutorial) <tutorial-quickstart-tensorflow>`"
msgstr ""

#: ../../source/ref-example-projects.rst:22
msgid ""
"`Quickstart TensorFlow (Blog Post) <https://flower.ai/blog/2020-12-11"
"-federated-learning-in-less-than-20-lines-of-code>`_"
msgstr ""

#: ../../source/ref-example-projects.rst:27
#: ../../source/tutorial-quickstart-pytorch.rst:45
msgid "Quickstart PyTorch"
msgstr ""

#: ../../source/ref-example-projects.rst:29
msgid ""
"The PyTorch quickstart example shows CIFAR-10 image classification with a"
" simple Convolutional Neural Network:"
msgstr ""

#: ../../source/ref-example-projects.rst:32
msgid ""
"`Quickstart PyTorch (Code) "
"<https://github.com/adap/flower/tree/main/examples/quickstart-pytorch>`_"
msgstr ""

#: ../../source/ref-example-projects.rst:34
msgid ":doc:`Quickstart PyTorch (Tutorial) <tutorial-quickstart-pytorch>`"
msgstr ""

#: ../../source/ref-example-projects.rst:38
msgid "PyTorch: From Centralized To Federated"
msgstr ""

#: ../../source/ref-example-projects.rst:40
msgid ""
"This example shows how a regular PyTorch project can be federated using "
"Flower:"
msgstr ""

#: ../../source/ref-example-projects.rst:42
msgid ""
"`PyTorch: From Centralized To Federated (Code) "
"<https://github.com/adap/flower/tree/main/examples/pytorch-from-"
"centralized-to-federated>`_"
msgstr ""

#: ../../source/ref-example-projects.rst:47
msgid "Federated Learning on Raspberry Pi and Nvidia Jetson"
msgstr ""

#: ../../source/ref-example-projects.rst:49
msgid ""
"This example shows how Flower can be used to build a federated learning "
"system that run across Raspberry Pi and Nvidia Jetson:"
msgstr ""

#: ../../source/ref-example-projects.rst:52
msgid ""
"`Federated Learning on Raspberry Pi and Nvidia Jetson (Code) "
"<https://github.com/adap/flower/tree/main/examples/embedded-devices>`_"
msgstr ""

#: ../../source/ref-example-projects.rst:54
msgid ""
"`Federated Learning on Raspberry Pi and Nvidia Jetson (Blog Post) "
"<https://flower.ai/blog/2020-12-16-running_federated_learning_applications_on_embedded_devices_with_flower>`_"
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:3
msgid "Exit Codes"
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:5
msgid ""
"This reference provides an index of all exit codes and recommended "
"resolutions."
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:9
#, fuzzy
msgid "Categories"
msgstr "속성"

#: ../../source/ref-exit-codes-dir.rst:11
msgid ""
"**Success exit codes (0-99)**: Indicate successful completion of "
"processes."
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:12
msgid ""
"**SuperLink-specific exit codes (100-199)**: Specific to ``flower-"
"superlink`` (SuperLink) errors."
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:14
msgid ""
"**SuperNode-specific exit codes (300-399)**: Specific to ``flower-"
"supernode`` (SuperNode) errors."
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:16
msgid ""
"**SuperExec-specific exit codes (400-499)**: Specific to ``flower-"
"superexec`` (SuperExec) errors."
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:18
msgid "**Common exit codes (600-699)**: Shared across multiple components."
msgstr ""

#: ../../source/ref-exit-codes-dir.rst:22
msgid "Indices"
msgstr ""

#: ../../source/ref-exit-codes/0.rst:3
msgid "[0] SUCCESS"
msgstr ""

#: ../../source/ref-exit-codes/0.rst:9
msgid "The process completed successfully."
msgstr ""

#: ../../source/ref-exit-codes/1.rst:3
msgid "[1] GRACEFUL_EXIT_SIGINT"
msgstr ""

#: ../../source/ref-exit-codes/1.rst:9
msgid "The process exited gracefully, triggered by ``SIGINT``."
msgstr ""

#: ../../source/ref-exit-codes/100.rst:3
msgid "[100] SUPERLINK_THREAD_CRASH"
msgstr ""

#: ../../source/ref-exit-codes/100.rst:9
msgid ""
"A critical background thread has crashed in the SuperLink, causing it to "
"exit prematurely. This indicates a serious issue with the SuperLink that "
"requires immediate investigation."
msgstr ""

#: ../../source/ref-exit-codes/100.rst:13
msgid "Critical background threads include:"
msgstr ""

#: ../../source/ref-exit-codes/100.rst:15
msgid ""
"**Scheduler**: Schedules the execution of runs. This thread exists only "
"when the isolation mode is set to ``subprocess`` (default)."
msgstr ""

#: ../../source/ref-exit-codes/100.rst:17
msgid ""
"**REST API server**: Manages the REST API server. This thread exists only"
" when the Fleet API type is set to ``rest``."
msgstr ""

#: ../../source/ref-exit-codes/100.rst:22
#: ../../source/ref-exit-codes/101.rst:20
#: ../../source/ref-exit-codes/102.rst:13
#: ../../source/ref-exit-codes/103.rst:13
#: ../../source/ref-exit-codes/104.rst:13
#: ../../source/ref-exit-codes/200.rst:32
#: ../../source/ref-exit-codes/201.rst:13
#: ../../source/ref-exit-codes/202.rst:13
#: ../../source/ref-exit-codes/300.rst:14
#: ../../source/ref-exit-codes/302.rst:15
#: ../../source/ref-exit-codes/303.rst:14
#: ../../source/ref-exit-codes/304.rst:15
#: ../../source/ref-exit-codes/400.rst:14
#: ../../source/ref-exit-codes/500.rst:17
#: ../../source/ref-exit-codes/600.rst:14
#: ../../source/ref-exit-codes/601.rst:13
#: ../../source/ref-exit-codes/602.rst:17
msgid "How to Resolve"
msgstr ""

#: ../../source/ref-exit-codes/100.rst:24
msgid "Check the logs for any errors that may have caused the thread to crash."
msgstr ""

#: ../../source/ref-exit-codes/100.rst:25
msgid "Ensure the SuperLink's configuration is correct."
msgstr ""

#: ../../source/ref-exit-codes/100.rst:26
#: ../../source/ref-exit-codes/101.rst:25
#: ../../source/ref-exit-codes/103.rst:19
msgid "If the issue persists, please contact support for further assistance."
msgstr ""

#: ../../source/ref-exit-codes/101.rst:3
msgid "[101] SUPERLINK_LICENSE_INVALID"
msgstr ""

#: ../../source/ref-exit-codes/101.rst:9
msgid ""
"The license of the SuperLink is invalid, causing it to exit prematurely "
"on startup."
msgstr ""

#: ../../source/ref-exit-codes/101.rst:11
msgid "Possible causes of invalid license include:"
msgstr ""

#: ../../source/ref-exit-codes/101.rst:13
msgid "``FLWR_LICENSE_KEY`` environment variable set to an invalid license key."
msgstr ""

#: ../../source/ref-exit-codes/101.rst:14
msgid ""
"The SuperLink failed to reach the public key endpoint from the license "
"server."
msgstr ""

#: ../../source/ref-exit-codes/101.rst:15
msgid ""
"The fetched public key is malformed (wrong PEM encoding or key type) or "
"its signature failed verification against signing key."
msgstr ""

#: ../../source/ref-exit-codes/101.rst:22
msgid "Ensure that the ``FLWR_LICENSE_KEY`` is valid."
msgstr ""

#: ../../source/ref-exit-codes/101.rst:23
msgid ""
"Ensure that the correct public key endpoint is used and is reachable by "
"the SuperLink."
msgstr ""

#: ../../source/ref-exit-codes/102.rst:3
msgid "[102] SUPERLINK_LICENSE_MISSING"
msgstr ""

#: ../../source/ref-exit-codes/102.rst:9
msgid ""
"The SuperLink license is missing, causing it to exit prematurely on "
"startup."
msgstr ""

#: ../../source/ref-exit-codes/102.rst:15
msgid ""
"Set the `FLWR_LICENSE_KEY` environment variable with a valid license key "
"when starting the SuperLink."
msgstr ""

#: ../../source/ref-exit-codes/103.rst:3
msgid "[103] SUPERLINK_LICENSE_URL_INVALID"
msgstr ""

#: ../../source/ref-exit-codes/103.rst:9
msgid ""
"The SuperLink license URL is invalid, causing it to exit prematurely on "
"startup."
msgstr ""

#: ../../source/ref-exit-codes/103.rst:15
msgid ""
"Set the `FLWR_LICENSE_URL` environment variable with a valid license URL "
"when starting the SuperLink."
msgstr ""

#: ../../source/ref-exit-codes/103.rst:17
msgid ""
"Ensure that the URL points to a valid license server that can provide the"
" necessary license information."
msgstr ""

#: ../../source/ref-exit-codes/104.rst:3
msgid "[104] SUPERLINK_INVALID_ARGS"
msgstr ""

#: ../../source/ref-exit-codes/104.rst:9
msgid "The SuperLink was started with invalid arguments."
msgstr ""

#: ../../source/ref-exit-codes/104.rst:15
msgid ""
"Some of the arguments passed to the SuperLink are incompatible with each "
"other. Check the SuperLink logs for additional help on how to resolve the"
" issue."
msgstr ""

#: ../../source/ref-exit-codes/2.rst:3
msgid "[2] GRACEFUL_EXIT_SIGQUIT"
msgstr ""

#: ../../source/ref-exit-codes/2.rst:9
msgid "The process exited gracefully, triggered by ``SIGQUIT``."
msgstr ""

#: ../../source/ref-exit-codes/200.rst:3
msgid "[200] SERVERAPP_STRATEGY_PRECONDITION_UNMET"
msgstr ""

#: ../../source/ref-exit-codes/200.rst:25
msgid ""
"The strategy received replies that cannot be aggregated because either "
"not all replies contain a supported number of records, because the keys "
"used within each record do not match those in other replies, or because "
"the key required by the strategy to perform weighted averaging is "
"missing."
msgstr ""

#: ../../source/ref-exit-codes/200.rst:34
msgid ""
"Please ensure all replies returned by ClientApps have one "
"|arrayrecord_link|_ (none when replies are from a round of federated "
"evaluation, i.e. when message type is `MessageType.EVALUATE`) and one "
"|metricrecord_link|_."
msgstr ""

#: ../../source/ref-exit-codes/200.rst:38
msgid ""
"The records in all replies must use identical keys. In addition, if the "
"strategy expects a key to perform weighted average (e.g. in "
"|fedavg_link|_) please ensure the returned |metricrecord_link|_ from "
"ClientApps do include this key."
msgstr ""

#: ../../source/ref-exit-codes/200.rst:42
msgid ""
"Let's see a few examples of payloads (|recorddict_link|_) that can and "
"can't be aggregated. Let's assume the `ServerApp` has been configured to "
"use |fedavg_link|_ with `num-examples` as the key to perform weighted "
"averaging:"
msgstr ""

#: ../../source/ref-exit-codes/200.rst:46
msgid ""
"These two payloads can be aggregated because all keys match, there is one"
" record of each type, and the key for weighted averaging is present."
msgstr ""

#: ../../source/ref-exit-codes/200.rst:64
msgid ""
"These payloads can't be aggregated because they have unmatching keys (see"
" one has `loss`, the other has `loss` and `accuracy`)"
msgstr ""

#: ../../source/ref-exit-codes/200.rst:82
msgid "These two payloads can't be aggregated (one has a missing `ArrayRecord`)"
msgstr ""

#: ../../source/ref-exit-codes/200.rst:94
msgid ""
"These payloads can't be aggregated because there is no key for weighted "
"averaging"
msgstr ""

#: ../../source/ref-exit-codes/201.rst:3
msgid "[201] SERVERAPP_EXCEPTION"
msgstr ""

#: ../../source/ref-exit-codes/201.rst:9
msgid ""
"An unhandled exception was raised during the execution of your ServerApp "
"code."
msgstr ""

#: ../../source/ref-exit-codes/201.rst:15
msgid ""
"This error indicates that your ServerApp code failed with an unhandled "
"exception. Check the logged exception details in the logs, review your "
"code carefully, and fix the underlying issue causing the error."
msgstr ""

#: ../../source/ref-exit-codes/202.rst:3
msgid "[202] SERVERAPP_STRATEGY_AGGREGATION_ERROR"
msgstr ""

#: ../../source/ref-exit-codes/202.rst:9
msgid "The strategy encountered an error during aggregation."
msgstr ""

#: ../../source/ref-exit-codes/202.rst:15
msgid ""
"Check the logs for more details on the specific aggregation error "
"encountered."
msgstr ""

#: ../../source/ref-exit-codes/3.rst:3
msgid "[3] GRACEFUL_EXIT_SIGTERM"
msgstr ""

#: ../../source/ref-exit-codes/3.rst:9
msgid "The process exited gracefully, triggered by ``SIGTERM``."
msgstr ""

#: ../../source/ref-exit-codes/300.rst:3
msgid "[300] SUPERNODE_REST_ADDRESS_INVALID"
msgstr ""

#: ../../source/ref-exit-codes/300.rst:9
msgid ""
"The provided SuperLink address for the REST API is invalid. The address "
"must start with ``http://`` or ``https://`` to be recognized correctly."
msgstr ""

#: ../../source/ref-exit-codes/300.rst:16
msgid ""
"When using the REST API, ensure that the server address starts with "
"either ``https://`` or ``http://``. For example:"
msgstr ""

#: ../../source/ref-exit-codes/300.rst:19
msgid "``http://127.0.0.1:8080``"
msgstr ""

#: ../../source/ref-exit-codes/300.rst:20
msgid "``https://example.com:8080``"
msgstr ""

#: ../../source/ref-exit-codes/300.rst:22
msgid ""
"Verify the address in your configuration or command-line arguments and "
"correct it as needed."
msgstr ""

#: ../../source/ref-exit-codes/302.rst:3
msgid "[302] SUPERNODE_NODE_AUTH_KEY_INVALID"
msgstr ""

#: ../../source/ref-exit-codes/302.rst:9
msgid ""
"Authentication requires a valid elliptic curve private key. This error "
"occurs when the provided private key file specified in ``--auth-"
"supernode-private-key`` is invalid or unreadable."
msgstr ""

#: ../../source/ref-exit-codes/302.rst:17
msgid "Ensure that the file path provided for the private key option is correct."
msgstr ""

#: ../../source/ref-exit-codes/302.rst:18
msgid "Verify that the file exists and contains a valid elliptic curve SSH key."
msgstr ""

#: ../../source/ref-exit-codes/302.rst:19
msgid ""
"If the files are corrupted or not in the correct format, regenerate the "
"elliptic curve SSH key pair and update the file paths accordingly. For "
"example, on Linux or macOS, **for rapid prototyping only** (not "
"production; follow company procedures for key management):"
msgstr ""

#: ../../source/ref-exit-codes/303.rst:3
msgid "[303] SUPERNODE_STARTED_WITHOUT_TLS_BUT_NODE_AUTH_ENABLED"
msgstr ""

#: ../../source/ref-exit-codes/303.rst:9
msgid ""
"The private key for SuperNode authentication was provided, but TLS is not"
" enabled. SuperNode authentication requires a secure TLS connection with "
"the SuperLink."
msgstr ""

#: ../../source/ref-exit-codes/303.rst:16
msgid "To resolve this issue you need to either:"
msgstr ""

#: ../../source/ref-exit-codes/303.rst:18
msgid ""
"Enable TLS by providing the required TLS certificates when launching the "
"SuperNode."
msgstr ""

#: ../../source/ref-exit-codes/303.rst:27
msgid ""
"Please refer to the documentation on `how to enable TLS in SuperNode "
"<../how-to-enable-tls-connections.rst>`_ for more details."
msgstr ""

#: ../../source/ref-exit-codes/303.rst:30
msgid ""
"If you are prototyping, you may disable the CLI-managed SuperNode "
"authentication mechanism by removing the private key argument when "
"launching the SuperNode. This will make your SuperNode use the automatic "
"authentication mechanism."
msgstr ""

#: ../../source/ref-exit-codes/303.rst:34
msgid ""
"Read more about both SuperNode authentication modes in the documentation "
"on `how to authenticate SuperNodes <../how-to-authenticate-"
"supernodes.rst>`_."
msgstr ""

#: ../../source/ref-exit-codes/304.rst:3
msgid "[304] SUPERNODE_INVALID_TRUSTED_ENTITIES"
msgstr ""

#: ../../source/ref-exit-codes/304.rst:9
msgid ""
"This error occurs when an invalid YAML file for trusted entities is "
"provided via the ``--trusted-entities`` option. The SuperNode must be "
"restarted with a valid trusted entities list."
msgstr ""

#: ../../source/ref-exit-codes/304.rst:17
msgid "To resolve this issue, you can do one of the following:"
msgstr ""

#: ../../source/ref-exit-codes/304.rst:19
msgid ""
"**Provide a valid trusted entities list** using the ``--trusted-"
"entities`` option when launching the SuperNode. Supply a YAML file (for "
"example, ``--trusted-entities ./pks.yaml``) that contains the trusted "
"entities’ public key IDs and their corresponding public keys."
msgstr ""

#: ../../source/ref-exit-codes/304.rst:24
msgid ""
"Public keys must be in **OpenSSH format**, and currently only the **ssh-"
"ed25519** key type is supported."
msgstr ""

#: ../../source/ref-exit-codes/304.rst:26
msgid ""
"Public key IDs must follow the format ``fpk_<UUID>``, where ``fpk`` "
"stands for Flower Public Key."
msgstr ""

#: ../../source/ref-exit-codes/304.rst:28
msgid "The YAML file should follow this structure:"
msgstr ""

#: ../../source/ref-exit-codes/304.rst:35
msgid "\\*Comments are optional."
msgstr ""

#: ../../source/ref-exit-codes/304.rst:37
msgid ""
"**Disable entity verification** by removing the ``--trusted-entities`` "
"option when starting the SuperNode. This allows the SuperNode to run "
"without entity verification."
msgstr ""

#: ../../source/ref-exit-codes/400.rst:3
msgid "[400] SUPEREXEC_INVALID_PLUGIN_CONFIG"
msgstr ""

#: ../../source/ref-exit-codes/400.rst:9
msgid ""
"The YAML configuration for the SuperExec plugin is invalid, could not be "
"parsed, or was provided at an invalid path."
msgstr ""

#: ../../source/ref-exit-codes/400.rst:16
msgid ""
"Confirm that the configuration file path is correct and that the file "
"exists."
msgstr ""

#: ../../source/ref-exit-codes/400.rst:17
msgid "Ensure the file is a valid YAML document."
msgstr ""

#: ../../source/ref-exit-codes/400.rst:18
msgid ""
"Verify that the file structure matches the expected schema for the "
"SuperExec plugin in use."
msgstr ""

#: ../../source/ref-exit-codes/400.rst:20
msgid ""
"Review the accompanying error message for details on the invalid portion,"
" and correct any syntax or structural issues."
msgstr ""

#: ../../source/ref-exit-codes/500.rst:3
msgid "[500] FLWRCLI_NODE_AUTH_PUBLIC_KEY_INVALID"
msgstr ""

#: ../../source/ref-exit-codes/500.rst:9
msgid ""
"The provided public key file is invalid. Authentication requires a valid "
"elliptic curve public key in the ssh format. This error occurs when "
"either:"
msgstr ""

#: ../../source/ref-exit-codes/500.rst:12
msgid ""
"The public key file specified passed to `flwr supernode create` is "
"invalid or unreadable."
msgstr ""

#: ../../source/ref-exit-codes/500.rst:19
msgid "Ensure that the file path provided for the public key option is correct."
msgstr ""

#: ../../source/ref-exit-codes/500.rst:20
msgid ""
"Verify that the file exists and contains a valid ECDSA public key in SSH "
"format with a standard elliptic curve following the NIST specifications "
"(e.g. SECP384R1)."
msgstr ""

#: ../../source/ref-exit-codes/500.rst:23
msgid ""
"3. If the files are corrupted or not in the correct format, regenerate "
"the elliptic curve key pair and update the file paths accordingly. For "
"example, in Linux/MacOS, **for rapid prototyping only** (not production; "
"follow company procedures for key management):"
msgstr ""

#: ../../source/ref-exit-codes/600.rst:3
msgid "[600] COMMON_ADDRESS_INVALID"
msgstr ""

#: ../../source/ref-exit-codes/600.rst:9
msgid ""
"The provided address is invalid and cannot be parsed. It must be a valid "
"URL, IPv4, or IPv6 address."
msgstr ""

#: ../../source/ref-exit-codes/600.rst:16
msgid "Verify that the address is correctly formatted as one of the following:"
msgstr ""

#: ../../source/ref-exit-codes/600.rst:17
msgid "URL (e.g., ``https://127.0.0.1:8080`` or ``https://example.com:8080``)"
msgstr ""

#: ../../source/ref-exit-codes/600.rst:18
msgid "IPv4 (e.g., ``192.168.1.1:9091``)"
msgstr ""

#: ../../source/ref-exit-codes/600.rst:19
msgid "IPv6 (e.g., ``[2001:0db8::1]:9092``)"
msgstr ""

#: ../../source/ref-exit-codes/601.rst:3
msgid "[601] COMMON_MISSING_EXTRA_REST"
msgstr ""

#: ../../source/ref-exit-codes/601.rst:9
msgid ""
"Extra dependencies required for using the REST-based Fleet API are "
"missing."
msgstr ""

#: ../../source/ref-exit-codes/601.rst:15
msgid ""
"To enable the REST-based Fleet API, install ``flwr`` with the ``rest`` "
"extra:"
msgstr ""

#: ../../source/ref-exit-codes/601.rst:21
msgid "Ensure that the installation completes successfully, and then retry."
msgstr ""

#: ../../source/ref-exit-codes/602.rst:3
msgid "[602] COMMON_TLS_NOT_SUPPORTED"
msgstr ""

#: ../../source/ref-exit-codes/602.rst:9
msgid ""
"The ``flower-superexec``, ``flwr-serverapp``, ``flwr-simulation``, and "
"``flwr-clientapp`` do not currently support TLS, as they are assumed to "
"be executed within the same network as their respective long-running "
"processes: ``flower-superlink`` and ``flower-supernode``. Please refer to"
" the `Flower Network Communication <../ref-flower-network-"
"communication.html>`_ guide for further details."
msgstr ""

#: ../../source/ref-exit-codes/602.rst:19
msgid "Use the ``--insecure`` flag to proceed without TLS."
msgstr ""

#: ../../source/ref-faq.rst:3
msgid "FAQ"
msgstr "자주 묻는 질문"

#: ../../source/ref-faq.rst:5
msgid ""
"This page collects answers to commonly asked questions about Federated "
"Learning with Flower."
msgstr ""

#: ../../source/ref-faq.rst
msgid ":fa:`eye,mr-1` Can Flower run on Jupyter Notebooks / Google Colab?"
msgstr ""

#: ../../source/ref-faq.rst:10
msgid ""
"Yes, it can! Flower even comes with a few under-the-hood optimizations to"
" make it work even better on Colab. Here's a quickstart example:"
msgstr ""

#: ../../source/ref-faq.rst:12
msgid ""
"`Flower simulation PyTorch "
"<https://colab.research.google.com/github/adap/flower/blob/main/examples"
"/simulation-pytorch/sim.ipynb>`_"
msgstr ""

#: ../../source/ref-faq.rst:13
msgid ""
"`Flower simulation TensorFlow/Keras "
"<https://colab.research.google.com/github/adap/flower/blob/main/examples"
"/simulation-tensorflow/sim.ipynb>`_"
msgstr ""

#: ../../source/ref-faq.rst
msgid ":fa:`eye,mr-1` How can I run Federated Learning on a Raspberry Pi?"
msgstr ""

#: ../../source/ref-faq.rst:17
msgid ""
"Find the `blog post about federated learning on embedded device here "
"<https://flower.ai/blog/2020-12-16-running_federated_learning_applications_on_embedded_devices_with_flower>`_"
" and the corresponding `GitHub code example "
"<https://github.com/adap/flower/tree/main/examples/embedded-devices>`_."
msgstr ""

#: ../../source/ref-faq.rst
msgid ":fa:`eye,mr-1` Does Flower support federated learning on Android devices?"
msgstr ""

#: ../../source/ref-faq.rst:21
msgid ""
"Yes, it does. Please take a look at our `blog post "
"<https://flower.ai/blog/2021-12-15-federated-learning-on-android-devices-"
"with-flower>`_ or check out the code examples:"
msgstr ""

#: ../../source/ref-faq.rst:23
msgid ""
"`Android Kotlin example <https://flower.ai/docs/examples/android-"
"kotlin.html>`_"
msgstr ""

#: ../../source/ref-faq.rst:24
msgid "`Android Java example <https://flower.ai/docs/examples/android.html>`_"
msgstr ""

#: ../../source/ref-faq.rst
msgid ":fa:`eye,mr-1` Can I combine federated learning with blockchain?"
msgstr ""

#: ../../source/ref-faq.rst:28
msgid ""
"Yes, of course. A list of available examples using Flower within a "
"blockchain environment is available here:"
msgstr ""

#: ../../source/ref-faq.rst:30
msgid "`FLock: A Decentralised AI Training Platform <https://www.flock.io/#/>`_."
msgstr ""

#: ../../source/ref-faq.rst:31
msgid "Contribute to on-chain training the model and earn rewards."
msgstr ""

#: ../../source/ref-faq.rst:32
msgid "Local blockchain with federated learning simulation."
msgstr ""

#: ../../source/ref-faq.rst:33
msgid ""
"`Flower meets Nevermined GitHub Repository <https://github.com"
"/nevermined-io/fl-demo/tree/master/image-classification-flower>`_."
msgstr ""

#: ../../source/ref-faq.rst:34
msgid ""
"`Flower meets Nevermined YouTube video "
"<https://www.youtube.com/watch?v=A0A9hSlPhKI>`_."
msgstr ""

#: ../../source/ref-faq.rst:35
msgid ""
"`Flower meets KOSMoS <https://www.isw-sites.de/kosmos/wp-"
"content/uploads/sites/13/2021/05/Talk-Flower-Summit-2021.pdf>`_."
msgstr ""

#: ../../source/ref-faq.rst:36
msgid ""
"`Flower meets Talan blog post <https://www.linkedin.com/pulse/federated-"
"learning-same-mask-different-faces-imen-"
"ayari/?trackingId=971oIlxLQ9%2BA9RB0IQ73XQ%3D%3D>`_ ."
msgstr ""

#: ../../source/ref-faq.rst:37
msgid ""
"`Flower meets Talan GitHub Repository "
"<https://gitlab.com/Talan_Innovation_Factory/food-waste-prevention>`_ ."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:-1
msgid ""
"The Flower Network Communication reference describes all mandatory and "
"optional network connections in Flower federated AI systems."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:7
#, fuzzy
msgid "Flower Network Communication"
msgstr "플라워 프레임워크 문서"

#: ../../source/ref-flower-network-communication.rst:9
msgid ""
"This reference complements the `Flower Architecture <explanation-flower-"
"architecture.html>`_ explanation by detailing the network connections "
"used in a deployed Flower federated AI system."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:15
msgid ""
"Optionally, a third connection to a third-party service can be "
"established to provide user-level authentication via `OIDC "
"<https://openid.net/developers/how-connect-works/>`_. This means that "
"only users authenticated via ``flwr login`` are able to interface with "
"the SuperLink."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:69
msgid ""
"Click the buttons above to toggle between the network diagrams for "
"isolation modes **subprocess** and **process**."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:74
#, fuzzy
msgid "Mandatory Network Connections"
msgstr "보안 연결을 위한 SSL 사용 설정"

#: ../../source/ref-flower-network-communication.rst:76
msgid "Deployed Flower systems have at least two types of network connections:"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:78
msgid ""
"**CLI to SuperLink (Control API)**: The ``flwr`` `CLI command <ref-api-"
"cli.html>`_, typically run on the users workstation, is used to interface"
" with a deployed Flower federation consisting of SuperLink and "
"SuperNodes. From a networking perspective, the ``flwr`` CLI acts as a "
"gRPC client and the SuperLink acts as a gRPC server. The ``flwr`` CLI is "
"the only way for a user (AI researchers, data scientist) to interface "
"with a deployed Flower federation. They cannot, for example, interface "
"directly with SuperNodes connected to the SuperLink. The ``flwr`` CLI to "
"SuperLink connection should always use TLS, but ``insecure`` mode is "
"supported for local testing."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:86
msgid ""
"**SuperNode to SuperLink (Fleet API)**: In Flower terminology, a Flower "
"federation is a set of SuperNodes connected to the same SuperLink. From a"
" networking perspective, each SuperNode acts as a gRPC client and the "
"SuperLink acts as a gRPC server. This means that, when deploying a "
"SuperNode, only outgoing connections are necessary to connect to the "
"SuperLink. Only the SuperNodes can initiate such requests and they do not"
" respond to incoming requests. The SuperNode to SuperLink connection "
"should always use TLS (see :doc:`how-to-enable-tls-connections` to learn "
"more), but ``insecure`` mode is supported for local testing."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:97
#, fuzzy
msgid "Optional Network Connections"
msgstr "SSL 연결 사용"

#: ../../source/ref-flower-network-communication.rst:99
msgid ""
"Depending on the SuperLink and SuperNode configuration, Flower systems "
"can have/use a number of additional network connections."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:103
#, fuzzy
msgid "Flower Components APIs"
msgstr "Flower ClientApp."

#: ../../source/ref-flower-network-communication.rst:105
msgid ""
"All Flower components — SuperLink, SuperNode, SuperExec, ``ServerApp`` "
"process, and ``ClientApp`` process — expose APIs to interact with other "
"Flower components. The SuperLink component includes three such APIs: the "
"ServerAppIo API, Fleet API, and the Control API. Similarly, the SuperNode"
" component includes the ClientAppIo API. Each of these APIs serves a "
"distinct purpose when running a Flower app using the deployment runtime, "
"as summarized in the table below."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:116
#, fuzzy
msgid "Component"
msgstr "공통"

#: ../../source/ref-flower-network-communication.rst:117
msgid "Default Port"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:118
msgid "API"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:119
msgid "Purpose"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:120
#, fuzzy
msgid "SuperLink"
msgstr "flower 초연결"

#: ../../source/ref-flower-network-communication.rst:121
msgid "9091"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:122
#, fuzzy
msgid "ServerAppIo API"
msgstr "Flower 서버앱"

#: ../../source/ref-flower-network-communication.rst:123
#, fuzzy
msgid "Used by the SuperExec and the ``ServerApp`` processes"
msgstr "서버(SuperLink)"

#: ../../source/ref-flower-network-communication.rst:125
msgid "9092"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:126
msgid "Fleet API"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:127
#, fuzzy
msgid "Used by the SuperNodes"
msgstr "서버(SuperLink)"

#: ../../source/ref-flower-network-communication.rst:129
msgid "9093"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:130
#, fuzzy
msgid "Control API"
msgstr "클라이언트앱"

#: ../../source/ref-flower-network-communication.rst:131
msgid ""
"Users interface with the SuperLink via this API using the `FlowerCLI "
"<ref-api-cli.html>`_"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:133
#, fuzzy
msgid "SuperNode"
msgstr "run\\_supernode"

#: ../../source/ref-flower-network-communication.rst:134
msgid "9094"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:135
#, fuzzy
msgid "ClientAppIo API"
msgstr "클라이언트앱"

#: ../../source/ref-flower-network-communication.rst:136
#, fuzzy
msgid "Used by the SuperExec and the ``ClientApp`` processes"
msgstr "서버(SuperLink)"

#: ../../source/ref-flower-network-communication.rst:139
#, fuzzy
msgid "Isolation Mode"
msgstr "해결법"

#: ../../source/ref-flower-network-communication.rst:141
msgid ""
"Both SuperLink and SuperNode can operate in different isolation modes. "
"The **SuperExec** is responsible for scheduling, launching, and managing "
"app processes, such as the ``ServerApp`` process and the ``ClientApp`` "
"process."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:145
msgid ""
"The ``subprocess`` isolation mode configures the SuperLink/SuperNode to "
"automatically run the SuperExec as a subprocess upon start. The "
"``process`` isolation mode, by contrast, expects the SuperExec to run in "
"a separately managed external process, so the SuperLink/SuperNode will "
"not launch one automatically. This enables, for example, running the "
"SuperLink/SuperNode and SuperExec in separate Docker containers with "
"different dependency sets, or running them on different servers within "
"the same network. See the :doc:`docker/index` guide for a deeper "
"understanding of how to use both modes."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:153
msgid ""
"When using the ``process`` isolation mode, additional network connections"
" are necessary to allow the external process running the SuperExec, "
"``ServerApp``, or ``ClientApp`` to communicate with the SuperLink or "
"SuperNode:"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:157
msgid ""
"**SuperExec/ServerApp process to SuperLink (ServerAppIO API)**: Both the "
"SuperExec for ``ServerApp``\\s and the ``ServerApp`` processes act as "
"gRPC clients and connect to the SuperLink's ServerAppIO API. This "
"connection enables the SuperExec to discover runs to launch and the "
"``ServerApp`` process to pull the necessary inputs to execute the "
"``ServerApp``. It also allows the ``ServerApp``, once running, to do "
"typical things like sending/receiving messages to/from available "
"SuperNodes (via the SuperLink)."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:163
msgid ""
"**SuperExec/ClientApp process to SuperNode (ClientAppIO API)**: Both the "
"SuperExec for ``ClientApp``\\s and the ``ClientApp`` processes act as "
"gRPC clients and connect to the SuperNode's ClientAppIO API. This "
"connection enables the SuperExec to discover runs to launch and the "
"``ClientApp`` process to pull the necessary details (e.g., FAB file) to "
"execute the ``ClientApp``, execute the ``ClientApp`` (e.g., local model "
"training), and return the execution results (e.g., locally update model "
"parameters) to the SuperNode."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:172
msgid ""
"In the current version of Flower, both of the connections above are "
"insecure because Flower assumes that the following groups of processes "
"run within the same trusted network:"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:176
msgid "SuperLink + SuperExec + ``ServerApp`` process"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:177
msgid "SuperNode + SuperExec + ``ClientApp`` process"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:179
msgid ""
"Each group must remain inside a single trusted network. They should never"
" communicate with each other over untrusted networks (e.g., the public "
"internet)."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:183
#, fuzzy
msgid "Account Authentication"
msgstr "설치 확인"

#: ../../source/ref-flower-network-communication.rst:185
msgid ""
"When account authentication is enabled, Flower uses an OIDC-compatible "
"server to authenticate requests:"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:188
msgid ""
"**SuperLink to OIDC server**: A SuperLink can optionally be configured to"
" only allow authenticated users to interact with it. In this setting, the"
" Flower SuperLink acts as a REST client to the OIDC-compatible server."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:193
#, fuzzy
msgid "Application-specific Connections"
msgstr "CLI 시뮬레이션"

#: ../../source/ref-flower-network-communication.rst:195
msgid ""
"Users who write Flower Apps (``ServerApp`` and ``ClientApp``) can also "
"make additional network requests. This is, strictly speaking, not part of"
" Flower as a Federated AI Platform. It is a decision of (a) the user "
"about what kinds of third-party systems their Flower App should connect "
"to and (b) the system administrator about what kinds of connections they "
"want to allow."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:201
#, fuzzy
msgid "Typical examples include:"
msgstr "예시:"

#: ../../source/ref-flower-network-communication.rst:203
msgid ""
"**ClientApp to Database**: ``ClientApp`` instances typically need to be "
"able to access the data to perform the action they have been designed for"
" (e.g. train locally a model, run a DB query). How this connection is "
"established depends on what storage technology is used at the client "
"side. Note that in the diagram above, we show two representative "
"connections to DBs in Client-A and Client-B. Your DB connection(s) may "
"likely be different to the illustration above."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:209
msgid ""
"**ServerApp to Database**: ``ServerApp`` instances might want to access "
"the data to perform the action they have been designed for (e.g. evaluate"
" a model on some data after aggregation). How this connection is "
"established depends on what storage technology used at the client side. "
"Note that in the diagram above we have omitted showing a DB connected to "
"the ``ServerApp`` components."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:214
msgid ""
"**ServerApp to metric logging service**: Metric logging services like "
"TensorBoard, MLFlow and Weights & Biases are often used to track the "
"progress of training runs. In this setting, the ``ServerApp`` typically "
"acts as a client to the metric logging service."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:220
#, fuzzy
msgid "Communication Model"
msgstr "해결법"

#: ../../source/ref-flower-network-communication.rst:222
msgid ""
"During real-world deployment, the push/pull communication model adopted "
"by each component can influence decisions related to resource "
"provisioning, scaling, monitoring, and reliability. To support such "
"decisions, the list below outlines the communication model used between "
"the Flower components:"
msgstr ""

#: ../../source/ref-flower-network-communication.rst:227
msgid ""
"**SuperLink ↔ SuperNode (Fleet API)**: The SuperNode pulls/pushes "
"Messages from/to the SuperLink via the Fleet API. The SuperNode also "
"pulls the FAB if a new run is being executed."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:230
msgid ""
"**SuperLink ↔ ServerApp (ServerAppIo API)**: The ``ServerApp`` process "
"pulls/pushes Messages from/to the SuperLink via the ServerAppIo API. The "
"``ServerApp`` also pulls the FAB as part of the first interaction with "
"the SuperLink, and at the end of the execution it pushes the Context back"
" to the SuperLink."
msgstr ""

#: ../../source/ref-flower-network-communication.rst:234
msgid ""
"**SuperNode ↔ ClientApp (ClientAppIo API)**: The ``ClientApp`` process "
"pulls/pushes Messages from/to the SuperNode via the ClientAppIo API. The "
"``ClientApp`` also pulls the FAB as part of the first interaction with "
"the SuperNode, and at the end of the execution it pushes the Context back"
" to the SuperNode."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:-1
msgid ""
"Comparison of Flower Runtimes for simulation and deployment of federated "
"AI apps."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:7
#, fuzzy
msgid "Flower Runtime Comparison"
msgstr "Flower 시뮬레이션."

#: ../../source/ref-flower-runtime-comparison.rst:9
msgid ""
"Flower Apps can be executed with both `simulation <how-to-run-"
"simulations.html>`_ or `deployment <how-to-run-flower-with-deployment-"
"engine.html>`_ runtimes. Switching between runtimes simply requires "
"specifying a different type of `federation` when executing the `flwr run`"
" command via the `Flower CLI <ref-api-cli.html>`_."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:14
msgid ""
"While Flower Apps can run in both simulation and deployment without "
"making changes to their code, there are some differences on how they get "
"executed depending on the runtime. The following table outlines the key "
"characteristics that differ when executing a Flower App in a Flower "
"federation with the simulation runtime from another using the deployment "
"runtime."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:24
#, fuzzy
msgid "Dimension"
msgstr "설명"

#: ../../source/ref-flower-runtime-comparison.rst:25
#, fuzzy
msgid "Simulation Runtime"
msgstr "Notebook에서 시뮬레이션"

#: ../../source/ref-flower-runtime-comparison.rst:26
#, fuzzy
msgid "Deployment Runtime"
msgstr "배포"

#: ../../source/ref-flower-runtime-comparison.rst:27
msgid "**Lifecycle Stage**"
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:28
msgid ""
"Ideal for rapid prototyping, algorithm validation, research, debugging, "
"and experimentation."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:30
msgid ""
"Deploy validated use cases in production, real-world privacy-preserving "
"applications."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:32
#, fuzzy
msgid "**Environment**"
msgstr "Flower 개발 환경 만들기"

#: ../../source/ref-flower-runtime-comparison.rst:33
msgid "Local or remote, single-node or multi-node, controlled."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:34
msgid "Distributed, remote."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:35
#, fuzzy
msgid "**Data**"
msgstr "설명"

#: ../../source/ref-flower-runtime-comparison.rst:36
msgid ""
"Simulated data partitions, public or private datasets or artificially "
"generated - a natural fit for `Flower Datasets "
"<https://flower.ai/docs/datasets/>`_."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:38
msgid "Real client-side data, residing on local databases or filesystems."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:39
#, fuzzy
msgid "**Backend**"
msgstr "**변경하기**"

#: ../../source/ref-flower-runtime-comparison.rst:40
msgid ""
"Multiple Python processes/workers coordinated using `Ray "
"<https://docs.ray.io/>`_."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:42
msgid ""
"Multiple independent processes or subprocesses running in coordination "
"with the SuperLink and SuperNodes."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:44
msgid "**Execution Mode**"
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:45
msgid "Multiprocessing execution where each process simulates a distinct client."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:46
msgid ""
"Parallel execution mode across a network of physical machines/devices or "
"computing environment."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:48
#, fuzzy
msgid "**Communication**"
msgstr "**변경사항 커밋**"

#: ../../source/ref-flower-runtime-comparison.rst:49
#, fuzzy
msgid "In-memory communication."
msgstr "플라워 프레임워크 문서"

#: ../../source/ref-flower-runtime-comparison.rst:50
msgid "TLS-enabled gRPC."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:51
#, fuzzy
msgid "**Server-side Infrastructure**"
msgstr "Flower 서버."

#: ../../source/ref-flower-runtime-comparison.rst:52
msgid ""
"Simulation runtime coordinates the spawning of multiple workers (Python "
"process) which act as `simulated` SuperNodes. The simulation runtime can "
"be started with or without the `SuperLink <ref-api-cli.html#flower-"
"superlink>`_."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:55
msgid ""
"The SuperLink awaits for SuperNodes to connect. User interface with the "
"SuperLink using the `Flower CLI <ref-api-cli.html>`_."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:57
#, fuzzy
msgid "**Server-side App execution**"
msgstr "서버 측 클리핑"

#: ../../source/ref-flower-runtime-comparison.rst:58
msgid ""
"A ``ServerApp`` process is initialized inside a controlled environment "
"and communicates in-memory with workers."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:60
msgid ""
"``ServerApp`` `process or subprocess <ref-flower-network-"
"communication.html>`_ runs independently from the SuperLink and "
"communicates with it over gRPC via the ServerAppIO API."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:63
#, fuzzy
msgid "**Client-side Infrastructure**"
msgstr "Flower 서버."

#: ../../source/ref-flower-runtime-comparison.rst:64
msgid "None. The simulation runtime is self-contained."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:65
msgid ""
"SuperNodes connect to the SuperLink via TLS-enabled gRPC using the Fleet "
"API. Node authentication can be enabled."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:67
#, fuzzy
msgid "**Client-side App execution**"
msgstr "클라이언트 측 클리핑"

#: ../../source/ref-flower-runtime-comparison.rst:68
msgid ""
"Each process executes a ``ClientApp`` on demand. They might execute "
"multiple instances of the same ``ClientApp`` to simulate large amounts of"
" clients. ``ClientApps`` are stateless."
msgstr ""

#: ../../source/ref-flower-runtime-comparison.rst:71
msgid ""
"Initialized as a ``ClientApp`` `process or subprocess <ref-flower-"
"network-communication.html>`_, it runs independently from the SuperNode "
"and communicates with it over gRPC via the ClientAppIo API. "
"``ClientApps`` are stateless."
msgstr ""

#: ../../source/ref-telemetry.md:1
msgid "Telemetry"
msgstr ""

#: ../../source/ref-telemetry.md:3
msgid ""
"The Flower open-source project collects **anonymous** usage metrics to "
"make well-informed decisions to improve Flower. Doing this enables the "
"Flower team to understand how Flower is used and what challenges users "
"might face."
msgstr ""

#: ../../source/ref-telemetry.md:5
msgid ""
"**Flower is a friendly framework for collaborative AI and data science.**"
" Staying true to this statement, Flower makes it easy to disable "
"telemetry for users that do not want to share anonymous usage metrics."
msgstr ""

#: ../../source/ref-telemetry.md:7
msgid "Principles"
msgstr ""

#: ../../source/ref-telemetry.md:9
msgid "We follow strong principles guarding anonymous usage metrics collection:"
msgstr ""

#: ../../source/ref-telemetry.md:11
msgid ""
"**Optional:** You will always be able to disable telemetry; read on to "
"learn “[How to opt-out](#how-to-opt-out)”."
msgstr ""

#: ../../source/ref-telemetry.md:12
msgid ""
"**Anonymous:** The reported usage metrics are anonymous and do not "
"contain any personally identifiable information (PII). See “[Collected "
"metrics](#collected-metrics)” to understand what metrics are being "
"reported."
msgstr ""

#: ../../source/ref-telemetry.md:13
msgid ""
"**Transparent:** You can easily inspect what anonymous metrics are being "
"reported; see the section “[How to inspect what is being reported](#how-"
"to-inspect-what-is-being-reported)”"
msgstr ""

#: ../../source/ref-telemetry.md:14
msgid ""
"**Open for feedback:** You can always reach out to us if you have "
"feedback; see the section “[How to contact us](#how-to-contact-us)” for "
"details."
msgstr ""

#: ../../source/ref-telemetry.md:16
msgid "How to opt-out"
msgstr ""

#: ../../source/ref-telemetry.md:18
msgid ""
"When Flower starts, it will check for an environment variable called "
"`FLWR_TELEMETRY_ENABLED`. Telemetry can easily be disabled by setting "
"`FLWR_TELEMETRY_ENABLED=0`. Assuming you are starting a Flower server or "
"client, simply do so by prepending your command as in:"
msgstr ""

#: ../../source/ref-telemetry.md:24
msgid ""
"Alternatively, you can export `FLWR_TELEMETRY_ENABLED=0` in, for example,"
" `.bashrc` (or whatever configuration file applies to your environment) "
"to disable Flower telemetry permanently."
msgstr ""

#: ../../source/ref-telemetry.md:26
msgid "Collected metrics"
msgstr ""

#: ../../source/ref-telemetry.md:28
msgid "Flower telemetry collects the following metrics:"
msgstr ""

#: ../../source/ref-telemetry.md:30
msgid ""
"**Flower version.** Understand which versions of Flower are currently "
"being used. This helps us to decide whether we should invest effort into "
"releasing a patch version for an older version of Flower or instead use "
"the bandwidth to build new features."
msgstr ""

#: ../../source/ref-telemetry.md:32
msgid ""
"**Operating system.** Enables us to answer questions such as: *Should we "
"create more guides for Linux, macOS, or Windows?*"
msgstr ""

#: ../../source/ref-telemetry.md:34
msgid ""
"**Python version.** Knowing the Python version helps us, for example, to "
"decide whether we should invest effort into supporting old versions of "
"Python or stop supporting them and start taking advantage of new Python "
"features."
msgstr ""

#: ../../source/ref-telemetry.md:36
msgid ""
"**Hardware properties.** Understanding the hardware environment that "
"Flower is being used in helps to decide whether we should, for example, "
"put more effort into supporting low-resource environments."
msgstr ""

#: ../../source/ref-telemetry.md:38
msgid ""
"**Execution mode.** Knowing what execution mode Flower starts in enables "
"us to understand how heavily certain features are being used and better "
"prioritize based on that."
msgstr ""

#: ../../source/ref-telemetry.md:40
msgid ""
"**Cluster.** Flower telemetry assigns a random in-memory cluster ID each "
"time a Flower workload starts. This allows us to understand which device "
"types not only start Flower workloads but also successfully complete "
"them."
msgstr ""

#: ../../source/ref-telemetry.md:42
msgid ""
"**Source.** Flower telemetry tries to store a random source ID in "
"`~/.flwr/source` the first time a telemetry event is generated. The "
"source ID is important to identify whether an issue is recurring or "
"whether an issue is triggered by multiple clusters running concurrently "
"(which often happens in simulation). For example, if a device runs "
"multiple workloads at the same time, and this results in an issue, then, "
"in order to reproduce the issue, multiple workloads must be started at "
"the same time."
msgstr ""

#: ../../source/ref-telemetry.md:44
msgid ""
"You may delete the source ID at any time. If you wish for all events "
"logged under a specific source ID to be deleted, you can send a deletion "
"request mentioning the source ID to `telemetry@flower.ai`. All events "
"related to that source ID will then be permanently deleted."
msgstr ""

#: ../../source/ref-telemetry.md:46
msgid ""
"We will not collect any personally identifiable information. If you think"
" any of the metrics collected could be misused in any way, please [get in"
" touch with us](#how-to-contact-us). We will update this page to reflect "
"any changes to the metrics collected and publish changes in the "
"changelog."
msgstr ""

#: ../../source/ref-telemetry.md:48
msgid ""
"If you think other metrics would be helpful for us to better guide our "
"decisions, please let us know! We will carefully review them; if we are "
"confident that they do not compromise user privacy, we may add them."
msgstr ""

#: ../../source/ref-telemetry.md:50
msgid "How to inspect what is being reported"
msgstr ""

#: ../../source/ref-telemetry.md:52
msgid ""
"We wanted to make it very easy for you to inspect what anonymous usage "
"metrics are reported. You can view all the reported telemetry information"
" by setting the environment variable `FLWR_TELEMETRY_LOGGING=1`. Logging "
"is disabled by default. You may use logging independently from "
"`FLWR_TELEMETRY_ENABLED` so that you can inspect the telemetry feature "
"without sending any metrics."
msgstr ""

#: ../../source/ref-telemetry.md:58
msgid ""
"To inspect Flower telemetry without sending any anonymous usage metrics, "
"use both environment variables:"
msgstr ""

#: ../../source/ref-telemetry.md:64
msgid "How to contact us"
msgstr ""

#: ../../source/ref-telemetry.md:66
msgid ""
"We want to hear from you. If you have any feedback or ideas on how to "
"improve the way we handle anonymous usage metrics, reach out to us via "
"[Slack](https://flower.ai/join-slack/) (channel `#telemetry`) or email "
"(`telemetry@flower.ai`)."
msgstr ""

#: None:-1
msgid "API reference"
msgstr "API 참조"

#: ../../source/reference.rst:24
msgid "Reference docs"
msgstr "참조 문서"

#: ../../source/reference.rst:3
#, fuzzy
msgid "Reference"
msgstr "참조"

#: ../../source/reference.rst:18:<autosummary>:1
msgid ":py:obj:`flwr <flwr>`\\"
msgstr ":py:obj:`flwr <flwr>`\\"

#: ../../source/simulate.rst:-1
msgid ""
"Run scalable federated learning simulations with the Flower Simulation "
"Runtime. Follow step-by-step guides to set up, configure, and execute "
"simulations easily."
msgstr ""

#: ../../source/simulate.rst:7
#, fuzzy
msgid "Simulate using the Flower Simulation Runtime"
msgstr "멀티 노드 Flower 시뮬레이션"

#: ../../source/tutorial-quickstart.rst:3
msgid "Quickstart tutorials"
msgstr "빠른 시작 튜토리얼"

#: ../../source/tutorial-quickstart-android.rst:-1
msgid ""
"Read this Federated Learning quickstart tutorial for creating an Android "
"app using Flower."
msgstr ""

#: ../../source/tutorial-quickstart-android.rst:5
msgid "Quickstart Android"
msgstr ""

#: ../../source/tutorial-quickstart-android.rst:12
msgid ""
"The experimental Flower Android SDK is not compatible with the latest "
"version of Flower. Android support is currently being reworked and will "
"be released in 2025."
msgstr ""

#: ../../source/tutorial-quickstart-android.rst:15
msgid ""
"This quickstart tutorial is kept for historical purposes and will be "
"updated once the new Android SDK is released."
msgstr ""

#: ../../source/tutorial-quickstart-android.rst:18
msgid ""
"Let's build a federated learning system using TFLite and Flower on "
"Android!"
msgstr ""

#: ../../source/tutorial-quickstart-android.rst:20
msgid ""
"Please refer to the `full code example "
"<https://github.com/adap/flower/tree/main/examples/android>`_ to learn "
"more."
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:-1
msgid ""
"Learn how to train a SqueezeNet model on MNIST using federated learning "
"with Flower and fastai in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:9
msgid "Quickstart fastai"
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:11
msgid ""
"In this federated learning tutorial we will learn how to train a "
"SqueezeNet model on MNIST using Flower and fastai. It is recommended to "
"create a virtual environment and run everything within a :doc:`virtualenv"
" <contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:15
#: ../../source/tutorial-quickstart-pytorch-lightning.rst:16
msgid "Then, clone the code example directly from GitHub:"
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:23
msgid ""
"This will create a new directory called `quickstart-fastai` containing "
"the following files:"
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:36
#: ../../source/tutorial-quickstart-pytorch-lightning.rst:37
#, fuzzy
msgid "Next, activate your environment, then run:"
msgstr "그 후 가상 환경을 활성화합니다:"

#: ../../source/tutorial-quickstart-fastai.rst:46
msgid ""
"This example by default runs the Flower Simulation Engine, creating a "
"federation of 10 nodes using `FedAvg <https://flower.ai/docs/framework"
"/ref-"
"api/flwr.serverapp.strategy.FedAvg.html#flwr.server.strategy.FedAvg>`_ as"
" the aggregation strategy. The dataset will be partitioned using Flower "
"Dataset's `IidPartitioner <https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
" Let's run the project:"
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:59
#: ../../source/tutorial-quickstart-huggingface.rst:65
#: ../../source/tutorial-quickstart-jax.rst:65
#: ../../source/tutorial-quickstart-pytorch-lightning.rst:56
#: ../../source/tutorial-quickstart-pytorch.rst:102
#: ../../source/tutorial-quickstart-scikitlearn.rst:92
#: ../../source/tutorial-quickstart-tensorflow.rst:94
msgid "With default arguments you will see an output like this one:"
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:125
#: ../../source/tutorial-quickstart-huggingface.rst:143
#: ../../source/tutorial-quickstart-jax.rst:133
#: ../../source/tutorial-quickstart-pytorch-lightning.rst:134
#: ../../source/tutorial-quickstart-pytorch.rst:170
#: ../../source/tutorial-quickstart-scikitlearn.rst:172
#: ../../source/tutorial-quickstart-tensorflow.rst:161
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:626
msgid ""
"You can also override the parameters defined in the "
"``[tool.flwr.app.config]`` section in ``pyproject.toml`` like this:"
msgstr ""

#: ../../source/tutorial-quickstart-fastai.rst:135
msgid ""
"Check the `source code <https://github.com/adap/flower/tree/main/examples"
"/quickstart-fastai>`_ of this tutorial in ``examples/quickstart-fastai`` "
"in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:-1
msgid ""
"Learn how to train a large language model on the IMDB dataset using "
"federated learning with Flower and 🤗 Hugging Face in this step-by-step "
"tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:8
msgid "Quickstart 🤗 Transformers"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:10
msgid ""
"In this federated learning tutorial we will learn how to train a large "
"language model (LLM) on the `IMDB "
"<https://huggingface.co/datasets/stanfordnlp/imdb>`_ dataset using Flower"
" and the 🤗 Hugging Face Transformers library. It is recommended to create"
" a virtual environment and run everything within a :doc:`virtualenv "
"<contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:16
msgid ""
"Let's use ``flwr new`` to create a complete Flower+🤗 Hugging Face "
"project. It will generate all the files needed to run, by default with "
"the Flower Simulation Engine, a federation of 10 nodes using |fedavg|_ "
"The dataset will be partitioned using |flowerdatasets|_'s "
"|iidpartitioner|_."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:21
#: ../../source/tutorial-quickstart-jax.rst:21
#: ../../source/tutorial-quickstart-mlx.rst:57
#: ../../source/tutorial-quickstart-pytorch.rst:58
#: ../../source/tutorial-quickstart-scikitlearn.rst:48
#: ../../source/tutorial-quickstart-tensorflow.rst:50
#: ../../source/tutorial-quickstart-xgboost.rst:63
msgid ""
"Now that we have a rough idea of what this example is about, let's get "
"started. First, install Flower in your new environment:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:29
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``HuggingFace``), give a name to your "
"project, and type in your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:37
#: ../../source/tutorial-quickstart-jax.rst:37
#: ../../source/tutorial-quickstart-mlx.rst:72
#: ../../source/tutorial-quickstart-pytorch.rst:74
#: ../../source/tutorial-quickstart-scikitlearn.rst:64
#: ../../source/tutorial-quickstart-tensorflow.rst:66
#: ../../source/tutorial-quickstart-xgboost.rst:79
msgid ""
"After running it you'll notice a new directory with your project name has"
" been created. It should have the following structure:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:51
#: ../../source/tutorial-quickstart-jax.rst:51
#: ../../source/tutorial-quickstart-mlx.rst:86
#: ../../source/tutorial-quickstart-pytorch.rst:88
#: ../../source/tutorial-quickstart-scikitlearn.rst:78
#: ../../source/tutorial-quickstart-tensorflow.rst:80
#: ../../source/tutorial-quickstart-xgboost.rst:93
msgid ""
"If you haven't yet installed the project and its dependencies, you can do"
" so by:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:58
#: ../../source/tutorial-quickstart-jax.rst:58
#: ../../source/tutorial-quickstart-pytorch.rst:95
#: ../../source/tutorial-quickstart-scikitlearn.rst:85
#: ../../source/tutorial-quickstart-tensorflow.rst:87
msgid "To run the project, do:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:133
msgid "You can also run the project with GPU as follows:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:140
msgid ""
"This will use the default arguments where each ``ClientApp`` will use 4 "
"CPUs and at most 4 ``ClientApp``\\s will run in a given GPU."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:151
#: ../../source/tutorial-quickstart-jax.rst:141
#: ../../source/tutorial-quickstart-pytorch.rst:178
#: ../../source/tutorial-quickstart-scikitlearn.rst:180
msgid ""
"What follows is an explanation of each component in the project you just "
"created: dataset partition, the model, defining the ``ClientApp`` and "
"defining the ``ServerApp``."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:155
#: ../../source/tutorial-quickstart-jax.rst:146
#: ../../source/tutorial-quickstart-mlx.rst:182
#: ../../source/tutorial-quickstart-pytorch.rst:183
#: ../../source/tutorial-quickstart-scikitlearn.rst:185
#: ../../source/tutorial-quickstart-tensorflow.rst:171
#: ../../source/tutorial-quickstart-xgboost.rst:216
#, fuzzy
msgid "The Data"
msgstr "Metadata"

#: ../../source/tutorial-quickstart-huggingface.rst:157
msgid ""
"This tutorial uses |flowerdatasets|_ to easily download and partition the"
" `IMDB <https://huggingface.co/datasets/stanfordnlp/imdb>`_ dataset. In "
"this example you'll make use of the |iidpartitioner|_ to generate "
"``num_partitions`` partitions. You can choose |otherpartitioners|_ "
"available in Flower Datasets. To tokenize the text, we will also load the"
" tokenizer from the pre-trained Transformer model that we'll use during "
"training - more on that in the next section. Each ``ClientApp`` will call"
" this function to create dataloaders with the data that correspond to "
"their data partition."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:202
#: ../../source/tutorial-quickstart-jax.rst:161
#: ../../source/tutorial-quickstart-mlx.rst:224
#: ../../source/tutorial-quickstart-pytorch.rst:219
#: ../../source/tutorial-quickstart-scikitlearn.rst:211
#: ../../source/tutorial-quickstart-tensorflow.rst:199
msgid "The Model"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:204
msgid ""
"We will leverage 🤗 Hugging Face to federate the training of language "
"models over multiple clients using Flower. More specifically, we will "
"fine-tune a pre-trained Transformer model (|berttiny|_) for sequence "
"classification over the dataset of IMDB ratings. The end goal is to "
"detect if a movie rating is positive or negative. If you have access to "
"larger GPUs, feel free to use larger models!"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:216
msgid ""
"Note that here, ``model_name`` is a string that will be loaded from the "
"``Context`` in the ClientApp and ServerApp."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:219
msgid ""
"In addition to loading the pretrained model weights and architecture, we "
"also include two utility functions to perform both training (i.e. "
"``train()``) and evaluation (i.e. ``test()``) using the above model. "
"These functions should look fairly familiar if you have some prior "
"experience with PyTorch. Note these functions do not have anything "
"specific to Flower. That being said, the training function will normally "
"be called, as we'll see later, from a Flower client passing its own data."
" In summary, your clients can use standard training/testing functions to "
"perform local training or evaluation:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:259
#: ../../source/tutorial-quickstart-jax.rst:204
#: ../../source/tutorial-quickstart-mlx.rst:268
#: ../../source/tutorial-quickstart-pytorch.rst:294
#: ../../source/tutorial-quickstart-scikitlearn.rst:227
#: ../../source/tutorial-quickstart-tensorflow.rst:229
#: ../../source/tutorial-quickstart-xgboost.rst:271
#, fuzzy
msgid "The ClientApp"
msgstr "클라이언트앱"

#: ../../source/tutorial-quickstart-huggingface.rst:261
msgid ""
"The main changes we have to make to use 🤗 Hugging Face with Flower have "
"to do with converting the |arrayrecord_link|_ received in the "
"|message_link|_ into a PyTorch ``state_dict`` and vice versa when "
"generating the reply ``Message`` from the ClientApp. We can make use of "
"the built-in methods in the ``ArrayRecord`` to make these conversions:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:284
#: ../../source/tutorial-quickstart-jax.rst:243
#: ../../source/tutorial-quickstart-pytorch.rst:318
#: ../../source/tutorial-quickstart-scikitlearn.rst:256
#: ../../source/tutorial-quickstart-tensorflow.rst:254
#: ../../source/tutorial-quickstart-xgboost.rst:299
msgid ""
"The rest of the functionality is directly inspired by the centralized "
"case. The |clientapp_link|_ comes with three core methods (``train``, "
"``evaluate``, and ``query``) that we can implement for different "
"purposes. For example: ``train`` to train the received model using the "
"local data; ``evaluate`` to assess its performance of the received model "
"on a validation set; and ``query`` to retrieve information about the node"
" executing the ``ClientApp``. In this tutorial we will only make use of "
"``train`` and ``evaluate``."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:292
#: ../../source/tutorial-quickstart-jax.rst:251
#: ../../source/tutorial-quickstart-pytorch.rst:326
#: ../../source/tutorial-quickstart-scikitlearn.rst:264
#: ../../source/tutorial-quickstart-tensorflow.rst:262
#: ../../source/tutorial-quickstart-xgboost.rst:307
msgid ""
"Let's see how the ``train`` method can be implemented. It receives as "
"input arguments a |message_link|_ from the ``ServerApp``. By default it "
"carries:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:295
#: ../../source/tutorial-quickstart-jax.rst:254
#: ../../source/tutorial-quickstart-pytorch.rst:329
#: ../../source/tutorial-quickstart-scikitlearn.rst:267
#: ../../source/tutorial-quickstart-tensorflow.rst:265
#: ../../source/tutorial-quickstart-xgboost.rst:310
msgid ""
"an ``ArrayRecord`` with the arrays of the model to federate. By default "
"they can be retrieved with key ``\"arrays\"`` when accessing the message "
"content."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:297
#: ../../source/tutorial-quickstart-jax.rst:256
#: ../../source/tutorial-quickstart-pytorch.rst:331
#: ../../source/tutorial-quickstart-scikitlearn.rst:269
#: ../../source/tutorial-quickstart-tensorflow.rst:267
#: ../../source/tutorial-quickstart-xgboost.rst:312
msgid ""
"a ``ConfigRecord`` with the configuration sent from the ``ServerApp``. By"
" default it can be retrieved with key ``\"config\"`` when accessing the "
"message content."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:300
#: ../../source/tutorial-quickstart-jax.rst:259
#: ../../source/tutorial-quickstart-scikitlearn.rst:272
#: ../../source/tutorial-quickstart-tensorflow.rst:270
msgid ""
"The ``train`` method also receives the ``Context``, giving access to "
"configs for your run and node. The run config hyperparameters are defined"
" in the ``pyproject.toml`` of your Flower App. The node config can only "
"be set when running Flower with the Deployment Runtime and is not "
"directly configurable during simulations."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:350
#: ../../source/tutorial-quickstart-jax.rst:299
#: ../../source/tutorial-quickstart-pytorch.rst:385
#: ../../source/tutorial-quickstart-tensorflow.rst:325
#: ../../source/tutorial-quickstart-xgboost.rst:395
msgid ""
"The ``@app.evaluate()`` method would be near identical with two "
"exceptions: (1) the model is not locally trained, instead it is used to "
"evaluate its performance on the locally held-out validation set; (2) "
"including the model in the reply Message is no longer needed because it "
"is not locally modified."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:356
#: ../../source/tutorial-quickstart-jax.rst:306
#: ../../source/tutorial-quickstart-mlx.rst:426
#: ../../source/tutorial-quickstart-mlx.rst:430
#: ../../source/tutorial-quickstart-pytorch.rst:392
#: ../../source/tutorial-quickstart-scikitlearn.rst:327
#: ../../source/tutorial-quickstart-tensorflow.rst:332
#: ../../source/tutorial-quickstart-xgboost.rst:402
#, fuzzy
msgid "The ServerApp"
msgstr "Flower 서버앱"

#: ../../source/tutorial-quickstart-huggingface.rst:358
#: ../../source/tutorial-quickstart-jax.rst:308
#: ../../source/tutorial-quickstart-pytorch.rst:394
#: ../../source/tutorial-quickstart-scikitlearn.rst:329
#: ../../source/tutorial-quickstart-tensorflow.rst:334
msgid ""
"To construct a |serverapp_link|_ we define its ``@app.main()`` method. "
"This method receive as input arguments:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:361
#: ../../source/tutorial-quickstart-jax.rst:311
#: ../../source/tutorial-quickstart-mlx.rst:435
#: ../../source/tutorial-quickstart-pytorch.rst:397
#: ../../source/tutorial-quickstart-scikitlearn.rst:332
#: ../../source/tutorial-quickstart-tensorflow.rst:337
#: ../../source/tutorial-quickstart-xgboost.rst:407
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:491
msgid ""
"a ``Grid`` object that will be used to interface with the nodes running "
"the ``ClientApp`` to involve them in a round of train/evaluate/query or "
"other."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:363
#: ../../source/tutorial-quickstart-jax.rst:313
#: ../../source/tutorial-quickstart-mlx.rst:437
#: ../../source/tutorial-quickstart-pytorch.rst:399
#: ../../source/tutorial-quickstart-scikitlearn.rst:334
#: ../../source/tutorial-quickstart-tensorflow.rst:339
#: ../../source/tutorial-quickstart-xgboost.rst:409
msgid "a ``Context`` object that provides access to the run configuration."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:365
msgid ""
"In this example we use the |fedavg|_ and configure it with a specific "
"value of ``fraction_train`` which is read from the run config. You can "
"find the default value defined in the ``pyproject.toml``. Then, the "
"execution of the strategy is launched when invoking its "
"|strategy_start_link|_ method. To it we pass:"
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:370
#: ../../source/tutorial-quickstart-jax.rst:320
#: ../../source/tutorial-quickstart-mlx.rst:444
#: ../../source/tutorial-quickstart-pytorch.rst:406
#: ../../source/tutorial-quickstart-scikitlearn.rst:341
#: ../../source/tutorial-quickstart-tensorflow.rst:346
#: ../../source/tutorial-quickstart-xgboost.rst:416
msgid "the ``Grid`` object."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:371
#: ../../source/tutorial-quickstart-jax.rst:321
msgid ""
"an ``ArrayRecord`` carrying a randomly initialized model that will serve "
"as the global model to be federated."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:373
#: ../../source/tutorial-quickstart-pytorch.rst:409
#: ../../source/tutorial-quickstart-scikitlearn.rst:344
msgid ""
"a ``ConfigRecord`` with the training hyperparameters to be sent to the "
"clients. The strategy will also insert the current round number in this "
"config before sending it to the participating nodes."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:376
#: ../../source/tutorial-quickstart-jax.rst:323
#: ../../source/tutorial-quickstart-mlx.rst:447
#: ../../source/tutorial-quickstart-pytorch.rst:412
#: ../../source/tutorial-quickstart-scikitlearn.rst:347
#: ../../source/tutorial-quickstart-tensorflow.rst:349
msgid ""
"the ``num_rounds`` parameter specifying how many rounds of ``FedAvg`` to "
"perform."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:415
msgid ""
"Note the ``start`` method of the strategy returns a result object. This "
"object contains all the relevant information about the FL process, "
"including the final model weights as an ``ArrayRecord``, and federated "
"training and evaluation metrics as ``MetricRecords``. You can easily log "
"the metrics using Python's `pprint "
"<https://docs.python.org/3/library/pprint.html>`_ and save the global "
"model `state_dict` using ``torch.save``."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:422
msgid ""
"Congratulations! You've successfully built and run your first federated "
"learning system for an LLM."
msgstr ""

#: ../../source/tutorial-quickstart-huggingface.rst:427
msgid ""
"Check the source code of the extended version of this tutorial in "
"|quickstart_hf_link|_ in the Flower GitHub repository. For a "
"comprehensive example of a federated fine-tuning of an LLM with Flower, "
"refer to the |flowertune|_ example in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:-1
msgid ""
"Read this Federated Learning quickstart tutorial for creating an iOS app "
"using Flower to train a neural network on MNIST."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:5
msgid "Quickstart iOS"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:12
msgid ""
"The experimental Flower iOS SDK is not compatible with the latest version"
" of Flower. iOS support is currently being reworked and will be released "
"in 2025."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:15
msgid ""
"This quickstart tutorial is kept for historical purposes and will be "
"updated once the new iOS SDK is released."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:18
msgid ""
"In this tutorial we will learn how to train a Neural Network on MNIST "
"using Flower and CoreML on iOS devices."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:21
msgid ""
"First of all, for running the Flower Python server, it is recommended to "
"create a virtual environment and run everything within a :doc:`virtualenv"
" <contributor-how-to-set-up-a-virtual-env>`. For the Flower client "
"implementation in iOS, it is recommended to use Xcode as our IDE."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:26
msgid ""
"Our example consists of one Python *server* and two iPhone *clients* that"
" all have the same model."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:29
msgid ""
"*Clients* are responsible for generating individual weight updates for "
"the model based on their local datasets. These updates are then sent to "
"the *server* which will aggregate them to produce a better model. "
"Finally, the *server* sends this improved version of the model back to "
"each *client*. A complete cycle of weight updates is called a *round*."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:35
msgid ""
"Now that we have a rough idea of what is going on, let's get started to "
"setup our Flower server environment. We first need to install Flower. You"
" can do this by using pip:"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:42
msgid "Or Poetry:"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:50
msgid "Flower Client"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:52
msgid ""
"Now that we have all our dependencies installed, let's run a simple "
"distributed training using CoreML as our local training pipeline and "
"MNIST as our dataset. For simplicity reasons we will use the complete "
"Flower client with CoreML, that has been implemented and stored inside "
"the Swift SDK. The client implementation can be seen below:"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:90
msgid ""
"Let's create a new application project in Xcode and add ``flwr`` as a "
"dependency in your project. For our application, we will store the logic "
"of our app in ``FLiOSModel.swift`` and the UI elements in "
"``ContentView.swift``. We will focus more on ``FLiOSModel.swift`` in this"
" quickstart. Please refer to the `full code example "
"<https://github.com/adap/flower/tree/main/examples/ios>`_ to learn more "
"about the app."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:96
msgid "Import Flower and CoreML related packages in ``FLiOSModel.swift``:"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:104
msgid ""
"Then add the mlmodel to the project simply by drag-and-drop, the mlmodel "
"will be bundled inside the application during deployment to your iOS "
"device. We need to pass the url to access mlmodel and run CoreML machine "
"learning processes, it can be retrieved by calling the function "
"``Bundle.main.url``. For the MNIST dataset, we need to preprocess it into"
" ``MLBatchProvider`` object. The preprocessing is done inside "
"``DataLoader.swift``."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:122
msgid ""
"Since CoreML does not allow the model parameters to be seen before "
"training, and accessing the model parameters during or after the training"
" can only be done by specifying the layer name, we need to know this "
"information beforehand, through looking at the model specification, which"
" are written as proto files. The implementation can be seen in "
"``MLModelInspect``."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:128
msgid ""
"After we have all of the necessary information, let's create our Flower "
"client."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:143
msgid ""
"Then start the Flower gRPC client and start communicating to the server "
"by passing our Flower client to the function ``startFlwrGRPC``."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:151
msgid ""
"That's it for the client. We only have to implement ``Client`` or call "
"the provided ``MLFlwrClient`` and call ``startFlwrGRPC()``. The attribute"
" ``hostname`` and ``port`` tells the client which server to connect to. "
"This can be done by entering the hostname and port in the application "
"before clicking the start button to start the federated learning process."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:159
msgid "Flower Server"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:161
msgid ""
"For simple workloads we can start a Flower server and leave all the "
"configuration possibilities at their default values. In a file named "
"``server.py``, import Flower and start the server:"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:173
msgid "Train the model, federated!"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:175
msgid ""
"With both client and server ready, we can now run everything and see "
"federated learning in action. FL systems usually have a server and "
"multiple clients. We therefore have to start the server first:"
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:183
msgid ""
"Once the server is running we can start the clients in different "
"terminals. Build and run the client through your Xcode, one through Xcode"
" Simulator and the other by deploying it to your iPhone. To see more "
"about how to deploy your app to iPhone or Simulator visit `here "
"<https://developer.apple.com/documentation/xcode/running-your-app-in-"
"simulator-or-on-a-device>`_."
msgstr ""

#: ../../source/tutorial-quickstart-ios.rst:189
msgid ""
"Congratulations! You've successfully built and run your first federated "
"learning system in your ios device. The full `source code "
"<https://github.com/adap/flower/blob/main/examples/ios>`_ for this "
"example can be found in ``examples/ios``."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:-1
msgid ""
"Learn how to train a linear regression using federated learning with "
"Flower and JAX in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:9
msgid "Quickstart JAX"
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:11
msgid ""
"In this federated learning tutorial we will learn how to train a linear "
"regression model using Flower and `JAX "
"<https://jax.readthedocs.io/en/latest/>`_. It is recommended to create a "
"virtual environment and run everything within a :doc:`virtualenv "
"<contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:16
msgid ""
"Let's use ``flwr new`` to create a complete Flower+JAX project. It will "
"generate all the files needed to run, by default with the Flower "
"Simulation Engine, a federation of 10 nodes using |fedavg|_. A random "
"regression dataset will be loaded from scikit-learn's |makeregression|_ "
"function."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:29
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``JAX``), give a name to your project, and "
"type in your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:148
msgid ""
"This tutorial uses scikit-learn's |makeregression|_ function to generate "
"a random regression problem."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:163
msgid ""
"We defined a simple linear regression model to demonstrate how to create "
"a JAX model, but feel free to replace it with a more sophisticated JAX "
"model if you'd like, (such as with NN-based `Flax "
"<https://flax.readthedocs.io/en/latest/index.html>`_):"
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:174
msgid ""
"In addition to defining the model architecture, we also include two "
"utility functions to perform both training (i.e. ``train()``) and "
"evaluation (i.e. ``evaluation()``) using the above model."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:206
msgid ""
"The main changes we have to make to use JAX with Flower have to do with "
"converting the |arrayrecord_link|_ received in the |message_link|_ into "
"NumPy arrays and vice versa when generating the reply ``Message`` from "
"the ClientApp. We also have to introduce the ``get_params()`` and "
"``set_params()`` functions for setting parameter values for the JAX "
"model. In ``get_params()``, JAX model parameters are extracted and "
"represented as a list of NumPy arrays. The ``set_params()`` function is "
"the opposite: given a list of NumPy arrays it applies them to an existing"
" JAX model. We will combine these functions with the built-in methods in "
"the ``ArrayRecord`` to make these conversions:"
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:315
msgid ""
"In this example we use the |fedavg|_ and configure it with a specific "
"value of ``input_dim`` which is read from the run config. You can find "
"the default value defined in the ``pyproject.toml``. Then, the execution "
"of the strategy is launched when invoking its |strategy_start_link|_ "
"method. To it we pass:"
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:325
msgid ""
"You may also pass a ``ConfigRecord`` with the training hyperparameters to"
" be sent to the clients. The strategy will also insert the current round "
"number in this config before sending it to the participating nodes. An "
"example where a ``ConfigRecord`` is passed can be found in the "
":doc:`Quickstart PyTorch <tutorial-quickstart-pytorch>` tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:363
msgid ""
"Note the ``start`` method of the strategy returns a result object. This "
"object contains all the relevant information about the FL process, "
"including the final model weights as an ``ArrayRecord``, and federated "
"training and evaluation metrics as ``MetricRecords``. You can easily log "
"the metrics using Python's `pprint "
"<https://docs.python.org/3/library/pprint.html>`_ and save the global "
"model NumPy arrays using ``np.savez()`` as shown above."
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:370
msgid ""
"Congratulations! You've successfully built and run your first federated "
"learning system for JAX with Flower!"
msgstr ""

#: ../../source/tutorial-quickstart-jax.rst:375
msgid ""
"Check the source code of the extended version of this tutorial in "
"|quickstart_jax_link|_ in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:-1
msgid ""
"Learn how to train an MLP on MNIST using federated learning with Flower "
"and MLX in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:45
#, fuzzy
msgid "Quickstart MLX"
msgstr "빠른 시작"

#: ../../source/tutorial-quickstart-mlx.rst:47
msgid ""
"In this federated learning tutorial, we will learn how to train a simple "
"MLP on MNIST using Flower and MLX. It is recommended to create a virtual "
"environment and run everything within a :doc:`virtualenv <contributor-"
"how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:51
msgid ""
"Let's use `flwr new` to create a complete Flower+MLX project. It will "
"generate all the files needed to run, by default with the Simulation "
"Engine, a federation of 10 nodes using |fedavg_link|_. The dataset will "
"be partitioned using Flower Dataset's `IidPartitioner "
"<https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:65
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``MLX``), give a name to your project, and "
"enter your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:93
#: ../../source/tutorial-quickstart-xgboost.rst:100
msgid "To run the project do:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:100
#: ../../source/tutorial-quickstart-xgboost.rst:107
msgid "With default arguments, you will see output like this:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:168
#: ../../source/tutorial-quickstart-xgboost.rst:173
msgid ""
"You can also override the parameters defined in the "
"``[tool.flwr.app.config]`` section in the ``pyproject.toml`` like this:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:176
msgid ""
"What follows is an explanation of each component in the project you just "
"created: dataset partitioning, the model, defining the ``ClientApp``, and"
" defining the ``ServerApp``."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:184
msgid ""
"We will use `Flower Datasets <https://flower.ai/docs/datasets/>`_ to "
"easily download and partition the `MNIST` dataset. In this example, "
"you'll make use of the `IidPartitioner <https://flower.ai/docs/datasets"
"/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_"
" to generate `num_partitions` partitions. You can choose from other "
"partitioners <https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.html>`_ available in Flower Datasets:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:226
msgid ""
"We define the model as in the `centralized MLX example "
"<https://github.com/ml-explore/mlx-examples/tree/main/mnist>`_, it's a "
"simple MLP:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:249
msgid ""
"We also define some utility functions to test our model and to iterate "
"over batches."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:270
msgid ""
"The main changes we have to make to use `MLX` with `Flower` will be found"
" in the ``get_params()`` and ``set_params()`` functions. MLX doesn't "
"provide an easy way to convert the model parameters into a list of "
"``np.array`` objects (the format we need for message serialization to "
"work)."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:275
msgid "MLX stores its parameters as follows:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:288
msgid ""
"Therefore, to get our list of ``np.array`` objects, we need to extract "
"each array and convert it into a NumPy array:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:297
msgid ""
"For the ``set_params()`` function, we perform the reverse operation. We "
"receive a list of NumPy arrays and want to convert them into MLX "
"parameters. Therefore, we iterate through pairs of parameters and assign "
"them to the `weight` and `bias` keys of each layer dictionary:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:312
msgid ""
"The rest of the functionality is directly inspired by the centralized "
"case. The |clientapp_link|_ will train the model on local data using the "
"standard MLX training loop:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:325
msgid ""
"Let's put everything together and see the complete implementation of the "
"``ClientApp``. First, the behavior in a round of training is defined "
"inside a function wrapped with the ``@app.train()`` decorator."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:329
msgid ""
"After reading configuration parameters from the |context_link|_, we "
"instantiate the model and apply the global parameters sent by the server "
"using the ``set_params()`` function defined above. We then define the "
"optimizer and loss function, load the local data partition using the "
"``load_data()``, and train the model on the data. Finally, we compute the"
" accuracy and loss on the training data and construct a reply "
"|message_link|_ containing an |arrayrecord_link|_ with the updated model "
"parameters and a ``MetricRecord`` with the training accuracy and loss. "
"Very importantly it also contains the key `num-examples` which will be "
"used by the server to perform weighted averaging of the model parameters."
" The value of this key is the number of training examples in the local "
"data partition."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:393
msgid ""
"The ``ClientApp`` also allows for evaluation of the model on local test "
"data. This can be done by defining a function wrapped with the "
"``@app.evaluate()`` decorator. The signature of the function is identical"
" to that of the ``train()`` function. As shown below, the evaluation "
"function is very similar to the training function, except that we don't "
"perform any training. We still need to update the model parameters with "
"those sent by the server, and then we compute the loss and accuracy using"
" the functions defined above. Finally, we construct a reply "
"|message_link|_ containing a ``MetricRecord`` with the evaluation "
"accuracy and loss, as well as the key `num-examples`, which will be used "
"by the server to perform weighted averaging of the metrics."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:432
#: ../../source/tutorial-quickstart-xgboost.rst:404
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:488
msgid ""
"To construct a |serverapp_link|_, we define its ``@app.main()`` method. "
"This method receives as input arguments:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:439
msgid ""
"In this example we use the |fedavg_link|_ and left with its default "
"parameters. Then, after initializing the ``MLP`` that would serve as "
"global model in the first round, the execution of the strategy is "
"launched when invoking its |strategy_start_link|_ method. To it we pass:"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:445
#: ../../source/tutorial-quickstart-xgboost.rst:417
msgid ""
"an ``ArrayRecord`` carrying a randomly initialized model that will serve "
"as the global"
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:446
#: ../../source/tutorial-quickstart-xgboost.rst:418
#, fuzzy
msgid "model to federate."
msgstr "모델 매개변수."

#: ../../source/tutorial-quickstart-mlx.rst:485
#: ../../source/tutorial-quickstart-pytorch.rst:449
#: ../../source/tutorial-quickstart-xgboost.rst:469
msgid ""
"Note the ``start`` method of the strategy returns a |result_link|_ "
"object. This object contains all the relevant information about the FL "
"process, including the final model weights as an ``ArrayRecord``, and "
"federated training and evaluation metrics as ``MetricRecords``."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:490
#: ../../source/tutorial-quickstart-pytorch.rst:454
#: ../../source/tutorial-quickstart-tensorflow.rst:393
#: ../../source/tutorial-quickstart-xgboost.rst:474
msgid ""
"Congratulations! You've successfully built and run your first federated "
"learning system."
msgstr ""

#: ../../source/tutorial-quickstart-mlx.rst:494
msgid ""
"Check the `source code <https://github.com/adap/flower/blob/main/examples"
"/quickstart-mlx>`_ of the extended version of this tutorial in ``examples"
"/quickstart-mlx`` in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-pandas.rst:-1
msgid ""
"Check out this Federated Learning quickstart tutorial for using Flower "
"with Pandas to perform Federated Analytics."
msgstr ""

#: ../../source/tutorial-quickstart-pandas.rst:5
msgid "Quickstart Pandas"
msgstr ""

#: ../../source/tutorial-quickstart-pandas.rst:10
msgid "Let's build a federated analytics system using Pandas and Flower!"
msgstr ""

#: ../../source/tutorial-quickstart-pandas.rst:12
msgid ""
"Please refer to the `full code example "
"<https://github.com/adap/flower/tree/main/examples/quickstart-pandas>`_ "
"to learn more."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:-1
msgid ""
"Learn how to train a Convolutional Neural Network on CIFAR-10 using "
"federated learning with Flower and PyTorch in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:47
msgid ""
"In this federated learning tutorial we will learn how to train a "
"Convolutional Neural Network on CIFAR-10 using Flower and PyTorch. It is "
"recommended to create a virtual environment and run everything within a "
":doc:`virtualenv <contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:52
msgid ""
"Let's use `flwr new` to create a complete Flower+PyTorch project. It will"
" generate all the files needed to run, by default with the Flower "
"Simulation Engine, a federation of 10 nodes using |fedavg_link|_. The "
"dataset will be partitioned using Flower Dataset's `IidPartitioner "
"<https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:66
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``PyTorch``), give a name to your project, "
"and type in your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:185
msgid ""
"This tutorial uses `Flower Datasets <https://flower.ai/docs/datasets/>`_ "
"to easily download and partition the `CIFAR-10` dataset. In this example "
"you'll make use of the `IidPartitioner <https://flower.ai/docs/datasets"
"/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_"
" to generate `num_partitions` partitions. You can choose `other "
"partitioners <https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.html>`_ available in Flower Datasets. Each "
"``ClientApp`` will call this function to create dataloaders with the data"
" that correspond to their data partition."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:221
msgid ""
"We defined a simple Convolutional Neural Network (CNN), but feel free to "
"replace it with a more sophisticated model if you'd like:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:246
msgid ""
"In addition to defining the model architecture, we also include two "
"utility functions to perform both training (i.e. ``train()``) and "
"evaluation (i.e. ``test()``) using the above model. These functions "
"should look fairly familiar if you have some prior experience with "
"PyTorch. Note these functions do not have anything specific to Flower. "
"That being said, the training function will normally be called, as we'll "
"see later, from a Flower client passing its own data. In summary, your "
"clients can use standard training/testing functions to perform local "
"training or evaluation:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:296
msgid ""
"The main changes we have to make to use `PyTorch` with `Flower` have to "
"do with converting the |arrayrecord_link|_ received in the "
"|message_link|_ into a `PyTorch` state_dict, and vice versa when "
"generating the reply ``Message`` from the ClientApp. We can make use of "
"built-in methods in the ``ArrayRecord`` to make these conversions:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:334
#: ../../source/tutorial-quickstart-xgboost.rst:315
msgid ""
"The ``train`` method also receives the |context_link|_, giving access to "
"configs for your run and node. The run config hyperparameters are defined"
" in the ``pyproject.toml`` of your Flower App. The node config can only "
"be set when running Flower with the Deployment Runtime and is not "
"directly configurable during simulations."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:401
#: ../../source/tutorial-quickstart-scikitlearn.rst:336
#: ../../source/tutorial-quickstart-tensorflow.rst:341
msgid ""
"In this example we use the |fedavg_link|_ and configure it with a "
"specific value of ``fraction_train`` which is read from the run config. "
"You can find the default value defined in the ``pyproject.toml``. Then, "
"the execution of the strategy is launched when invoking its "
"|strategy_start_link|_ method. To it we pass:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:407
#: ../../source/tutorial-quickstart-scikitlearn.rst:342
#: ../../source/tutorial-quickstart-tensorflow.rst:347
msgid ""
"an ``ArrayRecord`` carrying a randomly initialized model that will serve "
"as the global model to federated."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch.rst:458
msgid ""
"Check the `source code <https://github.com/adap/flower/blob/main/examples"
"/quickstart-pytorch>`_ of the extended version of this tutorial in "
"``examples/quickstart-pytorch`` in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:-1
msgid ""
"Learn how to train an autoencoder on MNIST using federated learning with "
"Flower and PyTorch Lightning in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:9
msgid "Quickstart PyTorch Lightning"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:11
msgid ""
"In this federated learning tutorial we will learn how to train an "
"AutoEncoder model on MNIST using Flower and PyTorch Lightning. It is "
"recommended to create a virtual environment and run everything within a "
":doc:`virtualenv <contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:24
msgid ""
"This will create a new directory called `quickstart-pytorch-lightning` "
"containing the following files:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:47
msgid ""
"By default, Flower Simulation Engine will be started and it will create a"
" federation of 4 nodes using |fedavg|_ as the aggregation strategy. The "
"dataset will be partitioned using Flower Dataset's |iidpartitioner|_. To "
"run the project, do:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:122
msgid ""
"Each simulated `ClientApp` (two per round) will also log a summary of "
"their local training process. Expect this output to be similar to:"
msgstr ""

#: ../../source/tutorial-quickstart-pytorch-lightning.rst:144
msgid ""
"Check the `source code <https://github.com/adap/flower/tree/main/examples"
"/quickstart-pytorch-lightning>`_ of this tutorial in ``examples"
"/quickstart-pytorch-lightning`` in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:-1
msgid ""
"Learn how to train a logistic regression on MNIST using federated "
"learning with Flower and scikit-learn in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:-1
msgid ""
"Check out this Federated Learning quickstart tutorial for using Flower "
"with scikit-learn to train a linear regression model."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:37
msgid "Quickstart scikit-learn"
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:39
msgid ""
"In this federated learning tutorial we will learn how to train a Logistic"
" Regression on MNIST using Flower and scikit-learn. It is recommended to "
"create a virtual environment and run everything within a :doc:`virtualenv"
" <contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:43
msgid ""
"Let's use ``flwr new`` to create a complete Flower+scikit-learn project. "
"It will generate all the files needed to run, by default with the Flower "
"Simulation Engine, a federation of 10 nodes using |fedavg_link|_ The "
"dataset will be partitioned using |flowerdatasets|_'s |iidpartitioner|_"
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:56
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``sklearn``), give a name to your project, "
"and type in your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:187
msgid ""
"This tutorial uses |flowerdatasets|_ to easily download and partition the"
" `MNIST <https://huggingface.co/datasets/ylecun/mnist>`_ dataset. In this"
" example you'll make use of the |iidpartitioner|_ to generate "
"``num_partitions`` partitions. You can choose |otherpartitioners|_ "
"available in Flower Datasets. Each ``ClientApp`` will call this function "
"to create dataloaders with the data that correspond to their data "
"partition."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:213
msgid ""
"We define the |logisticregression|_ model from scikit-learn in the "
"``get_model()`` function:"
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:229
msgid ""
"The main changes we have to make to use ``Scikit-learn`` with ``Flower`` "
"have to do with converting the |arrayrecord_link|_ received in the "
"|message_link|_ into numpy ndarrays and then use them to set the model "
"parameters. After training, another auxiliary function can be used to "
"extract then pack the updated numpy ndarrays into a ``Message`` from the "
"ClientApp. We can make use of built-in methods in the ``ArrayRecord`` to "
"make these conversions:"
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:320
msgid ""
"The ``@app.evaluate`` method mirrors ``train`` but only evaluates the "
"received model on the local validation set. It returns a ``MetricRecord``"
" containing the evaluation loss and accuracy and does not include the "
"model weights, since they are not modified during evaluation."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:386
msgid ""
"Congratulations! You've successfully built and run your first federated "
"learning system in scikit-learn on the MNIST dataset using the new "
"Message API."
msgstr ""

#: ../../source/tutorial-quickstart-scikitlearn.rst:391
#, fuzzy
msgid ""
"Check the source code of another Flower App using ``scikit-learn`` in the"
" `Flower GitHub repository "
"<https://github.com/adap/flower/tree/main/examples/quickstart-sklearn-"
"tabular>`_."
msgstr ""
"보안 연결을 보여주는 전체 코드 예제는 '여기 "
"<https://github.com/adap/flower/tree/main/examples/advanced-"
"tensorflow>`_'에서 확인할 수 있습니다."

#: ../../source/tutorial-quickstart-tensorflow.rst:-1
msgid ""
"Learn how to train a Convolutional Neural Network on CIFAR-10 using "
"federated learning with Flower and TensorFlow in this step-by-step "
"tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:37
msgid "Quickstart TensorFlow"
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:39
msgid ""
"In this tutorial we will learn how to train a Convolutional Neural "
"Network on CIFAR-10 using the Flower framework and TensorFlow. First of "
"all, it is recommended to create a virtual environment and run everything"
" within a :doc:`virtualenv <contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:44
msgid ""
"Let's use `flwr new` to create a complete Flower+TensorFlow project. It "
"will generate all the files needed to run, by default with the Flower "
"Simulation Engine, a federation of 10 nodes using |fedavg_link|_. The "
"dataset will be partitioned using Flower Dataset's `IidPartitioner "
"<https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:58
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``TensorFlow``), give a name to your project,"
" and type in your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:173
msgid ""
"This tutorial uses `Flower Datasets <https://flower.ai/docs/datasets/>`_ "
"to easily download and partition the `CIFAR-10` dataset. In this example "
"you'll make use of the `IidPartitioner <https://flower.ai/docs/datasets"
"/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_"
" to generate `num_partitions` partitions. You can choose `other "
"partitioners <https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.html>`_ available in Flower Datasets. Each "
"``ClientApp`` will call this function to create the ``NumPy`` arrays that"
" correspond to their data partition."
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:201
msgid ""
"Next, we need a model. We defined a simple Convolutional Neural Network "
"(CNN), but feel free to replace it with a more sophisticated model if "
"you'd like:"
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:231
msgid ""
"The main changes we have to make to use `Tensorflow` with `Flower` have "
"to do with converting the |arrayrecord_link|_ received in the "
"|message_link|_ into numpy ndarrays for use with the built-in "
"``set_weights()`` function. After training, the ``get_weights()`` "
"function can be used to extract then pack the updated numpy ndarrays into"
" a ``Message`` from the ClientApp. We can make use of built-in methods in"
" the ``ArrayRecord`` to make these conversions:"
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:386
msgid ""
"Note the ``start`` method of the strategy returns a result object. This "
"object contains all the relevant information about the FL process, "
"including the final model weights as an ``ArrayRecord``, and federated "
"training and evaluation metrics as ``MetricRecords``. You can easily log "
"the metrics using Python's `pprint "
"<https://docs.python.org/3/library/pprint.html>`_ and save the final "
"model weights using Tensorflow's ``save()`` function."
msgstr ""

#: ../../source/tutorial-quickstart-tensorflow.rst:397
msgid ""
"Check the source code of the extended version of this tutorial in "
"|quickstart_tf_link|_ in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:-1
msgid ""
"Learn how to train a classification model on the Higgs dataset using "
"federated learning with Flower and XGBoost in this step-by-step tutorial."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:45
msgid "Quickstart XGBoost"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:47
msgid ""
"In this federated learning tutorial, we will learn how to train a simple "
"XGBoost classifier on Higgs dataset using Flower and XGBoost. It is "
"recommended to create a virtual environment and run everything within a "
":doc:`virtualenv <contributor-how-to-set-up-a-virtual-env>`."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:52
msgid ""
"Let's use `flwr new` to create a complete Flower+XGBoost project. It will"
" generate all the files needed to run, by default with the Simulation "
"Engine, a federation of 10 nodes using |fedxgbbagging_link|_ strategy. "
"The dataset will be partitioned using Flower Dataset's `IidPartitioner "
"<https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:58
msgid ""
"|fedxgbbagging_link|_ (bootstrap aggregation) is an ensemble method that "
"improves stability and accuracy in machine learning, here applied to "
"XGBoost in FL. Each client generates a bootstrap sample by subsampling "
"its data and trains a tree per round, which is then aggregated by the "
"server and added to the global model."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:71
msgid ""
"Then, run the command below. You will be prompted to select one of the "
"available templates (choose ``XGBoost``), give a name to your project, "
"and enter your developer name:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:181
msgid ""
"What follows is an explanation of each component in the project you just "
"created: configurations, dataset partitioning, defining the "
"``ClientApp``, and defining the ``ServerApp``."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:187
#, fuzzy
msgid "The Configurations"
msgstr "구성 값"

#: ../../source/tutorial-quickstart-xgboost.rst:189
msgid ""
"We define all required configurations / hyper-parameters inside the "
"``pyproject.toml`` file:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:210
msgid ""
"The ``local-epochs`` represents the number of iterations for local tree "
"boost. We use CPU for the training in default. One can assign it to a GPU"
" by setting ``tree-method`` to ``gpu_hist``. We use AUC as evaluation "
"metric."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:218
msgid ""
"We will use `Flower Datasets <https://flower.ai/docs/datasets/>`_ to "
"easily download and partition the `Higgs` dataset. In this example, "
"you'll make use of the `IidPartitioner <https://flower.ai/docs/datasets"
"/ref-"
"api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_"
" to generate `num_partitions` partitions. You can choose from other "
"`partitioners <https://flower.ai/docs/datasets/ref-"
"api/flwr_datasets.partitioner.html>`_ available in Flower Datasets:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:244
msgid ""
"We train/test split using the given partition (client's local data), and "
"reformat data to DMatrix for the ``xgboost`` package. The functions of "
"``train_test_split`` and ``transform_dataset_to_dmatrix`` are defined as "
"below:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:273
msgid ""
"The main changes we have to make to use `XGBoost` with `Flower` have to "
"do with converting the |arrayrecord_link|_ received in the "
"|message_link|_ into a `XGBoost` loadable binary object, and vice versa "
"when generating the reply ``Message`` from the ClientApp. We can make use"
" of the following conversions:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:372
msgid ""
"At the first round, we call ``xgb.train()`` to build up the first set of "
"trees. From the second round, we load the global model sent from server "
"to new build Booster object, and then update model weights on local "
"training data with function ``_local_boost`` as follows:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:392
msgid ""
"Given ``num_local_round``, we update trees by calling "
"``bst_input.update`` method. After training, the last "
"``N=num_local_round`` trees will be extracted to send to the server."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:411
msgid ""
"In this example we use the ``FedXgbBagging`` strategy. Then, we "
"initialize an empty global model as the XGBoost model will be initialized"
" on client side in the first round. After that, the execution of the "
"strategy is launched when invoking its |strategy_start_link|_ method. To "
"it we pass:"
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:419
msgid "the ``num_rounds`` parameter specifying how many rounds to perform."
msgstr ""

#: ../../source/tutorial-quickstart-xgboost.rst:478
msgid ""
"Check the `source code <https://github.com/adap/flower/blob/main/examples"
"/xgboost-quickstart>`_ of the extended version of this tutorial in "
"``examples/xgboost-quickstart`` in the Flower GitHub repository."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:3
#, fuzzy
msgid "Customize a Flower Strategy"
msgstr "사용자 정의 전략"

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:17
msgid ""
"Welcome to the third part of the Flower federated learning tutorial. In "
"previous parts of this tutorial, we introduced federated learning with "
"PyTorch and the Flower framework (:doc:`part 1 <tutorial-series-get-"
"started-with-flower-pytorch>`) and we learned how strategies can be used "
"to customize the execution on both the server and the clients (:doc:`part"
" 2 <tutorial-series-use-a-federated-learning-strategy-pytorch>`)."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:23
msgid ""
"In this tutorial, we'll continue to customize the federated learning "
"system we built previously by creating a much more customized version of "
"``FedAdagrad``."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:28
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:36
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:57
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:42
#: ../../source/tutorial-series-what-is-federated-learning.rst:17
msgid ""
"`Star Flower on GitHub <https://github.com/adap/flower>`__ ⭐️ and join "
"the Flower community on Flower Discuss and the Flower Slack to connect, "
"ask questions, and get help:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:32
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:40
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:61
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:46
#: ../../source/tutorial-series-what-is-federated-learning.rst:21
msgid ""
"`Join Flower Discuss <https://discuss.flower.ai/>`__ We'd love to hear "
"from you in the ``Introduction`` topic! If anything is unclear, post in "
"``Flower Help - Beginners``."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:35
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:43
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:64
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:49
#: ../../source/tutorial-series-what-is-federated-learning.rst:24
#, fuzzy
msgid ""
"`Join Flower Slack <https://flower.ai/join-slack>`__ We'd love to hear "
"from you in the ``#introductions`` channel! If anything is unclear, head "
"over to the ``#questions`` channel."
msgstr ""
"`Star Flower on GitHub <https://github.com/adap/flower>`__ ⭐️ Slack의 오픈소스"
" Flower 커뮤니티에 가입하여 소통하고 질문하고 도움을 받을 수 있습니다: `Slack 가입<https://flower.ai"
"/join-slack>`__ 🌼 ``#introductions``채널에서 당신의 목소리를 듣고 싶습니다! 궁금한 점이 "
"있으시면``#questions`` 채널로 방문해 주시기 바랍니다."

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:39
msgid ""
"Let's build a new ``Strategy`` with a customized |strategy_start_link|_ "
"method that:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:41
msgid "saves a copy of the global model when a new best global accuracy is found;"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:42
msgid "logs the metrics generated during the run to Weights & Biases!"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:46
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:52
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:72
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:57
msgid "Preparation"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:48
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:54
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:59
msgid ""
"Before we begin with the actual code, let's make sure that we have "
"everything we need."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:51
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:57
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:62
msgid "Installing dependencies"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:55
msgid ""
"If you've completed part 1 and 2 of the tutorial, you can skip this step."
" But remember to include ``wandb`` as a dependency in your "
"``pyproject.toml`` file and install it in your environment."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:73
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:77
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:93
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:82
msgid ""
"After running the command, a new directory called ``flower-tutorial`` "
"will be created. It should have the following structure:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:88
msgid ""
"Next, add the `wandb` dependency to the project by editing the "
"``pyproject.toml`` file located in the root of the project. Add the "
"following line to the list of dependencies:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:95
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:91
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:97
msgid ""
"Next, we install the project and its dependencies, which are specified in"
" the ``pyproject.toml`` file:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:105
msgid ""
"If this is your first time installing ``wandb``, you might be asked to "
"create an account and then log in to your system. You can start this "
"process by typing this in your terminal:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:115
msgid "Customize the ``start`` method of a strategy"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:117
msgid ""
"Flower strategies have a number of methods that can be overridden to "
"customize their behavior. In part 2, you learned how to customize the "
"``configure_train`` method to perform learning rate decay and communicate"
" the updated learning rate as part of the |configrecord_link|_ sent to "
"the clients in the ``Message``. In this tutorial you'll learn how to "
"customize the |strategy_start_link|_ method. If you inspect the `source "
"code "
"<https://github.com/adap/flower/blob/main/framework/py/flwr/serverapp/strategy/strategy.py#L135>`_"
" of this method you'll see that it contains a for loop where each "
"iteration represents a federated learning round. Each round consists of "
"three distinct stages:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:127
msgid ""
"A training stage, where a subset of clients is selected to train the "
"current global model on their local data."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:129
msgid ""
"An evaluation stage, where a subset of clients is selected to evaluate "
"the updated global model on their local validation sets."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:131
msgid ""
"An optional stage to evaluate the global model on the server side. Note "
"that this is what you enabled in part 2 of this tutorial by means of the "
"``central_evaluate`` callback."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:135
msgid ""
"Let's extend the ``CustomFedAdagrad`` strategy we created earlier and "
"introduce:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:137
msgid ""
"``_update_best_acc``: An auxiliary method to save the global model "
"whenever a new best accuracy is found."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:139
msgid ""
"``set_save_path``: An auxiliary method to set the path where ``wandb`` "
"logs and model checkpoints will be saved. This method will be called from"
" the ``server_app.py`` after instantiating the strategy."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:142
msgid ""
"A customized |strategy_start_link|_ method to log metrics to Weight & "
"Biases (`W&B <https://wandb.ai/site>`__) and save the model checkpoints "
"to disk."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:330
msgid ""
"With the extended ``CustomFedAdagrad`` strategy defined, we now need to "
"set the path where the model checkpoints will be saved as well as the "
"name of the runs in ``W&B``. We need to call the ``set_save_path`` method"
" after instantiating the strategy and before calling the ``start`` "
"method. In ``server_app.py``, we can create a new directory called "
"``results`` and then a subdirectory with the current timestamp to store "
"the results of each run. We can then call the ``set_save_path``. In this "
"tutorial we create the directory based on the current date and time, this"
" means that each time you do ``flwr run`` a new directory will be used. "
"Let's see how this looks in code:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:367
#, fuzzy
msgid "Finally, let's run the ``FlowerApp``:"
msgstr "Flower 시뮬레이션."

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:373
msgid "After starting the run you will notice two things:"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:375
msgid ""
"A new directory will be created in ``outputs/YYYY-MM-DD/HH-MM-SS`` where "
"``YYYY-MM-DD/HH-MM-SS`` is the current date and time. This directory will"
" contain the model checkpoints saved during the run. Recall that a "
"checkpoint is saved whenever a new best accuracy is found during the "
"centralized evaluation stage."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:379
msgid ""
"A new run will be created in your `W&B project <https://wandb.ai/home>`_ "
"where you can visualize the metrics logged during the run."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:382
msgid ""
"Congratulations! You've successfully created a custom Flower strategy by "
"overriding the |strategy_start_link|_ method. You've also learned how to "
"log metrics to Weight & Biases and how to save model checkpoints to disk."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:388
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:326
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:426
msgid "Recap"
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:390
msgid ""
"In this tutorial, we've seen how to customize the |strategy_start_link|_ "
"method of a Flower strategy. This method is the main entry point of any "
"strategy and contains the logic to execute the federated learning "
"process. In this tutorial, you learned how to log the metrics to Weight &"
" Biases and how to save model checkpoints to disk."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:395
msgid ""
"In the next tutorial, we're going to cover how to communicate arbitrary "
"Python objects between the ``ClientApp`` and the ``ServerApp`` by "
"serializing them and send them in a ``Message`` as a ``ConfigRecord``."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:403
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:339
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:702
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:443
#: ../../source/tutorial-series-what-is-federated-learning.rst:369
msgid ""
"Before you continue, make sure to join the Flower community on Flower "
"Discuss (`Join Flower Discuss <https://discuss.flower.ai>`__) and on "
"Slack (`Join Slack <https://flower.ai/join-slack/>`__)."
msgstr ""

#: ../../source/tutorial-series-build-a-strategy-from-scratch-pytorch.rst:407
#: ../../source/tutorial-series-customize-the-client-pytorch.rst:343
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:706
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:447
#: ../../source/tutorial-series-what-is-federated-learning.rst:373
msgid ""
"There's a dedicated ``#questions`` Slack channel if you need help, but "
"we'd also love to hear who you are in ``#introductions``!"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:3
#, fuzzy
msgid "Communicate custom Messages"
msgstr "해결법"

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:21
msgid ""
"Welcome to the fourth part of the Flower federated learning tutorial. In "
"the previous parts of this tutorial, we introduced federated learning "
"with PyTorch and Flower (:doc:`part 1 <tutorial-series-get-started-with-"
"flower-pytorch>`), we learned how strategies can be used to customize the"
" execution on both the server and the clients (:doc:`part 2 <tutorial-"
"series-use-a-federated-learning-strategy-pytorch>`) and we built our own "
"custom strategy from scratch (:doc:`part 3 <tutorial-series-build-a"
"-strategy-from-scratch-pytorch>`)."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:29
msgid ""
"In this final tutorial, we turn our attention again to the ``ClientApp`` "
"and show how to communicate arbitrary Python objects via a ``Message`` "
"and how to use it on the ``ServerApp``. This can be useful if you want to"
" send additional information between ``ClientApp <--> ServerApp`` without"
" the need for custom protocols."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:47
msgid ""
"Let's go deeper and see how to serialize arbitrary Python objects and "
"communicate them! 🌼"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:61
#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:66
msgid "If you've completed part 1 of the tutorial, you can skip this step."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:101
#, fuzzy
msgid "Revisiting replying from ClientApps"
msgstr "NumPyClient"

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:103
msgid ""
"Let's remind ourselves how the communication between ``ClientApp`` and "
"``ServerApp`` works. A ``ClientApp`` function wrapped with "
"``@app.train()`` would typically return the locally updated model "
"parameters in addition to some metrics relevant to the training process, "
"such as the training loss and accuracy. In code, this would look like:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:126
msgid ""
"Then, on the ``ServerApp``, the Flower strategy will automatically "
"aggregate the |arrayrecord_link|_ and |metricrecord_link|_ from each "
"client into a single ``ArrayRecord`` and ``MetricRecord`` that can be "
"used to update the global model and log the aggregated metrics. Now, what"
" if we wanted to send additional information from the ``ClientApp`` to "
"the ``ServerApp``? For example, let's say we want to send how long the "
"execution of the ``ClientApp`` took. We can do this by adding a new "
"metric to the ``MetricRecord``. It will also be aggregated automatically "
"by the strategy. If you do for example:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:163
msgid ""
"If you'd like to communicate other types of objects and leave them out of"
" the aggregation process, you can use a |configrecord_link|_. In addition"
" to integers and floats, you can use a ``ConfigRecord`` to send strings, "
"booleans and even bytes. In the next section we'll learn to communicate "
"arbitrary Python objects by first serializing them to bytes."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:171
msgid "Communicating arbitrary objects"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:173
msgid ""
"Let's assume the training stage of our ``ClientApp`` produces a dataclass"
" like the one below and we would like to communicate it to the "
"``ServerApp`` via the ``Message``. Let's go ahead and define this in "
"``task.py``:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:190
msgid ""
"Now, let's see how the ``ClientApp`` can serialize this object, send it "
"to the ``ServerApp``, make the strategy deserialize it back to the "
"original object, and use it."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:194
#, fuzzy
msgid "Sending from ClientApps"
msgstr "클라이언트앱"

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:196
msgid ""
"Let's assume our ``ClientApp`` trains the model locally and generates an "
"instance of ``TrainProcessMetadata``. In order to send it as part of the "
"message reply, we need to serialize it to bytes. In this case, we can use"
" the ``pickle`` module from the Python standard library. We can then send"
" the serialized object in a ``ConfigRecord`` in the ``Message`` reply. "
"Let's see how this would look like in code:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:204
msgid ""
"The following code is for demonstration purposes only. In real-world "
"applications, since `pickle "
"<https://docs.python.org/3/library/pickle.html>`_ can execute arbitrary "
"code during unpickling, you should use a **SAFE** serialization method "
"than ``pickle``, such as ``json`` or a simple custom solution if the "
"object is not too complex. ``pickle`` is used here solely for simplicity."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:252
msgid ""
"Let's see next how the strategy on the ``ServerApp`` can deserialize the "
"object back to its original form and use it."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:256
#, fuzzy
msgid "Receiving on ServerApps"
msgstr "Flower 서버앱"

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:258
msgid ""
"As you know, a Flower strategy will automatically aggregate the "
"``ArrayRecord`` and ``MetricRecord`` from each client. However, it will "
"not do anything with the ``ConfigRecord`` we just sent. We can override "
"the ``aggregate_train`` method of our strategy to handle the "
"deserialization and use of the ``TrainProcessMetadata`` object."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:265
msgid ""
"We override the ``aggregate_train`` method because we sent the object "
"from a ``@app.train()`` function. If we had sent it from an "
"``@app.evaluate()`` function, we would override the "
"``aggregate_evaluate`` method instead."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:269
msgid ""
"Let's create a new custom strategy (or reuse the one created in part 2 "
"and part 3 of this tutorial) in ``server_app.py`` that extends the "
"``FedAdagrad`` strategy and overrides the ``aggregate_train`` method to "
"deserialize the ``TrainProcessMetadata`` object from each client and "
"print the training time and convergence status:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:302
#, fuzzy
msgid "Finally, we run the Flower App."
msgstr "Flower 시뮬레이션."

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:308
msgid ""
"You will observe that the training metadata from each client is logged to"
" the console of the ``ServerApp``. If you finish embedding the creation "
"of the ``TrainProcessMetadata`` object in the ``ClientApp``, you should "
"see output similar to this:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:320
msgid ""
"You can now use this information in your strategy logic as needed. For "
"example, to implement a custom aggregation method based on convergence "
"status or to log additional metrics."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:328
msgid ""
"In this part of the tutorial, we've seen how to communicate arbitrary "
"Python objects between the ``ClientApp`` and the ``ServerApp`` by "
"serializing them to bytes and sending them as a ``ConfigRecord`` in a "
"``Message``. We also learned how to deserialize them back to their "
"original form on the server side and use them in a custom strategy. Note "
"that the steps presented here are identical if you need to serialize "
"objects in the strategy to send them to the clients."
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:346
msgid ""
"This is the final part of the Flower tutorial (for now!), "
"congratulations! You're now well equipped to understand the rest of the "
"documentation. There are many topics we didn't cover in the tutorial, we "
"recommend the following resources:"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:350
msgid "`Read Flower Docs <https://flower.ai/docs/>`__"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:351
msgid "`Check out Flower Code Examples <https://flower.ai/docs/examples/>`__"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:352
msgid ""
"`Use Flower Baselines for your research "
"<https://flower.ai/docs/baselines/>`__"
msgstr ""

#: ../../source/tutorial-series-customize-the-client-pytorch.rst:353
msgid ""
"`Watch Flower AI Summit 2025 videos <https://flower.ai/events/flower-ai-"
"summit-2025/>`__"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:3
msgid "Get started with Flower"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:49
#: ../../source/tutorial-series-what-is-federated-learning.rst:5
msgid "Welcome to the Flower federated learning tutorial!"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:51
msgid ""
"In this tutorial, we'll build a federated learning system using the "
"Flower framework, Flower Datasets and PyTorch. In part 1, we use PyTorch "
"for model training and data loading. In part 2, we federate this PyTorch "
"project using Flower."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:68
#, fuzzy
msgid "Let's get started! 🌼"
msgstr "시작하기"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:74
msgid ""
"Before we begin with any actual code, let's make sure that we have "
"everything we need."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:108
msgid ""
"Next, we install the project and its dependencies, which are specified in"
" the ``pyproject.toml`` file."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:116
msgid ""
"Before we dive into federated learning, we'll take a look at the dataset "
"that we'll be using for this tutorial, which is the `CIFAR-10 "
"<https://www.cs.toronto.edu/~kriz/cifar.html>`_ dataset, and run a simple"
" centralized training pipeline using PyTorch."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:122
msgid "The ``CIFAR-10`` dataset"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:124
msgid ""
"Federated learning can be applied to many different types of tasks across"
" different domains. In this tutorial, we introduce federated learning by "
"training a simple convolutional neural network (CNN) on the popular "
"CIFAR-10 dataset. CIFAR-10 can be used to train image classifiers that "
"distinguish between images from ten different classes: 'airplane', "
"'automobile', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', and "
"'truck'."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:131
msgid ""
"We simulate having multiple datasets from multiple organizations (also "
"called the “cross-silo” setting in federated learning) by splitting the "
"original CIFAR-10 dataset into multiple partitions. Each partition will "
"represent the data from a single organization. We're doing this purely "
"for experimentation purposes. In the real world there's no need for data "
"splitting because each organization already has their own data (the data "
"is naturally partitioned)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:138
msgid ""
"Each organization will act as a client in the federated learning system. "
"Having ten organizations participate in a federation means having ten "
"clients connected to the federated learning server."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:142
msgid ""
"We use the `Flower Datasets <https://flower.ai/docs/datasets/>`_ library "
"(``flwr-datasets``) to partition CIFAR-10 into ten partitions using "
"``FederatedDataset``. Using the ``load_data()`` function defined in "
"``task.py``, we will create a small training and test set for each of the"
" ten organizations and wrap each of these into a PyTorch ``DataLoader``:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:177
msgid ""
"We now have a function that can return a training set and validation set "
"(``trainloader`` and ``valloader``) representing one dataset from one of "
"ten different organizations. Each ``trainloader``/``valloader`` pair "
"contains 4000 training examples and 1000 validation examples. There's "
"also a single ``testloader`` (we did not split the test set). Again, this"
" is only necessary for building research or educational systems, actual "
"federated learning systems have their data naturally distributed across "
"multiple partitions."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:187
#, fuzzy
msgid "The model, training, and test functions"
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:189
msgid ""
"Next, we're going to use PyTorch to define a simple convolutional neural "
"network. This introduction assumes basic familiarity with PyTorch, so it "
"doesn't cover the PyTorch-related aspects in full detail. If you want to "
"dive deeper into PyTorch, we recommend `this introductory tutorial "
"<https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html>`_."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:198
msgid ""
"We will use the simple CNN described in the aforementioned PyTorch "
"tutorial (The following code is already defined in ``task.py``):"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:224
#, fuzzy
msgid "Training and test functions"
msgstr "클라이언트 앱에 평가함수를 등록하는 데코레이터를 반환합니다."

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:226
msgid "The PyTorch template also provides the usual training and test functions:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:268
#, fuzzy
msgid "Federated Learning with Flower"
msgstr "연합 학습"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:270
msgid ""
"In federated learning, the server sends global model parameters to the "
"client, and the client updates the local model with parameters received "
"from the server. It then trains the model on the local data (which "
"changes the model parameters locally) and sends the updated/changed model"
" parameters back to the server (or, alternatively, it sends just the "
"gradients back to the server, not the full model parameters)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:277
msgid "Constructing Messages"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:279
msgid ""
"In Flower, the server and clients communicate by sending and receiving "
"|message_link|_ objects. A ``Message`` carries a ``RecordDict`` as its "
"main payload. The ``RecordDict`` is like a Python dictionary that can "
"contain multiple records of different types. There are three main types "
"of records:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:284
#, fuzzy
msgid ""
"|arrayrecord_link|_: Contains model parameters as a dictionary of NumPy "
"arrays"
msgstr "**parameters** -- 로컬 모델 파라미터를 NumPy 배열 목록으로 표시합니다."

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:285
msgid ""
"|metricrecord_link|_: Contains training or evaluation metrics as a "
"dictionary of integers, floats, lists of integers, or lists of floats."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:287
msgid ""
"|configrecord_link|_: Contains configuration parameters as a dictionary "
"of integers, floats, strings, booleans, or bytes. Lists of these types "
"are also supported."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:290
msgid ""
"Let's see a few examples of how to work with these types of records and, "
"ultimately, construct a ``RecordDict`` that can be sent over a "
"``Message``."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:316
#, fuzzy
msgid "Define the Flower ClientApp"
msgstr "Flower 클라이언트 앱을 실행합니다."

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:318
msgid ""
"Federated learning systems consist of a server and multiple nodes or "
"clients. In Flower, we create a |serverapp_link|_ and a |clientapp_link|_"
" to run the server-side and client-side code, respectively."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:322
msgid ""
"The core functionality of the ``ClientApp`` is to perform some action "
"with the local data that the node it runs from (e.g. an edge device, a "
"server in a data center, or a laptop) has access to. In this tutorial "
"such action is to train and evaluate the small CNN model defined earlier "
"using the local training and validation data."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:328
#, fuzzy
msgid "Training"
msgstr "중앙 집중식 훈련"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:330
msgid ""
"We can define how the ``ClientApp`` performs training by wrapping a "
"function with the ``@app.train()`` decorator. In this case we name this "
"function ``train`` because we'll use it to train the model on the local "
"data. The function always expects two arguments:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:334
msgid ""
"A |message_link|_: The message received from the server. It contains the "
"model parameters and any other configuration information sent by the "
"server."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:336
msgid ""
"A |context_link|_: The context object that contains information about the"
" node executing the ``ClientApp`` and about the current run."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:339
msgid ""
"Through the context you can retrieve the config settings defined in the "
"``pyproject.toml`` of your app. The context can be used to persist the "
"state of the client across multiple calls to ``train`` or ``evaluate``. "
"In Flower, ``ClientApps`` are ephemeral objects that get instantiated for"
" the execution of one ``Message`` and destroyed when a reply is "
"communicated back to the server."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:345
msgid ""
"Let's see an implementation of ``ClientApp`` that uses the previously "
"defined PyTorch CNN model, applies the parameters received from the "
"``ServerApp`` via the message, loads its local data, trains the model "
"with it (using the ``train_fn`` function), and generates a reply "
"``Message`` containing the updated model parameters as well as some "
"metrics of interest."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:393
msgid ""
"Note that the ``train_fn`` is simply an alias name pointing to the train "
"function defined earlier in this tutorial (where we defined the PyTorch "
"training loop and optimizer). To this function we pass the model we want "
"to train locally and the data loader, but also the number of local epochs"
" and the learning rate (``lr``) to use. Note how in this case the "
"``local-epochs`` setting is read from the run config via the ``Context`` "
"while the ``lr`` is read from the ``ConfigRecord`` sent by the server via"
" the ``Message``. This can be used to adjust the learning rate on each "
"round from the server. When this dynamism isn't needed, reading the "
"``lr`` from the run config via the ``Context`` is also perfectly valid."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:403
msgid ""
"Once training is completed, the ``ClientApp`` constructs a reply "
"``Message``. This reply typically includes a ``RecordDict`` with two "
"records:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:406
msgid "An ``ArrayRecord`` containing the updated model parameters"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:407
msgid ""
"A ``MetricRecord`` with relevant metrics (in this case, the training loss"
" and the number of examples used for training)"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:412
msgid ""
"Returning the number of examples under the ``\"num-examples\"`` key is "
"**required**, because strategies such as |fedavg_link|_ used by the "
"``ServerApp`` rely on this key to aggregate both models and metrics by "
"default, unless you override the ``weighted_by_key`` argument (for "
"example: ``FedAvg(weighted_by=\"my-different-key\")``)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:418
msgid ""
"After constructing the reply ``Message``, the ``ClientApp`` returns it. "
"Flower then handles sending the reply back to the server automatically."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:422
#, fuzzy
msgid "Evaluation"
msgstr "평가"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:424
msgid ""
"In a typical federated learning setup, the ``ClientApp`` would also "
"implement an ``@app.evaluate()`` function to evaluate the model received "
"from the ``ServerApp`` on local validation data. This is especially "
"useful to monitor the performance of the global model on each client "
"during training. The implementation of the ``evaluate`` function is very "
"similar to the ``train`` function, except that it calls the ``test_fn`` "
"function defined earlier in this tutorial (which implements the PyTorch "
"evaluation loop) and it returns a ``Message`` containing only a "
"``MetricRecord`` with the evaluation metrics (no ``ArrayRecord`` because "
"the model parameters are not updated during evaluation). Here's how the "
"``evaluate`` function looks like:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:471
msgid ""
"As you can see the ``evaluate`` implementation is near identical to the "
"``train`` implementation, except that it calls the ``test_fn`` function "
"instead of the ``train_fn`` function and it returns a ``Message`` "
"containing only a ``MetricRecord`` with metrics relevant to evaluation "
"(``eval_loss``, ``eval_acc`` -- both scalars). We also need to include "
"the ``num-examples`` key in the metrics so the server can aggregate the "
"evaluation metrics correctly."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:479
#, fuzzy
msgid "Define the Flower ServerApp"
msgstr "Flower 서버앱"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:481
msgid ""
"On the server side, we need to configure a strategy which encapsulates "
"the federated learning approach/algorithm, for example, *Federated "
"Averaging* (FedAvg). Flower has a number of built-in strategies, but we "
"can also use our own strategy implementations to customize nearly all "
"aspects of the federated learning approach. For this tutorial, we use the"
" built-in ``FedAvg`` implementation and customize it slightly by "
"specifying the fraction of connected nodes to involve in a round of "
"training."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:493
msgid "a |context_link|_ object that provides access to the run configuration."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:495
msgid ""
"Before launching the strategy via the |strategy_start_link|_ method, we "
"want to initialize the global model. This will be the model that gets "
"sent to the ``ClientApp`` running on the clients in the first round of "
"federated learning. We can do this by creating an instance of the model "
"(``Net``), extracting the parameters in its ``state_dict``, and "
"constructing an ``ArrayRecord`` with them. We can then make it available "
"to the strategy via the ``initial_arrays`` argument of the ``start()`` "
"method."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:502
msgid ""
"We can also optionally pass to the ``start()`` method a ``ConfigRecord`` "
"containing settings that we would like to communicate to the clients. "
"These will be sent as part of the ``Message`` that also carries the model"
" parameters."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:540
msgid ""
"Most of the execution of the ``ServerApp`` happens inside the "
"``strategy.start()`` method. After the specified number of rounds "
"(``num_rounds``), the ``start()`` method returns a |result_link|_ object "
"containing the final model parameters and metrics received from the "
"clients or generated by the strategy itself. We can then save the final "
"model to disk for later use."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:547
msgid "Run the training"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:549
msgid ""
"With all of these components in place, we can now run the federated "
"learning simulation with Flower! The last step is to run our simulation "
"in the command line, as follows:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:556
msgid ""
"This will execute the federated learning simulation with 10 clients, or "
"SuperNodes, defined in the ``[tool.flwr.federations.local-simulation]`` "
"section in the ``pyproject.toml``. You should expect an output log "
"similar to this:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:636
msgid ""
"Learn more about how to configure the execution of your Flower App by "
"checking the `pyproject.toml <how-to-configure-pyproject-toml.html>`_ "
"guide."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:640
msgid "Behind the scenes"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:642
msgid "So how does this work? How does Flower execute this simulation?"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:644
msgid ""
"When we execute ``flwr run``, we tell Flower that there are 10 clients "
"(``options.num-supernodes = 10``, where each SuperNode launches one "
"``ClientApp``)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:647
msgid ""
"Flower then asks the ``ServerApp`` to issue instructions to those nodes "
"using the ``FedAvg`` strategy. In this example, ``FedAvg`` is configured "
"with two key parameters:"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:650
#, python-format
msgid "``fraction-train=0.5`` → select 50% of the available clients for training"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:651
#, python-format
msgid ""
"``fraction-evaluate=1.0`` → select 100% of the available clients for "
"evaluation"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:653
msgid ""
"This means in our example, 5 out of 10 clients will be selected for "
"training, and all 10 clients will later participate in evaluation."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:656
#, fuzzy
msgid "A typical round looks like this:"
msgstr "일반적인 mod 함수는 다음과 같은 모습일 수 있습니다:"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:658
#, fuzzy
msgid "**Training**"
msgstr "설명"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:660
#, python-format
msgid "``FedAvg`` randomly selects 5 clients (50% of 10)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:661
msgid "Flower sends a ``TRAIN`` message to each selected ``ClientApp``."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:662
msgid ""
"Each ``ClientApp`` calls the function decorated with ``@app.train()``, "
"then returns a ``Message`` containing an ``ArrayRecord`` (the updated "
"model parameters) and a ``MetricRecord`` (the training loss and number of"
" examples)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:665
#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:676
msgid "The ``ServerApp`` receives all replies."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:666
msgid ""
"``FedAvg`` aggregates all ``ArrayRecord`` into a new ``ArrayRecord`` "
"representing the new global model and combines all ``MetricRecord``."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:669
#, fuzzy
msgid "**Evaluation**"
msgstr "평가"

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:671
msgid "``FedAvg`` selects all 10 clients (100%)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:672
msgid "Flower sends an ``EVALUATE`` message to each ``ClientApp``."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:673
msgid ""
"Each ``ClientApp`` calls the function decorated with ``@app.evaluate()`` "
"and returns a ``Message`` containing a ``MetricRecord`` (the evaluation "
"loss, accuracy, and number of examples)."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:677
msgid "``FedAvg`` aggregates all ``MetricRecord``."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:679
msgid ""
"Once both training and evaluation are done, the next round begins: "
"another training step, then another evaluation step, and so on, until the"
" configured number of rounds is reached."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:685
msgid "Final remarks"
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:687
msgid ""
"Congratulations, you just trained a convolutional neural network, "
"federated over 10 clients! With that, you understand the basics of "
"federated learning with Flower. The same approach you've seen can be used"
" with other machine learning frameworks (not just PyTorch) and tasks (not"
" just CIFAR-10 image classification), for example NLP with Hugging Face "
"Transformers or speech with SpeechBrain."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:693
msgid ""
"In the next tutorial, we're going to cover some more advanced concepts. "
"Want to customize your strategy? Do learning rate decay at the strategy "
"and communicate it to the clients ? Or evaluate the aggregated model on "
"the server side? We'll cover all this and more in the next tutorial."
msgstr ""

#: ../../source/tutorial-series-get-started-with-flower-pytorch.rst:709
msgid ""
"The :doc:`Flower Federated Learning Tutorial - Part 2 <tutorial-series-"
"use-a-federated-learning-strategy-pytorch>` goes into more depth about "
"strategies and all the advanced things you can build with them."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:3
msgid "Use a federated learning strategy"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:33
msgid ""
"Welcome to the next part of the federated learning tutorial. In previous "
"parts of this tutorial, we introduced federated learning with PyTorch and"
" Flower (:doc:`part 1 <tutorial-series-get-started-with-flower-"
"pytorch>`)."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:37
msgid ""
"In part 2, we'll begin to customize the federated learning system we "
"built in part 1 using the Flower framework, Flower Datasets, and PyTorch."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:53
msgid "Let's move beyond FedAvg with Flower strategies! 🌼"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:105
msgid ""
"So far, everything should look familiar if you've worked through the "
"introductory tutorial. With that, we're ready to introduce a number of "
"new features."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:110
msgid "Choosing a different strategy"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:112
msgid ""
"In part 1, we created a |serverapp_link|_ (in ``server_app.py``). In it, "
"we defined the strategy, the model to federatedly train, and then we "
"launched the strategy by calling its ``|strategy_start_link|`` method."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:116
msgid ""
"The strategy encapsulates the federated learning approach/algorithm, for "
"example, |fedavg_link|_. Let's try to use a different strategy this time."
" Modify the following lines in your ``server_app.py`` to switch from "
"``FedAvg`` to |fedadagrad_link|_."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:155
#, fuzzy
msgid "Next, run the training with the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:163
msgid "Server-side parameter **evaluation**"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:165
msgid ""
"Flower can evaluate the aggregated model on the server side or on the "
"client side. Client-side and server-side evaluation are similar in some "
"ways, but different in others."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:169
msgid ""
"**Centralized Evaluation** (or *server-side evaluation*) is conceptually "
"simple: it works the same way that evaluation in centralized machine "
"learning does. If there is a server-side dataset that can be used for "
"evaluation purposes, then that's great. We can evaluate the newly "
"aggregated model after each round of training without having to send the "
"model to clients. We're also fortunate in the sense that our entire "
"evaluation dataset is available at all times."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:176
msgid ""
"**Federated Evaluation** (or *client-side evaluation*) is more complex, "
"but also more powerful: it doesn't require a centralized dataset and "
"allows us to evaluate models over a larger set of data, which often "
"yields more realistic evaluation results. In fact, many scenarios require"
" us to use **Federated Evaluation** if we want to get representative "
"evaluation results at all. But this power comes at a cost: once we start "
"to evaluate on the client side, we should be aware that our evaluation "
"dataset can change over consecutive rounds of learning if those clients "
"are not always available. Moreover, the dataset held by each client can "
"also change over consecutive rounds. This can lead to evaluation results "
"that are not stable, so even if we would not change the model, we'd see "
"our evaluation results fluctuate over consecutive rounds."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:187
msgid ""
"We've seen how federated evaluation works on the client side (i.e., by "
"implementing a function wrapped with the ``@app.evaluate`` decorator in "
"your ``ClientApp``). Now let's see how we can evaluate the aggregated "
"model parameters on the server side."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:191
msgid ""
"To do so, we need to create a new function in ``task.py`` that we can "
"name ``central_evaluate``. This function is a callback that will be "
"passed to the |strategy_start_link|_ method of our strategy. This means "
"that the strategy will call this function after every round of federated "
"learning passing two arguments: the current round of federated learning "
"and the aggregated model parameters."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:197
msgid "Our ``central_evaluate`` function performs the following steps:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:199
#, fuzzy
msgid "Load the aggregated model parameters into a PyTorch model"
msgstr "4단계: 모델 업데이트를 새 글로벌 모델로 집계"

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:200
msgid "Load the entire CIFAR10 test dataset"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:201
#, fuzzy
msgid "Evaluate the model on the test dataset"
msgstr "로컬로 보유한 데이터 세트를 사용하여 제공된 매개변수를 평가합니다."

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:202
msgid "Return the evaluation metrics as a |metricrecord_link|_"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:240
msgid ""
"Remember we mentioned this ``central_evaluate`` will be called by the "
"strategy. To do so we need to pass it to the strategy's ``start`` method "
"as shown below."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:266
#, fuzzy
msgid "Finally, we run the simulation."
msgstr "Flower 시뮬레이션."

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:272
msgid ""
"You'll note that the server logs the metrics returned by the callback "
"after each round. Also, at the end of the run, note the ``ServerApp-side "
"Evaluate Metrics`` shown:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:285
#, fuzzy
msgid "Sending configurations to clients from strategies"
msgstr "기본 제공 전략을 통한 구성"

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:287
msgid ""
"In some situations, we want to configure client-side execution (training,"
" evaluation) from the server side. One example of this is the server "
"asking the clients to train for with a different learning rate based on "
"the current round number. Flower provides a way to send configuration "
"values from the server to the clients as part of the |message_link|_ that"
" the ``ClientApp`` receives. Let's see how we can do this."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:293
msgid ""
"To the |strategy_start_link|_ method of our strategy we are already "
"passing a |configrecord_link|_ specifying the initial learning rate. This"
" ``ConfigRecord`` will be sent to the clients in all the ``Messages`` "
"addressing the ``@app.train()`` function of the ``ClientApp``. Let's say "
"we want to decrease the learning rate by a factor of 0.5 every 5 rounds, "
"then we need to override the ``configure_train`` method of our strategy "
"and embed such logic."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:300
msgid ""
"To do so, we create a new class inheriting from |fedadagrad_link|_ and "
"override the ``configure_train`` method. We then use this new strategy in"
" our ``ServerApp``. Let's see how this looks like in code. Create a new "
"file called ``custom_strategy.py`` in the ``flower_tutorial`` directory "
"and add the following code:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:326
msgid ""
"Next, we use this new strategy in our ``ServerApp`` by importing it in "
"your ``server_app.py`` and use it instead of the standard ``FedAdagrad``."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:329
msgid ""
"Finally, run the training with the following command. Here we increase "
"the number of rounds to 15 to see the learning rate decay in action."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:336
msgid ""
"You'll note that in the ``configure_train`` stage of rounds 5 and 10, the"
" learning rate is decreased by a factor of 0.5 and the new learning rate "
"is printed to the terminal."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:339
msgid ""
"How do we know the ``ClientApp`` is using that new learning rate? Recall "
"that in ``client_app.py``, we are reading the learning rate from the "
"``Message`` received by the ``@app.train()`` function:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:363
msgid ""
"Congratulations! You have created your first custom strategy adding "
"dynamism to the ``ConfigRecord`` that is sent to clients."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:368
msgid "Scaling federated learning"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:370
msgid ""
"As a last step in this tutorial, let's see how we can use Flower to "
"experiment with a large number of clients. In the ``pyproject.toml``, "
"increase the number of SuperNodes to 1000:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:379
msgid ""
"Note that we can reuse the ``ClientApp`` for different ``num-supernodes``"
" since the ``Context`` carries the ``num-partitions`` key and for "
"simulations with Flower, the number of partitions is equal to the number "
"of SuperNodes."
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:383
#, python-format
msgid ""
"We now have 1000 partitions, each holding 45 training and 5 validation "
"examples. Given that the number of training examples on each client is "
"quite small, we should probably train the model a bit longer, so we "
"configure the clients to perform 3 local training epochs. We should also "
"adjust the fraction of clients selected for training during each round "
"(we don't want all 1000 clients participating in every round), so we "
"adjust ``fraction_train`` to ``0.025``, which means that only 2.5% of "
"available clients (so 25 clients) will be selected for training each "
"round. We update the ``fraction-train`` value in the ``pyproject.toml``:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:397
msgid ""
"Then, we update the initialization of our strategy in ``server_app.py`` "
"to the following:"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:418
#, fuzzy
msgid "Finally, run the simulation with the following command:"
msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:428
msgid ""
"In this tutorial, we've seen how we can gradually enhance our system by "
"customizing the strategy, choosing a different strategy, applying "
"learning rate decay at the strategy level, and evaluating models on the "
"server side. That's quite a bit of flexibility with so little code, "
"right?"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:433
msgid ""
"In the later sections, we've seen how we can communicate arbitrary values"
" between server and clients to fully customize client-side execution. "
"With that capability, we built a large-scale Federated Learning "
"simulation using the Flower Virtual Client Engine and ran an experiment "
"involving 1000 clients in the same workload — all in the same Flower "
"project!"
msgstr ""

#: ../../source/tutorial-series-use-a-federated-learning-strategy-pytorch.rst:450
#, fuzzy
msgid ""
"The :doc:`Flower Federated Learning Tutorial - Part 3 <tutorial-series-"
"build-a-strategy-from-scratch-pytorch>` shows how to build a fully custom"
" ``Strategy`` from scratch."
msgstr ""
"`Flower 연합 학습 튜토리얼- 1부 <https://flower.ai/docs/framework/tutorial-get-"
"started-with-flower-pytorch.html>`__ PyTorch와 Flower를 사용하여 간단한 연합 학습 시스템을"
" 구축하는 방법을 보여줍니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:3
msgid "What is Federated Learning?"
msgstr "연합 학습이란 무엇입니까?"

#: ../../source/tutorial-series-what-is-federated-learning.rst:7
msgid ""
"In this tutorial, you will learn what federated learning is, build your "
"first system in Flower, and gradually extend it. If you work through all "
"parts of the tutorial, you will be able to build advanced federated "
"learning systems that approach the current state of the art in the field."
msgstr ""
"이 튜토리얼에서 연합 학습이 무엇인지 배우고 Flower로 첫 번째 시스템을 구축하고 점진적으로 확장해 나갈 것입니다. 본 "
"튜토리얼의 모든 부분을 완성할 수 있다면, 당신은 고급 연합 학습 시스템을 구축하여 그 분야의 현재 최고 기술 수준에 접근할 수 "
"있을 것입니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:12
#, fuzzy
msgid ""
"🧑‍🏫 This tutorial starts from zero and expects no familiarity with "
"federated learning. Only a basic understanding of data science and Python"
" programming is assumed."
msgstr ""
"🧑‍🏫이 튜토리얼은 사전 지식을 많이 필요로 하지 않으며 연합 학습에 대해 상세히알 필요는 없습니다. 데이터 과학과 파이썬 "
"프로그래밍에 대한 기본적인 이해만 가정합니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:28
msgid "Let's get started!"
msgstr ""

#: ../../source/tutorial-series-what-is-federated-learning.rst:32
#, fuzzy
msgid "Classical Machine Learning"
msgstr "전통적인 머신러닝(기계학습)"

#: ../../source/tutorial-series-what-is-federated-learning.rst:34
#, fuzzy
msgid ""
"Before we begin discussing federated learning, let us quickly recap how "
"most machine learning works today."
msgstr "연합 학습에 대해 논의하기 전에 현재 대부분의 머신러닝이 어떻게 작동하는지 간략히 요약하겠습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:37
msgid ""
"In machine learning, we have a model, and we have data. The model could "
"be a neural network (as depicted here), or something else, like classical"
" linear regression."
msgstr ""
"머신러닝에서 우리는 모델과 데이터를 가지고 있습니다. 모델은 신경망(그림과 같이)일 수도 있고 고전적인 선형 회귀와 같은 다른 것일"
" 수도 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:46
msgid ""
"We train the model using the data to perform a useful task. A task could "
"be to detect objects in images, transcribe an audio recording, or play a "
"game like Go."
msgstr ""
"우리는 유용한 작업을 수행하기 위해 데이터를 사용하여 모델을 훈련합니다. 작업은 이미지 속 물체를 감지하거나 음성 녹음을 기록하거나"
" 바둑과 같은 게임을 하는 것일 수 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:55
#, fuzzy
msgid ""
"In practice, the training data we work with doesn't originate on the "
"machine we train the model on."
msgstr "실제로 우리가 사용하는 훈련 데이터는 모델을 훈련시키는 기계에서 비롯된 것이 아닙니다. 그 데이터는 다른 곳에서 만들어졌습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:58
#, fuzzy
msgid ""
"This data gets created “somewhere else”. For instance, the data can "
"originate on a smartphone by the user interacting with an app, a car "
"collecting sensor data, a laptop receiving input via the keyboard, or a "
"smart speaker listening to someone trying to sing a song."
msgstr ""
"스마트폰에서 사용자와 앱의 상호 작용, 센서 데이터를 수집하는 자동차, 키보드를 통해 입력을 받는 노트북 또는 누군가 노래를 "
"부르리는 것을 듣는 스마트 스피커에서 비롯됩니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:69
#, fuzzy
msgid ""
"What's also important to mention, this “somewhere else” is usually not "
"just one place, it's many places. It could be several devices all running"
" the same app. But it could also be several organizations, all generating"
" data for the same task."
msgstr ""
"또한 중요한 것은 이 \"다른 곳\"이 보통 한 곳만 아니라 여러 곳이라는 것입니다. 같은 앱을 실행하는 여러 기기일 수도 "
"있습니다. 하지만 여러 조직이 모두 같은 작업을 위해 데이터를 생성하는 것일 수도 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:81
#, fuzzy
msgid ""
"So to use machine learning, or any kind of data analysis, the approach "
"that has been used in the past was to collect all this data on a central "
"server. This server can be located somewhere in a data center, or "
"somewhere in the cloud."
msgstr ""
"따라서 머신러닝이나 어떤 종류의 데이터 분석을 이용하려면 과거에는 중앙 서버에서 모든 데이터를 수집하는 방법이 사용되었습니다. 이 "
"서버는 데이터 센터 어딘가에 있을 수도 있고 클라우드 어딘가에 있을 수도 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:91
msgid ""
"Once all the data is collected in one place, we can finally use machine "
"learning algorithms to train our model on the data. This is the machine "
"learning approach that we've basically always relied on."
msgstr ""
"모든 데이터가 한 곳에 모이면, 우리는 궁극적으로 머신러닝 알고리즘을 사용하여 데이터에서 모델을 훈련시킬 수 있습니다. 이것이 바로"
" 우리가 기본적으로 사용해 온 머신러닝 방법입니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:105
msgid "Challenges of classical machine learning"
msgstr "클래식 머신러닝의 어려움"

#: ../../source/tutorial-series-what-is-federated-learning.rst:107
#, fuzzy
msgid ""
"This classical machine learning approach we've just seen can be used in "
"some cases. Great examples include categorizing holiday photos, or "
"analyzing web traffic. Cases, where all the data is naturally available "
"on a centralized server."
msgstr ""
"우리가 방금 본 전통적 머신러닝의 접근 방식은 경우에 따라 다르게 사용될 수 있습니다. 좋은 예로는 휴일 사진을 분류하거나 웹 "
"트래픽을 분석하는 것이 있습니다. 이러한 사례에서 모든 데이터는 자연스럽게 중앙 서버에 존재합니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:117
msgid ""
"But the approach can not be used in many other cases. Cases, where the "
"data is not available on a centralized server, or cases where the data "
"available on one server is not enough to train a good model."
msgstr ""
"그러나 이 방법은 다른 많은 경우에 적용되지 않을 수 있습니다. 예를 들어, 중앙 집중식 서버에 데이터가 없거나 서버의 데이터가 "
"좋은 모델을 훈련하기에 충분하지 않을 수 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:129
#, fuzzy
msgid ""
"There are many reasons why the classical centralized machine learning "
"approach does not work for a large number of highly important real-world "
"use cases. Those reasons include:"
msgstr ""
"전통적인 중앙 집중식 머신러닝 방법이 현실 세계에서 매우 중요한 수많은 사용 사례를 충족시킬 수 없는 이유가 있습니다. 이유는 "
"다음과 같은 여러 가지가 있습니다:"

#: ../../source/tutorial-series-what-is-federated-learning.rst:132
#, fuzzy
msgid ""
"**Regulations**: GDPR (Europe), CCPA (California), PIPEDA (Canada), LGPD "
"(Brazil), PDPL (Argentina), KVKK (Turkey), POPI (South Africa), FSS "
"(Russia), CDPR (China), PDPB (India), PIPA (Korea), APPI (Japan), PDP "
"(Indonesia), PDPA (Singapore), APP (Australia), and other regulations "
"protect sensitive data from being moved. In fact, those regulations "
"sometimes even prevent single organizations from combining their own "
"users' data for machine learning training because those users live in "
"different parts of the world, and their data is governed by different "
"data protection regulations."
msgstr ""
"**규정**: GDPR (유럽), CCPA (캘리포니아), PIPEDA (캐나다), LGPD (브라질), PDPL (아르헨티나), "
"KVKK (터키), POPI (남아프리카공화국), FSS (러시아), CDPR (중국), PDPB (인도), PIPA (한국), "
"APPI (일본), PDP (인도네시아), PDPA (싱가포르), APP (호주)등의 법규로 민감한 데이터가 이동하지 않도록 "
"보호하고 있습니다. 실제로 이러한 규정은 사용자가 세계의 다른 지역에 살고 데이터가 다른 데이터 보호 규정에 의해 통제되기 때문에 "
"단일 조직이 자체 사용자 데이터를 인공 지능 학습에 사용하는 것을 방지하기도 합니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:139
msgid ""
"**User preference**: In addition to regulation, there are use cases where"
" users just expect that no data leaves their device, ever. If you type "
"your passwords and credit card info into the digital keyboard of your "
"phone, you don't expect those passwords to end up on the server of the "
"company that developed that keyboard, do you? In fact, that use case was "
"the reason federated learning was invented in the first place."
msgstr ""
"**사용자 선호도**: 규정 외에도 일부 사용 사례에서 사용자는 데이터가 자기 장치를 떠나지 않기를 예상합니다. 휴대폰의 디지털 "
"키보드에 비밀번호와 신용카드 정보를 입력하면 비밀번호가 해당 키보드를 개발한 회사의 서버에 뜨길 원하지는 않겠죠? 사실, 이 사용 "
"사례가 애당초 연합 학습이 발명된 이유였습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:144
msgid ""
"**Data volume**: Some sensors, like cameras, produce such a high data "
"volume that it is neither feasible nor economic to collect all the data "
"(due to, for example, bandwidth or communication efficiency). Think about"
" a national rail service with hundreds of train stations across the "
"country. If each of these train stations is outfitted with a number of "
"security cameras, the volume of raw on-device data they produce requires "
"incredibly powerful and exceedingly expensive infrastructure to process "
"and store. And most of the data isn't even useful."
msgstr ""
"**데이터 볼륨**: 일부 센서(예:카메라)는 너무 많은 데이터 볼륨을 생성하여 모든 데이터를 수집하는 것이 실현 가능하지도 않고 "
"경제적이지도 않습니다(예: 대역폭 또는 통신 효율로 인해). 전국에 수백 개 기차역이 있는 국가 철도 서비스를 생각해 보세요. 각 "
"기차역에 수 많은 보안 카메라가 설치되어 있다면, 그들이 생산하는 대량의 미가공 된 온디바이스 데이터는 처리 및 저장을 위해 "
"엄청나게 강력하고 매우 비싼기반 구조를 필요로 합니다. 그런데 대부분의 데이터는 유용하지도 않습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:152
msgid "Examples where centralized machine learning does not work include:"
msgstr "중앙 집중식 머신러닝이 작동하지 않는 예는 다음과 같습니다:"

#: ../../source/tutorial-series-what-is-federated-learning.rst:154
#, fuzzy
msgid ""
"Sensitive healthcare records from multiple hospitals to train cancer "
"detection models."
msgstr "여러 병원의 민감한 의료기록으로 암 검진 모델 훈련"

#: ../../source/tutorial-series-what-is-federated-learning.rst:155
#, fuzzy
msgid ""
"Financial information from different organizations to detect financial "
"fraud."
msgstr "금융 사기를 탐지하기 위한 다양한 조직의 금융 정보"

#: ../../source/tutorial-series-what-is-federated-learning.rst:156
#, fuzzy
msgid "Location data from your electric car to make better range prediction."
msgstr "더 나은 범위 예측을 위해 전기 자동차의 위치 데이터"

#: ../../source/tutorial-series-what-is-federated-learning.rst:157
#, fuzzy
msgid "End-to-end encrypted messages to train better auto-complete models."
msgstr "더 나은 자동 완성 모델을 훈련시키기 위한 엔드 투 엔드 암호화 된 메시지"

#: ../../source/tutorial-series-what-is-federated-learning.rst:159
msgid ""
"The popularity of privacy-enhancing systems like the `Brave "
"<https://brave.com/>`__ browser or the `Signal <https://signal.org/>`__ "
"messenger shows that users care about privacy. In fact, they choose the "
"privacy-enhancing version over other alternatives, if such an alternative"
" exists. But what can we do to apply machine learning and data science to"
" these cases to utilize private data? After all, these are all areas that"
" would benefit significantly from recent advances in AI."
msgstr ""
"`Brave <https://brave.com/>`__ 브라우저나 `Signal <https://signal.org/>`__ "
"메신저와 같은 개인 정보 보호 시스템의 인기는 사용자들이 개인 정보 보호에 신경 쓴다는 것을 보여줍니다. 실제로 그러한 대안이 "
"존재하는 경우 다른 대안보다 개인 정보 보호 강화 버전을 선택합니다. 그런데 이러한 사례에 머신러닝 및 데이터 과학을 적용하여 "
"프라이버시 데이터를 활용하려면 어떻게 해야 합니까? 이 모든 분야는 최근 AI의 발전으로 상당한 이익을 얻을 수 있는 분야입니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:168
#, fuzzy
msgid "Federated Learning"
msgstr "연합 학습"

#: ../../source/tutorial-series-what-is-federated-learning.rst:170
#, fuzzy
msgid ""
"Federated Learning simply reverses this approach. It enables machine "
"learning on distributed data by moving the training to the data, instead "
"of moving the data to the training. Here's a one-liner explanation:"
msgstr ""
"연합 학습은 이 방법을 쉽게 뒤집었습니다. 데이터를 컴퓨팅 센터로 옮기는 대신 컴퓨팅 능력을 데이터가 생성되는 장소로 이동 "
"시킴으로써 분산된 데이터에서 머신러닝을 실현합니다. 요약하자면:"

#: ../../source/tutorial-series-what-is-federated-learning.rst:174
#, fuzzy
msgid "Centralized machine learning: move the data to the computation"
msgstr "중앙 집중식 머신러닝: 데이터를 컴퓨팅 센터로 이동"

#: ../../source/tutorial-series-what-is-federated-learning.rst:175
#, fuzzy
msgid "Federated (machine) Learning: move the computation to the data"
msgstr "연합(기계)학습: 컴퓨팅을 데이터로 옮김"

#: ../../source/tutorial-series-what-is-federated-learning.rst:177
#, fuzzy
msgid ""
"By doing so, Federated Learning enables us to use machine learning (and "
"other data science approaches) in areas where it wasn't possible before. "
"We can now train excellent medical AI models by enabling different "
"hospitals to work together. We can solve financial fraud by training AI "
"models on the data of different financial institutions. We can build "
"novel privacy-enhancing applications (such as secure messaging) that have"
" better built-in AI than their non-privacy-enhancing alternatives. And "
"those are just a few of the examples that come to mind. As we deploy "
"Federated Learning, we discover more and more areas that can suddenly be "
"reinvented because they now have access to vast amounts of previously "
"inaccessible data."
msgstr ""
"이를 통해 이전에는 불가능했던 분야에서 머신러닝(및 기타 데이터 과학 방법)을 사용할 수 있습니다. 이제 다양한 병원이 협력할 수 "
"있도록 함으로써 우수한 의료 AI 모델을 훈련할 수 있습니다. 다양한 금융 기관의 데이터에 대한 AI 모델을 훈련하여 금융 사기를 "
"해결할 수 있습니다. 개인 정보 보호를 강화하지 않는 대안보다 더 나은 AI가 내장된 새로운 개인 정보 보호 강화 애플리케이션(예:"
" 보안 메시징)을 구축할 수 있습니다. 그것들은 떠오르는 몇 가지 예에 불과합니다. 연합 학습을 구축함에 따라 이전에 액세스할 수 "
"없었던 많은 데이터에 액세스할 수 있게 되었기 때문에 갑자기 재생될 수 있는 영역이 점점 더 많아지고 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:187
#, fuzzy
msgid ""
"So how does Federated Learning work, exactly? Let's start with an "
"intuitive explanation."
msgstr "그렇다면 연합 학습은 어떻게 작동합니까? 직관적인 설명부터 시작하겠습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:190
msgid "Federated learning in five steps"
msgstr "연합 학습의 5단계"

#: ../../source/tutorial-series-what-is-federated-learning.rst:193
msgid "Step 0: Initialize global model"
msgstr "0단계: 글로벌 모델 초기화"

#: ../../source/tutorial-series-what-is-federated-learning.rst:195
msgid ""
"We start by initializing the model on the server. This is exactly the "
"same in classic centralized learning: we initialize the model parameters,"
" either randomly or from a previously saved checkpoint."
msgstr ""
"서버에서 모델을 초기화하는 것으로 시작합니다. 이것은 전통적인 중앙 집중식 학습과도 동일합니다: 임의로 또는 이전에 저장된 "
"체크포인트에서 모델 매개변수를 초기화합니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:208
msgid ""
"Step 1: Send model to a number of connected organizations/devices (client"
" nodes)"
msgstr "1단계: 연결된 여러 조직/장치(클라이언트 노드)에 모델 전송"

#: ../../source/tutorial-series-what-is-federated-learning.rst:210
#, fuzzy
msgid ""
"Next, we send the parameters of the global model to the connected client "
"nodes (think: edge devices like smartphones or servers belonging to "
"organizations). This is to ensure that each participating node starts its"
" local training using the same model parameters. We often use only a few "
"of the connected nodes instead of all nodes. The reason for this is that "
"selecting more and more client nodes has diminishing returns."
msgstr ""
"다음으로 글로벌 모델의 파라미터를 연결된 클라이언트 노드(예: 스마트폰과 같은 에지 디바이스 또는 조직에 속한 서버)로 보냅니다. "
"이것은 각 참여 노드가 동일한 모델 매개변수를 사용하여 로컬 훈련을 시작하도록 하기 위함입니다. 일반적으로 모든 노드가 아닌 몇 "
"개의 연결 노드만 사용합니다. 그 이유는 점점 더 많은 클라이언트 노드를 선택하면 학습의 효율성이 감소하기 때문입니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:223
msgid ""
"Step 2: Train model locally on the data of each organization/device "
"(client node)"
msgstr "2단계: 각 조직/장치(클라이언트 노드)의 데이터에 대해 로컬로 모델 훈련"

#: ../../source/tutorial-series-what-is-federated-learning.rst:225
msgid ""
"Now that all (selected) client nodes have the latest version of the "
"global model parameters, they start the local training. They use their "
"own local dataset to train their own local model. They don't train the "
"model until full convergence, but they only train for a little while. "
"This could be as little as one epoch on the local data, or even just a "
"few steps (mini-batches)."
msgstr ""
"이제 모든(선택된) 클라이언트 노드에는 최신 버전의 글로벌 모델 파라미터가 있으며 로컬 훈련을 시작합니다. 그들은 자신의 로컬 "
"데이터 세트를 사용하여 자신의 로컬 모델을 훈련합니다. 모델이 완전히 수렴할 때까지 훈련하지 않고 잠시만 훈련합니다. 이는 로컬 "
"데이터에서 한 단계 정도로 짧거나 몇 단계(mini-batches)에 불과할 수 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:238
msgid "Step 3: Return model updates back to the server"
msgstr "3단계: 모델 파라미터를 업데이트하여 서버로 되돌리기"

#: ../../source/tutorial-series-what-is-federated-learning.rst:240
msgid ""
"After local training, each client node has a slightly different version "
"of the model parameters they originally received. The parameters are all "
"different because each client node has different examples in its local "
"dataset. The client nodes then send those model updates back to the "
"server. The model updates they send can either be the full model "
"parameters or just the gradients that were accumulated during local "
"training."
msgstr ""
"로컬 훈련 후에는 클라이언트 노드마다 원래 받은 모델 파라미터의 버전이 조금씩 다릅니다. 파라미터가 다른 이유는 각 클라이언트 "
"노드의 로컬 데이터 세트에 다른 데이터가 있기 때문입니다. 그런 다음 클라이언트 노드는 이러한 모델 업데이트를 서버로 다시 "
"보냅니다. 보내는 모델 업데이트는 전체 모델 파라미터거나 로컬 교육 중에 누적된 그레디언트(gradient)일 수 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:253
msgid "Step 4: Aggregate model updates into a new global model"
msgstr "4단계: 모델 업데이트를 새 글로벌 모델로 집계"

#: ../../source/tutorial-series-what-is-federated-learning.rst:255
msgid ""
"The server receives model updates from the selected client nodes. If it "
"selected 100 client nodes, it now has 100 slightly different versions of "
"the original global model, each trained on the local data of one client. "
"But didn't we want to have one model that contains the learnings from the"
" data of all 100 client nodes?"
msgstr ""
"서버는 선택된 클라이언트 노드들로부터 모델 업데이트들을 수신합니다. 서버가 100개의 클라이언트 노드를 선택했다면 이제 각각 "
"클라이언트의 로컬 데이터를 기반으로 훈련된 100개의 조금씩 다른 원래 글로벌 모델 버전을 갖게 됩니다. 하지만 우리는 100개의 "
"모든 클라이언트 노드의 데이터에서 학습한 내용을 포함하는 모델을 하나만 갖고 싶지 않았습니까?"

#: ../../source/tutorial-series-what-is-federated-learning.rst:260
#, fuzzy
msgid ""
"In order to get one single model, we have to combine all the model "
"updates we received from the client nodes. This process is called "
"*aggregation*, and there are many different ways to do it. The most basic"
" way is called *Federated Averaging* (`McMahan et al., 2016 "
"<https://arxiv.org/abs/1602.05629>`__), often abbreviated as *FedAvg*. "
"*FedAvg* takes the 100 model updates and, as the name suggests, averages "
"them. To be more precise, it takes the *weighted average* of the model "
"updates, weighted by the number of examples each client used for "
"training. The weighting is important to make sure that each data example "
"has the same “influence” on the resulting global model. If one client has"
" 10 examples, and another client has 100 examples, then - without "
"weighting - each of the 10 examples would influence the global model ten "
"times as much as each of the 100 examples."
msgstr ""
"단일 모델 하나를 얻으려면 클라이언트 노드에서 받은 모든 모델 업데이트를 결합해야 합니다. 이 과정이 *집합*라고 하며 여러 가지 "
"방법이 있습니다. 가장 기본적인 방법은*Federated Averaging* (`McMahan et al., 2016 "
"<https://arxiv.org/abs/1602.05629>`__)이라고 하고 보통 줄여서 *FedAvg*로 표기합니다. "
"*FedAvg* 는 100개의 모델 업데이트를 받아 이름에서 알 수 있듯이 모델 업데이트를 평균화합니다. 더 정확히 말하면, 모델 "
"업데이트의 *가중 평균* 을 각 클라이언트가 훈련에 사용한 예제 수에 따라 가중치를 부여합니다. 가중치는 각 데이터 예제가 결과 "
"글로벌 모델에 동일한 \"영향\" 을 미치는지 확인하는 데 중요합니다. 한 클라이언트에 10개의 데이터 포인트가 있고 다른 "
"클라이언트에 100개의 데이터 포인트가 있다면 가중치를 부여하지 않고 10개의 예가 100개의 사례보다 글로벌 모델에 10배 더 "
"많은 영향을 미칩니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:281
msgid "Step 5: Repeat steps 1 to 4 until the model converges"
msgstr "5단계: 모델이 수렴할 때까지 1~4단계를 반복합니다"

#: ../../source/tutorial-series-what-is-federated-learning.rst:283
msgid ""
"Steps 1 to 4 are what we call a single round of federated learning. The "
"global model parameters get sent to the participating client nodes (step "
"1), the client nodes train on their local data (step 2), they send their "
"updated models to the server (step 3), and the server then aggregates the"
" model updates to get a new version of the global model (step 4)."
msgstr ""
"단계 1에서 4는 우리가 말하는 단일 라운드 연합 학습입니다. 글로벌 모델 파라미터는 참여하는 클라이언트 노드에 전송되고(1단계),"
" 클라이언트 노드는 로컬 데이터에 대한 훈련을 받고(2단계), 업데이트된 모델을 서버에 전송하고(3단계), 서버는 모델 업데이트를 "
"집계하여 글로벌 모델의 새로운 버전을 얻습니다(4단계)."

#: ../../source/tutorial-series-what-is-federated-learning.rst:289
msgid ""
"During a single round, each client node that participates in that "
"iteration only trains for a little while. This means that after the "
"aggregation step (step 4), we have a model that has been trained on all "
"the data of all participating client nodes, but only for a little while. "
"We then have to repeat this training process over and over again to "
"eventually arrive at a fully trained model that performs well across the "
"data of all client nodes."
msgstr ""
"한 라운드의 반복에서 해당 반복에 참여하는 각 클라이언트 노드는 짧은 시간 동안만 훈련합니다. 집계 단계(4단계) 이후 우리 모델이"
" 관련된 모든 클라이언트 노드의 모든 데이터에 대해 잠시 동안만 훈련되었음을 의미합니다. 그런 다음 모든 클라이언트 노드의 "
"데이터에서 잘 작동하는 완전히 훈련된 모델에 도달하려면 이 훈련 과정을 계속 반복해야 합니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:299
msgid ""
"Congratulations, you now understand the basics of federated learning. "
"There's a lot more to discuss, of course, but that was federated learning"
" in a nutshell. In later parts of this tutorial, we will go into more "
"detail. Interesting questions include: How can we select the best client "
"nodes that should participate in the next round? What's the best way to "
"aggregate model updates? How can we handle failing client nodes "
"(stragglers)?"
msgstr ""
"축하합니다, 이제 연합 학습의 기초에 대해 알게 되었습니다. 물론 아직 논의해야 할 내용이 많지만 이는 연합 학습의 축소판일 "
"뿐입니다. 본 튜토리얼의 후반부에는 좀 더 자세히 설명하겠습니다. 흥미로운 질문은 다음과 같습니다: 다음 라운드에 참여해야 할 가장"
" 좋은 클라이언트 노드를 어떻게 선택할 수 있을까요? 모델 업데이트를 집계하는 가장 좋은 방법은 무엇일까요? 실패한 클라이언트 "
"노드(낙오자)를 어떻게 처리할 수 있을까요?"

#: ../../source/tutorial-series-what-is-federated-learning.rst:308
msgid ""
"Just like we can train a model on the decentralized data of different "
"client nodes, we can also evaluate the model on that data to receive "
"valuable metrics. This is called federated evaluation, sometimes "
"abbreviated as FE. In fact, federated evaluation is an integral part of "
"most federated learning systems."
msgstr ""
"다양한 클라이언트 노드의 분산된 데이터에 대해 모델을 훈련할 수 있는 것처럼 해당 데이터에 대한 모델을 평가하여 가치 있는 "
"메트릭(metrics)을 받을 수도 있습니다. 이를 연합 평가라고 하며 FE라고 약칭하기도 합니다. 사실 연합 평가는 대부분의 연합"
" 학습 시스템에서 필수적인 부분입니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:314
#, fuzzy
msgid "Federated Analytics"
msgstr "연합 분석"

#: ../../source/tutorial-series-what-is-federated-learning.rst:316
msgid ""
"In many cases, machine learning isn't necessary to derive value from "
"data. Data analysis can yield valuable insights, but again, there's often"
" not enough data to get a clear answer. What's the average age at which "
"people develop a certain type of health condition? Federated analytics "
"enables such queries over multiple client nodes. It is usually used in "
"conjunction with other privacy-enhancing technologies like secure "
"aggregation to prevent the server from seeing the results submitted by "
"individual client nodes."
msgstr ""
"많은 경우 머신러닝은 데이터로부터 가치를 얻기 위한 필수 조건이 아닙니다. 데이터 분석을 통해 귀중한 통찰력을 얻을 수 있지만, "
"명확한 답변을 얻기에는 데이터가 충분하지 않은 경우가 많습니다. 특정 유형의 건강 상태가 발생하는 평균 연령은 몇 살입니까? 연합 "
"분석을 사용하면 여러 클라이언트 노드에서 이러한 쿼리(query)를 실행할 수 있습니다. 서버가 단일 클라이언트 노드에서 제출한 "
"결과를 보지 못하도록 보안을 강화한 집합 방식과 같은 다른 프라이버시 향상 기술과 함께 자주 사용됩니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:327
#, fuzzy
msgid ""
"Differential privacy (DP) is often mentioned in the context of Federated "
"Learning. It is a privacy-preserving method used when analyzing and "
"sharing statistical data, ensuring the privacy of individual "
"participants. DP achieves this by adding statistical noise to the model "
"updates, ensuring any individual participants' information cannot be "
"distinguished or re-identified. This technique can be considered an "
"optimization that provides a quantifiable privacy protection measure."
msgstr ""
"차분 프라이버시(Differential Privacy)는 연합 학습의 맥락에서 종종 언급됩니다. 통계 데이터를 분석하고 공유할 때 "
"사용하는 프라이버시 보호 방식으로, 참가자 개인의 프라이버시를 보장합니다. 차분 프라이버시는 모델 업데이트에 통계적 "
"잡음(noise)를 추가하여 개별 참가자의 정보를 구별하거나 재식별할 수 없도록 함으로써 이를 달성합니다. 이 기술은 정량적 개인 "
"정보 보호 조치를 제공하는 최적화라고 볼 수 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:336
msgid "Flower"
msgstr "Flower"

#: ../../source/tutorial-series-what-is-federated-learning.rst:338
msgid ""
"Federated learning, federated evaluation, and federated analytics require"
" infrastructure to move machine learning models back and forth, train and"
" evaluate them on local data, and then aggregate the updated models. "
"Flower provides the infrastructure to do exactly that in an easy, "
"scalable, and secure way. In short, Flower presents a unified approach to"
" federated learning, analytics, and evaluation. It allows the user to "
"federate any workload, any ML framework, and any programming language."
msgstr ""
"연합 학습, 연합 평가 및 연합 분석은 머신러닝 모델을 앞뒤로 이동하고 로컬 데이터에 대해 훈련 및 평가한 다음 업데이트된 모델을 "
"통합하기 위한 기본 프레임워크가 필요합니다. Flower가 제공하는 기반 구조는 간단하고 확장 가능하며 안전한 방식으로 이러한 "
"목표를 달성합니다. 간단히 말해서, Flower는 연합 학습, 분석 및 평가를 위한 통합 접근 방식을 제공합니다. 이를 통해 "
"사용자는 모든 워크로드, 머신러닝 프레임워크 및 모든 프로그래밍 언어를 통합할 수 있습니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:357
msgid "Final Remarks"
msgstr ""

#: ../../source/tutorial-series-what-is-federated-learning.rst:359
msgid ""
"Congratulations, you just learned the basics of federated learning and "
"how it relates to the classic (centralized) machine learning!"
msgstr "축하합니다, 지금까지 당신은 연합 학습의 기본 지식과 그것이 어떻게 전통적 (중앙 집중식) 머신러닝과 관련되는지 배웠습니다!"

#: ../../source/tutorial-series-what-is-federated-learning.rst:362
msgid ""
"In the next part of this tutorial, we are going to build a first "
"federated learning system with Flower."
msgstr "이 튜토리얼의 다음 부분에서는 Flower와 함께 첫 번째 연합 학습 시스템을 구축할 것입니다."

#: ../../source/tutorial-series-what-is-federated-learning.rst:376
msgid ""
"The `Flower Federated Learning Tutorial - Part 1 "
"<https://flower.ai/docs/framework/tutorial-get-started-with-flower-"
"pytorch.html>`__ shows how to build a simple federated learning system "
"with PyTorch and Flower."
msgstr ""
"`Flower 연합 학습 튜토리얼- 1부 <https://flower.ai/docs/framework/tutorial-get-"
"started-with-flower-pytorch.html>`__ PyTorch와 Flower를 사용하여 간단한 연합 학습 시스템을"
" 구축하는 방법을 보여줍니다."

#~ msgid ""
#~ "Currently, Flower provides two images, a"
#~ " ``base`` image and a ``superlink`` "
#~ "image. The base image, as the name"
#~ " suggests, contains basic dependencies that"
#~ " the SuperLink needs. This includes "
#~ "system dependencies, Python and Python "
#~ "tools. The SuperLink image is based "
#~ "on the base image, but it "
#~ "additionally installs the SuperLink using "
#~ "``pip``."
#~ msgstr ""
#~ "현재, Flower는 \"base\" 이미지 그리고 "
#~ "\"superlink\" 이미지를 제공합니다. base 이미지는 이름에서"
#~ " 알 수 있듯이 SuperLink가 필요로 하는 기본"
#~ " dependencies를 포함하고 있습니다. 여기에는 시스템 "
#~ "dependencies, Python 및 Python 도구가 포함됩니다."
#~ " SuperLink 이미지는 base 이미지를 기반으로 하지만"
#~ " \"pip\"을 사용하여 SuperLink를 추가로 설치합니다."

#~ msgid "``3.11``"
#~ msgstr "``3.11``"

#~ msgid "Defaults to ``22.04``."
#~ msgstr "``22.04``이 기본값."

#~ msgid "Defaults to ``flwr/base``."
#~ msgstr "``flwr/base``이 기본값."

#~ msgid "The Python version of the base image."
#~ msgstr "base 이미지의 Python 버전."

#~ msgid "Defaults to ``py3.11``."
#~ msgstr "``py3.11``이 기본값."

#~ msgid "Defaults to ``ubuntu22.04``."
#~ msgstr "``ubuntu22.04``이 기본값."

#~ msgid "Defaults to ``flwr``."
#~ msgstr "``flwr``이 기본값."

#~ msgid ""
#~ "The name of image is ``flwr_superlink``"
#~ " and the tag ``0.1.0``. Remember that"
#~ " the build arguments as well as "
#~ "the name and tag can be adapted"
#~ " to your needs. These values serve"
#~ " as examples only."
#~ msgstr ""
#~ "이미지의 이름은 ``flwr_superlink``이고 태그는 "
#~ "``0.1.0``입니다. 필요에 따라 빌드 argument들 뿐만 "
#~ "아니라 이름과 태그도 정할 수 있습니다. 이 값들은"
#~ " 예시일 뿐입니다."

#~ msgid "Edge Client Engine"
#~ msgstr "엣지 클라이언트 엔진"

#~ msgid ""
#~ "`Flower <https://flower.ai>`_ core framework "
#~ "architecture with Edge Client Engine"
#~ msgstr "`Flower <https://flower.ai>`_의 핵심 프레임워크 아키텍처와 엣지 클라이언트 엔진"

#~ msgid "Virtual Client Engine"
#~ msgstr "가상 클라이언트 엔진"

#~ msgid ""
#~ "`Flower <https://flower.ai>`_ core framework "
#~ "architecture with Virtual Client Engine"
#~ msgstr "`Flower <https://flower.ai>`_의 핵심 프레임워크 아키텍처와 가상 클라이언트 엔진"

#~ msgid "Virtual Client Engine and Edge Client Engine in the same workload"
#~ msgstr "동일 작업에서 가상 클라이언트 엔진과 엣지 클라이언트 엔진"

#~ msgid ""
#~ "`Flower <https://flower.ai>`_ core framework "
#~ "architecture with both Virtual Client "
#~ "Engine and Edge Client Engine"
#~ msgstr "`Flower <https://flower.ai>`_의 핵심 프레임워크 아키텍처와 가상 및 엣지 클라이언트 엔진"

#~ msgid "Clone the flower repository."
#~ msgstr "Flower 레포지토리를 복제합니다."

#~ msgid ""
#~ "Please follow the first section on "
#~ ":doc:`Run Flower using Docker <how-"
#~ "to-run-flower-using-docker>` which "
#~ "covers this step in more detail."
#~ msgstr ""
#~ ":doc:Run Flower using Docker <how-to-"
#~ "run-flower-using-docker>의 첫 번째 섹션을"
#~ " 따라 주십시오. 해당 부분을 더 자세히 설명해 "
#~ "줍니다."

#~ msgid "``22.04``"
#~ msgstr "``22.04``"

#~ msgid "``23.0.1``"
#~ msgstr "``23.0.1``"

#~ msgid "``69.0.2``"
#~ msgstr "``69.0.2``"

#~ msgid "``1.8.0``"
#~ msgstr "``1.8.0``"

#~ msgid "Building the SuperLink/SuperNode or ServerApp image"
#~ msgstr "SuperLink/SuperNode 또는 ServerApp 이미지 빌드"

#~ msgid "``1.8.0-py3.10-ubuntu22.04``"
#~ msgstr "``1.8.0-py3.10-ubuntu22.04``"

#~ msgid ""
#~ "The following example creates a "
#~ "SuperLink/SuperNode or ServerApp image with"
#~ " the official Flower base image:"
#~ msgstr "다음 예시에서는 공식 Flower 기본 이미지로 SuperLink/SuperNode 또는 ServerApp이미지를 만듭니다:"

#~ msgid "Trigger the CI for building the Docker images."
#~ msgstr "Docker 이미지 빌드를 위해 CI를 트리거합니다."

#~ msgid ""
#~ "To trigger the workflow, a collaborator"
#~ " must create a ``workflow_dispatch`` event"
#~ " in the GitHub CI. This can be"
#~ " done either through the UI or "
#~ "via the GitHub CLI. The event "
#~ "requires only one input, the Flower "
#~ "version, to be released."
#~ msgstr ""
#~ "워크플로우를 트리거하려면 공동 작업자가 GitHub CI에서 "
#~ "``workflow_dispatch``를 생성해야 합니다. 이 작업은 "
#~ "UI 또는 GitHub CLI 를 통해 수행할 수"
#~ " 있습니다. 이벤트는 Flower 버전 한 가지 입력만"
#~ " 필요합니다."

#~ msgid "**Via the UI**"
#~ msgstr "**UI를 통해서**"

#~ msgid ""
#~ "Go to the ``Build docker images`` "
#~ "workflow `page "
#~ "<https://github.com/adap/flower/actions/workflows/docker-"
#~ "images.yml>`_."
#~ msgstr ""
#~ "``Build docker images`` 워크플로우 `페이지 "
#~ "<https://github.com/adap/flower/actions/workflows/docker-"
#~ "images.yml>`_로 이동합니다."

#~ msgid ""
#~ "Click on the ``Run workflow`` button "
#~ "and type the new version of Flower"
#~ " in the ``Version of Flower`` input"
#~ " field."
#~ msgstr "``Run workflow`` 버튼을 누르고 ``Version of Flower``에 Flower의 새버전을 입력합니다."

#~ msgid "Click on the **green** ``Run workflow`` button."
#~ msgstr "**초록색**의 ``Run workflow``버튼을 클릭합니다."

#~ msgid "**Via the GitHub CI**"
#~ msgstr "**GitHub CI를 통해서**"

#~ msgid ""
#~ "Make sure you are logged in via"
#~ " ``gh auth login`` and that the "
#~ "current working directory is the root"
#~ " of the Flower repository."
#~ msgstr "``gh auth login``을 통해 로그인 했는지, 현재 작업 디렉토리가 Flower 리포지토리의 root인지 확인하세요."

#~ msgid ""
#~ "Trigger the workflow via ``gh workflow"
#~ " run docker-images.yml -f flwr-"
#~ "version=<NEW_VERSION>``."
#~ msgstr ""
#~ "``gh workflow run docker-images.yml -f"
#~ " flwr-version=<NEW_VERSION>``을 통해 워크플로우 를"
#~ " 트리거합니다."

#~ msgid "Example: JAX - Run JAX Federated"
#~ msgstr "예시: JAX - JAX Federated 실행"

#~ msgid ""
#~ "The simplest way to get started "
#~ "with Flower is by using the "
#~ "pre-made Docker images, which you can"
#~ " find on `Docker Hub "
#~ "<https://hub.docker.com/u/flwr>`__. Supported "
#~ "architectures include ``amd64`` and "
#~ "``arm64v8``."
#~ msgstr ""
#~ "Flower를 시작하는 가장 간단한 방법은 `Docker "
#~ "Hub <https://hub.docker.com/u/flwr>`__에서 찾을 수 "
#~ "있는 미리 만들어진 Docker 이미지를 사용하는 것입니다."
#~ " 지원되는 아키텍처는 ``amd64`` 및 ``arm64v8``입니다."

#~ msgid ""
#~ "If you do not see the version "
#~ "of Docker but instead get an error"
#~ " saying that the command was not "
#~ "found, you will need to install "
#~ "Docker first. You can find installation"
#~ " instruction `here <https://docs.docker.com/get-"
#~ "docker/>`_."
#~ msgstr ""
#~ "전이 표시되지 않고 대신 명령을 찾을 수 없다는"
#~ " 오류가 표시되는 경우 먼저 Docker를 설치해야 "
#~ "합니다. `여기 <https://docs.docker.com/get-docker/>`_에서"
#~ " 설치 지침을 찾을 수 있습니다."

#~ msgid ""
#~ "On Linux, Docker commands require "
#~ "``sudo`` privilege. If you want to "
#~ "avoid using ``sudo``, you can follow "
#~ "the `Post-installation steps "
#~ "<https://docs.docker.com/engine/install/linux-postinstall/>`_"
#~ " on the official Docker website."
#~ msgstr ""
#~ "Linux에서 Docker 명령을 실행하려면 ``sudo`` 권한이"
#~ " 필요합니다. ``sudo`` 를 사용하지 않으려면 공식 "
#~ "Docker 웹사이트의 `Post-installation steps "
#~ "<https://docs.docker.com/engine/install/linux-postinstall/>`_를"
#~ " 따르세요."

#~ msgid ""
#~ "To ensure optimal performance and "
#~ "compatibility, the SuperLink, SuperNode and"
#~ " ServerApp image must have the same"
#~ " version when running together. This "
#~ "guarantees seamless integration and avoids "
#~ "potential conflicts or issues that may"
#~ " arise from using different versions."
#~ msgstr ""
#~ "최적의 성능과 호환성을 보장하려면 SuperLink, SuperNode"
#~ " 및 ServerApp 이미지를 함께 실행할 때 버전이"
#~ " 동일해야 합니다. 이렇게 하면 원활한 통합을 보장하고"
#~ " 서로 다른 버전을 사용할 때 발생할 수 있는"
#~ " 잠재적인 충돌이나 문제를 방지할 수 있습니다."

#~ msgid "Flower SuperLink"
#~ msgstr "Flower SuperLink"

#~ msgid "If you're looking to try out Flower, you can use the following command:"
#~ msgstr "Flower를 사용해보고 싶다면 다음 명령을 사용하면 됩니다:"

#~ msgid ""
#~ "The command pulls the Docker image "
#~ "with the tag ``1.8.0`` from Docker "
#~ "Hub. The tag specifies the Flower "
#~ "version. In this case, Flower 1.8.0. "
#~ "The ``--rm`` flag tells Docker to "
#~ "remove the container after it exits."
#~ msgstr ""
#~ "이 명령은 Docker Hub에서 ``1.8.0`` 태그가 "
#~ "있는 Docker 이미지를 가져옵니다. 이 태그는 Flower"
#~ " 버전을 지정합니다. 이 경우, Flower 1.8.0입니다."
#~ " '`--rm`` 플래그는 컨테이너가 종료된 후 컨테이너를 "
#~ "제거하도록 Docker에 지시합니다."

#~ msgid ""
#~ "The ``-p <host>:<container>`` flag tells "
#~ "Docker to map the ports "
#~ "``9091``/``9092`` of the host to "
#~ "``9091``/``9092`` of the container, allowing"
#~ " you to access the Driver API "
#~ "on ``http://localhost:9091`` and the Fleet "
#~ "API on ``http://localhost:9092``. Lastly, any"
#~ " flag that comes after the tag "
#~ "is passed to the Flower SuperLink. "
#~ "Here, we are passing the flag "
#~ "``--insecure``."
#~ msgstr ""
#~ "``-p <host>:<container>`` 플래그는 호스트의 포트 "
#~ "``9091``/``9092``를 컨테이너의 ``9091``/``9092``에 매핑하여 "
#~ "``http://localhost:9091``의 드라이버 API와 "
#~ "``http://localhost:9092``의 Fleet API에 액세스할 수"
#~ " 있도록 Docker에 지시합니다. 마지막으로, 태그 뒤에 "
#~ "오는 모든 플래그는 Flower SuperLink에 전달됩니다. "
#~ "여기서는 ``--insecure``플래그를 전달합니다."

#~ msgid ""
#~ "The ``--insecure`` flag enables insecure "
#~ "communication (using HTTP, not HTTPS) "
#~ "and should only be used for "
#~ "testing purposes. We strongly recommend "
#~ "enabling `SSL <https://flower.ai/docs/framework/how-"
#~ "to-run-flower-using-docker.html#enabling-"
#~ "ssl-for-secure-connections>`__ when "
#~ "deploying to a production environment."
#~ msgstr ""
#~ "``--insecure`` 플래그는 안전하지 않은 통신(HTTPS가 아닌"
#~ " HTTP 사용)을 활성화하며 테스트 목적으로만 사용해야 "
#~ "합니다. 프로덕션 환경에 배포할 때는 `SSL "
#~ "<https://flower.ai/docs/framework/how-to-run-"
#~ "flower-using-docker.html#enabling-ssl-for-"
#~ "secure-connections>`__을 활성화할 것을 강력히 권장합니다."

#~ msgid ""
#~ "You can use ``--help`` to view all"
#~ " available flags that the SuperLink "
#~ "supports:"
#~ msgstr "'`--help``을 사용하면 SuperLink가 지원하는 모든 플래그를 볼 수 있습니다:"

#~ msgid "Mounting a volume to store the state on the host system"
#~ msgstr "호스트 시스템에 상태를 저장할 볼륨 마운트하기"

#~ msgid ""
#~ "If you want to persist the state"
#~ " of the SuperLink on your host "
#~ "system, all you need to do is "
#~ "specify a directory where you want "
#~ "to save the file on your host "
#~ "system and a name for the database"
#~ " file. By default, the SuperLink "
#~ "container runs with a non-root "
#~ "user called ``app`` with the user "
#~ "ID ``49999``. It is recommended to "
#~ "create new directory and change the "
#~ "user ID of the directory to "
#~ "``49999`` to ensure the mounted "
#~ "directory has the proper permissions. If"
#~ " you later want to delete the "
#~ "directory, you can change the user "
#~ "ID back to the current user ID "
#~ "by running ``sudo chown -R $USER:$(id"
#~ " -gn) state``."
#~ msgstr ""
#~ "호스트 시스템에서 SuperLink의 상태를 유지하려면 호스트 "
#~ "시스템에서 파일을 저장할 디렉터리와 데이터베이스 파일의 이름을"
#~ " 지정하기만 하면 됩니다. 기본적으로 SuperLink 컨테이너는"
#~ " 사용자 ID가 ``49999``인 ``app``이라는 루트가 아닌"
#~ " 사용자로 실행됩니다. 마운트된 디렉터리에 적절한 권한이 "
#~ "있는지 확인하려면 새 디렉터리를 생성하고 디렉터리의 사용자"
#~ " ID를 ``49999``로 변경하는 것이 좋습니다. 나중에 "
#~ "디렉터리를 삭제하려면 ``sudo chown -R $USER:$(id"
#~ " -gn) state``를 실행하여 사용자 ID를 현재 "
#~ "사용자 ID로 다시 변경할 수 있습니다."

#~ msgid ""
#~ "Assuming all files we need are in"
#~ " the local ``certificates`` directory, we"
#~ " can use the flag ``--volume`` to "
#~ "mount the local directory into the "
#~ "``/app/certificates/`` directory of the "
#~ "container. This allows the SuperLink to"
#~ " access the files within the "
#~ "container. The ``ro`` stands for "
#~ "``read-only``. Docker volumes default to"
#~ " ``read-write``; that option tells "
#~ "Docker to make the volume ``read-"
#~ "only`` instead. Finally, we pass the "
#~ "names of the certificates and key "
#~ "file to the SuperLink with the "
#~ "``--ssl-ca-certfile``, ``--ssl-certfile`` "
#~ "and ``--ssl-keyfile`` flag."
#~ msgstr ""
#~ "필요한 모든 파일이 로컬``certificates`` 디렉터리에 있다고"
#~ " 가정하면, ``--volume``플래그를 사용하여 로컬 디렉터리를 "
#~ "컨테이너의 ``/app/certificates/`` 디렉터리에 마운트할 수 "
#~ "있습니다. 이렇게 하면 SuperLink 가 컨테이너 내의"
#~ " 파일에 액세스할 수 있습니다. ``ro``는 ``read-"
#~ "only``을 의미합니다. Docker 볼륨은 기본적으로 "
#~ "``read-write``로 설정되어 있는데, 이 옵션을 사용하면"
#~ " 볼륨을 ``read-only``으로 만들 수 있습니다. "
#~ "마지막으로 인증서 및 키 파일의 이름을 ``--ssl-"
#~ "ca-certfile``, ``--ssl-certfile`` 및 "
#~ "``--ssl-keyfile`` 플래그와 함께 SuperLink에 전달합니다."

#~ msgid ""
#~ "The SuperNode Docker image comes with"
#~ " a pre-installed version of Flower"
#~ " and serves as a base for "
#~ "building your own SuperNode image."
#~ msgstr ""
#~ "SuperNode Docker 이미지는 Flower의 사전 설치된 "
#~ "버전과 함께 제공되며, 자체 SuperNode 이미지를 "
#~ "구축하기 위한 기반 역할을 합니다."

#~ msgid ""
#~ "We will use the ``quickstart-pytorch``"
#~ " example, which you can find in "
#~ "the Flower repository, to illustrate how"
#~ " you can dockerize your ClientApp."
#~ msgstr ""
#~ "Flower 레포지토리에서 찾을 수 있는 ``quickstart-"
#~ "pytorch`` 예제를 사용하여 ClientApp을 도커라이즈하는 "
#~ "방법을 설명하겠습니다."

#~ msgid ""
#~ "Before we can start, we need to"
#~ " meet a few prerequisites in our "
#~ "local development environment. You can "
#~ "skip the first part if you want"
#~ " to run your ClientApp instead of "
#~ "the ``quickstart-pytorch`` example."
#~ msgstr ""
#~ "시작하기 전에 로컬 개발 환경에서 몇 가지 전제"
#~ " 조건을 충족해야 합니다. 'quickstart-pytorch' "
#~ "예제 대신 ClientApp을 실행하려는 경우 첫 번째 "
#~ "부분을 건너뛸 수 있습니다."

#~ msgid "Let's assume the following project layout:"
#~ msgstr "다음과 같은 프로젝트 레이아웃을 가정해 보겠습니다:"

#~ msgid ""
#~ "First, we need to create a "
#~ "``requirements.txt`` file in the directory "
#~ "where the ``ClientApp`` code is located."
#~ " In the file, we list all the"
#~ " dependencies that the ClientApp requires."
#~ msgstr ""
#~ "먼저 ``ClientApp`` 코드가 있는 디렉토리에 "
#~ "``requirements.txt`` 파일을 만들어야 합니다. 이 "
#~ "파일에는 클라이언트 앱에 필요한 모든 의존성을 나열합니다."

#~ msgid ""
#~ "Note that `flwr <https://pypi.org/project/flwr/>`__"
#~ " is already installed in the "
#~ "``flwr/supernode`` base image, so you "
#~ "only need to include other package "
#~ "dependencies in your ``requirements.txt``, "
#~ "such as ``torch``, ``tensorflow``, etc."
#~ msgstr ""
#~ "`flwr <https://pypi.org/project/flwr/>`__ 는 이미 "
#~ "``flwr/supernode`` 기본 이미지에 설치되어 있으므로, "
#~ "``torch``, ``tensorflow`` 등과 같은 다른 패키지"
#~ " dependencies만 ``requirements.txt``에 포함시키면 됩니다."

#~ msgid ""
#~ "Next, we create a Dockerfile. If "
#~ "you use the ``quickstart-pytorch`` "
#~ "example, create a new file called "
#~ "``Dockerfile.supernode`` in ``examples/quickstart-"
#~ "pytorch``."
#~ msgstr ""
#~ "다음으로, Dockerfile을 생성합니다.``quickstart-pytorch`` "
#~ "예제를 사용하는 경우 ``examples/quickstart-pytorch``에"
#~ " ``Dockerfile.supernode``라는 새 파일을 생성합니다."

#~ msgid ""
#~ "The ``Dockerfile.supernode`` contains the "
#~ "instructions that assemble the SuperNode "
#~ "image."
#~ msgstr "``Dockerfile.supernode``에는 SuperNode 이미지를 조립하는 지침이 포함되어 있습니다."

#~ msgid ""
#~ "In the first two lines, we "
#~ "instruct Docker to use the SuperNode "
#~ "image tagged ``nightly`` as a base "
#~ "image and set our working directory "
#~ "to ``/app``. The following instructions "
#~ "will now be executed in the "
#~ "``/app`` directory. Next, we install the"
#~ " ClientApp dependencies by copying the "
#~ "``requirements.txt`` file into the image "
#~ "and run ``pip install``. In the "
#~ "last two lines, we copy the "
#~ "``client.py`` module into the image and"
#~ " set the entry point to ``flower-"
#~ "client-app`` with the argument "
#~ "``client:app``. The argument is the "
#~ "object reference of the ClientApp "
#~ "(``<module>:<attribute>``) that will be run"
#~ " inside the ClientApp."
#~ msgstr ""
#~ "처음 두 줄에서는 ``nightly`` 태그가 붙은 "
#~ "SuperNode 이미지를 기본 이미지로 사용하고 작업 "
#~ "디렉터리를 ``/app``로 설정하도록 Docker에 지시합니다. 이제"
#~ " ``/app`` 디렉토리에서 다음 명령이 실행됩니다. 다음으로,"
#~ " ``requirements.txt`` 파일을 이미지에 복사하여 "
#~ "ClientApp dependencies 요소를 설치하고 ``pip "
#~ "install``을 실행합니다. 마지막 두 줄에서 "
#~ "``client.py`` 모듈을 이미지에 복사하고 ``client:app`` "
#~ "인수를 사용하여 진입점을 ``flower-client-app``로 "
#~ "설정합니다. 인수는 클라이언트앱 내부에서 실행될 클라이언트앱의 "
#~ "객체 참조 (``<module>:<attribute>``) 입니다."

#~ msgid "Building the SuperNode Docker image"
#~ msgstr "SuperNode Docker 이미지 빌드"

#~ msgid ""
#~ "We gave the image the name "
#~ "``flwr_supernode``, and the tag ``0.0.1``. "
#~ "Remember that the here chosen values "
#~ "only serve as an example. You can"
#~ " change them to your needs."
#~ msgstr ""
#~ "이미지에 ``flwr_supernode``라는 이름을 붙이고 ``0.0.1``"
#~ " 태그를 붙였습니다. 여기서 선택한 값은 예시일 뿐이라는"
#~ " 점을 기억하세요. 필요에 따라 변경할 수 있습니다."

#~ msgid "Running the SuperNode Docker image"
#~ msgstr "SuperNode Docker 이미지 실행"

#~ msgid "Now that we have built the SuperNode image, we can finally run it."
#~ msgstr "이제 SuperNode 이미지를 빌드했으니 이제 실행할 수 있습니다."

#~ msgid "Let's break down each part of this command:"
#~ msgstr "이 명령의 각 부분을 자세히 살펴보겠습니다:"

#~ msgid ""
#~ "``--rm``: This option specifies that the"
#~ " container should be automatically removed"
#~ " when it stops."
#~ msgstr "``--rm``: 이 옵션은 컨테이너가 중지될 때 자동으로 제거되도록 지정합니다."

#~ msgid "``--insecure``: This option enables insecure communication."
#~ msgstr "``--insecure``: 이 옵션은 보안되지 않은 통신을 활성화합니다."

#~ msgid ""
#~ "``--superlink 192.168.1.100:9092``: This option "
#~ "specifies the address of the SuperLinks"
#~ " Fleet"
#~ msgstr "``--superlink 192.168.1.100:9092``: 이 옵션은 SuperLinks Fleet의 주소를 지정합니다"

#~ msgid "API to connect to. Remember to update it with your SuperLink IP."
#~ msgstr "API에 연결할 수 있습니다. SuperLink IP로 업데이트하는 것을 잊지 마세요."

#~ msgid ""
#~ "To test running Flower locally, you "
#~ "can create a `bridge network "
#~ "<https://docs.docker.com/network/network-tutorial-"
#~ "standalone/#use-user-defined-bridge-"
#~ "networks>`__, use the ``--network`` argument"
#~ " and pass the name of the "
#~ "Docker network to run your SuperNodes."
#~ msgstr ""
#~ "로컬에서 Flower를 실행하는 것을 테스트하려면 `bridge "
#~ "network <https://docs.docker.com/network/network-"
#~ "tutorial-standalone/#use-user-defined-bridge-"
#~ "networks>`__를 생성하고 ``--network`` argument를 "
#~ "사용하고 SuperNodes를 실행할 Docker 네트워크의 이름을"
#~ " 전달하면 됩니다."

#~ msgid ""
#~ "Any argument that comes after the "
#~ "tag is passed to the Flower "
#~ "SuperNode binary. To see all available"
#~ " flags that the SuperNode supports, "
#~ "run:"
#~ msgstr ""
#~ "태그 뒤에 오는 모든 argument는 Flower "
#~ "SuperNode 바이너리에 전달됩니다. SuperNode가 지원하는 "
#~ "사용 가능한 모든 플래그를 보려면 실행하세요:"

#~ msgid ""
#~ "To enable SSL, we will need to "
#~ "mount a PEM-encoded root certificate "
#~ "into your SuperNode container."
#~ msgstr "SSL을 사용하려면 PEM 인코딩된 루트 인증서를 SuperNode 컨테이너에 마운트해야 합니다."

#~ msgid ""
#~ "Similar to the SuperNode image, the "
#~ "ServerApp Docker image comes with a "
#~ "pre-installed version of Flower and "
#~ "serves as a base for building your"
#~ " own ServerApp image."
#~ msgstr ""
#~ "SuperNode 이미지와 마찬가지로 ServerApp Docker "
#~ "이미지는 Flower의 사전 설치된 버전과 함께 제공되며,"
#~ " 자체 ServerApp 이미지를 구축하기 위한 기본 "
#~ "역할을 합니다."

#~ msgid ""
#~ "We will use the same ``quickstart-"
#~ "pytorch`` example as we do in the"
#~ " Flower SuperNode section. If you "
#~ "have not already done so, please "
#~ "follow the `SuperNode Prerequisites`_ before"
#~ " proceeding."
#~ msgstr ""
#~ "여기서는 Flower SuperNode 섹션에서와 동일한`quickstart-"
#~ "pytorch`` 예제를 사용하겠습니다. 아직 수행하지 않았다면 "
#~ "계속 진행하기 전에 `SuperNode Prerequisites`_ 을"
#~ " 따르세요."

#~ msgid "Creating a ServerApp Dockerfile"
#~ msgstr "ServerApp Dockerfile 만들기"

#~ msgid ""
#~ "First, we need to create a "
#~ "Dockerfile in the directory where the"
#~ " ``ServerApp`` code is located. If "
#~ "you use the ``quickstart-pytorch`` "
#~ "example, create a new file called "
#~ "``Dockerfile.serverapp`` in ``examples/quickstart-"
#~ "pytorch``."
#~ msgstr ""
#~ "먼저, ``ServerApp`` 코드가 있는 디렉토리에 Docker파일을"
#~ " 생성해야 합니다. ``quickstart-pytorch`` 예제를 "
#~ "사용하는 경우 ``examples/quickstart-pytorch``에 "
#~ "``Dockerfile.serverapp``이라는 새 파일을 생성합니다."

#~ msgid ""
#~ "The ``Dockerfile.serverapp`` contains the "
#~ "instructions that assemble the ServerApp "
#~ "image."
#~ msgstr "``Dockerfile.serverapp``에는 ServerApp 이미지를 합치는 지침이 포함되어 있습니다."

#~ msgid ""
#~ "In the first two lines, we "
#~ "instruct Docker to use the ServerApp "
#~ "image tagged ``1.8.0`` as a base "
#~ "image and set our working directory "
#~ "to ``/app``. The following instructions "
#~ "will now be executed in the "
#~ "``/app`` directory. In the last two "
#~ "lines, we copy the ``server.py`` module"
#~ " into the image and set the "
#~ "entry point to ``flower-server-app`` "
#~ "with the argument ``server:app``. The "
#~ "argument is the object reference of "
#~ "the ServerApp (``<module>:<attribute>``) that "
#~ "will be run inside the ServerApp "
#~ "container."
#~ msgstr ""
#~ "처음 두 줄에서는 ``1.8.0`` 태그가 붙은 "
#~ "ServerApp 이미지를 기본 이미지로 사용하고 작업 "
#~ "디렉터리를 ``/app``로 설정하도록 Docker에 지시합니다. 이제"
#~ " ``/app`` 디렉토리에서 다음 명령이 실행됩니다. 마지막"
#~ " 두 줄에서는 ``server.py`` 모듈을 이미지에 복사하고"
#~ " ``server:app`` argument를 사용하여 진입점을 "
#~ "``flower-server-app``로 설정합니다. 인수는 ServerApp"
#~ " 컨테이너 내에서 실행될 ServerApp의 객체 "
#~ "참조(``<module>:<attribute>``)입니다."

#~ msgid "Building the ServerApp Docker image"
#~ msgstr "ServerApp Docker 이미지 빌드"

#~ msgid "Running the ServerApp Docker image"
#~ msgstr "ServerApp Docker 이미지 실행"

#~ msgid "Now that we have built the ServerApp image, we can finally run it."
#~ msgstr "이제 ServerApp 이미지를 빌드했으니 이제 실행할 수 있습니다."

#~ msgid ""
#~ "``--superlink 192.168.1.100:9091``: This option "
#~ "specifies the address of the SuperLinks"
#~ " Driver"
#~ msgstr "``--superlink 192.168.1.100:9091``: 이 옵션은 SuperLinks 드라이버의 주소를 지정합니다"

#~ msgid ""
#~ "To test running Flower locally, you "
#~ "can create a `bridge network "
#~ "<https://docs.docker.com/network/network-tutorial-"
#~ "standalone/#use-user-defined-bridge-"
#~ "networks>`__, use the ``--network`` argument"
#~ " and pass the name of the "
#~ "Docker network to run your ServerApps."
#~ msgstr ""
#~ "로컬에서 Flower를 실행하는 것을 테스트하려면 `bridge "
#~ "network <https://docs.docker.com/network/network-"
#~ "tutorial-standalone/#use-user-defined-bridge-"
#~ "networks>`__,를 생성하고 ``--network`` argument를 "
#~ "사용하여 ServerApp을 실행할 Docker 네트워크의 이름을 "
#~ "전달하면 됩니다."

#~ msgid ""
#~ "Any argument that comes after the "
#~ "tag is passed to the Flower "
#~ "ServerApp binary. To see all available"
#~ " flags that the ServerApp supports, "
#~ "run:"
#~ msgstr ""
#~ "태그 뒤에 오는 모든 argument는 Flower "
#~ "ServerApp 바이너리에 전달됩니다. ServerApp에서 지원하는 "
#~ "사용 가능한 모든 플래그를 보려면 실행하세요:"

#~ msgid ""
#~ "To enable SSL, we will need to "
#~ "mount a PEM-encoded root certificate "
#~ "into your ServerApp container."
#~ msgstr "SSL을 사용하려면 PEM 인코딩된 루트 인증서를 ServerApp 컨테이너에 마운트해야 합니다."

#~ msgid ""
#~ "Assuming the certificate already exists "
#~ "locally, we can use the flag "
#~ "``--volume`` to mount the local "
#~ "certificate into the container's ``/app/`` "
#~ "directory. This allows the ServerApp to"
#~ " access the certificate within the "
#~ "container. Use the ``--root-certificates`` "
#~ "flags when starting the container."
#~ msgstr ""
#~ "인증서가 이미 로컬에 존재한다고 가정하면, ``--volume`` "
#~ "플래그를 사용하여 로컬 인증서를 컨테이너의 ``/app/`` "
#~ "디렉터리에 마운트할 수 있습니다. 이렇게 하면 "
#~ "ServerApp이 컨테이너 내의 인증서에 액세스할 수 "
#~ "있습니다. 컨테이너를 시작할 때 ``--root-"
#~ "certificates`` 플래그를 사용하세요."

#~ msgid ":py:obj:`run_client_app <flwr.client.run_client_app>`\\ \\(\\)"
#~ msgstr ":py:obj:`run_client_app <flwr.client.run_client_app>`\\ \\(\\)"

#~ msgid ":py:obj:`run_supernode <flwr.client.run_supernode>`\\ \\(\\)"
#~ msgstr ":py:obj:`run_supernode <flwr.client.run_supernode>`\\ \\(\\)"

#~ msgid "d defaults to None."
#~ msgstr "d는 기본값이 None입니다."

#~ msgid "Update R from dict/iterable E and F."
#~ msgstr "dict/iterable E 및 F에서 R을 업데이트합니다."

#~ msgid ""
#~ ":py:obj:`RUN_DRIVER_API_ENTER "
#~ "<flwr.common.EventType.RUN_DRIVER_API_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_DRIVER_API_ENTER "
#~ "<flwr.common.EventType.RUN_DRIVER_API_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_DRIVER_API_LEAVE "
#~ "<flwr.common.EventType.RUN_DRIVER_API_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_DRIVER_API_LEAVE "
#~ "<flwr.common.EventType.RUN_DRIVER_API_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_FLEET_API_ENTER "
#~ "<flwr.common.EventType.RUN_FLEET_API_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_FLEET_API_ENTER "
#~ "<flwr.common.EventType.RUN_FLEET_API_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_FLEET_API_LEAVE "
#~ "<flwr.common.EventType.RUN_FLEET_API_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_FLEET_API_LEAVE "
#~ "<flwr.common.EventType.RUN_FLEET_API_LEAVE>`\\"

#~ msgid ":py:obj:`DRIVER_CONNECT <flwr.common.EventType.DRIVER_CONNECT>`\\"
#~ msgstr ":py:obj:`DRIVER_CONNECT <flwr.common.EventType.DRIVER_CONNECT>`\\"

#~ msgid ":py:obj:`DRIVER_DISCONNECT <flwr.common.EventType.DRIVER_DISCONNECT>`\\"
#~ msgstr ":py:obj:`DRIVER_DISCONNECT <flwr.common.EventType.DRIVER_DISCONNECT>`\\"

#~ msgid ""
#~ ":py:obj:`START_DRIVER_ENTER "
#~ "<flwr.common.EventType.START_DRIVER_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_DRIVER_ENTER "
#~ "<flwr.common.EventType.START_DRIVER_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`START_DRIVER_LEAVE "
#~ "<flwr.common.EventType.START_DRIVER_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_DRIVER_LEAVE "
#~ "<flwr.common.EventType.START_DRIVER_LEAVE>`\\"

#~ msgid ""
#~ "An identifier that can be used "
#~ "when loading a particular data partition"
#~ " for a ClientApp. Making use of "
#~ "this identifier is more relevant when"
#~ " conducting simulations."
#~ msgstr ""
#~ "클라이언트 앱의 특정 데이터 파티션을 로드할 때 "
#~ "사용할 수 있는 식별자입니다. 시뮬레이션을 수행할 때 "
#~ "이 식별자를 사용하는 것이 더 적절합니다."

#~ msgid ":py:obj:`partition_id <flwr.common.Metadata.partition_id>`\\"
#~ msgstr ":py:obj:`partition_id <flwr.common.Metadata.partition_id>`\\"

#~ msgid "An identifier telling which data partition a ClientApp should use."
#~ msgstr "클라이언트앱이 사용해야 하는 데이터 파티션을 알려주는 식별자입니다."

#~ msgid ":py:obj:`run_server_app <flwr.server.run_server_app>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`run_superlink <flwr.server.run_superlink>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Run Flower SuperLink (Driver API and Fleet API)."
#~ msgstr "Flower SuperLink(Driver API 및 Fleet API)를 실행하세요."

#~ msgid ""
#~ ":py:obj:`LegacyContext <flwr.server.LegacyContext>`\\ "
#~ "\\(state\\[\\, config\\, strategy\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`flwr.server.strategy <flwr.server.strategy>`\\"
#~ msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#~ msgid ":py:obj:`flwr.server.workflow <flwr.server.workflow>`\\"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid "run\\_driver\\_api"
#~ msgstr ""

#~ msgid "run\\_fleet\\_api"
#~ msgstr ""

#~ msgid ""
#~ "The protocol involves four main stages:"
#~ " - 'setup': Send SecAgg+ configuration "
#~ "to clients and collect their public "
#~ "keys. - 'share keys': Broadcast public"
#~ " keys among clients and collect "
#~ "encrypted secret"
#~ msgstr ""

#~ msgid "key shares."
#~ msgstr ""

#~ msgid ""
#~ "The protocol involves four main stages:"
#~ " - 'setup': Send SecAgg configuration "
#~ "to clients and collect their public "
#~ "keys. - 'share keys': Broadcast public"
#~ " keys among clients and collect "
#~ "encrypted secret"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`start_simulation <flwr.simulation.start_simulation>`\\"
#~ " \\(\\*\\, client\\_fn\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "'A dictionary, e.g {\"<keyA>\": <value>, "
#~ "\"<keyB>\": <value>} to configure a "
#~ "backend. Values supported in <value> are"
#~ " those included by "
#~ "`flwr.common.typing.ConfigsRecordValues`."
#~ msgstr ""

#~ msgid ""
#~ "When diabled, only INFO, WARNING and "
#~ "ERROR log messages will be shown. "
#~ "If enabled, DEBUG-level logs will "
#~ "be displayed."
#~ msgstr ""

#~ msgid ""
#~ "A function creating client instances. "
#~ "The function must take a single "
#~ "`str` argument called `cid`. It should"
#~ " return a single client instance of"
#~ " type Client. Note that the created"
#~ " client instances are ephemeral and "
#~ "will often be destroyed after a "
#~ "single method invocation. Since client "
#~ "instances are not long-lived, they "
#~ "should not attempt to carry state "
#~ "over method invocations. Any state "
#~ "required by the instance (model, "
#~ "dataset, hyperparameters, ...) should be "
#~ "(re-)created in either the call to "
#~ "`client_fn` or the call to any of"
#~ " the client methods (e.g., load "
#~ "evaluation data in the `evaluate` method"
#~ " itself)."
#~ msgstr ""

#~ msgid ""
#~ "The total number of clients in "
#~ "this simulation. This must be set "
#~ "if `clients_ids` is not set and "
#~ "vice-versa."
#~ msgstr ""

#~ msgid ""
#~ "List `client_id`s for each client. This"
#~ " is only required if `num_clients` is"
#~ " not set. Setting both `num_clients` "
#~ "and `clients_ids` with `len(clients_ids)` not"
#~ " equal to `num_clients` generates an "
#~ "error."
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial we will learn how"
#~ " to train a Convolutional Neural "
#~ "Network on CIFAR10 using Flower and "
#~ "PyTorch."
#~ msgstr ""

#~ msgid ""
#~ "*Clients* are responsible for generating "
#~ "individual weight-updates for the model"
#~ " based on their local datasets. These"
#~ " updates are then sent to the "
#~ "*server* which will aggregate them to"
#~ " produce a better model. Finally, the"
#~ " *server* sends this improved version "
#~ "of the model back to each "
#~ "*client*. A complete cycle of weight "
#~ "updates is called a *round*."
#~ msgstr ""

#~ msgid ""
#~ "Now that we have a rough idea "
#~ "of what is going on, let's get "
#~ "started. We first need to install "
#~ "Flower. You can do this by running"
#~ " :"
#~ msgstr ""

#~ msgid ""
#~ "Since we want to use PyTorch to"
#~ " solve a computer vision task, let's"
#~ " go ahead and install PyTorch and "
#~ "the **torchvision** library:"
#~ msgstr ""

#~ msgid ""
#~ "Now that we have all our "
#~ "dependencies installed, let's run a "
#~ "simple distributed training with two "
#~ "clients and one server. Our training "
#~ "procedure and network architecture are "
#~ "based on PyTorch's `Deep Learning with"
#~ " PyTorch "
#~ "<https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "In a file called :code:`client.py`, "
#~ "import Flower and PyTorch related "
#~ "packages:"
#~ msgstr ""

#~ msgid "In addition, we define the device allocation in PyTorch with:"
#~ msgstr ""

#~ msgid ""
#~ "We use PyTorch to load CIFAR10, a"
#~ " popular colored image classification "
#~ "dataset for machine learning. The "
#~ "PyTorch :code:`DataLoader()` downloads the "
#~ "training and test data that are "
#~ "then normalized."
#~ msgstr ""

#~ msgid ""
#~ "Define the loss and optimizer with "
#~ "PyTorch. The training of the dataset "
#~ "is done by looping over the "
#~ "dataset, measure the corresponding loss "
#~ "and optimize it."
#~ msgstr ""

#~ msgid ""
#~ "Define then the validation of the  "
#~ "machine learning network. We loop over"
#~ " the test set and measure the "
#~ "loss and accuracy of the test set."
#~ msgstr ""

#~ msgid ""
#~ "After defining the training and testing"
#~ " of a PyTorch machine learning model,"
#~ " we use the functions for the "
#~ "Flower clients."
#~ msgstr ""

#~ msgid ""
#~ "The Flower clients will use a "
#~ "simple CNN adapted from 'PyTorch: A "
#~ "60 Minute Blitz':"
#~ msgstr ""

#~ msgid ""
#~ "After loading the data set with "
#~ ":code:`load_data()` we define the Flower "
#~ "interface."
#~ msgstr ""

#~ msgid ""
#~ "Flower provides a convenience class "
#~ "called :code:`NumPyClient` which makes it "
#~ "easier to implement the :code:`Client` "
#~ "interface when your workload uses "
#~ "PyTorch. Implementing :code:`NumPyClient` usually"
#~ " means defining the following methods "
#~ "(:code:`set_parameters` is optional though):"
#~ msgstr ""

#~ msgid "receive the updated local model weights"
#~ msgstr ""

#~ msgid "which can be implemented in the following way:"
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated learning "
#~ "system. The full `source code "
#~ "<https://github.com/adap/flower/blob/main/examples/quickstart-"
#~ "pytorch/client.py>`_ for this example can "
#~ "be found in :code:`examples/quickstart-"
#~ "pytorch`."
#~ msgstr ""

#~ msgid ""
#~ "In this example, we split the "
#~ "dataset into two partitions with uniform"
#~ " distribution (:code:`IidPartitioner(num_partitions=2)`). "
#~ "Then, we load the partition for "
#~ "the given client based on "
#~ ":code:`node_id`:"
#~ msgstr ""

#~ msgid ""
#~ "The :code:`self.bst` is used to keep "
#~ "the Booster objects that remain "
#~ "consistent across rounds, allowing them "
#~ "to store predictions from trees "
#~ "integrated in earlier rounds and "
#~ "maintain other essential data structures "
#~ "for training."
#~ msgstr ""

#~ msgid ""
#~ "In :code:`fit`, at the first round, "
#~ "we call :code:`xgb.train()` to build up"
#~ " the first set of trees. the "
#~ "returned Booster object and config are"
#~ " stored in :code:`self.bst` and "
#~ ":code:`self.config`, respectively. From the "
#~ "second round, we load the global "
#~ "model sent from server to "
#~ ":code:`self.bst`, and then update model "
#~ "weights on local training data with "
#~ "function :code:`local_boost` as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Given :code:`num_local_round`, we update trees"
#~ " by calling :code:`self.bst.update` method. "
#~ "After training, the last "
#~ ":code:`N=num_local_round` trees will be "
#~ "extracted to send to the server."
#~ msgstr ""

#~ msgid ""
#~ "In :code:`evaluate`, we call "
#~ ":code:`self.bst.eval_set` function to conduct "
#~ "evaluation on valid set. The AUC "
#~ "value will be returned."
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement :code:`Client`and call"
#~ " :code:`fl.client.start_client()`. The string "
#~ ":code:`\"[::]:8080\"` tells the client which"
#~ " server to connect to. In our "
#~ "case we can run the server and "
#~ "the client on the same machine, "
#~ "therefore we use :code:`\"[::]:8080\"`. If "
#~ "we run a truly federated workload "
#~ "with the server and clients running "
#~ "on different machines, all that needs"
#~ " to change is the :code:`server_address`"
#~ " we point the client at."
#~ msgstr ""

#~ msgid ""
#~ "We use two clients for this "
#~ "example. An :code:`evaluate_metrics_aggregation` "
#~ "function is defined to collect and "
#~ "wighted average the AUC values from "
#~ "clients."
#~ msgstr ""

#~ msgid ""
#~ "Welcome to the third part of the"
#~ " Flower federated learning tutorial. In "
#~ "previous parts of this tutorial, we "
#~ "introduced federated learning with PyTorch "
#~ "and Flower (`part 1 "
#~ "<https://flower.ai/docs/framework/tutorial-get-started-"
#~ "with-flower-pytorch.html>`__) and we "
#~ "learned how strategies can be used "
#~ "to customize the execution on both "
#~ "the server and the clients (`part "
#~ "2 <https://flower.ai/docs/framework/tutorial-use-a"
#~ "-federated-learning-strategy-pytorch.html>`__)."
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we'll continue to "
#~ "customize the federated learning system "
#~ "we built previously by creating a "
#~ "custom version of FedAvg (again, using"
#~ " `Flower <https://flower.ai/>`__ and `PyTorch "
#~ "<https://pytorch.org/>`__)."
#~ msgstr ""

#~ msgid ""
#~ "`Star Flower on GitHub "
#~ "<https://github.com/adap/flower>`__ ⭐️ and join "
#~ "the Flower community on Slack to "
#~ "connect, ask questions, and get help:"
#~ " `Join Slack <https://flower.ai/join-slack>`__"
#~ " 🌼 We'd love to hear from you"
#~ " in the ``#introductions`` channel! And "
#~ "if anything is unclear, head over "
#~ "to the ``#questions`` channel."
#~ msgstr ""

#~ msgid "Let's build a new ``Strategy`` from scratch!"
#~ msgstr ""

#~ msgid ""
#~ "Let's now load the CIFAR-10 training "
#~ "and test set, partition them into "
#~ "ten smaller datasets (each split into"
#~ " training and validation set), and "
#~ "wrap everything in their own "
#~ "``DataLoader``. We introduce a new "
#~ "parameter ``num_clients`` which allows us "
#~ "to call ``load_datasets`` with different "
#~ "numbers of clients."
#~ msgstr ""

#~ msgid ""
#~ "To implement the Flower client, we "
#~ "(again) create a subclass of "
#~ "``flwr.client.NumPyClient`` and implement the "
#~ "three methods ``get_parameters``, ``fit``, and"
#~ " ``evaluate``. Here, we also pass the"
#~ " ``cid`` to the client and use "
#~ "it log additional details:"
#~ msgstr ""

#~ msgid ""
#~ "Let's go deeper and see what it"
#~ " takes to move from ``NumPyClient`` "
#~ "to ``Client``!"
#~ msgstr ""

#~ msgid ""
#~ "So far, we've implemented our client "
#~ "by subclassing ``flwr.client.NumPyClient``. The "
#~ "three methods we implemented are "
#~ "``get_parameters``, ``fit``, and ``evaluate``. "
#~ "Finally, we wrap the creation of "
#~ "instances of this class in a "
#~ "function called ``client_fn``:"
#~ msgstr ""

#~ msgid ""
#~ "We've seen this before, there's nothing"
#~ " new so far. The only *tiny* "
#~ "difference compared to the previous "
#~ "notebook is naming, we've changed "
#~ "``FlowerClient`` to ``FlowerNumPyClient`` and "
#~ "``client_fn`` to ``numpyclient_fn``. Let's run"
#~ " it to see the output we get:"
#~ msgstr ""

#~ msgid ""
#~ "This works as expected, two clients "
#~ "are training for three rounds of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ "Let's dive a little bit deeper and"
#~ " discuss how Flower executes this "
#~ "simulation. Whenever a client is "
#~ "selected to do some work, "
#~ "``start_simulation`` calls the function "
#~ "``numpyclient_fn`` to create an instance "
#~ "of our ``FlowerNumPyClient`` (along with "
#~ "loading the model and the data)."
#~ msgstr ""

#~ msgid ""
#~ "`Check out Flower Code Examples "
#~ "<https://github.com/adap/flower/tree/main/examples>`__"
#~ msgstr ""

#~ msgid ""
#~ "`Watch Flower Summit 2023 videos "
#~ "<https://flower.ai/conf/flower-summit-2023/>`__"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we'll build a "
#~ "federated learning system using Flower, "
#~ "`Flower Datasets <https://flower.ai/docs/datasets/>`__ "
#~ "and PyTorch. In part 1, we use "
#~ "PyTorch for the model training pipeline"
#~ " and data loading. In part 2, "
#~ "we continue to federate the PyTorch-"
#~ "based pipeline using Flower."
#~ msgstr ""

#~ msgid "Loading the data"
#~ msgstr ""

#~ msgid ""
#~ "We simulate having multiple datasets "
#~ "from multiple organizations (also called "
#~ "the \"cross-silo\" setting in federated"
#~ " learning) by splitting the original "
#~ "CIFAR-10 dataset into multiple partitions. "
#~ "Each partition will represent the data"
#~ " from a single organization. We're "
#~ "doing this purely for experimentation "
#~ "purposes, in the real world there's "
#~ "no need for data splitting because "
#~ "each organization already has their own"
#~ " data (so the data is naturally "
#~ "partitioned)."
#~ msgstr ""

#~ msgid ""
#~ "Each organization will act as a "
#~ "client in the federated learning system."
#~ " So having ten organizations participate"
#~ " in a federation means having ten "
#~ "clients connected to the federated "
#~ "learning server."
#~ msgstr ""

#~ msgid ""
#~ "Let's now create the Federated Dataset"
#~ " abstraction that from ``flwr-datasets``"
#~ " that partitions the CIFAR-10. We "
#~ "will create small training and test "
#~ "set for each edge device and wrap"
#~ " each of them into a PyTorch "
#~ "``DataLoader``:"
#~ msgstr ""

#~ msgid ""
#~ "We now have a list of ten "
#~ "training sets and ten validation sets"
#~ " (``trainloaders`` and ``valloaders``) "
#~ "representing the data of ten different"
#~ " organizations. Each ``trainloader``/``valloader`` "
#~ "pair contains 4000 training examples and"
#~ " 1000 validation examples. There's also "
#~ "a single ``testloader`` (we did not "
#~ "split the test set). Again, this "
#~ "is only necessary for building research"
#~ " or educational systems, actual federated"
#~ " learning systems have their data "
#~ "naturally distributed across multiple "
#~ "partitions."
#~ msgstr ""

#~ msgid ""
#~ "Let's take a look at the first "
#~ "batch of images and labels in the"
#~ " first training set (i.e., "
#~ "``trainloaders[0]``) before we move on:"
#~ msgstr ""

#~ msgid ""
#~ "The output above shows a random "
#~ "batch of images from the first "
#~ "``trainloader`` in our list of ten "
#~ "``trainloaders``. It also prints the "
#~ "labels associated with each image (i.e.,"
#~ " one of the ten possible labels "
#~ "we've seen above). If you run the"
#~ " cell again, you should see another"
#~ " batch of images."
#~ msgstr ""

#~ msgid "Defining the model"
#~ msgstr ""

#~ msgid "Training the model"
#~ msgstr ""

#~ msgid ""
#~ "We now have all the basic building"
#~ " blocks we need: a dataset, a "
#~ "model, a training function, and a "
#~ "test function. Let's put them together"
#~ " to train the model on the "
#~ "dataset of one of our organizations "
#~ "(``trainloaders[0]``). This simulates the "
#~ "reality of most machine learning "
#~ "projects today: each organization has "
#~ "their own data and trains models "
#~ "only on this internal data:"
#~ msgstr ""

#~ msgid ""
#~ "Training the simple CNN on our "
#~ "CIFAR-10 split for 5 epochs should "
#~ "result in a test set accuracy of"
#~ " about 41%, which is not good, "
#~ "but at the same time, it doesn't"
#~ " really matter for the purposes of"
#~ " this tutorial. The intent was just"
#~ " to show a simplistic centralized "
#~ "training pipeline that sets the stage"
#~ " for what comes next - federated "
#~ "learning!"
#~ msgstr ""

#~ msgid "Updating model parameters"
#~ msgstr ""

#~ msgid ""
#~ "In federated learning, the server sends"
#~ " the global model parameters to the"
#~ " client, and the client updates the"
#~ " local model with the parameters "
#~ "received from the server. It then "
#~ "trains the model on the local data"
#~ " (which changes the model parameters "
#~ "locally) and sends the updated/changed "
#~ "model parameters back to the server "
#~ "(or, alternatively, it sends just the"
#~ " gradients back to the server, not"
#~ " the full model parameters)."
#~ msgstr ""

#~ msgid ""
#~ "The details of how this works are"
#~ " not really important here (feel free"
#~ " to consult the PyTorch documentation "
#~ "if you want to learn more). In "
#~ "essence, we use ``state_dict`` to access"
#~ " PyTorch model parameter tensors. The "
#~ "parameter tensors are then converted "
#~ "to/from a list of NumPy ndarray's "
#~ "(which Flower knows how to "
#~ "serialize/deserialize):"
#~ msgstr ""

#~ msgid "Implementing a Flower client"
#~ msgstr ""

#~ msgid ""
#~ "With that out of the way, let's"
#~ " move on to the interesting part. "
#~ "Federated learning systems consist of a"
#~ " server and multiple clients. In "
#~ "Flower, we create clients by "
#~ "implementing subclasses of ``flwr.client.Client``"
#~ " or ``flwr.client.NumPyClient``. We use "
#~ "``NumPyClient`` in this tutorial because "
#~ "it is easier to implement and "
#~ "requires us to write less boilerplate."
#~ msgstr ""

#~ msgid ""
#~ "To implement the Flower client, we "
#~ "create a subclass of "
#~ "``flwr.client.NumPyClient`` and implement the "
#~ "three methods ``get_parameters``, ``fit``, and"
#~ " ``evaluate``:"
#~ msgstr ""

#~ msgid ""
#~ "``fit``: Receive model parameters from "
#~ "the server, train the model parameters"
#~ " on the local data, and return "
#~ "the (updated) model parameters to the"
#~ " server"
#~ msgstr ""

#~ msgid ""
#~ "``evaluate``: Receive model parameters from"
#~ " the server, evaluate the model "
#~ "parameters on the local data, and "
#~ "return the evaluation result to the "
#~ "server"
#~ msgstr ""

#~ msgid ""
#~ "Our class ``FlowerClient`` defines how "
#~ "local training/evaluation will be performed"
#~ " and allows Flower to call the "
#~ "local training/evaluation through ``fit`` and"
#~ " ``evaluate``. Each instance of "
#~ "``FlowerClient`` represents a *single client*"
#~ " in our federated learning system. "
#~ "Federated learning systems have multiple "
#~ "clients (otherwise, there's not much to"
#~ " federate), so each client will be"
#~ " represented by its own instance of"
#~ " ``FlowerClient``. If we have, for "
#~ "example, three clients in our workload,"
#~ " then we'd have three instances of"
#~ " ``FlowerClient``. Flower calls "
#~ "``FlowerClient.fit`` on the respective "
#~ "instance when the server selects a "
#~ "particular client for training (and "
#~ "``FlowerClient.evaluate`` for evaluation)."
#~ msgstr ""

#~ msgid "Using the Virtual Client Engine"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we want to "
#~ "simulate a federated learning system "
#~ "with 10 clients on a single "
#~ "machine. This means that the server "
#~ "and all 10 clients will live on"
#~ " a single machine and share resources"
#~ " such as CPU, GPU, and memory. "
#~ "Having 10 clients would mean having "
#~ "10 instances of ``FlowerClient`` in "
#~ "memory. Doing this on a single "
#~ "machine can quickly exhaust the "
#~ "available memory resources, even if only"
#~ " a subset of these clients "
#~ "participates in a single round of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ "In addition to the regular capabilities"
#~ " where server and clients run on "
#~ "multiple machines, Flower, therefore, provides"
#~ " special simulation capabilities that "
#~ "create ``FlowerClient`` instances only when"
#~ " they are actually necessary for "
#~ "training or evaluation. To enable the"
#~ " Flower framework to create clients "
#~ "when necessary, we need to implement "
#~ "a function called ``client_fn`` that "
#~ "creates a ``FlowerClient`` instance on "
#~ "demand. Flower calls ``client_fn`` whenever"
#~ " it needs an instance of one "
#~ "particular client to call ``fit`` or "
#~ "``evaluate`` (those instances are usually "
#~ "discarded after use, so they should "
#~ "not keep any local state). Clients "
#~ "are identified by a client ID, or"
#~ " short ``cid``. The ``cid`` can be"
#~ " used, for example, to load different"
#~ " local data partitions for different "
#~ "clients, as can be seen below:"
#~ msgstr ""

#~ msgid "Starting the training"
#~ msgstr ""

#~ msgid ""
#~ "We now have the class ``FlowerClient``"
#~ " which defines client-side "
#~ "training/evaluation and ``client_fn`` which "
#~ "allows Flower to create ``FlowerClient`` "
#~ "instances whenever it needs to call "
#~ "``fit`` or ``evaluate`` on one "
#~ "particular client. The last step is "
#~ "to start the actual simulation using "
#~ "``flwr.simulation.start_simulation``."
#~ msgstr ""

#~ msgid ""
#~ "The function ``start_simulation`` accepts a"
#~ " number of arguments, amongst them "
#~ "the ``client_fn`` used to create "
#~ "``FlowerClient`` instances, the number of "
#~ "clients to simulate (``num_clients``), the "
#~ "number of federated learning rounds "
#~ "(``num_rounds``), and the strategy. The "
#~ "strategy encapsulates the federated learning"
#~ " approach/algorithm, for example, *Federated "
#~ "Averaging* (FedAvg)."
#~ msgstr ""

#~ msgid ""
#~ "Flower has a number of built-in"
#~ " strategies, but we can also use "
#~ "our own strategy implementations to "
#~ "customize nearly all aspects of the "
#~ "federated learning approach. For this "
#~ "example, we use the built-in "
#~ "``FedAvg`` implementation and customize it "
#~ "using a few basic parameters. The "
#~ "last step is the actual call to"
#~ " ``start_simulation`` which - you guessed"
#~ " it - starts the simulation:"
#~ msgstr ""

#~ msgid ""
#~ "When we call ``start_simulation``, we "
#~ "tell Flower that there are 10 "
#~ "clients (``num_clients=10``). Flower then goes"
#~ " ahead an asks the ``FedAvg`` "
#~ "strategy to select clients. ``FedAvg`` "
#~ "knows that it should select 100% "
#~ "of the available clients "
#~ "(``fraction_fit=1.0``), so it goes ahead "
#~ "and selects 10 random clients (i.e., "
#~ "100% of 10)."
#~ msgstr ""

#~ msgid ""
#~ "Flower then asks the selected 10 "
#~ "clients to train the model. When "
#~ "the server receives the model parameter"
#~ " updates from the clients, it hands"
#~ " those updates over to the strategy"
#~ " (*FedAvg*) for aggregation. The strategy"
#~ " aggregates those updates and returns "
#~ "the new global model, which then "
#~ "gets used in the next round of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ "The only thing left to do is "
#~ "to tell the strategy to call this"
#~ " function whenever it receives evaluation"
#~ " metric dictionaries from the clients:"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we'll begin to "
#~ "customize the federated learning system "
#~ "we built in the introductory notebook"
#~ " (again, using `Flower <https://flower.ai/>`__"
#~ " and `PyTorch <https://pytorch.org/>`__)."
#~ msgstr ""

#~ msgid "Let's move beyond FedAvg with Flower strategies!"
#~ msgstr ""

#~ msgid ""
#~ "Flower, by default, initializes the "
#~ "global model by asking one random "
#~ "client for the initial parameters. In"
#~ " many cases, we want more control "
#~ "over parameter initialization though. Flower"
#~ " therefore allows you to directly "
#~ "pass the initial parameters to the "
#~ "Strategy:"
#~ msgstr ""

#~ msgid ""
#~ "Passing ``initial_parameters`` to the "
#~ "``FedAvg`` strategy prevents Flower from "
#~ "asking one of the clients for the"
#~ " initial parameters. If we look "
#~ "closely, we can see that the logs"
#~ " do not show any calls to the"
#~ " ``FlowerClient.get_parameters`` method."
#~ msgstr ""

#~ msgid ""
#~ "We've seen the function ``start_simulation``"
#~ " before. It accepts a number of "
#~ "arguments, amongst them the ``client_fn`` "
#~ "used to create ``FlowerClient`` instances, "
#~ "the number of clients to simulate "
#~ "``num_clients``, the number of rounds "
#~ "``num_rounds``, and the strategy."
#~ msgstr ""

#~ msgid ""
#~ "Next, we'll just pass this function "
#~ "to the FedAvg strategy before starting"
#~ " the simulation:"
#~ msgstr ""

#~ msgid ""
#~ "We now have 1000 partitions, each "
#~ "holding 45 training and 5 validation "
#~ "examples. Given that the number of "
#~ "training examples on each client is "
#~ "quite small, we should probably train"
#~ " the model a bit longer, so we"
#~ " configure the clients to perform 3"
#~ " local training epochs. We should "
#~ "also adjust the fraction of clients "
#~ "selected for training during each round"
#~ " (we don't want all 1000 clients "
#~ "participating in every round), so we "
#~ "adjust ``fraction_fit`` to ``0.05``, which "
#~ "means that only 5% of available "
#~ "clients (so 50 clients) will be "
#~ "selected for training each round:"
#~ msgstr ""

#~ msgid "|93b02017c78049bbbd5ae456dcb2c91b|"
#~ msgstr "|93b02017c78049bbbd5ae456dcb2c91b|"

#~ msgid "|01471150fd5144c080a176b43e92a3ff|"
#~ msgstr "|01471150fd5144c080a176b43e92a3ff|"

#~ msgid "|9bc21c7dbd17444a8f070c60786e3484|"
#~ msgstr "|9bc21c7dbd17444a8f070c60786e3484|"

#~ msgid "|3047bbce54b34099ae559963d0420d79|"
#~ msgstr "|3047bbce54b34099ae559963d0420d79|"

#~ msgid "|e9f8ce948593444fb838d2f354c7ec5d|"
#~ msgstr "|e9f8ce948593444fb838d2f354c7ec5d|"

#~ msgid "|c24c1478b30e4f74839208628a842d1e|"
#~ msgstr "|c24c1478b30e4f74839208628a842d1e|"

#~ msgid "|1b3613d7a58847b59e1d3180802dbc09|"
#~ msgstr "|1b3613d7a58847b59e1d3180802dbc09|"

#~ msgid "|9980b5213db547d0b8024a50992b9e3f|"
#~ msgstr "|9980b5213db547d0b8024a50992b9e3f|"

#~ msgid "|c7afb4c92d154bfaa5e8cb9a150e17f1|"
#~ msgstr "|c7afb4c92d154bfaa5e8cb9a150e17f1|"

#~ msgid "|032eb6fed6924ac387b9f13854919196|"
#~ msgstr "|032eb6fed6924ac387b9f13854919196|"

#~ msgid "|fbf225add7fd4df5a9bf25a95597d954|"
#~ msgstr "|fbf225add7fd4df5a9bf25a95597d954|"

#~ msgid "|7efbe3d29d8349b89594e8947e910525|"
#~ msgstr "|7efbe3d29d8349b89594e8947e910525|"

#~ msgid "|329fb3c04c744eda83bb51fa444c2266|"
#~ msgstr "|329fb3c04c744eda83bb51fa444c2266|"

#~ msgid "|c00bf2750bc24d229737a0fe1395f0fc|"
#~ msgstr "|c00bf2750bc24d229737a0fe1395f0fc|"

#~ msgid "run\\_client\\_app"
#~ msgstr "클라이언트앱"

#~ msgid "run\\_supernode"
#~ msgstr "run\\_supernode"

#~ msgid "Retrieve the corresponding layout by the string key."
#~ msgstr ""

#~ msgid ""
#~ "When there isn't an exact match, "
#~ "all the existing keys in the "
#~ "layout map will be treated as a"
#~ " regex and map against the input "
#~ "key again. The first match will be"
#~ " returned, based on the key insertion"
#~ " order. Return None if there isn't"
#~ " any match found."
#~ msgstr ""

#~ msgid "the string key as the query for the layout."
#~ msgstr ""

#~ msgid "Corresponding layout based on the query."
#~ msgstr ""

#~ msgid "run\\_server\\_app"
#~ msgstr "Flower 서버앱"

#~ msgid "run\\_superlink"
#~ msgstr "flower 초연결"

#~ msgid "Start a Ray-based Flower simulation server."
#~ msgstr "멀티 노드 Flower 시뮬레이션"

#~ msgid ""
#~ "A function creating `Client` instances. "
#~ "The function must have the signature "
#~ "`client_fn(context: Context). It should return"
#~ " a single client instance of type "
#~ "`Client`. Note that the created client"
#~ " instances are ephemeral and will "
#~ "often be destroyed after a single "
#~ "method invocation. Since client instances "
#~ "are not long-lived, they should "
#~ "not attempt to carry state over "
#~ "method invocations. Any state required "
#~ "by the instance (model, dataset, "
#~ "hyperparameters, ...) should be (re-)created"
#~ " in either the call to `client_fn`"
#~ " or the call to any of the "
#~ "client methods (e.g., load evaluation "
#~ "data in the `evaluate` method itself)."
#~ msgstr ""

#~ msgid "The total number of clients in this simulation."
#~ msgstr ""

#~ msgid ""
#~ "UNSUPPORTED, WILL BE REMOVED. USE "
#~ "`num_clients` INSTEAD. List `client_id`s for"
#~ " each client. This is only required"
#~ " if `num_clients` is not set. Setting"
#~ " both `num_clients` and `clients_ids` with"
#~ " `len(clients_ids)` not equal to "
#~ "`num_clients` generates an error. Using "
#~ "this argument will raise an error."
#~ msgstr ""

#~ msgid ""
#~ "CPU and GPU resources for a single"
#~ " client. Supported keys are `num_cpus` "
#~ "and `num_gpus`. To understand the GPU"
#~ " utilization caused by `num_gpus`, as "
#~ "well as using custom resources, please"
#~ " consult the Ray documentation."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.server.Server`. If no instance"
#~ " is provided, then `start_server` will "
#~ "create one."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.server.Strategy`. If no "
#~ "strategy is provided, then `start_server` "
#~ "will use `flwr.server.strategy.FedAvg`."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.server.ClientManager`. If no "
#~ "implementation is provided, then "
#~ "`start_simulation` will use "
#~ "`flwr.server.client_manager.SimpleClientManager`."
#~ msgstr ""

#~ msgid ""
#~ "Optional dictionary containing arguments for"
#~ " the call to `ray.init`. If "
#~ "ray_init_args is None (the default), Ray"
#~ " will be initialized with the "
#~ "following default args:  { "
#~ "\"ignore_reinit_error\": True, \"include_dashboard\": "
#~ "False }  An empty dictionary can "
#~ "be used (ray_init_args={}) to prevent "
#~ "any arguments from being passed to "
#~ "ray.init."
#~ msgstr ""

#~ msgid ""
#~ "Optional dictionary containing arguments for"
#~ " the call to `ray.init`. If "
#~ "ray_init_args is None (the default), Ray"
#~ " will be initialized with the "
#~ "following default args:"
#~ msgstr ""

#~ msgid "{ \"ignore_reinit_error\": True, \"include_dashboard\": False }"
#~ msgstr ""

#~ msgid ""
#~ "An empty dictionary can be used "
#~ "(ray_init_args={}) to prevent any arguments"
#~ " from being passed to ray.init."
#~ msgstr ""

#~ msgid ""
#~ "Set to True to prevent `ray.shutdown()`"
#~ " in case `ray.is_initialized()=True`."
#~ msgstr ""

#~ msgid ""
#~ "Optionally specify the type of actor "
#~ "to use. The actor object, which "
#~ "persists throughout the simulation, will "
#~ "be the process in charge of "
#~ "executing a ClientApp wrapping input "
#~ "argument `client_fn`."
#~ msgstr ""

#~ msgid ""
#~ "If you want to create your own "
#~ "Actor classes, you might need to "
#~ "pass some input argument. You can "
#~ "use this dictionary for such purpose."
#~ msgstr ""

#~ msgid ""
#~ "(default: \"DEFAULT\") Optional string "
#~ "(\"DEFAULT\" or \"SPREAD\") for the VCE"
#~ " to choose in which node the "
#~ "actor is placed. If you are an "
#~ "advanced user needed more control you"
#~ " can use lower-level scheduling "
#~ "strategies to pin actors to specific "
#~ "compute nodes (e.g. via "
#~ "NodeAffinitySchedulingStrategy). Please note this"
#~ " is an advanced feature. For all "
#~ "details, please refer to the Ray "
#~ "documentation: https://docs.ray.io/en/latest/ray-"
#~ "core/scheduling/index.html"
#~ msgstr ""

#~ msgid "**hist** -- Object containing metrics from training."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with FastAI to train a vision "
#~ "model on CIFAR-10."
#~ msgstr ""

#~ msgid "Let's build a federated learning system using fastai and Flower!"
#~ msgstr ""

#~ msgid ""
#~ "Please refer to the `full code "
#~ "example <https://github.com/adap/flower/tree/main/examples"
#~ "/quickstart-fastai>`_ to learn more."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federating Learning "
#~ "quickstart tutorial for using Flower "
#~ "with HuggingFace Transformers in order "
#~ "to fine-tune an LLM."
#~ msgstr ""

#~ msgid ""
#~ "Let's build a federated learning system"
#~ " using Hugging Face Transformers and "
#~ "Flower!"
#~ msgstr ""

#~ msgid ""
#~ "We will leverage Hugging Face to "
#~ "federate the training of language models"
#~ " over multiple clients using Flower. "
#~ "More specifically, we will fine-tune "
#~ "a pre-trained Transformer model "
#~ "(distilBERT) for sequence classification over"
#~ " a dataset of IMDB ratings. The "
#~ "end goal is to detect if a "
#~ "movie rating is positive or negative."
#~ msgstr ""

#~ msgid "Dependencies"
#~ msgstr ""

#~ msgid ""
#~ "To follow along this tutorial you "
#~ "will need to install the following "
#~ "packages: :code:`datasets`, :code:`evaluate`, "
#~ ":code:`flwr`, :code:`torch`, and "
#~ ":code:`transformers`. This can be done "
#~ "using :code:`pip`:"
#~ msgstr ""

#~ msgid "Standard Hugging Face workflow"
#~ msgstr ""

#~ msgid "Handling the data"
#~ msgstr ""

#~ msgid ""
#~ "To fetch the IMDB dataset, we will"
#~ " use Hugging Face's :code:`datasets` "
#~ "library. We then need to tokenize "
#~ "the data and create :code:`PyTorch` "
#~ "dataloaders, this is all done in "
#~ "the :code:`load_data` function:"
#~ msgstr ""

#~ msgid "Training and testing the model"
#~ msgstr ""

#~ msgid ""
#~ "Once we have a way of creating "
#~ "our trainloader and testloader, we can"
#~ " take care of the training and "
#~ "testing. This is very similar to "
#~ "any :code:`PyTorch` training or testing "
#~ "loop:"
#~ msgstr ""

#~ msgid "Creating the model itself"
#~ msgstr ""

#~ msgid ""
#~ "To create the model itself, we "
#~ "will just load the pre-trained "
#~ "distillBERT model using Hugging Face’s "
#~ ":code:`AutoModelForSequenceClassification` :"
#~ msgstr ""

#~ msgid "Federating the example"
#~ msgstr ""

#~ msgid "Creating the IMDBClient"
#~ msgstr ""

#~ msgid ""
#~ "To federate our example to multiple "
#~ "clients, we first need to write "
#~ "our Flower client class (inheriting from"
#~ " :code:`flwr.client.NumPyClient`). This is very"
#~ " easy, as our model is a "
#~ "standard :code:`PyTorch` model:"
#~ msgstr ""

#~ msgid ""
#~ "The :code:`get_parameters` function lets the"
#~ " server get the client's parameters. "
#~ "Inversely, the :code:`set_parameters` function "
#~ "allows the server to send its "
#~ "parameters to the client. Finally, the"
#~ " :code:`fit` function trains the model "
#~ "locally for the client, and the "
#~ ":code:`evaluate` function tests the model "
#~ "locally and returns the relevant "
#~ "metrics."
#~ msgstr ""

#~ msgid "Starting the server"
#~ msgstr ""

#~ msgid ""
#~ "Now that we have a way to "
#~ "instantiate clients, we need to create"
#~ " our server in order to aggregate "
#~ "the results. Using Flower, this can "
#~ "be done very easily by first "
#~ "choosing a strategy (here, we are "
#~ "using :code:`FedAvg`, which will define "
#~ "the global weights as the average "
#~ "of all the clients' weights at "
#~ "each round) and then using the "
#~ ":code:`flwr.server.start_server` function:"
#~ msgstr ""

#~ msgid ""
#~ "The :code:`weighted_average` function is there"
#~ " to provide a way to aggregate "
#~ "the metrics distributed amongst the "
#~ "clients (basically this allows us to "
#~ "display a nice average accuracy and "
#~ "loss for every round)."
#~ msgstr ""

#~ msgid "Putting everything together"
#~ msgstr ""

#~ msgid "We can now start client instances using:"
#~ msgstr ""

#~ msgid ""
#~ "And they will be able to connect"
#~ " to the server and start the "
#~ "federated training."
#~ msgstr ""

#~ msgid ""
#~ "If you want to check out "
#~ "everything put together, you should "
#~ "check out the `full code example "
#~ "<https://github.com/adap/flower/tree/main/examples/quickstart-"
#~ "huggingface>`_ ."
#~ msgstr ""

#~ msgid ""
#~ "Of course, this is a very basic"
#~ " example, and a lot can be "
#~ "added or modified, it was just to"
#~ " showcase how simply we could "
#~ "federate a Hugging Face workflow using"
#~ " Flower."
#~ msgstr ""

#~ msgid ""
#~ "Note that in this example we used"
#~ " :code:`PyTorch`, but we could have "
#~ "very well used :code:`TensorFlow`."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with PyTorch Lightning to train an "
#~ "Auto Encoder model on MNIST."
#~ msgstr ""

#~ msgid ""
#~ "Let's build a horizontal federated "
#~ "learning system using PyTorch Lightning "
#~ "and Flower!"
#~ msgstr ""

#~ msgid ""
#~ "Please refer to the `full code "
#~ "example <https://github.com/adap/flower/tree/main/examples"
#~ "/quickstart-pytorch-lightning>`_ to learn "
#~ "more."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with TensorFlow to train a MobilNetV2"
#~ " model on CIFAR-10."
#~ msgstr ""

#~ msgid "Let's build a federated learning system in less than 20 lines of code!"
#~ msgstr ""

#~ msgid "Before Flower can be imported we have to install it:"
#~ msgstr ""

#~ msgid ""
#~ "Since we want to use the Keras "
#~ "API of TensorFlow (TF), we have to"
#~ " install TF as well:"
#~ msgstr ""

#~ msgid "Next, in a file called :code:`client.py`, import Flower and TensorFlow:"
#~ msgstr ""

#~ msgid ""
#~ "We use the Keras utilities of TF"
#~ " to load CIFAR10, a popular colored"
#~ " image classification dataset for machine"
#~ " learning. The call to "
#~ ":code:`tf.keras.datasets.cifar10.load_data()` downloads "
#~ "CIFAR10, caches it locally, and then "
#~ "returns the entire training and test "
#~ "set as NumPy ndarrays."
#~ msgstr ""

#~ msgid ""
#~ "Next, we need a model. For the "
#~ "purpose of this tutorial, we use "
#~ "MobilNetV2 with 10 output classes:"
#~ msgstr ""

#~ msgid ""
#~ "The Flower server interacts with clients"
#~ " through an interface called "
#~ ":code:`Client`. When the server selects "
#~ "a particular client for training, it "
#~ "sends training instructions over the "
#~ "network. The client receives those "
#~ "instructions and calls one of the "
#~ ":code:`Client` methods to run your code"
#~ " (i.e., to train the neural network"
#~ " we defined earlier)."
#~ msgstr ""

#~ msgid ""
#~ "Flower provides a convenience class "
#~ "called :code:`NumPyClient` which makes it "
#~ "easier to implement the :code:`Client` "
#~ "interface when your workload uses Keras."
#~ " The :code:`NumPyClient` interface defines "
#~ "three methods which can be implemented"
#~ " in the following way:"
#~ msgstr ""

#~ msgid ""
#~ "We can now create an instance of"
#~ " our class :code:`CifarClient` and add "
#~ "one line to actually run this "
#~ "client:"
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement :code:`Client` or "
#~ ":code:`NumPyClient` and call "
#~ ":code:`fl.client.start_client()`. If you implement"
#~ " a client of type :code:`NumPyClient` "
#~ "you'll need to first call its "
#~ ":code:`to_client()` method. The string "
#~ ":code:`\"[::]:8080\"` tells the client which"
#~ " server to connect to. In our "
#~ "case we can run the server and "
#~ "the client on the same machine, "
#~ "therefore we use :code:`\"[::]:8080\"`. If "
#~ "we run a truly federated workload "
#~ "with the server and clients running "
#~ "on different machines, all that needs"
#~ " to change is the :code:`server_address`"
#~ " we point the client at."
#~ msgstr ""

#~ msgid "Each client will have its own dataset."
#~ msgstr ""

#~ msgid ""
#~ "You should now see how the "
#~ "training does in the very first "
#~ "terminal (the one that started the "
#~ "server):"
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated learning "
#~ "system. The full `source code "
#~ "<https://github.com/adap/flower/blob/main/examples/quickstart-"
#~ "tensorflow/client.py>`_ for this can be "
#~ "found in :code:`examples/quickstart-"
#~ "tensorflow/client.py`."
#~ msgstr ""

#~ msgid "|e5918c1c06a4434bbe4bf49235e40059|"
#~ msgstr ""

#~ msgid "|c0165741bd1944f09ec55ce49032377d|"
#~ msgstr ""

#~ msgid "|0a0ac9427ac7487b8e52d75ed514f04e|"
#~ msgstr ""

#~ msgid "|5defee3ea4ca40d99fcd3e4ea045be25|"
#~ msgstr ""

#~ msgid "|74f26ca701254d3db57d7899bd91eb55|"
#~ msgstr ""

#~ msgid "|bda79f21f8154258a40e5766b2634ad7|"
#~ msgstr ""

#~ msgid "|89d30862e62e4f9989e193483a08680a|"
#~ msgstr ""

#~ msgid "|77e9918671c54b4f86e01369c0785ce8|"
#~ msgstr ""

#~ msgid "|7e4ccef37cc94148a067107b34eb7447|"
#~ msgstr ""

#~ msgid "|28e47e4cded14479a0846c8e5f22c872|"
#~ msgstr ""

#~ msgid "|4b8c5d1afa144294b76ffc76e4658a38|"
#~ msgstr ""

#~ msgid "|9dbdb3a0f6cb4a129fac863eaa414c17|"
#~ msgstr ""

#~ msgid "|81749d0ac0834c36a83bd38f433fea31|"
#~ msgstr ""

#~ msgid "|ed9aae51da70428eab7eef32f21e819e|"
#~ msgstr ""

#~ msgid "|e87b69b2ada74ea49412df16f4a0b9cc|"
#~ msgstr ""

#~ msgid "|33cacb7d985c4906b348515c1a5cd993|"
#~ msgstr ""

#~ msgid "|cc080a555947492fa66131dc3a967603|"
#~ msgstr ""

#~ msgid "|085c3e0fb8664c6aa06246636524b20b|"
#~ msgstr ""

#~ msgid "|bfe69c74e48c45d49b50251c38c2a019|"
#~ msgstr ""

#~ msgid "|ebbecd651f0348d99c6511ea859bf4ca|"
#~ msgstr ""

#~ msgid "|163117eb654a4273babba413cf8065f5|"
#~ msgstr ""

#~ msgid "|452ac3ba453b4cd1be27be1ba7560d64|"
#~ msgstr ""

#~ msgid "|f403fcd69e4e44409627e748b404c086|"
#~ msgstr ""

#~ msgid "|4b00fe63870145968f8443619a792a42|"
#~ msgstr ""

#~ msgid "|368378731066486fa4397e89bc6b870c|"
#~ msgstr ""

#~ msgid "|a66aa83d85bf4ffba7ed660b718066da|"
#~ msgstr ""

#~ msgid "|82324b9af72a4582a81839d55caab767|"
#~ msgstr ""

#~ msgid "|fbf2da0da3cc4f8ab3b3eff852d80c41|"
#~ msgstr ""

#~ msgid ""
#~ "Some quickstart examples may have "
#~ "limitations or requirements that prevent "
#~ "them from running on every environment."
#~ " For more information, please see "
#~ "`Limitations`_."
#~ msgstr ""

#~ msgid ""
#~ "Change the application code. For "
#~ "example, change the  ``seed`` in "
#~ "``quickstart_docker/task.py`` to ``43`` and "
#~ "save it:"
#~ msgstr ""

#~ msgid ":code:`fit`"
#~ msgstr ":code:`fit`"

#~ msgid ""
#~ "Note that since version :code:`1.11.0`, "
#~ ":code:`flower-server-app` no longer "
#~ "supports passing a reference to a "
#~ "`ServerApp` attribute. Instead, you need "
#~ "to pass the path to Flower app "
#~ "via the argument :code:`--app`. This is"
#~ " the path to a directory containing"
#~ " a `pyproject.toml`. You can create a"
#~ " valid Flower app by executing "
#~ ":code:`flwr new` and following the "
#~ "prompt."
#~ msgstr ""

#~ msgid ""
#~ "The following examples are available as"
#~ " standalone projects. Quickstart TensorFlow/Keras"
#~ " ---------------------------"
#~ msgstr ""

#~ msgid ""
#~ "Let's create a new application project"
#~ " in Xcode and add :code:`flwr` as "
#~ "a dependency in your project. For "
#~ "our application, we will store the "
#~ "logic of our app in "
#~ ":code:`FLiOSModel.swift` and the UI elements"
#~ " in :code:`ContentView.swift`. We will "
#~ "focus more on :code:`FLiOSModel.swift` in "
#~ "this quickstart. Please refer to the "
#~ "`full code example "
#~ "<https://github.com/adap/flower/tree/main/examples/ios>`_ to "
#~ "learn more about the app."
#~ msgstr ""

#~ msgid "Import Flower and CoreML related packages in :code:`FLiOSModel.swift`:"
#~ msgstr ""

#~ msgid ""
#~ "Then add the mlmodel to the "
#~ "project simply by drag-and-drop, "
#~ "the mlmodel will be bundled inside "
#~ "the application during deployment to "
#~ "your iOS device. We need to pass"
#~ " the url to access mlmodel and "
#~ "run CoreML machine learning processes, "
#~ "it can be retrieved by calling the"
#~ " function :code:`Bundle.main.url`. For the "
#~ "MNIST dataset, we need to preprocess "
#~ "it into :code:`MLBatchProvider` object. The"
#~ " preprocessing is done inside "
#~ ":code:`DataLoader.swift`."
#~ msgstr ""

#~ msgid ""
#~ "Since CoreML does not allow the "
#~ "model parameters to be seen before "
#~ "training, and accessing the model "
#~ "parameters during or after the training"
#~ " can only be done by specifying "
#~ "the layer name, we need to know"
#~ " this information beforehand, through "
#~ "looking at the model specification, "
#~ "which are written as proto files. "
#~ "The implementation can be seen in "
#~ ":code:`MLModelInspect`."
#~ msgstr ""

#~ msgid ""
#~ "Then start the Flower gRPC client "
#~ "and start communicating to the server"
#~ " by passing our Flower client to "
#~ "the function :code:`startFlwrGRPC`."
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement :code:`Client` or "
#~ "call the provided :code:`MLFlwrClient` and "
#~ "call :code:`startFlwrGRPC()`. The attribute "
#~ ":code:`hostname` and :code:`port` tells the"
#~ " client which server to connect to."
#~ " This can be done by entering "
#~ "the hostname and port in the "
#~ "application before clicking the start "
#~ "button to start the federated learning"
#~ " process."
#~ msgstr ""

#~ msgid ""
#~ "For simple workloads we can start "
#~ "a Flower server and leave all the"
#~ " configuration possibilities at their "
#~ "default values. In a file named "
#~ ":code:`server.py`, import Flower and start "
#~ "the server:"
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated learning "
#~ "system in your ios device. The "
#~ "full `source code "
#~ "<https://github.com/adap/flower/blob/main/examples/ios>`_ for"
#~ " this example can be found in "
#~ ":code:`examples/ios`."
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial, we will learn "
#~ "how to train a :code:`Logistic "
#~ "Regression` model on MNIST using Flower"
#~ " and scikit-learn."
#~ msgstr ""

#~ msgid ""
#~ "Now that we have all our "
#~ "dependencies installed, let's run a "
#~ "simple distributed training with two "
#~ "clients and one server. However, before"
#~ " setting up the client and server,"
#~ " we will define all functionalities "
#~ "that we need for our federated "
#~ "learning setup within :code:`utils.py`. The"
#~ " :code:`utils.py` contains different functions"
#~ " defining all the machine learning "
#~ "basics:"
#~ msgstr ""

#~ msgid ":code:`get_model_parameters()`"
#~ msgstr ""

#~ msgid "Returns the parameters of a :code:`sklearn` LogisticRegression model"
#~ msgstr ""

#~ msgid ":code:`set_model_params()`"
#~ msgstr ""

#~ msgid "Sets the parameters of a :code:`sklearn` LogisticRegression model"
#~ msgstr ""

#~ msgid ":code:`set_initial_params()`"
#~ msgstr ""

#~ msgid ""
#~ "Please check out :code:`utils.py` `here "
#~ "<https://github.com/adap/flower/blob/main/examples/sklearn-"
#~ "logreg-mnist/utils.py>`_ for more details. "
#~ "The pre-defined functions are used "
#~ "in the :code:`client.py` and imported. "
#~ "The :code:`client.py` also requires to "
#~ "import several packages such as Flower"
#~ " and scikit-learn:"
#~ msgstr ""

#~ msgid ""
#~ "Prior to local training, we need "
#~ "to load the MNIST dataset, a "
#~ "popular image classification dataset of "
#~ "handwritten digits for machine learning, "
#~ "and partition the dataset for FL. "
#~ "This can be conveniently achieved using"
#~ " `Flower Datasets <https://flower.ai/docs/datasets>`_."
#~ " The :code:`FederatedDataset.load_partition()` method"
#~ " loads the partitioned training set "
#~ "for each partition ID defined in "
#~ "the :code:`--partition-id` argument."
#~ msgstr ""

#~ msgid ""
#~ "Next, the logistic regression model is"
#~ " defined and initialized with "
#~ ":code:`utils.set_initial_params()`."
#~ msgstr ""

#~ msgid ""
#~ "The Flower server interacts with clients"
#~ " through an interface called "
#~ ":code:`Client`. When the server selects "
#~ "a particular client for training, it "
#~ "sends training instructions over the "
#~ "network. The client receives those "
#~ "instructions and calls one of the "
#~ ":code:`Client` methods to run your code"
#~ " (i.e., to fit the logistic "
#~ "regression we defined earlier)."
#~ msgstr ""

#~ msgid ""
#~ "Flower provides a convenience class "
#~ "called :code:`NumPyClient` which makes it "
#~ "easier to implement the :code:`Client` "
#~ "interface when your workload uses "
#~ "scikit-learn. Implementing :code:`NumPyClient` "
#~ "usually means defining the following "
#~ "methods (:code:`set_parameters` is optional "
#~ "though):"
#~ msgstr ""

#~ msgid ":code:`set_parameters` (optional)"
#~ msgstr ""

#~ msgid "is directly imported with :code:`utils.set_model_params()`"
#~ msgstr ""

#~ msgid ""
#~ "We can now create an instance of"
#~ " our class :code:`MnistClient` and add "
#~ "one line to actually run this "
#~ "client:"
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement :code:`Client` or "
#~ ":code:`NumPyClient` and call "
#~ ":code:`fl.client.start_client()`. If you implement"
#~ " a client of type :code:`NumPyClient` "
#~ "you'll need to first call its "
#~ ":code:`to_client()` method. The string "
#~ ":code:`\"0.0.0.0:8080\"` tells the client "
#~ "which server to connect to. In our"
#~ " case we can run the server and"
#~ " the client on the same machine, "
#~ "therefore we use :code:`\"0.0.0.0:8080\"`. If"
#~ " we run a truly federated workload"
#~ " with the server and clients running"
#~ " on different machines, all that "
#~ "needs to change is the "
#~ ":code:`server_address` we pass to the "
#~ "client."
#~ msgstr ""

#~ msgid ":code:`server.py`, import Flower and start the server:"
#~ msgstr ""

#~ msgid ""
#~ "The number of federated learning rounds"
#~ " is set in :code:`fit_round()` and "
#~ "the evaluation is defined in "
#~ ":code:`get_evaluate_fn()`. The evaluation function"
#~ " is called after each federated "
#~ "learning round and gives you information"
#~ " about loss and accuracy. Note that"
#~ " we also make use of Flower "
#~ "Datasets here to load the test "
#~ "split of the MNIST dataset for "
#~ "server-side evaluation."
#~ msgstr ""

#~ msgid ""
#~ "The :code:`main` contains the server-"
#~ "side parameter initialization "
#~ ":code:`utils.set_initial_params()` as well as "
#~ "the aggregation strategy "
#~ ":code:`fl.server.strategy:FedAvg()`. The strategy is"
#~ " the default one, federated averaging "
#~ "(or FedAvg), with two clients and "
#~ "evaluation after each federated learning "
#~ "round. The server can be started "
#~ "with the command "
#~ ":code:`fl.server.start_server(server_address=\"0.0.0.0:8080\", "
#~ "strategy=strategy, "
#~ "config=fl.server.ServerConfig(num_rounds=3))`."
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated learning "
#~ "system. The full `source code "
#~ "<https://github.com/adap/flower/tree/main/examples/sklearn-"
#~ "logreg-mnist>`_ for this example can "
#~ "be found in :code:`examples/sklearn-logreg-"
#~ "mnist`."
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial we will learn how"
#~ " to train a federated XGBoost model"
#~ " on HIGGS dataset using Flower and"
#~ " :code:`xgboost` package. We use a "
#~ "simple example (`full code xgboost-"
#~ "quickstart <https://github.com/adap/flower/tree/main/examples"
#~ "/xgboost-quickstart>`_) with two *clients* "
#~ "and one *server* to demonstrate how "
#~ "federated XGBoost works, and then we "
#~ "dive into a more complex example "
#~ "(`full code xgboost-comprehensive "
#~ "<https://github.com/adap/flower/tree/main/examples/xgboost-"
#~ "comprehensive>`_) to run various experiments."
#~ msgstr ""

#~ msgid ""
#~ "Since we want to use :code:`xgboost` "
#~ "package to build up XGBoost trees, "
#~ "let's go ahead and install "
#~ ":code:`xgboost`:"
#~ msgstr ""

#~ msgid ""
#~ "In a file called :code:`client.py`, "
#~ "import xgboost, Flower, Flower Datasets "
#~ "and other related functions:"
#~ msgstr ""

#~ msgid ""
#~ "In this example, we split the "
#~ "dataset into 30 partitions with uniform"
#~ " distribution (:code:`IidPartitioner(num_partitions=30)`)."
#~ " Then, we load the partition for "
#~ "the given client based on "
#~ ":code:`partition_id`:"
#~ msgstr ""

#~ msgid ""
#~ "After that, we do train/test splitting"
#~ " on the given partition (client's "
#~ "local data), and transform data format"
#~ " for :code:`xgboost` package."
#~ msgstr ""

#~ msgid ""
#~ "The functions of :code:`train_test_split` and"
#~ " :code:`transform_dataset_to_dmatrix` are defined "
#~ "as below:"
#~ msgstr ""

#~ msgid ""
#~ "The :code:`num_local_round` represents the "
#~ "number of iterations for local tree "
#~ "boost. We use CPU for the training"
#~ " in default. One can shift it "
#~ "to GPU by setting :code:`tree_method` to"
#~ " :code:`gpu_hist`. We use AUC as "
#~ "evaluation metric."
#~ msgstr ""

#~ msgid ""
#~ "After loading the dataset we define "
#~ "the Flower client. We follow the "
#~ "general rule to define :code:`XgbClient` "
#~ "class inherited from :code:`fl.client.Client`."
#~ msgstr ""

#~ msgid ""
#~ "All required parameters defined above "
#~ "are passed to :code:`XgbClient`'s constructor."
#~ msgstr ""

#~ msgid ""
#~ "Then, we override :code:`get_parameters`, "
#~ ":code:`fit` and :code:`evaluate` methods "
#~ "insides :code:`XgbClient` class as follows."
#~ msgstr ""

#~ msgid ""
#~ "Unlike neural network training, XGBoost "
#~ "trees are not started from a "
#~ "specified random weights. In this case,"
#~ " we do not use :code:`get_parameters` "
#~ "and :code:`set_parameters` to initialise model"
#~ " parameters for XGBoost. As a result,"
#~ " let's return an empty tensor in "
#~ ":code:`get_parameters` when it is called "
#~ "by the server at the first round."
#~ msgstr ""

#~ msgid ""
#~ "In :code:`fit`, at the first round, "
#~ "we call :code:`xgb.train()` to build up"
#~ " the first set of trees. From "
#~ "the second round, we load the "
#~ "global model sent from server to "
#~ "new build Booster object, and then "
#~ "update model weights on local training"
#~ " data with function :code:`local_boost` as"
#~ " follows:"
#~ msgstr ""

#~ msgid ""
#~ "Given :code:`num_local_round`, we update trees"
#~ " by calling :code:`bst_input.update` method. "
#~ "After training, the last "
#~ ":code:`N=num_local_round` trees will be "
#~ "extracted to send to the server."
#~ msgstr ""

#~ msgid ""
#~ "In :code:`evaluate`, after loading the "
#~ "global model, we call :code:`bst.eval_set` "
#~ "function to conduct evaluation on valid"
#~ " set. The AUC value will be "
#~ "returned."
#~ msgstr ""

#~ msgid ""
#~ "Now, we can create an instance of"
#~ " our class :code:`XgbClient` and add "
#~ "one line to actually run this "
#~ "client:"
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement :code:`Client` and "
#~ "call :code:`fl.client.start_client()`. The string"
#~ " :code:`\"[::]:8080\"` tells the client "
#~ "which server to connect to. In our"
#~ " case we can run the server and"
#~ " the client on the same machine, "
#~ "therefore we use :code:`\"[::]:8080\"`. If "
#~ "we run a truly federated workload "
#~ "with the server and clients running "
#~ "on different machines, all that needs"
#~ " to change is the :code:`server_address`"
#~ " we point the client at."
#~ msgstr ""

#~ msgid ""
#~ "In a file named :code:`server.py`, "
#~ "import Flower and FedXgbBagging from "
#~ ":code:`flwr.server.strategy`."
#~ msgstr ""

#~ msgid ""
#~ "We use two clients for this "
#~ "example. An :code:`evaluate_metrics_aggregation` "
#~ "function is defined to collect and "
#~ "wighted average the AUC values from "
#~ "clients. The :code:`config_func` function is"
#~ " to return the current FL round "
#~ "number to client's :code:`fit()` and "
#~ ":code:`evaluate()` methods."
#~ msgstr ""

#~ msgid ""
#~ "In file :code:`flwr.server.strategy.fedxgb_bagging.py`,"
#~ " we define :code:`FedXgbBagging` inherited "
#~ "from :code:`flwr.server.strategy.FedAvg`. Then, we"
#~ " override the :code:`aggregate_fit`, "
#~ ":code:`aggregate_evaluate` and :code:`evaluate` "
#~ "methods as follows:"
#~ msgstr ""

#~ msgid ""
#~ "In :code:`aggregate_fit`, we sequentially "
#~ "aggregate the clients' XGBoost trees by"
#~ " calling :code:`aggregate()` function:"
#~ msgstr ""

#~ msgid ""
#~ "In this function, we first fetch "
#~ "the number of trees and the number"
#~ " of parallel trees for the current"
#~ " and previous model by calling "
#~ ":code:`_get_tree_nums`. Then, the fetched "
#~ "information will be aggregated. After "
#~ "that, the trees (containing model "
#~ "weights) are aggregated to generate a"
#~ " new tree model."
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated XGBoost "
#~ "system. The AUC values can be "
#~ "checked in :code:`metrics_distributed`. One "
#~ "can see that the average AUC "
#~ "increases over FL rounds."
#~ msgstr ""

#~ msgid ""
#~ "The full `source code "
#~ "<https://github.com/adap/flower/blob/main/examples/xgboost-"
#~ "quickstart/>`_ for this example can be"
#~ " found in :code:`examples/xgboost-quickstart`."
#~ msgstr ""

#~ msgid ""
#~ "To do this, we first customise a"
#~ " :code:`ClientManager` in :code:`server_utils.py`:"
#~ msgstr ""

#~ msgid ""
#~ "The customised :code:`ClientManager` samples "
#~ "all available clients in each FL "
#~ "round based on the order of "
#~ "connection to the server. Then, we "
#~ "define a new strategy :code:`FedXgbCyclic` "
#~ "in :code:`flwr.server.strategy.fedxgb_cyclic.py`, in "
#~ "order to sequentially select only one"
#~ " client in given round and pass "
#~ "the received model to next client."
#~ msgstr ""

#~ msgid ""
#~ "Unlike the original :code:`FedAvg`, we "
#~ "don't perform aggregation here. Instead, "
#~ "we just make a copy of the "
#~ "received client model as global model"
#~ " by overriding :code:`aggregate_fit`."
#~ msgstr ""

#~ msgid ""
#~ "Also, the customised :code:`configure_fit` and"
#~ " :code:`configure_evaluate` methods ensure the"
#~ " clients to be sequentially selected "
#~ "given FL round:"
#~ msgstr ""

#~ msgid ""
#~ "In :code:`dataset.py`, we have a "
#~ "function :code:`instantiate_partitioner` to "
#~ "instantiate the data partitioner based "
#~ "on the given :code:`num_partitions` and "
#~ ":code:`partitioner_type`. Currently, we provide "
#~ "four supported partitioner type to "
#~ "simulate the uniformity/non-uniformity in "
#~ "data quantity (uniform, linear, square, "
#~ "exponential)."
#~ msgstr ""

#~ msgid ""
#~ "To facilitate centralised evaluation, we "
#~ "define a function in :code:`server_utils.py`:"
#~ msgstr ""

#~ msgid ""
#~ "This function returns a evaluation "
#~ "function which instantiates a :code:`Booster`"
#~ " object and loads the global model"
#~ " weights to it. The evaluation is "
#~ "conducted by calling :code:`eval_set()` "
#~ "method, and the tested AUC value "
#~ "is reported."
#~ msgstr ""

#~ msgid ""
#~ "As for distributed evaluation on the "
#~ "clients, it's same as the quick-"
#~ "start example by overriding the "
#~ ":code:`evaluate()` method insides the "
#~ ":code:`XgbClient` class in :code:`client_utils.py`."
#~ msgstr ""

#~ msgid ""
#~ "We also provide an example code "
#~ "(:code:`sim.py`) to use the simulation "
#~ "capabilities of Flower to simulate "
#~ "federated XGBoost training on either a"
#~ " single machine or a cluster of "
#~ "machines."
#~ msgstr ""

#~ msgid ""
#~ "After importing all required packages, "
#~ "we define a :code:`main()` function to"
#~ " perform the simulation process:"
#~ msgstr ""

#~ msgid ""
#~ "We first load the dataset and "
#~ "perform data partitioning, and the "
#~ "pre-processed data is stored in a "
#~ ":code:`list`. After the simulation begins, "
#~ "the clients won't need to pre-"
#~ "process their partitions again."
#~ msgstr ""

#~ msgid ""
#~ "After that, we start the simulation "
#~ "by calling :code:`fl.simulation.start_simulation`:"
#~ msgstr ""

#~ msgid ""
#~ "One of key parameters for "
#~ ":code:`start_simulation` is :code:`client_fn` which"
#~ " returns a function to construct a"
#~ " client. We define it as follows:"
#~ msgstr ""

#~ msgid ""
#~ "In :code:`utils.py`, we define the "
#~ "arguments parsers for clients, server "
#~ "and simulation, allowing users to "
#~ "specify different experimental settings. Let's"
#~ " first see the sever side:"
#~ msgstr ""

#~ msgid ""
#~ "This allows user to specify training "
#~ "strategies / the number of total "
#~ "clients / FL rounds / participating "
#~ "clients / clients for evaluation, and"
#~ " evaluation fashion. Note that with "
#~ ":code:`--centralised-eval`, the sever will "
#~ "do centralised evaluation and all "
#~ "functionalities for client evaluation will "
#~ "be disabled."
#~ msgstr ""

#~ msgid ""
#~ "This defines various options for client"
#~ " data partitioning. Besides, clients also"
#~ " have an option to conduct evaluation"
#~ " on centralised test set by setting"
#~ " :code:`--centralised-eval`, as well as "
#~ "an option to perform scaled learning "
#~ "rate based on the number of "
#~ "clients by setting :code:`--scaled-lr`."
#~ msgstr ""

#~ msgid ""
#~ "The full `code "
#~ "<https://github.com/adap/flower/blob/main/examples/xgboost-"
#~ "comprehensive/>`_ for this comprehensive "
#~ "example can be found in :code:`examples"
#~ "/xgboost-comprehensive`."
#~ msgstr ""

#~ msgid "|b8714c45b74b4d8fb008e2ebb3bc1d44|"
#~ msgstr ""

#~ msgid "|75f1561efcfd422ea67d28d1513120dc|"
#~ msgstr ""

#~ msgid "|6a1f51b235304558a9bdaaabfc93b8d2|"
#~ msgstr ""

#~ msgid "|35e70dab1fb544af9aa3a9c09c4f9797|"
#~ msgstr ""

#~ msgid "|d7efb5705dd3467f991ed23746824a07|"
#~ msgstr ""

#~ msgid "|94e7b021c7b540bfbedf7f082a41ff87|"
#~ msgstr ""

#~ msgid "|a80714782dde439ab73936518f91fc3c|"
#~ msgstr ""

#~ msgid "|c62080ca6197473da57d191c8225a9d9|"
#~ msgstr ""

#~ msgid "|21a8f1e6a5b14a7bbb8559979d0e8a2b|"
#~ msgstr ""

#~ msgid "|c310f2a22f7b4917bf42775aae7a1c09|"
#~ msgstr ""

#~ msgid "|a0c5b43401194535a8460bcf02e65f9a|"
#~ msgstr ""

#~ msgid "|aabfdbd5564e41a790f8ea93cc21a444|"
#~ msgstr ""

#~ msgid "|c9cc8f160fa647b09e742fe4dc8edb54|"
#~ msgstr ""

#~ msgid "|7e83aad011cd4907b2f02f907c6922e9|"
#~ msgstr ""

#~ msgid "|4627c2bb6cc443ae9e079f81f33c9dd9|"
#~ msgstr ""

#~ msgid "|131af8322dc5466b827afd24be98f8c0|"
#~ msgstr ""

#~ msgid "|f92920b87f3a40179bf7ddd0b6144c53|"
#~ msgstr ""

#~ msgid "|d62da263071d45a496f543e41fce3a19|"
#~ msgstr ""

#~ msgid "|ad851971645b4e1fbf8d15bcc0b2ee11|"
#~ msgstr ""

#~ msgid "|929e9a6de6b34edb8488e644e2bb5221|"
#~ msgstr ""

#~ msgid "|404cf9c9e8d64784a55646c0f9479cbc|"
#~ msgstr ""

#~ msgid "|b021ff9d25814458b1e631f8985a648b|"
#~ msgstr ""

#~ msgid "|e6ca84e1df244f238288a768352678e5|"
#~ msgstr ""

#~ msgid "|39c2422082554a21963baffb33a0d057|"
#~ msgstr ""

#~ msgid "|07ecf5fcd6814e88906accec6fa0fbfb|"
#~ msgstr ""

#~ msgid "|57e78c0ca8a94ba5a64a04b1f2280e55|"
#~ msgstr ""

#~ msgid "|9819b40e59ee40a4921e1244e8c99bac|"
#~ msgstr ""

#~ msgid "|797bf279c4894b5ead31dc9b0534ed62|"
#~ msgstr ""

#~ msgid "|3a7aceef05f0421794726ac54aaf12fd|"
#~ msgstr ""

#~ msgid "|d741075f8e624331b42c0746f7d258a0|"
#~ msgstr ""

#~ msgid "|8fc92d668bcb42b8bda55143847f2329|"
#~ msgstr ""

#~ msgid "|1c705d833a024f22adcaeb8ae3d13b0b|"
#~ msgstr ""

#~ msgid "|77a037b546a84262b608e04bc82a2c96|"
#~ msgstr ""

#~ msgid "|f568e24c9fb0435690ac628210a4be96|"
#~ msgstr ""

#~ msgid "|a7bf029981514e2593aa3a2b48c9d76a|"
#~ msgstr ""

#~ msgid "|3f645ad807f84be8b1f8f3267173939c|"
#~ msgstr ""

#~ msgid "|a06a9dbd603f45819afd8e8cfc3c4b8f|"
#~ msgstr ""

#~ msgid "|edcf9a04d96e42608fd01a333375febe|"
#~ msgstr ""

#~ msgid "|3dae22fe797043968e2b7aa7073c78bd|"
#~ msgstr ""

#~ msgid "|ba178f75267d4ad8aa7363f20709195f|"
#~ msgstr ""

#~ msgid "|c380c750bfd2444abce039a1c6fa8e60|"
#~ msgstr ""

#~ msgid "|e7cec00a114b48359935c6510595132e|"
#~ msgstr ""

#~ msgid ""
#~ "Include SecAgg, SecAgg+, and LightSecAgg "
#~ "protocol. The LightSecAgg protocol has "
#~ "not been implemented yet, so its "
#~ "diagram and abstraction may not be "
#~ "accurate in practice. The SecAgg "
#~ "protocol can be considered as a "
#~ "special case of the SecAgg+ protocol."
#~ msgstr ""
#~ "SecAgg, SecAgg+, LightSecAgg 프로토콜을 포함합니다. "
#~ "LightSecAgg 프로토콜은 아직 구현되지 않았기 때문에 "
#~ "다이어그램과 추상화가 실제로는 정확하지 않을 수 있습니다."
#~ " SecAgg 프로토콜은 SecAgg+ 프로토콜의 특수한 경우로"
#~ " 간주할 수 있습니다."

#~ msgid "The ``SecAgg+`` abstraction"
#~ msgstr "The :code:`SecAgg+` 추상화"

#~ msgid ""
#~ "In this implementation, each client will"
#~ " be assigned with a unique index "
#~ "(int) for secure aggregation, and thus"
#~ " many python dictionaries used have "
#~ "keys of int type rather than "
#~ "ClientProxy type."
#~ msgstr ""
#~ "구현에서는 각 클라이언트에 secure aggregation를 위한"
#~ " 고유 인덱스(int)가 할당되므로 사용되는 많은 파이썬 "
#~ "dictionaries에는 ClientProxy 타입이 아닌 int "
#~ "타입의 키가 있습니다."

#~ msgid ""
#~ "The Flower server will execute and "
#~ "process received results in the "
#~ "following order:"
#~ msgstr "Flower 서버는 수신된 결과를 다음 순서로 실행하고 처리합니다:"

#~ msgid "The ``LightSecAgg`` abstraction"
#~ msgstr "The :code:`LightSecAgg` 추상"

#~ msgid "Types"
#~ msgstr "타입"

#~ msgid ""
#~ "Docker Compose is `installed "
#~ "<https://docs.docker.com/compose/install/>`_."
#~ msgstr ""

#~ msgid "Run the example:"
#~ msgstr "전체 코드 예제"

#~ msgid "Follow the logs of the SuperExec service:"
#~ msgstr ""

#~ msgid "Only runs on AMD64."
#~ msgstr ""

#~ msgid ""
#~ "Use the method that works best for"
#~ " you to copy the ``server`` "
#~ "directory, the certificates, and your "
#~ "Flower project to the remote machine."
#~ msgstr ""

#~ msgid ""
#~ "The Path of the ``PROJECT_DIR`` should"
#~ " be relative to the location of "
#~ "the ``server`` Docker Compose files."
#~ msgstr ""

#~ msgid ""
#~ "The Path of the ``PROJECT_DIR`` should"
#~ " be relative to the location of "
#~ "the ``client`` Docker Compose files."
#~ msgstr ""

#~ msgid ""
#~ "The Path of the ``root-certificates``"
#~ " should be relative to the location"
#~ " of the ``pyproject.toml`` file."
#~ msgstr ""

#~ msgid "To run the project, execute:"
#~ msgstr ""

#~ msgid "Run the ``quickstart-docker`` project by executing the command:"
#~ msgstr ""

#~ msgid "Follow the SuperExec logs to track the execution of the run:"
#~ msgstr ""

#~ msgid "Execute the command to run the quickstart example:"
#~ msgstr ""

#~ msgid "Monitor the SuperExec logs and wait for the summary to appear:"
#~ msgstr ""

#~ msgid "Example: FedBN in PyTorch - From Centralized To Federated"
#~ msgstr "예시: PyTorch에서 FedBN - 중앙 집중식에서 연합식으로"

#~ msgid ""
#~ "All files are revised based on "
#~ ":doc:`Example: PyTorch - From Centralized "
#~ "To Federated <example-pytorch-from-"
#~ "centralized-to-federated>`. The only thing"
#~ " to do is modifying the file "
#~ "called ``cifar.py``, revised part is "
#~ "shown below:"
#~ msgstr ""
#~ "모든 파일은 :doc:`예제: 파이토치 -중앙 집중식에서 "
#~ "연합식으로 <example-pytorch-from-centralized-"
#~ "to-federated>`를 기반으로 수정합니다. :code:`cifar.py`라는"
#~ " 파일을 수정하기만 하면 되며, 수정된 부분은 아래와"
#~ " 같습니다:"

#~ msgid ""
#~ "The model architecture defined in class"
#~ " Net() is added with Batch "
#~ "Normalization layers accordingly."
#~ msgstr "Net() 클래스에 정의된 모델 아키텍처는 그에 따라 배치 정규화 레이어가 추가됩니다."

#~ msgid "You can now run your machine learning workload:"
#~ msgstr "이제 머신 러닝 워크로드를 실행할 수 있습니다:"

#~ msgid ""
#~ "So far this should all look fairly"
#~ " familiar if you've used PyTorch "
#~ "before. Let's take the next step "
#~ "and use what we've built to create"
#~ " a federated learning system within "
#~ "FedBN, the system consists of one "
#~ "server and two clients."
#~ msgstr ""
#~ "지금까지는 파이토치를 사용해 본 적이 있다면 상당히 "
#~ "익숙하게 보일 것입니다. 다음 단계로 넘어가서 우리가 "
#~ "구축한 것을 사용하여 FedBN 내에서 하나의 서버와 "
#~ "두 개의 클라이언트로 구성된 연합학습 시스템을 만들어 "
#~ "보겠습니다."

#~ msgid "Federated Training"
#~ msgstr "연합 훈련"

#~ msgid ""
#~ "If you have read :doc:`Example: PyTorch"
#~ " - From Centralized To Federated "
#~ "<example-pytorch-from-centralized-to-"
#~ "federated>`, the following parts are "
#~ "easy to follow, only ``get_parameters`` "
#~ "and ``set_parameters`` function in "
#~ "``client.py`` needed to revise. If not,"
#~ " please read the :doc:`Example: PyTorch "
#~ "- From Centralized To Federated "
#~ "<example-pytorch-from-centralized-to-"
#~ "federated>`. first."
#~ msgstr ""
#~ ":doc:`예제: 파이토치 - 중앙 집중식에서 연합식으로 "
#~ "<example-pytorch-from-centralized-to-"
#~ "federated>`를 읽었다면, 다음 부분은 쉽게 따라할 수"
#~ " 있으며 :code:`client.py`의 :code:`get_parameters`와 "
#~ ":code:`set_parameters` 함수만 수정해야 합니다. 그렇지 "
#~ "않은 경우 :doc:`예제: 파이토치 - 중앙 집중식에서"
#~ " 연합식으로 <example-pytorch-from-"
#~ "centralized-to-federated>`를 먼저 읽어보세요."

#~ msgid ""
#~ "Our example consists of one *server* "
#~ "and two *clients*. In FedBN, "
#~ "``server.py`` keeps unchanged, we can "
#~ "start the server directly."
#~ msgstr ""
#~ "이 예제는 하나의 *서버*와 두 개의 *클라이언트*로 "
#~ "구성됩니다. FedBN에서 :code:`server.py`는 변경되지 않고 "
#~ "그대로 유지되므로 서버를 바로 시작할 수 있습니다."

#~ msgid "Now, you can now open two additional terminal windows and run"
#~ msgstr "이제 두 개의 터미널 창을 추가로 열고 다음을 실행할 수 있습니다"

#~ msgid ""
#~ "in each window (make sure that the"
#~ " server is still running before you"
#~ " do so) and see your (previously "
#~ "centralized) PyTorch project run federated "
#~ "learning with FedBN strategy across two"
#~ " clients. Congratulations!"
#~ msgstr ""
#~ "를 입력하고(클릭하기 전에 서버가 계속 실행 중인지 "
#~ "확인하세요), (이전에 중앙 집중된) PyTorch 프로젝트가 "
#~ "두 클라이언트에서 FedBN으로 연합 학습을 실행하는 것을"
#~ " 확인합니다. 축하합니다!"

#~ msgid "Example: PyTorch - From Centralized To Federated"
#~ msgstr "예제: 파이토치 - 중앙 집중식에서 연합식으로"

#~ msgid ""
#~ "This tutorial will show you how to"
#~ " use Flower to build a federated "
#~ "version of an existing machine learning"
#~ " workload. We are using PyTorch to"
#~ " train a Convolutional Neural Network "
#~ "on the CIFAR-10 dataset. First, we "
#~ "introduce this machine learning task "
#~ "with a centralized training approach "
#~ "based on the `Deep Learning with "
#~ "PyTorch "
#~ "<https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html>`_"
#~ " tutorial. Then, we build upon the"
#~ " centralized training code to run the"
#~ " training in a federated fashion."
#~ msgstr ""
#~ "이 튜토리얼에서는 Flower를 사용해 기존 머신 러닝 "
#~ "워크로드의 연합 버전을 구축하는 방법을 보여드립니다. 여기서는"
#~ " PyTorch를 사용해 CIFAR-10 데이터 세트에서 컨볼루션"
#~ " 신경망을 훈련합니다. 먼저, 'PyTorch로 딥 러닝 "
#~ "<https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html>`_"
#~ " 튜토리얼을 기반으로 centralized 학습 접근 방식을 "
#~ "사용하여 이 머신 러닝 작업을 소개합니다. 그런 "
#~ "다음 centralized 훈련 코드를 기반으로 연합 방식"
#~ " 훈련을 실행합니다."

#~ msgid ""
#~ "We begin with a brief description "
#~ "of the centralized CNN training code."
#~ " If you want a more in-depth"
#~ " explanation of what's going on then"
#~ " have a look at the official "
#~ "`PyTorch tutorial "
#~ "<https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html>`_."
#~ msgstr ""
#~ "중앙 집중식 CNN 트레이닝 코드에 대한 간략한 "
#~ "설명부터 시작하겠습니다. 무슨 일이 일어나고 있는지 더 "
#~ "자세히 설명하려면 공식 `PyTorch 튜토리얼 "
#~ "<https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html>`_을"
#~ " 참조하세요."

#~ msgid ""
#~ "Let's create a new file called "
#~ "``cifar.py`` with all the components "
#~ "required for a traditional (centralized) "
#~ "training on CIFAR-10. First, all "
#~ "required packages (such as ``torch`` and"
#~ " ``torchvision``) need to be imported. "
#~ "You can see that we do not "
#~ "import any package for federated "
#~ "learning. You can keep all these "
#~ "imports as they are even when we"
#~ " add the federated learning components "
#~ "at a later point."
#~ msgstr ""
#~ "CIFAR-10에 대한 기존 (중앙 집중식) 교육에 필요한"
#~ " 모든 구성 요소가 포함된 :code:`cifar.py`라는 새"
#~ " 파일을 생성해 보겠습니다. 먼저, 필요한 모든 "
#~ "패키지(예: :code:`torch` 및 :code:`torchvision`)를 "
#~ "가져와야 합니다. 연합 학습을 위한 패키지를 가져오지 "
#~ "않는 것을 확인 할 수 있습니. 나중에 연합 "
#~ "학습 구성 요소를 추가할 때에도 이러한 모든 "
#~ "가져오기를 그대로 유지할 수 있습니다."

#~ msgid ""
#~ "As already mentioned we will use "
#~ "the CIFAR-10 dataset for this machine"
#~ " learning workload. The model architecture"
#~ " (a very simple Convolutional Neural "
#~ "Network) is defined in ``class Net()``."
#~ msgstr ""
#~ "이미 언급했듯이 이 머신 러닝 워크로드에는 CIFAR-10"
#~ " 데이터 세트를 사용합니다. 모델 아키텍처(매우 간단한 "
#~ "컨볼루션 신경망)는 :code:`class Net()`에 정의되어 "
#~ "있습니다."

#~ msgid ""
#~ "The ``load_data()`` function loads the "
#~ "CIFAR-10 training and test sets. The "
#~ "``transform`` normalized the data after "
#~ "loading."
#~ msgstr ""
#~ ":code:`load_data()` 함수는 CIFAR-10 훈련 및 "
#~ "테스트 세트를 로드합니다. :code:`transform`은 로드 후"
#~ " 데이터를 정규화합니다."

#~ msgid ""
#~ "We now need to define the training"
#~ " (function ``train()``) which loops over"
#~ " the training set, measures the loss,"
#~ " backpropagates it, and then takes "
#~ "one optimizer step for each batch "
#~ "of training examples."
#~ msgstr ""
#~ "이제 학습 집합을 반복하고, 손실을 측정하고, 이를 "
#~ "역전파한 다음 각 학습 예제 배치에 대해 하나의"
#~ " 최적화 단계를 수행하는 학습(함수 :code:`train()`)을 "
#~ "정의해야 합니다."

#~ msgid ""
#~ "The evaluation of the model is "
#~ "defined in the function ``test()``. The"
#~ " function loops over all test samples"
#~ " and measures the loss of the "
#~ "model based on the test dataset."
#~ msgstr ""
#~ "모델 평가는 :code:`test()` 함수에 정의되어 있습니다. "
#~ "이 함수는 모든 테스트 샘플을 반복하고 테스트 "
#~ "데이터 세트에 따라 모델의 손실을 측정합니다."

#~ msgid ""
#~ "Having defined the data loading, model"
#~ " architecture, training, and evaluation we"
#~ " can put everything together and "
#~ "train our CNN on CIFAR-10."
#~ msgstr "데이터 로딩, 모델 아키텍처, 훈련 및 평가를 정의했으면 모든 것을 종합하여 CIFAR-10에서 CNN을 훈련할 수 있습니다."

#~ msgid ""
#~ "So far, this should all look "
#~ "fairly familiar if you've used PyTorch"
#~ " before. Let's take the next step "
#~ "and use what we've built to create"
#~ " a simple federated learning system "
#~ "consisting of one server and two "
#~ "clients."
#~ msgstr ""
#~ "지금까지는 파이토치를 사용해 본 적이 있다면 상당히 "
#~ "익숙하게 보일 것입니다. 다음 단계로 넘어가서 구축한 "
#~ "것을 사용하여 하나의 서버와 두 개의 클라이언트로 "
#~ "구성된 간단한 연합 학습 시스템을 만들어 보겠습니다."

#~ msgid ""
#~ "The simple machine learning project "
#~ "discussed in the previous section trains"
#~ " the model on a single dataset "
#~ "(CIFAR-10), we call this centralized "
#~ "learning. This concept of centralized "
#~ "learning, as shown in the previous "
#~ "section, is probably known to most "
#~ "of you, and many of you have "
#~ "used it previously. Normally, if you'd"
#~ " want to run machine learning "
#~ "workloads in a federated fashion, then"
#~ " you'd have to change most of "
#~ "your code and set everything up "
#~ "from scratch. This can be a "
#~ "considerable effort."
#~ msgstr ""
#~ "이전 섹션에서 설명한 간단한 머신 러닝 프로젝트는 "
#~ "단일 데이터 세트(CIFAR-10)로 모델을 학습시키는데, 이를 "
#~ "중앙 집중식 학습이라고 부릅니다. 이전 섹션에서 설명한 "
#~ "중앙 집중식 학습의 개념은 대부분 알고 계실 "
#~ "것이며, 많은 분들이 이전에 사용해 보셨을 것입니다. "
#~ "일반적으로 머신 러닝 워크로드를 연합 방식으로 실행하려면"
#~ " 대부분의 코드를 변경하고 모든 것을 처음부터 다시"
#~ " 설정해야 합니다. 이는 상당한 노력이 필요할 수 "
#~ "있습니다."

#~ msgid ""
#~ "However, with Flower you can evolve "
#~ "your pre-existing code into a "
#~ "federated learning setup without the "
#~ "need for a major rewrite."
#~ msgstr "하지만 Flower를 사용하면 대대적인 재작성 없이도 기존 코드를 연합 학습 설정으로 발전시킬 수 있습니다."

#~ msgid ""
#~ "The concept is easy to understand. "
#~ "We have to start a *server* and"
#~ " then use the code in ``cifar.py``"
#~ " for the *clients* that are connected"
#~ " to the *server*. The *server* sends"
#~ " model parameters to the clients. The"
#~ " *clients* run the training and "
#~ "update the parameters. The updated "
#~ "parameters are sent back to the "
#~ "*server* which averages all received "
#~ "parameter updates. This describes one "
#~ "round of the federated learning process"
#~ " and we repeat this for multiple "
#~ "rounds."
#~ msgstr ""
#~ "개념은 이해하기 쉽습니다. *서버*를 시작한 다음 *서버*에"
#~ " 연결된 *클라이언트*에 대해 :code:`cifar.py`의 코드를 "
#~ "사용해야 합니다. *서버*는 모델 파라미터를 클라이언트로 "
#~ "전송합니다. *클라이언트*는 학습을 실행하고 파라미터를 업데이트합니다."
#~ " 업데이트된 파라미터는 *서버*로 다시 전송되며, *서버*는 "
#~ "수신된 모든 파라미터 업데이트의 평균을 구합니다. 이것은"
#~ " 연합 학습 프로세스의 한 라운드를 설명하며 여러 "
#~ "라운드에 걸쳐 이 과정을 반복합니다."

#~ msgid ""
#~ "Our example consists of one *server* "
#~ "and two *clients*. Let's set up "
#~ "``server.py`` first. The *server* needs "
#~ "to import the Flower package ``flwr``."
#~ " Next, we use the ``start_server`` "
#~ "function to start a server and "
#~ "tell it to perform three rounds of"
#~ " federated learning."
#~ msgstr ""
#~ "이 예제는 하나의 *서버*와 두 개의 *클라이언트*로 "
#~ "구성됩니다. 먼저 :code:`server.py`를 설정해 보겠습니다. "
#~ "*server*는 Flower 패키지 :code:`flwr`를 가져와야 "
#~ "합니다. 다음으로, :code:`start_server` 함수를 사용하여 "
#~ "서버를 시작하고 세 차례의 연합 학습을 수행하도록 "
#~ "지시합니다."

#~ msgid "We can already start the *server*:"
#~ msgstr "이미 *서버*를 시작할 수 있습니다:"

#~ msgid ""
#~ "Finally, we will define our *client* "
#~ "logic in ``client.py`` and build upon"
#~ " the previously defined centralized "
#~ "training in ``cifar.py``. Our *client* "
#~ "needs to import ``flwr``, but also "
#~ "``torch`` to update the parameters on"
#~ " our PyTorch model:"
#~ msgstr ""
#~ "마지막으로, :code:`client.py`에서 *client* 로직을 정의하고"
#~ " :code:`cifar.py`에서 이전에 정의한 중앙 집중식 "
#~ "학습을 기반으로 구축합니다. *클라이언트*는 :code:`flwr`을 "
#~ "가져와야 하며, PyTorch 모델의 파라미터를 업데이트하기 "
#~ "위해 :code:`torch`도 가져와야 합니다:"

#~ msgid ""
#~ "Implementing a Flower *client* basically "
#~ "means implementing a subclass of either"
#~ " ``flwr.client.Client`` or ``flwr.client.NumPyClient``."
#~ " Our implementation will be based on"
#~ " ``flwr.client.NumPyClient`` and we'll call "
#~ "it ``CifarClient``. ``NumPyClient`` is "
#~ "slightly easier to implement than "
#~ "``Client`` if you use a framework "
#~ "with good NumPy interoperability (like "
#~ "PyTorch or TensorFlow/Keras) because it "
#~ "avoids some of the boilerplate that "
#~ "would otherwise be necessary. ``CifarClient``"
#~ " needs to implement four methods, two"
#~ " methods for getting/setting model "
#~ "parameters, one method for training the"
#~ " model, and one method for testing"
#~ " the model:"
#~ msgstr ""
#~ "Flower *클라이언트*를 구현한다는 것은 기본적으로 "
#~ ":code:`flwr.client.Client` 또는 "
#~ ":code:`flwr.client.NumPyClient`의 서브클래스를 구현하는 것을 "
#~ "의미합니다. 우리의 구현은 :code:`flwr.client.NumPyClient`를 "
#~ "기반으로 하며, 이를 :code:`CifarClient`라고 부를 "
#~ "것입니다. :code:`NumPyClient`는 파이토치나 텐서플로우/Keras처럼 "
#~ "NumPy 상호운용성이 좋은 프레임워크를 사용하는 경우 필요한"
#~ " 일부 보일러플레이트를 피하기 때문에 :code:`Client`보다 "
#~ "구현하기가 조금 더 쉽습니다. code:`CifarClient`는 모델"
#~ " 파라미터를 가져오거나 설정하는 메서드 2개, 모델 "
#~ "학습을 위한 메서드 1개, 모델 테스트를 위한 "
#~ "메서드 1개 등 네 가지 메서드를 구현해야 합니다:"

#~ msgid "``set_parameters``"
#~ msgstr ":code:`set_parameters`"

#~ msgid ""
#~ "set the model parameters on the "
#~ "local model that are received from "
#~ "the server"
#~ msgstr "서버에서 수신한 로컬 모델의 모델 파라미터를 설정합니다"

#~ msgid ""
#~ "loop over the list of model "
#~ "parameters received as NumPy ``ndarray``'s "
#~ "(think list of neural network layers)"
#~ msgstr "(신경망 레이어 목록으로 생각하면 됩니다) NumPy :code:`ndarray`로 받은 모델 파라미터 목록에 대해 반복합니다"

#~ msgid "``get_parameters``"
#~ msgstr ":code:`get_parameters`"

#~ msgid ""
#~ "get the model parameters and return "
#~ "them as a list of NumPy "
#~ "``ndarray``'s (which is what "
#~ "``flwr.client.NumPyClient`` expects)"
#~ msgstr ""
#~ "모델 매개변수를 가져와서 NumPy :code:`ndarray`의 "
#~ "목록으로 반환합니다(이는 :code:`flwr.client.NumPyClient`가 기대하는"
#~ " 바와 같습니다)"

#~ msgid ""
#~ "update the parameters of the local "
#~ "model with the parameters received from"
#~ " the server"
#~ msgstr "서버에서 받은 파라미터로 로컬 모델의 파라미터를 업데이트합니다"

#~ msgid "train the model on the local training set"
#~ msgstr "로컬 훈련 세트에서 모델을 훈련합니다"

#~ msgid "get the updated local model weights and return them to the server"
#~ msgstr "업데이트된 로컬 모델 가중치를 가져와 서버로 반환합니다"

#~ msgid "evaluate the updated model on the local test set"
#~ msgstr "로컬 테스트 세트에서 업데이트된 모델을 평가합니다"

#~ msgid "return the local loss and accuracy to the server"
#~ msgstr "로컬 손실 및 정확도를 서버에 반환합니다"

#~ msgid ""
#~ "The two ``NumPyClient`` methods ``fit`` "
#~ "and ``evaluate`` make use of the "
#~ "functions ``train()`` and ``test()`` "
#~ "previously defined in ``cifar.py``. So "
#~ "what we really do here is we "
#~ "tell Flower through our ``NumPyClient`` "
#~ "subclass which of our already defined"
#~ " functions to call for training and"
#~ " evaluation. We included type annotations"
#~ " to give you a better understanding"
#~ " of the data types that get "
#~ "passed around."
#~ msgstr ""
#~ "두 개의 :code:`NumPyClient` 메서드인 :code:`fit`과 "
#~ ":code:`evaluate`는 이전에 :code:`cifar.py`에 정의된 "
#~ "함수인 :code:`train()`과 :code:`test()`를 활용합니다. "
#~ "따라서 여기서 실제로 하는 일은 :code:`NumPyClient`"
#~ " 서브클래스를 통해 이미 정의된 함수 중 훈련과 "
#~ "평가를 위해 호출할 함수를 Flower에 알려주는 것입니다."
#~ " 전달되는 데이터 유형을 더 잘 이해할 수 "
#~ "있도록 type annotations을 포함했습니다."

#~ msgid ""
#~ "All that's left to do it to "
#~ "define a function that loads both "
#~ "model and data, creates a "
#~ "``CifarClient``, and starts this client. "
#~ "You load your data and model by"
#~ " using ``cifar.py``. Start ``CifarClient`` "
#~ "with the function ``fl.client.start_client()`` "
#~ "by pointing it at the same IP "
#~ "address we used in ``server.py``:"
#~ msgstr ""
#~ "이제 모델과 데이터를 모두 로드하는 함수를 정의하고, "
#~ ":code:`CifarClient`를 생성하고, 이 클라이언트를 시작하는 "
#~ "작업만 남았습니다. 코드:`cifar.py`를 사용하여 데이터와 모델을"
#~ " 로드합니다. :code:`server.py`에서 사용한 것과 동일한 "
#~ "IP 주소를 지정하여 :code:`fl.client.start_client()` "
#~ "함수로 :code:`CifarClient`를 시작합니다:"

#~ msgid "And that's it. You can now open two additional terminal windows and run"
#~ msgstr "여기까지입니다. 이제 두 개의 터미널 창을 추가로 열고 다음을 실행할 수 있습니다"

#~ msgid ""
#~ "in each window (make sure that the"
#~ " server is running before you do "
#~ "so) and see your (previously "
#~ "centralized) PyTorch project run federated "
#~ "learning across two clients. Congratulations!"
#~ msgstr ""
#~ "를 입력하고(그 전에 서버가 실행 중인지 확인하세요) "
#~ "(이전에는 중앙 집중식) PyTorch 프로젝트가 두 "
#~ "클라이언트에서 연합 학습을 실행하는 것을 확인합니다. "
#~ "축하합니다!"

#~ msgid ""
#~ "The full source code for this "
#~ "example: `PyTorch: From Centralized To "
#~ "Federated (Code) "
#~ "<https://github.com/adap/flower/blob/main/examples/pytorch-"
#~ "from-centralized-to-federated>`_. Our "
#~ "example is, of course, somewhat over-"
#~ "simplified because both clients load the"
#~ " exact same dataset, which isn't "
#~ "realistic. You're now prepared to "
#~ "explore this topic further. How about"
#~ " using different subsets of CIFAR-10 "
#~ "on each client? How about adding "
#~ "more clients?"
#~ msgstr ""
#~ "이 예제의 전체 소스 코드: `파이토치: 중앙 "
#~ "Centralized에서 Federated으로 (코드) "
#~ "<https://github.com/adap/flower/blob/main/examples/pytorch-"
#~ "from-centralized-to-federated>`_. 물론 이 "
#~ "예제는 두 클라이언트가 완전히 동일한 데이터 세트를 "
#~ "로드하기 때문에 다소 지나치게 단순화되어 있으며, 이는 "
#~ "현실적이지 않습니다. 이제 이 주제를 더 자세히 "
#~ "살펴볼 준비가 되셨습니다. 각 클라이언트에서 서로 다른 "
#~ "CIFAR-10의 하위 집합을 사용해 보는 것은 어떨까요?"
#~ " 클라이언트를 더 추가하는 것은 어떨까요?"

#~ msgid ""
#~ "To help you start and manage all"
#~ " of the concurrently executing training "
#~ "runs, Flower offers one additional "
#~ "long-running server-side service called "
#~ "**SuperExec**. When you type ``flwr "
#~ "run`` to start a new training run,"
#~ " the ``flwr`` CLI bundles your local"
#~ " project (mainly your ``ServerApp`` and "
#~ "``ClientApp``) and sends it to the "
#~ "**SuperExec**. The **SuperExec** will then "
#~ "take care of starting and managing "
#~ "your ``ServerApp``, which in turn "
#~ "selects SuperNodes to execute your "
#~ "``ClientApp``."
#~ msgstr ""

#~ msgid ""
#~ "This architecture allows many users to"
#~ " (concurrently) run their projects on "
#~ "the same federation, simply by typing"
#~ " ``flwr run`` on their local "
#~ "developer machine."
#~ msgstr ""

#~ msgid "Flower Deployment Engine with SuperExec"
#~ msgstr ""

#~ msgid "The SuperExec service for managing concurrent training runs in Flower."
#~ msgstr ""

#~ msgid "FED Template"
#~ msgstr "FED 템플릿"

#~ msgid "Table of Contents"
#~ msgstr "목차"

#~ msgid "[Table of Contents](#table-of-contents)"
#~ msgstr "[목차](#목차)"

#~ msgid "[Summary](#summary)"
#~ msgstr "[요약](#요약)"

#~ msgid "[Motivation](#motivation)"
#~ msgstr "[동기](#동기)"

#~ msgid "[Goals](#goals)"
#~ msgstr "[목표](#목표)"

#~ msgid "[Non-Goals](#non-goals)"
#~ msgstr "[비목표](#비목표)"

#~ msgid "[Proposal](#proposal)"
#~ msgstr "[제안](#제안)"

#~ msgid "[Drawbacks](#drawbacks)"
#~ msgstr "[단점](#단점)"

#~ msgid "[Alternatives Considered](#alternatives-considered)"
#~ msgstr "[고려되는 대안](#고려되는 대안)"

#~ msgid "[Appendix](#appendix)"
#~ msgstr "[부록](#부록)"

#~ msgid "Summary"
#~ msgstr "요약"

#~ msgid "\\[TODO - sentence 1: summary of the problem\\]"
#~ msgstr "\\[TODO - 문장 1: 문제 요약\\]"

#~ msgid "\\[TODO - sentence 2: summary of the solution\\]"
#~ msgstr "\\[TODO - 문장 2: 솔루션 요약\\]"

#~ msgid "Motivation"
#~ msgstr "동기"

#~ msgid "\\[TODO\\]"
#~ msgstr "\\[TODO\\]"

#~ msgid "Goals"
#~ msgstr "목표"

#~ msgid "Non-Goals"
#~ msgstr "목표가 아닌 것"

#~ msgid "Proposal"
#~ msgstr "제안"

#~ msgid "Drawbacks"
#~ msgstr "단점"

#~ msgid "Alternatives Considered"
#~ msgstr "고려되는 대안"

#~ msgid "\\[Alternative 1\\]"
#~ msgstr "\\[대안 1\\]"

#~ msgid "\\[Alternative 2\\]"
#~ msgstr "\\[대안 2\\]"

#~ msgid "Flower Enhancement Doc"
#~ msgstr "Flower Enhancement Doc"

#~ msgid "[Enhancement Doc Template](#enhancement-doc-template)"
#~ msgstr "[Enhancement Doc 템플릿](#enhancement-doc-템플릿)"

#~ msgid "[Metadata](#metadata)"
#~ msgstr "[Metadata](#metadata)"

#~ msgid "[Workflow](#workflow)"
#~ msgstr "[워크플로우](#워크플로우)"

#~ msgid "[GitHub Issues](#github-issues)"
#~ msgstr "[GitHub Issues](#github-issues)"

#~ msgid "[Google Docs](#google-docs)"
#~ msgstr "[Google Docs](#google-docs)"

#~ msgid "A Flower Enhancement is a standardized development process to"
#~ msgstr "Flower Enhancement는 다음과 같은 표준화된 개발 프로세스입니다"

#~ msgid "provide a common structure for proposing larger changes"
#~ msgstr "더 큰 변경 사항을 제안하기 위한 공통 구조를 제공합니다"

#~ msgid "ensure that the motivation for a change is clear"
#~ msgstr "변화의 동기가 분명한지 확인합니다"

#~ msgid "persist project information in a version control system"
#~ msgstr "버전 관리 시스템에서 프로젝트 정보를 유지합니다"

#~ msgid "document the motivation for impactful user-facing changes"
#~ msgstr "사용자에게 영향력 있는 변화에 대한 동기를 문서화합니다"

#~ msgid "reserve GitHub issues for tracking work in flight"
#~ msgstr "운행 중 작업 추적을 위한 깃허브 이슈를 예약합니다"

#~ msgid ""
#~ "ensure community participants can successfully"
#~ " drive changes to completion across "
#~ "one or more releases while stakeholders"
#~ " are adequately represented throughout the"
#~ " process"
#~ msgstr ""
#~ "커뮤니티 참여자가 하나 이상의 릴리즈에서 변경 사항을 "
#~ "성공적으로 완료할 수 있도록 하는 동시에 이해 "
#~ "관계자가 프로세스 전반에 걸쳐 적절히 대표되도록 보장합니다"

#~ msgid "Hence, an Enhancement Doc combines aspects of"
#~ msgstr "따라서 Enhancement 문서에는 다음과 같은 측면이 결합되어 있습니다"

#~ msgid "a feature, and effort-tracking document"
#~ msgstr "기능 및 effort-tracking 문서"

#~ msgid "a product requirements document"
#~ msgstr "제품 요구 사항 문서"

#~ msgid "a design document"
#~ msgstr "디자인 문서"

#~ msgid ""
#~ "into one file, which is created "
#~ "incrementally in collaboration with the "
#~ "community."
#~ msgstr "를 하나의 파일로 통합하여 커뮤니티와 협력해 점진적으로 생성합니다."

#~ msgid ""
#~ "For far-fetching changes or features "
#~ "proposed to Flower, an abstraction "
#~ "beyond a single GitHub issue or "
#~ "pull request is required to understand"
#~ " and communicate upcoming changes to "
#~ "the project."
#~ msgstr ""
#~ "Flower에 제안된 변경 사항이나 기능을 멀리 가져오는"
#~ " 경우, 프로젝트의 향후 변경 사항을 이해하고 전달하기"
#~ " 위해 단일 GitHub 이슈 또는 pull "
#~ "request를 넘어서는 abstraction이 필요합니다."

#~ msgid ""
#~ "The purpose of this process is to"
#~ " reduce the amount of \"tribal "
#~ "knowledge\" in our community. By moving"
#~ " decisions from Slack threads, video "
#~ "calls, and hallway conversations into a"
#~ " well-tracked artifact, this process "
#~ "aims to enhance communication and "
#~ "discoverability."
#~ msgstr ""
#~ "이 프로세스의 목적은 커뮤니티 내 '부족한 지식'의 "
#~ "양을 줄이는 것입니다. 이 프로세스는 Slack 스레드,"
#~ " 영상 통화, 복도 대화에서 나온 의사 결정을 "
#~ "잘 추적된 아티팩트로 옮김으로써 커뮤니케이션과 검색 가능성을"
#~ " 향상시키는 것을 목표로 합니다."

#~ msgid ""
#~ "Roughly any larger, user-facing "
#~ "enhancement should follow the Enhancement "
#~ "process. If an enhancement would be "
#~ "described in either written or verbal"
#~ " communication to anyone besides the "
#~ "author or developer, then consider "
#~ "creating an Enhancement Doc."
#~ msgstr ""
#~ "대략적으로 사용자를 대상으로 하는 대규모 개선 사항은 "
#~ "개선 프로세스를 따라야 합니다. 개선 사항을 작성자나 "
#~ "개발자 이외의 다른 사람에게 서면 또는 구두로 "
#~ "설명해야 하는 경우에는 개선 문서 작성을 고려하세요."

#~ msgid ""
#~ "Similarly, any technical effort (refactoring,"
#~ " major architectural change) that will "
#~ "impact a large section of the "
#~ "development community should also be "
#~ "communicated widely. The Enhancement process"
#~ " is suited for this even if it"
#~ " will have zero impact on the "
#~ "typical user or operator."
#~ msgstr ""
#~ "마찬가지로 개발 커뮤니티의 많은 부분에 영향을 미치는 "
#~ "기술적 노력(리팩토링, 주요 아키텍처 변경)도 널리 알려야"
#~ " 합니다. 개선 프로세스는 일반 사용자나 운영자에게 전혀"
#~ " 영향을 미치지 않더라도 이를 위해 적합합니다."

#~ msgid ""
#~ "For small changes and additions, going"
#~ " through the Enhancement process would "
#~ "be time-consuming and unnecessary. This"
#~ " includes, for example, adding new "
#~ "Federated Learning algorithms, as these "
#~ "only add features without changing how"
#~ " Flower works or is used."
#~ msgstr ""
#~ "작은 변경 및 추가의 경우, 개선 프로세스를 거치는"
#~ " 것은 시간이 많이 걸리고 불필요합니다. 예를 들어,"
#~ " 새로운 연합 학습 알고리즘을 추가하는 것은 "
#~ "Flower의 작동 방식이나 사용 방식을 변경하지 않고 "
#~ "기능만 추가하는 것이기 때문입니다."

#~ msgid ""
#~ "Enhancements are different from feature "
#~ "requests, as they are already providing"
#~ " a laid-out path for implementation"
#~ " and are championed by members of "
#~ "the community."
#~ msgstr "기능 개선은 이미 구현할 수 있는 경로가 마련되어 있고 커뮤니티 구성원들이 지지하는 것이므로 기능 요청과는 다릅니다."

#~ msgid ""
#~ "An Enhancement is captured in a "
#~ "Markdown file that follows a defined "
#~ "template and a workflow to review "
#~ "and store enhancement docs for reference"
#~ " — the Enhancement Doc."
#~ msgstr ""
#~ "개선 사항은 정의된 템플릿과 참조용으로 Enhancement "
#~ "Doc.를 검토하고 저장하는 워크플로우를 따르는 Markdown "
#~ "파일에 캡처됩니다."

#~ msgid "Enhancement Doc Template"
#~ msgstr "Enhancement Doc 템플릿"

#~ msgid ""
#~ "Each enhancement doc is provided as "
#~ "a Markdown file having the following "
#~ "structure"
#~ msgstr "각 개선 사항 문서는 다음과 같은 구조의 Markdown 파일로 제공됩니다"

#~ msgid "Metadata (as [described below](#metadata) in form of a YAML preamble)"
#~ msgstr "Metadata ([아래 설명](#metadata) YAML preamble 형식)"

#~ msgid "Title (same as in metadata)"
#~ msgstr "Title (metadata와 같게)"

#~ msgid "Table of Contents (if needed)"
#~ msgstr "Table of Contents (필요시)"

#~ msgid "Notes/Constraints/Caveats (optional)"
#~ msgstr "Notes/Constraints/Caveats (선택 사항)"

#~ msgid "Design Details (optional)"
#~ msgstr "Design Details (선택 사항)"

#~ msgid "Graduation Criteria"
#~ msgstr "졸업 기준"

#~ msgid "Upgrade/Downgrade Strategy (if applicable)"
#~ msgstr "업그레이드/다운그레이드 전략(해당되는 경우)"

#~ msgid "As a reference, this document follows the above structure."
#~ msgstr "참고로 이 문서는 위의 구조를 따릅니다."

#~ msgid ""
#~ "**fed-number** (Required) The `fed-"
#~ "number` of the last Flower Enhancement"
#~ " Doc + 1. With this number, it"
#~ " becomes easy to reference other "
#~ "proposals."
#~ msgstr ""
#~ "**피드 번호** (필수) 마지막 Flower Enhancement"
#~ " 문서의 `피드 번호` + 1. 이 번호를 "
#~ "사용하면 다른 제안을 쉽게 참조할 수 있습니다."

#~ msgid "**title** (Required) The title of the proposal in plain language."
#~ msgstr "**제목** (필수) 제안서의 제목을 평이한 언어로 입력합니다."

#~ msgid ""
#~ "**status** (Required) The current status "
#~ "of the proposal. See [workflow](#workflow) "
#~ "for the possible states."
#~ msgstr "**상태** (필수) 제안의 현재 상태입니다. 가능한 상태는 [워크플로](#워크플로)를 참조하세요."

#~ msgid ""
#~ "**authors** (Required) A list of authors"
#~ " of the proposal. This is simply "
#~ "the GitHub ID."
#~ msgstr "**저자** (필수) 제안서의 작성자 목록입니다. 간단히 GitHub ID입니다."

#~ msgid ""
#~ "**creation-date** (Required) The date "
#~ "that the proposal was first submitted"
#~ " in a PR."
#~ msgstr "**생성 날짜** (필수) PR에서 제안서를 처음 제출한 날짜입니다."

#~ msgid ""
#~ "**last-updated** (Optional) The date "
#~ "that the proposal was last changed "
#~ "significantly."
#~ msgstr "**마지막 업데이트** (선택 사항) 제안서가 마지막으로 크게 변경된 날짜입니다."

#~ msgid ""
#~ "**see-also** (Optional) A list of "
#~ "other proposals that are relevant to "
#~ "this one."
#~ msgstr "**함께 보기** (선택 사항) 이 제안과 관련된 다른 제안 목록입니다."

#~ msgid "**replaces** (Optional) A list of proposals that this one replaces."
#~ msgstr "**대체** (선택 사항) 이 제안이 대체하는 제안 목록입니다."

#~ msgid ""
#~ "**superseded-by** (Optional) A list of"
#~ " proposals that this one supersedes."
#~ msgstr "**대체됨** (선택 사항) 이 제안이 대체하는 제안의 목록입니다."

#~ msgid "Workflow"
#~ msgstr "워크플로우"

#~ msgid ""
#~ "The idea forming the enhancement should"
#~ " already have been discussed or "
#~ "pitched in the community. As such, "
#~ "it needs a champion, usually the "
#~ "author, who shepherds the enhancement. "
#~ "This person also has to find "
#~ "committers to Flower willing to review"
#~ " the proposal."
#~ msgstr ""
#~ "개선 사항을 구성하는 아이디어는 이미 커뮤니티에서 논의되었거나"
#~ " 제안된 적이 있어야 합니다. 따라서 개선 사항을 "
#~ "주도하는 사(보통 작성자)이 필요합니다. 이 사람은 또한"
#~ " 제안을 검토할 의향이 있는 Flower 커미터를 찾아야"
#~ " 합니다."

#~ msgid ""
#~ "New enhancements are checked in with "
#~ "a file name in the form of "
#~ "`NNNN-YYYYMMDD-enhancement-title.md`, with "
#~ "`NNNN` being the Flower Enhancement Doc"
#~ " number, to `enhancements`. All "
#~ "enhancements start in `provisional` state "
#~ "as part of a pull request. "
#~ "Discussions are done as part of "
#~ "the pull request review."
#~ msgstr ""
#~ "새 개선 사항은 `NNNN-YYYYMMDD-enhancement-"
#~ "title.md` 형식의 파일 이름으로 체크인되며, `NNNN`은 "
#~ "Flower 개선 문서 번호이고 `enhancements`에 해당합니다."
#~ " 모든 개선 사항은 pull request의 일부로 "
#~ "`잠정` 상태에서 시작됩니다. 토론은 pull request "
#~ "검토의 일부로 이루어집니다."

#~ msgid ""
#~ "Once an enhancement has been reviewed"
#~ " and approved, its status is changed"
#~ " to `implementable`. The actual "
#~ "implementation is then done in separate"
#~ " pull requests. These pull requests "
#~ "should mention the respective enhancement "
#~ "as part of their description. After "
#~ "the implementation is done, the proposal"
#~ " status is changed to `implemented`."
#~ msgstr ""
#~ "개선 사항이 검토 및 승인되면 상태가 '구현 "
#~ "가능'으로 변경됩니다. 그런 다음 실제 구현은 별도의 "
#~ "pull requests를 통해 이루어집니다. 이러한 pull "
#~ "requests는 설명의 일부로 해당 개선 사항을 언급해야"
#~ " 합니다. 구현이 완료되면 제안 상태는 '구현됨'으로 "
#~ "변경됩니다."

#~ msgid ""
#~ "Under certain conditions, other states "
#~ "are possible. An Enhancement has the "
#~ "following states:"
#~ msgstr "특정 조건에서는 다른 상태도 가능합니다. 개선에는 다음과 같은 상태가 있습니다:"

#~ msgid ""
#~ "`provisional`: The enhancement has been "
#~ "proposed and is actively being defined."
#~ " This is the starting state while "
#~ "the proposal is being fleshed out "
#~ "and actively defined and discussed."
#~ msgstr ""
#~ "'잠정적': 개선 사항이 제안되어 활발히 정의되고 있습니다."
#~ " 제안이 구체화되고 활발하게 정의 및 논의되는 동안의"
#~ " 시작 단계입니다."

#~ msgid "`implementable`: The enhancement has been reviewed and approved."
#~ msgstr "`구현 가능`: 개선 사항이 검토 및 승인되었습니다."

#~ msgid ""
#~ "`implemented`: The enhancement has been "
#~ "implemented and is no longer actively"
#~ " changed."
#~ msgstr "`구현됨`: 개선 사항이 구현되었으며 더 이상 활발히 변경되지 않습니다."

#~ msgid ""
#~ "`deferred`: The enhancement is proposed "
#~ "but not actively being worked on."
#~ msgstr "'지연됨': 개선 사항이 제안되었지만 아직 활발히 작업 중이 아닙니다."

#~ msgid ""
#~ "`rejected`: The authors and reviewers "
#~ "have decided that this enhancement is"
#~ " not moving forward."
#~ msgstr "`거부됨`: 작성자와 검토자는 이 개선 사항을 더 이상 진행하지 않기로 결정했습니다."

#~ msgid "`withdrawn`: The authors have withdrawn the enhancement."
#~ msgstr "`철회`: 작성자가 개선 사항을 철회했습니다."

#~ msgid "`replaced`: The enhancement has been replaced by a new enhancement."
#~ msgstr "'대체됨': 개선 사항이 새로운 개선 사항으로 대체되었습니다."

#~ msgid ""
#~ "Adding an additional process to the "
#~ "ones already provided by GitHub (Issues"
#~ " and Pull Requests) adds more "
#~ "complexity and can be a barrier "
#~ "for potential first-time contributors."
#~ msgstr ""
#~ "GitHub에서 이미 제공하는 프로세스(이슈 및 Pull "
#~ "Requests)에 추가 프로세스를 추가하면 더 복잡해지고 "
#~ "잠재적인 처음인 기여자에게는 장벽이 될 수 있습니다."

#~ msgid ""
#~ "Expanding the proposal template beyond "
#~ "the single-sentence description currently "
#~ "required in the features issue template"
#~ " may be a heavy burden for "
#~ "non-native English speakers."
#~ msgstr ""
#~ "현재 기능 이슈 템플릿에서 요구되는 한 문장 설명"
#~ " 이상으로 제안서 템플릿을 확장하는 것은 영어가 모국어가"
#~ " 아닌 사용자에게는 큰 부담이 될 수 있습니다."

#~ msgid "GitHub Issues"
#~ msgstr "GitHub 이슈"

#~ msgid ""
#~ "Using GitHub Issues for these kinds "
#~ "of enhancements is doable. One could "
#~ "use, for example, tags, to differentiate"
#~ " and filter them from other issues."
#~ " The main issue is in discussing "
#~ "and reviewing an enhancement: GitHub "
#~ "issues only have a single thread "
#~ "for comments. Enhancements usually have "
#~ "multiple threads of discussion at the"
#~ " same time for various parts of "
#~ "the doc. Managing these multiple "
#~ "discussions can be confusing when using"
#~ " GitHub Issues."
#~ msgstr ""
#~ "이러한 종류의 개선을 위해 GitHub 이슈를 사용하면 "
#~ "가능합니다. 예를 들어 태그를 사용하여 다른 이슈와 "
#~ "구별하고 필터링할 수 있습니다. 주요 이슈는 개선 "
#~ "사항에 대해 토론하고 검토하는 것입니다: GitHub 이슈에는"
#~ " 댓글 스레드가 하나만 있습니다. 개선 사항에는 "
#~ "일반적으로 문서의 여러 부분에 대해 동시에 여러 "
#~ "개의 토론 스레드가 있습니다. GitHub 이슈를 사용할"
#~ " 때 이러한 여러 토론을 관리하면 혼란스러울 수 "
#~ "있습니다."

#~ msgid "Google Docs"
#~ msgstr "Google 문서 도구"

#~ msgid ""
#~ "Google Docs allow for multiple threads"
#~ " of discussions. But as Google Docs"
#~ " are hosted outside the project, "
#~ "their discoverability by the community "
#~ "needs to be taken care of. A "
#~ "list of links to all proposals has"
#~ " to be managed and made available "
#~ "for the community. Compared to shipping"
#~ " proposals as part of Flower's "
#~ "repository, the potential for missing "
#~ "links is much higher."
#~ msgstr ""
#~ "Google 문서는 여러 스레드의 토론을 허용합니다. 하지만"
#~ " Google 문서는 프로젝트 외부에서 호스팅되므로 커뮤니티에서"
#~ " 검색할 수 있도록 관리해야 합니다. 모든 제안에 "
#~ "대한 링크 목록을 관리하고 커뮤니티에 제공해야 합니다. "
#~ "Flower 저장소의 일부로 제안서를 보낼 때와 비교하면"
#~ " 링크가 누락될 가능성이 훨씬 더 높습니다."

#~ msgid "FED - Flower Enhancement Doc"
#~ msgstr "FED - Flower 개선 문서"

#~ msgid ""
#~ "Along with model parameters, Flower can"
#~ " send configuration values to clients. "
#~ "Configuration values can be used for "
#~ "various purposes. They are, for example,"
#~ " a popular way to control client-"
#~ "side hyperparameters from the server."
#~ msgstr ""
#~ "모델 파라미터와 함께 Flower는 설정 값을 클라이언트에"
#~ " 전송할 수 있습니다. 구성 값은 다양한 용도로 "
#~ "사용할 수 있습니다. 예를 들어 서버에서 클라이언트 "
#~ "측 하이퍼파라미터를 제어하는 데 널리 사용되는 방법입니다."

#~ msgid ""
#~ "Configuration values are represented as "
#~ "a dictionary with ``str`` keys and "
#~ "values of type ``bool``, ``bytes``, "
#~ "``double`` (64-bit precision float), ``int``,"
#~ " or ``str`` (or equivalent types in"
#~ " different languages). Here is an "
#~ "example of a configuration dictionary in"
#~ " Python:"
#~ msgstr ""
#~ "구성 값은 ``str`` 키와 ``bool``, ``bytes``,"
#~ " ``double``(64비트 정밀도 정수), ``int`` 또는 "
#~ "``str``(또는 다른 언어의 동등한 유형) 유형의 값으로"
#~ " 구성된 사전으로 표현됩니다. 다음은 Python의 구성 "
#~ "사전 예제입니다:"

#~ msgid ""
#~ "One can, for example, convert a "
#~ "list of floating-point numbers to "
#~ "a JSON string, then send the JSON"
#~ " string using the configuration dictionary,"
#~ " and then convert the JSON string "
#~ "back to a list of floating-point"
#~ " numbers on the client."
#~ msgstr ""
#~ "예를 들어 부동 소수점 숫자 목록을 JSON "
#~ "문자열로 변환한 다음 구성 dictionary을 사용하여 "
#~ "JSON 문자열을 전송한 다음 클라이언트에서 다시 부동 "
#~ "소수점 숫자 목록으로 변환할 수 있습니다."

#~ msgid ""
#~ "The easiest way to send configuration"
#~ " values to clients is to use a"
#~ " built-in strategy like ``FedAvg``. "
#~ "Built-in strategies support so-called "
#~ "configuration functions. A configuration "
#~ "function is a function that the "
#~ "built-in strategy calls to get the"
#~ " configuration dictionary for the current"
#~ " round. It then forwards the "
#~ "configuration dictionary to all the "
#~ "clients selected during that round."
#~ msgstr ""
#~ "클라이언트에 구성 값을 보내는 가장 쉬운 방법은 "
#~ ":code:`FedAvg`와 같은 기본 제공 전략을 사용하는 "
#~ "것입니다. 기본 제공 전략은 소위 구성 함수를 "
#~ "지원합니다. 구성 함수는 내장 전략이 현재 단계의 "
#~ "구성 사전을 가져오기 위해 호출하는 함수입니다. 그런 "
#~ "다음 해당 단계 동안 선택된 모든 클라이언트에 구성"
#~ " 사전을 전달합니다."

#~ msgid ""
#~ "To make the built-in strategies "
#~ "use this function, we can pass it"
#~ " to ``FedAvg`` during initialization using"
#~ " the parameter ``on_fit_config_fn``:"
#~ msgstr ""
#~ "기본 제공 전략이 이 함수를 사용하도록 하려면 "
#~ "초기화 중에 매개 변수 :code:`on_fit_config_fn`을 "
#~ "사용하여 ``FedAvg``에 이 함수를 전달하면 됩니다:"

#~ msgid ""
#~ "One the client side, we receive "
#~ "the configuration dictionary in ``fit``:"
#~ msgstr "클라이언트 측에서는 ``fit``으로 구성 dictionary을 받습니다:"

#~ msgid ""
#~ "There is also an `on_evaluate_config_fn` "
#~ "to configure evaluation, which works the"
#~ " same way. They are separate "
#~ "functions because one might want to "
#~ "send different configuration values to "
#~ "`evaluate` (for example, to use a "
#~ "different batch size)."
#~ msgstr ""
#~ "평가를 구성하는 `on_evaluate_config_fn`도 있으며, 같은 "
#~ "방식으로 작동합니다. 다른 배치 크기를 사용하기 위해 "
#~ "다른 구성 값을 `evaluate`로 보내려고 할 수 "
#~ "있기 때문에 이 함수는 별도의 함수입니다."

#~ msgid ""
#~ "The built-in strategies call this "
#~ "function every round (that is, every "
#~ "time `Strategy.configure_fit` or "
#~ "`Strategy.configure_evaluate` runs). Calling "
#~ "`on_evaluate_config_fn` every round allows us"
#~ " to vary/change the config dict over"
#~ " consecutive rounds. If we wanted to"
#~ " implement a hyperparameter schedule, for"
#~ " example, to increase the number of"
#~ " local epochs during later rounds, we"
#~ " could do the following:"
#~ msgstr ""
#~ "기본 제공 전략은 매 라운드마다 이 함수를 "
#~ "호출합니다(즉, `Strategy.configure_fit` 또는 "
#~ "`Strategy.configure_evaluate`가 실행될 때마다). 매 "
#~ "라운드마다 `on_evaluate_config_fn`을 호출하면 연속된 라운드에서"
#~ " config dict를 변경/변경할 수 있습니다. 예를 "
#~ "들어 이후 라운드에서 로컬 에포크 수를 늘리기 위해"
#~ " 하이퍼파라미터 일정을 구현하려면 다음과 같이 할 수"
#~ " 있습니다:"

#~ msgid "The ``FedAvg`` strategy will call this function *every round*."
#~ msgstr ":code:`FedAvg` 전략은 이 함수를 *매 라운드마다* 호출합니다."

#~ msgid "Configuring individual clients"
#~ msgstr "개별 클라이언트 구성"

#~ msgid ""
#~ "In some cases, it is necessary to"
#~ " send different configuration values to "
#~ "different clients."
#~ msgstr "경우에 따라 다른 구성 값을 다른 클라이언트에 보내야 하는 경우도 있습니다."

#~ msgid ""
#~ "This can be achieved by customizing "
#~ "an existing strategy or by "
#~ ":doc:`implementing a custom strategy from "
#~ "scratch <how-to-implement-strategies>`. "
#~ "Here's a nonsensical example that "
#~ "customizes ``FedAvg`` by adding a custom"
#~ " ``\"hello\": \"world\"`` configuration key/value"
#~ " pair to the config dict of a"
#~ " *single client* (only the first "
#~ "client in the list, the other "
#~ "clients in this round to not "
#~ "receive this \"special\" config value):"
#~ msgstr ""
#~ "이는 기존 전략을 사용자 지정하거나 :doc:`implementing"
#~ " a custom strategy from scratch "
#~ "<how-to-implement-strategies>`를 통해 수행할 "
#~ "수 있습니다. 다음은 사용자 지정 ``\"hello\"'를 "
#~ "추가하여 :code:`FedAvg`를 사용자 지정하는 무의미한 예입니다:"
#~ " \"world\"`` 구성 키/값 쌍을 *단일 클라이언트*의"
#~ " config dict에 추가합니다(목록의 첫 번째 클라이언트만,"
#~ " 이 라운드의 다른 클라이언트는 이 \"특별한\" 구성"
#~ " 값을 수신하지 않음):"

#~ msgid "Configure logging"
#~ msgstr "로깅 구성"

#~ msgid ""
#~ "The Flower logger keeps track of "
#~ "all core events that take place in"
#~ " federated learning workloads. It presents"
#~ " information by default following a "
#~ "standard message format:"
#~ msgstr ""
#~ "Flower 로거는 federated 학습 워크로드에서 발생하는 "
#~ "모든 핵심 이벤트를 추적합니다. 기본적으로 표준 메시지 "
#~ "형식에 따라 정보를 표시합니다:"

#~ msgid ""
#~ "containing relevant information including: log"
#~ " message level (e.g. ``INFO``, ``DEBUG``),"
#~ " a timestamp, the line where the "
#~ "logging took place from, as well "
#~ "as the log message itself. In this"
#~ " way, the logger would typically "
#~ "display information on your terminal as"
#~ " follows:"
#~ msgstr ""
#~ "로그 메시지 수준(예: :code:`INFO`, :code:`DEBUG`), "
#~ "타임스탬프, 로깅이 발생한 줄, 로그 메시지 자체 "
#~ "등 관련 정보를 포함합니다. 이러한 방식으로 로거는 "
#~ "일반적으로 다음과 같은 정보를 터미널에 표시합니다:"

#~ msgid "Saving log to file"
#~ msgstr "파일에 로그 저장"

#~ msgid ""
#~ "By default, the Flower log is "
#~ "outputted to the terminal where you "
#~ "launch your Federated Learning workload "
#~ "from. This applies for both gRPC-"
#~ "based federation (i.e. when you do "
#~ "``fl.server.start_server``) and when using the"
#~ " ``VirtualClientEngine`` (i.e. when you do"
#~ " ``fl.simulation.start_simulation``). In some "
#~ "situations you might want to save "
#~ "this log to disk. You can do "
#~ "so by calling the "
#~ "`fl.common.logger.configure() "
#~ "<https://github.com/adap/flower/blob/main/src/py/flwr/common/logger.py>`_"
#~ " function. For example:"
#~ msgstr ""
#~ "기본적으로 Flower 로그는 Federated 학습 워크로드를 "
#~ "실행하는 터미널에 출력됩니다. 이는 gRPC 기반 "
#~ "페더레이션(즉,:code:`fl.simulation.start_simulation`를 실행하는 경우)과"
#~ " :code:`VirtualClientEngine`을 사용하는 경우(즉, "
#~ ":코드:`fl.simulation.start_simulation`을 실행하는 경우) 모두에"
#~ " 적용됩니다. 경우에 따라 이 로그를 디스크에 저장하고"
#~ " 싶을 수도 있습니다. 이 경우 "
#~ "`fl.common.logger.configure() "
#~ "<https://github.com/adap/flower/blob/main/src/py/flwr/common/logger.py>`_"
#~ " 함수를 호출하여 저장할 수 있습니다. 예를 들어:"

#~ msgid ""
#~ "With the above, Flower will record "
#~ "the log you see on your terminal"
#~ " to ``log.txt``. This file will be"
#~ " created in the same directory as "
#~ "were you are running the code "
#~ "from. If we inspect we see the "
#~ "log above is also recorded but "
#~ "prefixing with ``identifier`` each line:"
#~ msgstr ""
#~ "위와 같이 하면 Flower는 터미널에 표시되는 로그를 "
#~ ":code:`log.txt`에 기록합니다. 이 파일은 코드를 실행한"
#~ " 디렉터리와 동일한 디렉터리에 생성됩니다. 검사해보면 위의 "
#~ "로그도 기록되지만 각 줄 앞에 :code:`identifier` "
#~ "접두사가 붙는 것을 확인할 수 있습니다:"

#~ msgid "Log your own messages"
#~ msgstr "나만의 메시지 기록"

#~ msgid ""
#~ "You might expand the information shown"
#~ " by default with the Flower logger"
#~ " by adding more messages relevant to"
#~ " your application. You can achieve "
#~ "this easily as follows."
#~ msgstr ""
#~ "애플리케이션과 관련된 메시지를 더 추가하여 Flower 로거에"
#~ " 기본적으로 표시되는 정보를 확장할 수 있습니다. 다음과"
#~ " 같이 쉽게 추가할 수 있습니다."

#~ msgid ""
#~ "In this way your logger will show,"
#~ " in addition to the default messages,"
#~ " the ones introduced by the clients"
#~ " as specified above."
#~ msgstr "이렇게 하면 로거에 기본 메시지 외에 위에서 지정한 대로 클라이언트가 소개한 메시지가 표시됩니다."

#~ msgid "Log to a remote service"
#~ msgstr "원격 서비스에 로그인"

#~ msgid ""
#~ "The ``fl.common.logger.configure`` function, also"
#~ " allows specifying a host to which"
#~ " logs can be pushed (via ``POST``)"
#~ " through a native Python "
#~ "``logging.handler.HTTPHandler``. This is a "
#~ "particularly useful feature in ``gRPC``-based"
#~ " Federated Learning workloads where "
#~ "otherwise gathering logs from all "
#~ "entities (i.e. the server and the "
#~ "clients) might be cumbersome. Note that"
#~ " in Flower simulation, the server "
#~ "automatically displays all logs. You can"
#~ " still specify a ``HTTPHandler`` should "
#~ "you wish to backup or analyze the"
#~ " logs somewhere else."
#~ msgstr ""
#~ "또한 :code:`fl.common.logger.configure` 함수를 사용하면 "
#~ "네이티브 Python :code:`logging.handler.HTTPHandler`를 통해"
#~ " 로그를 푸시할 수 있는 호스트를 지정할 수 "
#~ "있습니다(:code:`POST`를 통해). 이는 모든 엔티티(예: 서버"
#~ " 및 클라이언트)에서 로그를 수집하는 것이 번거로울 수"
#~ " 있는 :code:`gRPC` 기반 Federated 학습 "
#~ "워크로드에서 특히 유용한 기능입니다. Flower 시뮬레이션에서는 "
#~ "서버가 모든 로그를 자동으로 표시합니다. 로그를 다른 "
#~ "곳에 백업하거나 분석하려는 경우 :code:`HTTPHandler`를 "
#~ "지정할 수 있습니다."

#~ msgid "Monitor simulation"
#~ msgstr "모니터 시뮬레이션"

#~ msgid ""
#~ "Flower allows you to monitor system "
#~ "resources while running your simulation. "
#~ "Moreover, the Flower simulation engine "
#~ "is powerful and enables you to "
#~ "decide how to allocate resources per "
#~ "client manner and constrain the total"
#~ " usage. Insights from resource consumption"
#~ " can help you make smarter decisions"
#~ " and speed up the execution time."
#~ msgstr ""
#~ "Flower를 사용하면 시뮬레이션을 실행하는 동안 시스템 "
#~ "리소스를 모니터링할 수 있습니다. 또한 Flower 시뮬레이션"
#~ " 엔진은 강력하며 클라이언트별 리소스 할당 방법을 "
#~ "결정하고 총 사용량을 제한할 수 있습니다. 리소스 "
#~ "소비에 대한 인사이트를 통해 더 현명한 결정을 "
#~ "내리고 실행 시간을 단축할 수 있습니다."

#~ msgid ""
#~ "The specific instructions assume you are"
#~ " using macOS and have the `Homebrew"
#~ " <https://brew.sh/>`_ package manager installed."
#~ msgstr ""
#~ "구체적인 지침은 macOS를 사용 중이고 'Homebrew "
#~ "<https://brew.sh/>`_ 패키지 관리자가 설치되어 있다고 "
#~ "가정합니다."

#~ msgid "Downloads"
#~ msgstr "다운로드"

#~ msgid ""
#~ "`Prometheus <https://prometheus.io/>`_ is used "
#~ "for data collection, while `Grafana "
#~ "<https://grafana.com/>`_ will enable you to"
#~ " visualize the collected data. They "
#~ "are both well integrated with `Ray "
#~ "<https://www.ray.io/>`_ which Flower uses "
#~ "under the hood."
#~ msgstr ""
#~ "`Prometheus <https://prometheus.io/>`_는 데이터 수집에 "
#~ "사용되며, `Grafana <https://grafana.com/>`_는 수집된 "
#~ "데이터를 시각화할 수 있게 해줍니다. 이 두 도구는"
#~ " 모두 Flower가 내부적으로 사용하는 `Ray "
#~ "<https://www.ray.io/>`_와 잘 통합되어 있습니다."

#~ msgid ""
#~ "Overwrite the configuration files (depending"
#~ " on your device, it might be "
#~ "installed on a different path)."
#~ msgstr "구성 파일을 덮어씁니다(장치에 따라 다른 경로에 설치되어 있을 수 있음)."

#~ msgid "If you are on an M1 Mac, it should be:"
#~ msgstr "M1 Mac을 사용 중이라면:"

#~ msgid "On the previous generation Intel Mac devices, it should be:"
#~ msgstr "이전 세대 Intel Mac 장치에서는:"

#~ msgid ""
#~ "Open the respective configuration files "
#~ "and change them. Depending on your "
#~ "device, use one of the two "
#~ "following commands:"
#~ msgstr "각 구성 파일을 열고 변경합니다. 장치에 따라 다음 두 명령 중 하나를 사용합니다:"

#~ msgid ""
#~ "and then delete all the text in"
#~ " the file and paste a new "
#~ "Prometheus config you see below. You "
#~ "may adjust the time intervals to "
#~ "your requirements:"
#~ msgstr ""
#~ "를 입력한 다음 파일의 모든 텍스트를 삭제하고 "
#~ "아래에 표시된 새 Prometheus 설정을 붙여넣습니다. "
#~ "요구 사항에 따라 시간 간격을 조정할 수 있습니다:"

#~ msgid ""
#~ "Now after you have edited the "
#~ "Prometheus configuration, do the same "
#~ "with the Grafana configuration files. "
#~ "Open those using one of the "
#~ "following commands as before:"
#~ msgstr ""
#~ "이제 Prometheus 구성을 편집한 후 Grafana 구성"
#~ " 파일에 대해서도 동일한 작업을 수행합니다. 이전과 "
#~ "마찬가지로 다음 명령 중 하나를 사용하여 파일을 "
#~ "엽니다:"

#~ msgid ""
#~ "Your terminal editor should open and "
#~ "allow you to apply the following "
#~ "configuration as before."
#~ msgstr "터미널 편집기가 열리면 이전과 마찬가지로 다음 구성을 적용할 수 있습니다."

#~ msgid ""
#~ "Congratulations, you just downloaded all "
#~ "the necessary software needed for "
#~ "metrics tracking. Now, let’s start it."
#~ msgstr "축하합니다. 매트릭 트레킹에 필요한 모든 소프트웨어를 다운로드하셨습니다. 이제 시작해 보겠습니다."

#~ msgid "Tracking metrics"
#~ msgstr "매트릭 트래킹"

#~ msgid ""
#~ "Before running your Flower simulation, "
#~ "you have to start the monitoring "
#~ "tools you have just installed and "
#~ "configured."
#~ msgstr "Flower 시뮬레이션을 실행하기 전에 방금 설치 및 구성한 모니터링 도구를 시작해야 합니다."

#~ msgid ""
#~ "Please include the following argument in"
#~ " your Python code when starting a "
#~ "simulation."
#~ msgstr "시뮬레이션을 시작할 때 Python 코드에 다음 전달인자를 포함하세요."

#~ msgid "Now, you are ready to start your workload."
#~ msgstr "이제 워크로드를 시작할 준비가 되었습니다."

#~ msgid ""
#~ "Shortly after the simulation starts, you"
#~ " should see the following logs in "
#~ "your terminal:"
#~ msgstr "시뮬레이션이 시작되고 얼마 지나지 않아 터미널에 다음 로그가 표시됩니다:"

#~ msgid "You can look at everything at http://127.0.0.1:8265 ."
#~ msgstr "`<http://127.0.0.1:8265>`_ 에서 모든 것을 볼 수 있습니다."

#~ msgid ""
#~ "It's a Ray Dashboard. You can "
#~ "navigate to Metrics (on the left "
#~ "panel, the lowest option)."
#~ msgstr "Ray 대시보드입니다. 메트릭(왼쪽 패널의 가장 아래 옵션)으로 이동할 수 있습니다."

#~ msgid ""
#~ "Or alternatively, you can just see "
#~ "them in Grafana by clicking on the"
#~ " right-up corner, “View in Grafana”."
#~ " Please note that the Ray dashboard"
#~ " is only accessible during the "
#~ "simulation. After the simulation ends, "
#~ "you can only use Grafana to "
#~ "explore the metrics. You can start "
#~ "Grafana by going to "
#~ "``http://localhost:3000/``."
#~ msgstr ""
#~ "또는 오른쪽 위 모서리인 \"Grafana에서 보기\"를 "
#~ "클릭하여 Grafana에서 바로 확인할 수도 있습니다. Ray"
#~ " 대시보드는 시뮬레이션 중에만 액세스할 수 있다는 점에"
#~ " 유의하세요. 시뮬레이션이 종료된 후에는 Grafana를 사용하여"
#~ " 메트릭을 탐색할 수만 있습니다. "
#~ "``http://localhost:3000/``로 이동하여 Grafana를 시작할 "
#~ "수 있습니다."

#~ msgid ""
#~ "After you finish the visualization, stop"
#~ " Prometheus and Grafana. This is "
#~ "important as they will otherwise block,"
#~ " for example port ``3000`` on your"
#~ " machine as long as they are "
#~ "running."
#~ msgstr ""
#~ "시각화를 완료한 후에는 Prometheus와 Grafana를 중지합니다."
#~ " 그렇지 않으면 실행 중인 동안 컴퓨터에서 포트 "
#~ ":code:`3000` 등을 차단하므로 이 작업이 중요합니다."

#~ msgid "Resource allocation"
#~ msgstr "리소스 할당"

#~ msgid ""
#~ "You must understand how the Ray "
#~ "library works to efficiently allocate "
#~ "system resources to simulation clients "
#~ "on your own."
#~ msgstr "Ray 라이브러리가 어떻게 작동하는지 이해해야 시뮬레이션 클라이언트에 시스템 리소스를 효율적으로 할당할 수 있습니다."

#~ msgid ""
#~ "Initially, the simulation (which Ray "
#~ "handles under the hood) starts by "
#~ "default with all the available resources"
#~ " on the system, which it shares "
#~ "among the clients. It doesn't mean "
#~ "it divides it equally among all of"
#~ " them, nor that the model training"
#~ " happens at all of them "
#~ "simultaneously. You will learn more "
#~ "about that in the later part of"
#~ " this blog. You can check the "
#~ "system resources by running the "
#~ "following:"
#~ msgstr ""
#~ "처음에 시뮬레이션(Ray가 내부에서 처리하는)은 기본적으로 시스템에서"
#~ " 사용 가능한 모든 리소스를 사용하여 시작되며, 이"
#~ " 리소스는 클라이언트 간에 공유됩니다. 그렇다고 해서 "
#~ "모든 클라이언트에게 균등하게 분배하거나 모든 클라이언트에서 "
#~ "동시에 모델 학습이 이루어지는 것은 아닙니다. 이에 "
#~ "대한 자세한 내용은 이 블로그의 뒷부분에서 설명합니다. "
#~ "다음을 실행하여 시스템 리소스를 확인할 수 있습니다:"

#~ msgid "In Google Colab, the result you see might be similar to this:"
#~ msgstr "Google Colab에서는 이와 유사한 결과가 표시될 수 있습니다:"

#~ msgid ""
#~ "However, you can overwrite the defaults."
#~ " When starting a simulation, do the"
#~ " following (you don't need to "
#~ "overwrite all of them):"
#~ msgstr "그러나 기본값을 덮어쓸 수 있습니다. 시뮬레이션을 시작할 때 다음을 수행합니다(모두 덮어쓸 필요는 없음):"

#~ msgid "Let’s also specify the resource for a single client."
#~ msgstr "단일 클라이언트에 대한 리소스도 지정해 보겠습니다."

#~ msgid ""
#~ "Now comes the crucial part. Ray "
#~ "will start a new client only when"
#~ " it has all the required resources"
#~ " (such that they run in parallel) "
#~ "when the resources allow."
#~ msgstr ""
#~ "이제 중요한 부분이 나옵니다. Ray는 리소스가 허용하는"
#~ " 경우에만 필요한 모든 리소스가 있을 때(병렬로 실행되는"
#~ " 등) 새 클라이언트를 시작합니다."

#~ msgid ""
#~ "In the example above, only one "
#~ "client will be run, so your "
#~ "clients won't run concurrently. Setting "
#~ "``client_num_gpus = 0.5`` would allow "
#~ "running two clients and therefore enable"
#~ " them to run concurrently. Be careful"
#~ " not to require more resources than"
#~ " available. If you specified "
#~ "``client_num_gpus = 2``, the simulation "
#~ "wouldn't start (even if you had 2"
#~ " GPUs but decided to set 1 in"
#~ " ``ray_init_args``)."
#~ msgstr ""
#~ "위의 예에서는 하나의 클라이언트만 실행되므로 클라이언트가 "
#~ "동시에 실행되지 않습니다. :code:`client_num_gpus = "
#~ "0.5` 를 설정하면 두 개의 클라이언트를 실행할 "
#~ "수 있으므로 동시에 실행할 수 있습니다. 사용 "
#~ "가능한 리소스보다 더 많은 리소스를 요구하지 않도록 "
#~ "주의하세요. :code:`client_num_gpus = 2`를 지정하면 "
#~ "시뮬레이션이 시작되지 않습니다(GPU가 2개이지만 "
#~ ":code:`ray_init_args`에서 1개를 설정한 경우에도 마찬가지입니다)."

#~ msgid "Q: I don't see any metrics logged."
#~ msgstr "질문: 기록된 메트릭이 보이지 않습니다."

#~ msgid ""
#~ "A: The timeframe might not be "
#~ "properly set. The setting is in "
#~ "the top right corner (\"Last 30 "
#~ "minutes\" by default). Please change the"
#~ " timeframe to reflect the period when"
#~ " the simulation was running."
#~ msgstr ""
#~ "A: 기간이 제대로 설정되지 않았을 수 있습니다. "
#~ "설정은 오른쪽 상단에 있습니다(기본값은 '지난 30분'). "
#~ "시뮬레이션이 실행된 기간을 반영하도록 기간을 변경해 주세요."

#~ msgid ""
#~ "Q: I see “Grafana server not "
#~ "detected. Please make sure the Grafana"
#~ " server is running and refresh this"
#~ " page” after going to the Metrics "
#~ "tab in Ray Dashboard."
#~ msgstr ""
#~ "질문: \"Grafana 서버가 감지되지 않았습니다. Ray "
#~ "대시보드의 메트릭 탭으로 이동한 후 Grafana 서버가"
#~ " 실행 중인지 확인하고 이 페이지를 새로고침하세요.\"라는 "
#~ "메시지가 표시됩니다."

#~ msgid ""
#~ "A: You probably don't have Grafana "
#~ "running. Please check the running "
#~ "services"
#~ msgstr "A: Grafana가 실행되고 있지 않을 수 있습니다. 실행 중인 서비스를 확인하세요"

#~ msgid ""
#~ "Q: I see \"This site can't be "
#~ "reached\" when going to http://127.0.0.1:8265."
#~ msgstr ""
#~ "Q: `<http://127.0.0.1:8265>`_로 이동할 때 \"이 "
#~ "사이트에 연결할 수 없습니다.\"라는 메시지가 표시됩니다."

#~ msgid ""
#~ "A: Either the simulation has already "
#~ "finished, or you still need to "
#~ "start Prometheus."
#~ msgstr "A: 시뮬레이션이 이미 완료되었거나 아직 Prometheus를 시작해야 합니다."

#~ msgid "Resources"
#~ msgstr "리소스"

#~ msgid ""
#~ "Ray Dashboard: https://docs.ray.io/en/latest/ray-"
#~ "observability/getting-started.html"
#~ msgstr ""
#~ "Ray 대시보드: `<https://docs.ray.io/en/latest/ray-"
#~ "observability/getting-started.html>`_"

#~ msgid "Ray Metrics: https://docs.ray.io/en/latest/cluster/metrics.html"
#~ msgstr "Ray 메트릭: `<https://docs.ray.io/en/latest/cluster/metrics.html>`_"

#~ msgid ""
#~ "The ``VirtualClientEngine`` schedules, launches "
#~ "and manages `virtual` clients. These "
#~ "clients are identical to `non-virtual`"
#~ " clients (i.e. the ones you launch"
#~ " via the command `flwr.client.start_client "
#~ "<ref-api-flwr.html#start-client>`_) in the"
#~ " sense that they can be configure "
#~ "by creating a class inheriting, for "
#~ "example, from `flwr.client.NumPyClient <ref-"
#~ "api-flwr.html#flwr.client.NumPyClient>`_ and therefore"
#~ " behave in an identical way. In "
#~ "addition to that, clients managed by "
#~ "the ``VirtualClientEngine`` are:"
#~ msgstr ""
#~ ":code:`VirtualClientEngine`은 `virtual` 클라이언트를 예약,"
#~ " 실행 및 관리합니다. 이러한 클라이언트는 `non-"
#~ "virtual` 클라이언트(예: `flwr.client.start_client <ref-"
#~ "api-flwr.html#start-client>`_ 명령을 통해 "
#~ "실행하는 클라이언트)와 동일하며, `flwr.client.NumPyClient "
#~ "<ref-api-flwr.html#flwr.client.NumPyClient>`_에서 상속하는"
#~ " 클래스 생성으로 구성될 수 있으므로 동일한 방식으로"
#~ " 동작합니다. 그 외에도 :code:`VirtualClientEngine`에 "
#~ "의해 관리되는 클라이언트는 다음과 같습니다:"

#~ msgid ""
#~ "Running Flower simulations still require "
#~ "you to define your client class, a"
#~ " strategy, and utility functions to "
#~ "download and load (and potentially "
#~ "partition) your dataset. With that out"
#~ " of the way, launching your "
#~ "simulation is done with `start_simulation "
#~ "<ref-api-flwr.html#flwr.simulation.start_simulation>`_ "
#~ "and a minimal example looks as "
#~ "follows:"
#~ msgstr ""
#~ "Flower 시뮬레이션을 실행하려면 여전히 클라이언트 클래스, "
#~ "전략 및 유틸리티 함수를 정의하여 데이터 세트를 "
#~ "다운로드하고 로드(및 파티션)해야 합니다. 이 작업을 마친"
#~ " 후 시뮬레이션을 시작하려면 `start_simulation <ref-"
#~ "api-flwr.html#flwr.simulation.start_simulation>`_을 사용하면"
#~ " 되며, 최소한의 예시는 다음과 같습니다:"

#~ msgid ""
#~ "By default the VCE has access to"
#~ " all system resources (i.e. all CPUs,"
#~ " all GPUs, etc) since that is "
#~ "also the default behavior when starting"
#~ " Ray. However, in some settings you"
#~ " might want to limit how many "
#~ "of your system resources are used "
#~ "for simulation. You can do this "
#~ "via the ``ray_init_args`` input argument "
#~ "to ``start_simulation`` which the VCE "
#~ "internally passes to Ray's ``ray.init`` "
#~ "command. For a complete list of "
#~ "settings you can configure check the "
#~ "`ray.init <https://docs.ray.io/en/latest/ray-"
#~ "core/api/doc/ray.init.html#ray-init>`_ documentation. "
#~ "Do not set ``ray_init_args`` if you "
#~ "want the VCE to use all your "
#~ "system's CPUs and GPUs."
#~ msgstr ""
#~ "기본적으로 VCE는 모든 시스템 리소스(예: 모든 CPU,"
#~ " 모든 GPU 등)에 액세스할 수 있으며, 이는 "
#~ "Ray를 시작할 때의 기본 동작이기도 합니다. 그러나 "
#~ "일부 설정에서는 시뮬레이션에 사용되는 시스템 리소스의 수를"
#~ " 제한하고 싶을 수 있습니다. 이 설정은 VCE가 "
#~ "내부적으로 Ray의 :code:`ray.init` 명령에 전달하는 "
#~ ":code:`start_simulation`에 대한 :code:`ray_init_args` "
#~ "입력 인수를 통해 수행할 수 있습니다. 구성할 수"
#~ " 있는 전체 설정 목록은 `ray.init "
#~ "<https://docs.ray.io/en/latest/ray-core/api/doc/ray.init.html"
#~ "#ray-init>`_ 설명서를 확인하세요. VCE가 시스템의 모든"
#~ " CPU와 GPU를 사용하도록 하려면 :code:`ray_init_args`를"
#~ " 설정하지 마세요."

#~ msgid ""
#~ "By default the ``VirtualClientEngine`` assigns"
#~ " a single CPU core (and nothing "
#~ "else) to each virtual client. This "
#~ "means that if your system has 10"
#~ " cores, that many virtual clients can"
#~ " be concurrently running."
#~ msgstr ""
#~ "기본적으로 :code:`VirtualClientEngine`은 각 가상 클라이언트에"
#~ " 단일 CPU 코어를 할당합니다(그 외에는 아무것도 "
#~ "할당하지 않음). 즉, 시스템에 코어가 10개인 경우 "
#~ "그만큼 많은 가상 클라이언트를 동시에 실행할 수 "
#~ "있습니다."

#~ msgid "``num_cpus`` indicates the number of CPU cores a client would get."
#~ msgstr ":code:`num_cpus`는 클라이언트에서 사용할 수 있는 CPU 코어 수를 나타냅니다."

#~ msgid ""
#~ "``num_gpus`` indicates the **ratio** of "
#~ "GPU memory a client gets assigned."
#~ msgstr ":code:`num_gpus`는 클라이언트에 할당되는 GPU 메모리의 **비율**을 나타냅니다."

#~ msgid "Let's see a few examples:"
#~ msgstr "몇 가지 예를 살펴보겠습니다:"

#~ msgid ""
#~ "To understand all the intricate details"
#~ " on how resources are used to "
#~ "schedule FL clients and how to "
#~ "define custom resources, please take a"
#~ " look at the `Ray documentation "
#~ "<https://docs.ray.io/en/latest/ray-"
#~ "core/scheduling/resources.html>`_."
#~ msgstr ""
#~ "리소스가 FL 클라이언트를 예약하는 데 사용되는 방법과 "
#~ "사용자 지정 리소스를 정의하는 방법에 대한 모든 "
#~ "복잡한 세부 사항을 이해하려면 'Ray 문서 "
#~ "<https://docs.ray.io/en/latest/ray-"
#~ "core/scheduling/resources.html>'를 참조하세요."

#~ msgid ""
#~ "A few ready-to-run complete "
#~ "examples for Flower simulation in "
#~ "Tensorflow/Keras and PyTorch are provided "
#~ "in the `Flower repository "
#~ "<https://github.com/adap/flower>`_. You can run "
#~ "them on Google Colab too:"
#~ msgstr ""
#~ "Tensorflow/Keras와 파이토치에서 바로 실행할 수 있는 "
#~ "몇 가지 Flower 시뮬레이션 예제는 `Flower "
#~ "레포지토리 <https://github.com/adap/flower>`_에서 제공됩니다. "
#~ "Google Colab에서도 실행할 수 있습니다:"

#~ msgid ""
#~ "`Tensorflow/Keras Simulation "
#~ "<https://github.com/adap/flower/tree/main/examples/simulation-"
#~ "tensorflow>`_: 100 clients collaboratively "
#~ "train a MLP model on MNIST."
#~ msgstr ""
#~ "`Tensorflow/Keras 시뮬레이션 "
#~ "<https://github.com/adap/flower/tree/main/examples/simulation-"
#~ "tensorflow>`_: 100개의 클라이언트가 공동으로 MNIST에서 "
#~ "MLP 모델을 훈련합니다."

#~ msgid ""
#~ "Have a copy of your dataset in "
#~ "all nodes (more about this in "
#~ ":ref:`simulation considerations <considerations-"
#~ "for-simulations>`)"
#~ msgstr ""
#~ "모든 노드에 데이터 세트의 사본을 보유하세요(자세한 내용은"
#~ " :ref:`simulation considerations <considerations-"
#~ "for-simulations>`에서 확인하세요)"

#~ msgid ""
#~ "Pass ``ray_init_args={\"address\"=\"auto\"}`` to "
#~ "`start_simulation <ref-api-"
#~ "flwr.html#flwr.simulation.start_simulation>`_ so the "
#~ "``VirtualClientEngine`` attaches to a running"
#~ " Ray instance."
#~ msgstr ""
#~ ":code:`ray_init_args={\"address\"=\"auto\"}`를 `start_simulation"
#~ " <ref-api-"
#~ "flwr.html#flwr.simulation.start_simulation>`_에 전달하여 "
#~ ":code:`VirtualClientEngine`이 실행 중인 Ray 인스턴스에"
#~ " 연결되도록 합니다."

#~ msgid "Multi-node simulation good-to-know"
#~ msgstr "멀티 노드 시뮬레이션에 대해 알아두면 좋은 사항"

#~ msgid ""
#~ "Here we list a few interesting "
#~ "functionality when running multi-node FL"
#~ " simulations:"
#~ msgstr "여기에서는 멀티 노드 FL 시뮬레이션을 실행할 때 흥미로운 몇 가지 기능을 나열합니다:"

#~ msgid ""
#~ "User ``ray status`` to check all "
#~ "nodes connected to your head node "
#~ "as well as the total resources "
#~ "available to the ``VirtualClientEngine``."
#~ msgstr ""
#~ "사용자는 :code:`ray status`를 통해 헤드 노드에 "
#~ "연결된 모든 노드와 :code:`VirtualClientEngine`에 사용 "
#~ "가능한 총 리소스를 확인할 수 있습니다."

#~ msgid "Considerations for simulations"
#~ msgstr "시뮬레이션 시 고려 사항"

#~ msgid ""
#~ "We are actively working on these "
#~ "fronts so to make it trivial to"
#~ " run any FL workload with Flower "
#~ "simulation."
#~ msgstr "Flower 시뮬레이션으로 모든 FL 워크로드를 간편하게 실행할 수 있도록 이러한 측면에서 적극적으로 노력하고 있습니다."

#~ msgid ""
#~ "The current VCE allows you to run"
#~ " Federated Learning workloads in simulation"
#~ " mode whether you are prototyping "
#~ "simple scenarios on your personal laptop"
#~ " or you want to train a complex"
#~ " FL pipeline across multiple high-"
#~ "performance GPU nodes. While we add "
#~ "more capabilities to the VCE, the "
#~ "points below highlight some of the "
#~ "considerations to keep in mind when "
#~ "designing your FL pipeline with Flower."
#~ " We also highlight a couple of "
#~ "current limitations in our implementation."
#~ msgstr ""
#~ "현재 VCE를 사용하면 개인 노트북에서 간단한 시나리오를"
#~ " 프로토타이핑하든, 여러 고성능 GPU 노드에서 복잡한 "
#~ "FL 파이프라인을 훈련하든 상관없이 시뮬레이션 모드에서 "
#~ "Federated 학습 워크로드를 실행할 수 있습니다. "
#~ "VCE에 더 많은 기능을 추가하는 동안, 아래에서는 "
#~ "Flower로 FL 파이프라인을 설계할 때 염두에 두어야"
#~ " 할 몇 가지 사항을 강조합니다. 또한 현재 "
#~ "구현에서 몇 가지 제한 사항을 강조합니다."

#~ msgid "GPU resources"
#~ msgstr "GPU 리소스"

#~ msgid ""
#~ "The VCE assigns a share of GPU "
#~ "memory to a client that specifies "
#~ "the key ``num_gpus`` in ``client_resources``."
#~ " This being said, Ray (used "
#~ "internally by the VCE) is by "
#~ "default:"
#~ msgstr ""
#~ "VCE는 :code:`client_resources`에서 :code:`num_gpus` 키를"
#~ " 지정하는 클라이언트에 GPU 메모리 공유를 할당합니다. "
#~ "즉, (VCE에서 내부적으로 사용하는) Ray가 기본적으로 "
#~ "사용됩니다:"

#~ msgid ""
#~ "not aware of the total VRAM "
#~ "available on the GPUs. This means "
#~ "that if you set ``num_gpus=0.5`` and "
#~ "you have two GPUs in your system"
#~ " with different (e.g. 32GB and 8GB)"
#~ " VRAM amounts, they both would run"
#~ " 2 clients concurrently."
#~ msgstr ""
#~ "GPU에서 사용 가능한 총 VRAM을 인식하지 못합니다."
#~ " 즉, 시스템에 서로 다른(예: 32GB와 8GB) "
#~ "VRAM 용량을 가진 두 개의 GPU가 있고 "
#~ ":code:`num_gpus=0.5`를 설정하면 둘 다 동시에 2개의"
#~ " 클라이언트를 실행하게 됩니다."

#~ msgid ""
#~ "not aware of other unrelated (i.e. "
#~ "not created by the VCE) workloads "
#~ "are running on the GPU. Two "
#~ "takeaways from this are:"
#~ msgstr ""
#~ "관련 없는(즉, VCE에 의해 생성되지 않은) 다른 "
#~ "워크로드가 GPU에서 실행되고 있는지 알지 못합니다. 여기서"
#~ " 두 가지 시사점을 얻을 수 있습니다:"

#~ msgid ""
#~ "Your Flower server might need a "
#~ "GPU to evaluate the `global model` "
#~ "after aggregation (by instance when "
#~ "making use of the `evaluate method "
#~ "<how-to-implement-strategies.html#the-"
#~ "evaluate-method>`_)"
#~ msgstr ""
#~ "집계 후 '글로벌 모델'을 평가하려면 Flower 서버에"
#~ " GPU가 필요할 수 있습니다(예: `evaluate method"
#~ " <how-to-implement-strategies.html#the-"
#~ "evaluate-method>`_를 사용할 때)"

#~ msgid ""
#~ "If you want to run several "
#~ "independent Flower simulations on the "
#~ "same machine you need to mask-out"
#~ " your GPUs with "
#~ "``CUDA_VISIBLE_DEVICES=\"<GPU_IDs>\"`` when launching "
#~ "your experiment."
#~ msgstr ""
#~ "동일한 머신에서 여러 개의 독립적인 Flower 시뮬레이션을"
#~ " 실행하려면, 실험을 시작할 때 "
#~ ":code:`CUDA_VISIBLE_DEVICES=\"<GPU_IDs>\"`로 GPU를 마스킹해야 "
#~ "합니다."

#~ msgid ""
#~ "In addition, the GPU resource limits "
#~ "passed to ``client_resources`` are not "
#~ "`enforced` (i.e. they can be exceeded)"
#~ " which can result in the situation"
#~ " of client using more VRAM than "
#~ "the ratio specified when starting the"
#~ " simulation."
#~ msgstr ""
#~ "또한 :code:`client_resources`에 전달된 GPU 리소스 "
#~ "제한이 '강제'되지 않아(즉, 초과할 수 있음) 클라이언트가"
#~ " 시뮬레이션을 시작할 때 지정된 비율보다 더 많은 "
#~ "VRAM을 사용하는 상황이 발생할 수 있습니다."

#~ msgid "TensorFlow with GPUs"
#~ msgstr "GPU를 사용한 TensorFlow"

#~ msgid ""
#~ "When `using a GPU with TensorFlow "
#~ "<https://www.tensorflow.org/guide/gpu>`_ nearly your "
#~ "entire GPU memory of all your GPUs"
#~ " visible to the process will be "
#~ "mapped. This is done by TensorFlow "
#~ "for optimization purposes. However, in "
#~ "settings such as FL simulations where"
#~ " we want to split the GPU into"
#~ " multiple `virtual` clients, this is "
#~ "not a desirable mechanism. Luckily we"
#~ " can disable this default behavior by"
#~ " `enabling memory growth "
#~ "<https://www.tensorflow.org/guide/gpu#limiting_gpu_memory_growth>`_."
#~ msgstr ""
#~ "`TensorFlow와 함께 GPU를 사용 "
#~ "<https://www.tensorflow.org/guide/gpu>`_하면 프로세스에 보이는 "
#~ "모든 GPU의 거의 전체 GPU 메모리가 매핑됩니다. "
#~ "이는 최적화 목적으로 TensorFlow에서 수행됩니다. 그러나 "
#~ "GPU를 여러 개의 '가상' 클라이언트로 분할하려는 FL"
#~ " 시뮬레이션과 같은 설정에서는 이는 바람직한 메커니즘이 "
#~ "아닙니다. 다행히도 '메모리 증가 활성화 "
#~ "<https://www.tensorflow.org/guide/gpu#limiting_gpu_memory_growth>`_'를"
#~ " 통해 이 기본 동작을 비활성화할 수 있습니다."

#~ msgid ""
#~ "This would need to be done in "
#~ "the main process (which is where "
#~ "the server would run) and in each"
#~ " Actor created by the VCE. By "
#~ "means of ``actor_kwargs`` we can pass"
#~ " the reserved key `\"on_actor_init_fn\"` in"
#~ " order to specify a function to "
#~ "be executed upon actor initialization. "
#~ "In this case, to enable GPU growth"
#~ " for TF workloads. It would look "
#~ "as follows:"
#~ msgstr ""
#~ "이 작업은 메인 프로세스(서버가 실행되는 곳)와 VCE에서"
#~ " 생성한 각 액터에서 수행해야 합니다. "
#~ ":code:`actor_kwargs`를 통해 예약 키 "
#~ "`\"on_actor_init_fn\"`을 전달하여 액터 초기화 시 "
#~ "실행할 함수를 지정할 수 있습니다. 이 경우 TF"
#~ " 워크로드에 대한 GPU 증가를 활성화합니다. 다음과 "
#~ "같이 보입니다:"

#~ msgid "Multi-node setups"
#~ msgstr "멀티 노드 설정"

#~ msgid ""
#~ "The VCE does not currently offer a"
#~ " way to control on which node a"
#~ " particular `virtual` client is executed."
#~ " In other words, if more than a"
#~ " single node have the resources "
#~ "needed by a client to run, then"
#~ " any of those nodes could get "
#~ "the client workload scheduled onto. "
#~ "Later in the FL process (i.e. in"
#~ " a different round) the same client"
#~ " could be executed by a different "
#~ "node. Depending on how your clients "
#~ "access their datasets, this might "
#~ "require either having a copy of "
#~ "all dataset partitions on all nodes "
#~ "or a dataset serving mechanism (e.g. "
#~ "using nfs, a database) to circumvent "
#~ "data duplication."
#~ msgstr ""
#~ "VCE는 현재 특정 '가상' 클라이언트를 어느 노드에서 "
#~ "실행할지 제어하는 방법을 제공하지 않습니다. 즉, 클라이언트가"
#~ " 실행하는 데 필요한 리소스가 하나 이상의 노드에 "
#~ "있는 경우 해당 노드 중 어느 노드에나 클라이언트"
#~ " 워크로드가 예약될 수 있습니다. FL 프로세스 "
#~ "후반부(즉, 다른 라운드에서)에는 동일한 클라이언트가 다른 "
#~ "노드에서 실행될 수 있습니다. 클라이언트가 데이터 세트에"
#~ " 액세스하는 방식에 따라 모든 노드에 모든 데이터 "
#~ "세트 파티션의 복사본을 보유하거나 데이터 중복을 피하기 "
#~ "위해 데이터 세트 제공 메커니즘(예: nfs, 데이터베이스"
#~ " 사용)을 사용해야 할 수 있습니다."

#~ msgid ""
#~ "By definition virtual clients are "
#~ "`stateless` due to their ephemeral "
#~ "nature. A client state can be "
#~ "implemented as part of the Flower "
#~ "client class but users need to "
#~ "ensure this saved to persistent storage"
#~ " (e.g. a database, disk) and that "
#~ "can be retrieve later by the same"
#~ " client regardless on which node it"
#~ " is running from. This is related "
#~ "to the point above also since, in"
#~ " some way, the client's dataset could"
#~ " be seen as a type of `state`."
#~ msgstr ""
#~ "정의상 가상 클라이언트는 임시적 특성으로 인해 '상태 "
#~ "없음'입니다. 클라이언트 상태는 Flower 클라이언트 클래스의 "
#~ "일부로 구현할 수 있지만, 사용자는 이를 영구 "
#~ "저장소(예: 데이터베이스, 디스크)에 저장하여 나중에 실행 "
#~ "중인 노드와 관계없이 동일한 클라이언트가 검색할 수 "
#~ "있도록 해야 합니다. 이는 어떤 식으로든 클라이언트의 "
#~ "데이터 세트가 일종의 '상태'로 볼 수 있기 때문에"
#~ " 위의 요점과도 관련이 있습니다."

#~ msgid ""
#~ "This creates a strategy with all "
#~ "parameters left at their default values"
#~ " and passes it to the "
#~ "``start_server`` function. It is usually "
#~ "recommended to adjust a few parameters"
#~ " during instantiation:"
#~ msgstr ""
#~ "이렇게 하면 모든 매개변수가 기본값으로 유지된 전략이 "
#~ "생성되어 :code:`start_server` 함수에 전달됩니다. 일반적으로 "
#~ "인스턴스화 중에 몇 가지 매개변수를 조정하는 것이 "
#~ "좋습니다:"

#~ msgid "Legacy example guides"
#~ msgstr "레거시 예제 가이드"

#~ msgid "flwr is the Flower command line interface."
#~ msgstr "Flower ClientProxy 인스턴스 등록 해제."

#~ msgid "Options"
#~ msgstr "해결법"

#~ msgid "Install completion for the current shell."
#~ msgstr "현재 실행에 대한 식별자입니다."

#~ msgid ""
#~ "Show completion for the current shell,"
#~ " to copy it or customize the "
#~ "installation."
#~ msgstr ""

#~ msgid "Build a Flower App into a Flower App Bundle (FAB)."
#~ msgstr ""

#~ msgid ""
#~ "You can run ``flwr build`` without "
#~ "any arguments to bundle the app "
#~ "located in the current directory. "
#~ "Alternatively, you can you can specify"
#~ " a path using the ``--app`` option"
#~ " to bundle an app located at "
#~ "the provided path. For example:"
#~ msgstr ""

#~ msgid "``flwr build --app ./apps/flower-hello-world``."
#~ msgstr ""

#~ msgid "Path of the Flower App to bundle into a FAB"
#~ msgstr ""

#~ msgid "Install a Flower App Bundle."
#~ msgstr "Flower 설치"

#~ msgid "It can be ran with a single FAB file argument:"
#~ msgstr ""

#~ msgid "``flwr install ./target_project.fab``"
#~ msgstr ""

#~ msgid "The target install directory can be specified with ``--flwr-dir``:"
#~ msgstr ""

#~ msgid "``flwr install ./target_project.fab --flwr-dir ./docs/flwr``"
#~ msgstr ""

#~ msgid ""
#~ "This will install ``target_project`` to "
#~ "``./docs/flwr/``. By default, ``flwr-dir`` "
#~ "is equal to:"
#~ msgstr ""

#~ msgid "``$FLWR_HOME/`` if ``$FLWR_HOME`` is defined"
#~ msgstr ""

#~ msgid "``$XDG_DATA_HOME/.flwr/`` if ``$XDG_DATA_HOME`` is defined"
#~ msgstr ""

#~ msgid "``$HOME/.flwr/`` in all other cases"
#~ msgstr ""

#~ msgid "The desired install path."
#~ msgstr ""

#~ msgid "Optional argument"
#~ msgstr "선택적 개선 사항"

#~ msgid "The source FAB file to install."
#~ msgstr ""

#~ msgid "Get logs from a Flower project run."
#~ msgstr ""

#~ msgid "Flag to stream or print logs from the Flower run"
#~ msgstr ""

#~ msgid "default"
#~ msgstr ""

#~ msgid "``True``"
#~ msgstr "``DISTRO``"

#~ msgid "Required argument"
#~ msgstr "빌드 전달인자"

#~ msgid "The Flower run ID to query"
#~ msgstr "Flower 커뮤니티 가입하기"

#~ msgid "Path of the Flower project to run"
#~ msgstr ""

#~ msgid "Name of the federation to run the app on"
#~ msgstr ""

#~ msgid "Create new Flower App."
#~ msgstr "Flower 서버를 실행하세요."

#~ msgid "The ML framework to use"
#~ msgstr ""

#~ msgid "options"
#~ msgstr "해결법"

#~ msgid ""
#~ "PyTorch | TensorFlow | sklearn | "
#~ "HuggingFace | JAX | MLX | NumPy"
#~ " | FlowerTune | Flower Baseline"
#~ msgstr ""

#~ msgid "The Flower username of the author"
#~ msgstr ""

#~ msgid "The name of the Flower App"
#~ msgstr "Flower 기본 이미지의 태그."

#~ msgid "Run Flower App."
#~ msgstr "Flower 서버를 실행하세요."

#~ msgid "Override configuration key-value pairs, should be of the format:"
#~ msgstr ""

#~ msgid ""
#~ "`--run-config 'key1=\"value1\" key2=\"value2\"' "
#~ "--run-config 'key3=\"value3\"'`"
#~ msgstr ""

#~ msgid ""
#~ "Note that `key1`, `key2`, and `key3` "
#~ "in this example need to exist "
#~ "inside the `pyproject.toml` in order to"
#~ " be properly overriden."
#~ msgstr ""

#~ msgid ""
#~ "Use `--stream` with `flwr run` to "
#~ "display logs; logs are not streamed "
#~ "by default."
#~ msgstr ""

#~ msgid "``False``"
#~ msgstr "``flwr/base``"

#~ msgid "Path of the Flower App to run."
#~ msgstr "Flower 기본 이미지의 태그."

#~ msgid "Name of the federation to run the app on."
#~ msgstr ""

#~ msgid ""
#~ "Note that since version ``1.11.0``, "
#~ "``flower-server-app`` no longer supports"
#~ " passing a reference to a `ServerApp`"
#~ " attribute. Instead, you need to pass"
#~ " the path to Flower app via the"
#~ " argument ``--app``. This is the path"
#~ " to a directory containing a "
#~ "`pyproject.toml`. You can create a valid"
#~ " Flower app by executing ``flwr new``"
#~ " and following the prompt."
#~ msgstr ""

#~ msgid ""
#~ "A config (key/value mapping) held by "
#~ "the entity in a given run and "
#~ "that will stay local. It can be"
#~ " used at any point during the "
#~ "lifecycle of this entity (e.g. across"
#~ " multiple rounds)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`RUN_SUPEREXEC_ENTER "
#~ "<flwr.common.EventType.RUN_SUPEREXEC_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SUPERNODE_ENTER "
#~ "<flwr.common.EventType.RUN_SUPERNODE_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_SUPEREXEC_LEAVE "
#~ "<flwr.common.EventType.RUN_SUPEREXEC_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SUPERNODE_LEAVE "
#~ "<flwr.common.EventType.RUN_SUPERNODE_LEAVE>`\\"

#~ msgid "Log error stating that module `ray` could not be imported."
#~ msgstr ""

#~ msgid ""
#~ "This tutorial will show you how to"
#~ " use Flower to build a federated "
#~ "version of an existing JAX workload. "
#~ "We are using JAX to train a "
#~ "linear regression model on a scikit-"
#~ "learn dataset. We will structure the "
#~ "example similar to our `PyTorch - "
#~ "From Centralized To Federated "
#~ "<https://github.com/adap/flower/blob/main/examples/pytorch-"
#~ "from-centralized-to-federated>`_ walkthrough. "
#~ "First, we build a centralized training"
#~ " approach based on the `Linear "
#~ "Regression with JAX "
#~ "<https://coax.readthedocs.io/en/latest/examples/linear_regression/jax.html>`_"
#~ " tutorial`. Then, we build upon the"
#~ " centralized training code to run the"
#~ " training in a federated fashion."
#~ msgstr ""
#~ "이 튜토리얼에서는 Flower를 사용하여 기존 JAX "
#~ "워크로드의 연합 버전을 구축하는 방법을 보여드립니다. JAX를"
#~ " 사용해 scikit-learn 데이터 세트에서 선형 "
#~ "회귀 모델을 훈련하고 있습니다. 예제는 '파이토치 - "
#~ "Centralized에서 Federated으로 "
#~ "<https://github.com/adap/flower/blob/main/examples/pytorch-"
#~ "from-centralized-to-federated>`_ 워크스루와 유사하게"
#~ " 구성하겠습니다. 먼저, `JAX를 사용한 선형 회귀 "
#~ "<https://coax.readthedocs.io/en/latest/examples/linear_regression/jax.html>`_"
#~ " 튜토리얼`을 기반으로 centralized 학습 접근 방식을"
#~ " 구축합니다. 그런 다음 centralized 트레이닝 코드를"
#~ " 기반으로 federated 방식으로 트레이닝을 실행합니다."

#~ msgid ""
#~ "Before we start building our JAX "
#~ "example, we need install the packages"
#~ " ``jax``, ``jaxlib``, ``scikit-learn``, and"
#~ " ``flwr``:"
#~ msgstr ""
#~ "JAX 예제 빌드를 시작하기 전에 :code:`jax`, "
#~ ":code:`jaxlib`, :code:`scikit-learn`, :code:`flwr`"
#~ " 패키지를 설치해야 합니다:"

#~ msgid "Linear Regression with JAX"
#~ msgstr "JAX를 사용한 선형 회귀"

#~ msgid ""
#~ "We begin with a brief description "
#~ "of the centralized training code based"
#~ " on a ``Linear Regression`` model. If"
#~ " you want a more in-depth "
#~ "explanation of what's going on then "
#~ "have a look at the official `JAX"
#~ " documentation <https://jax.readthedocs.io/>`_."
#~ msgstr ""
#~ "먼저 :code:`선형 회귀` 모델을 기반으로 하는 중앙"
#~ " 집중식 훈련 코드에 대한 간략한 설명부터 "
#~ "시작하겠습니다. 더 자세한 설명을 원하시면 공식 `JAX"
#~ " 문서 <https://jax.readthedocs.io/>`_를 참조하세요."

#~ msgid ""
#~ "Let's create a new file called "
#~ "``jax_training.py`` with all the components"
#~ " required for a traditional (centralized)"
#~ " linear regression training. First, the "
#~ "JAX packages ``jax`` and ``jaxlib`` need"
#~ " to be imported. In addition, we "
#~ "need to import ``sklearn`` since we "
#~ "use ``make_regression`` for the dataset "
#~ "and ``train_test_split`` to split the "
#~ "dataset into a training and test "
#~ "set. You can see that we do "
#~ "not yet import the ``flwr`` package "
#~ "for federated learning. This will be "
#~ "done later."
#~ msgstr ""
#~ "전통적인(중앙 집중식) 선형 회귀 훈련에 필요한 모든 "
#~ "구성 요소가 포함된 :code:`jax_training.py`라는 새 "
#~ "파일을 생성해 보겠습니다. 먼저, JAX 패키지인 "
#~ ":code:`jax`와 :code:`jaxlib`를 가져와야 합니다. 또한 "
#~ "데이터 세트에 :code:`make_regression`을 사용하고 데이터 "
#~ "세트를 학습 및 테스트 세트로 분할하기 위해 "
#~ ":code:`train_test_split`을 사용하므로 :code:`sklearn`을 "
#~ "가져와야 합니다. 연합 학습을 위해 아직 "
#~ ":code:`flwr` 패키지를 가져오지 않은 것을 볼 수"
#~ " 있습니다. 이 작업은 나중에 수행됩니다."

#~ msgid ""
#~ "The ``load_data()`` function loads the "
#~ "mentioned training and test sets."
#~ msgstr "code:`load_data()` 함수는 앞서 언급한 트레이닝 및 테스트 세트를 로드합니다."

#~ msgid ""
#~ "The model architecture (a very simple"
#~ " ``Linear Regression`` model) is defined"
#~ " in ``load_model()``."
#~ msgstr "모델 아키텍처(매우 간단한 :code:`선형 회귀` 모델)는 :code:`load_model()`에 정의되어 있습니다."

#~ msgid ""
#~ "We now need to define the training"
#~ " (function ``train()``), which loops over"
#~ " the training set and measures the"
#~ " loss (function ``loss_fn()``) for each "
#~ "batch of training examples. The loss "
#~ "function is separate since JAX takes "
#~ "derivatives with a ``grad()`` function "
#~ "(defined in the ``main()`` function and"
#~ " called in ``train()``)."
#~ msgstr ""
#~ "이제 훈련 집합을 반복하고 각 훈련 예제 배치에"
#~ " 대해 손실을 측정하는(함수 :code:`loss_fn()`) 훈련(함수"
#~ " :code:`train()`)을 정의해야 합니다. JAX는 "
#~ ":code:`grad()` 함수(:code:`main()` 함수에 정의되고 "
#~ ":code:`train()`에서 호출됨)로 파생물을 취하므로 손실 함수는"
#~ " 분리되어 있습니다."

#~ msgid ""
#~ "The evaluation of the model is "
#~ "defined in the function ``evaluation()``. "
#~ "The function takes all test examples "
#~ "and measures the loss of the "
#~ "linear regression model."
#~ msgstr ""
#~ "모델의 평가는 :code:`evaluation()` 함수에 정의되어 "
#~ "있습니다. 이 함수는 모든 테스트 예제를 가져와 "
#~ "선형 회귀 모델의 손실을 측정합니다."

#~ msgid ""
#~ "Having defined the data loading, model"
#~ " architecture, training, and evaluation we"
#~ " can put everything together and "
#~ "train our model using JAX. As "
#~ "already mentioned, the ``jax.grad()`` function"
#~ " is defined in ``main()`` and passed"
#~ " to ``train()``."
#~ msgstr ""
#~ "데이터 로딩, 모델 아키텍처, 훈련 및 평가를 "
#~ "정의했으므로 이제 모든 것을 종합하여 JAX를 사용 "
#~ "모델을 훈련할 수 있습니다. 이미 언급했듯이 "
#~ ":code:`jax.grad()` 함수는 :code:`main()`에 정의되어 "
#~ ":code:`train()`에 전달됩니다."

#~ msgid "You can now run your (centralized) JAX linear regression workload:"
#~ msgstr "이제 (중앙 집중식) JAX 선형 회귀 워크로드를 실행할 수 있습니다:"

#~ msgid ""
#~ "So far this should all look fairly"
#~ " familiar if you've used JAX before."
#~ " Let's take the next step and "
#~ "use what we've built to create a"
#~ " simple federated learning system "
#~ "consisting of one server and two "
#~ "clients."
#~ msgstr ""
#~ "지금까지는 JAX를 사용해 본 적이 있다면 이 모든"
#~ " 것이 상당히 익숙해 보일 것입니다. 다음 단계로 "
#~ "넘어가서 우리가 구축한 것을 사용하여 하나의 서버와 "
#~ "두 개의 클라이언트로 구성된 간단한 연합 학습 "
#~ "시스템을 만들어 보겠습니다."

#~ msgid "JAX meets Flower"
#~ msgstr "JAX와 Flower의 만남"

#~ msgid ""
#~ "The concept of federating an existing"
#~ " workload is always the same and "
#~ "easy to understand. We have to "
#~ "start a *server* and then use the"
#~ " code in ``jax_training.py`` for the "
#~ "*clients* that are connected to the "
#~ "*server*. The *server* sends model "
#~ "parameters to the clients. The *clients*"
#~ " run the training and update the "
#~ "parameters. The updated parameters are "
#~ "sent back to the *server*, which "
#~ "averages all received parameter updates. "
#~ "This describes one round of the "
#~ "federated learning process, and we "
#~ "repeat this for multiple rounds."
#~ msgstr ""
#~ "기존 워크로드를 연합하는 개념은 항상 동일하고 이해하기 "
#~ "쉽습니다. 서버*를 시작한 다음 *서버*에 연결된 "
#~ "*클라이언트*에 대해 :code:`jax_training.py`의 코드를 사용해야"
#~ " 합니다. *서버*는 모델 파라미터를 클라이언트로 전송합니다."
#~ " 클라이언트는 학습을 실행하고 파라미터를 업데이트합니다. 업데이트된"
#~ " 파라미터는 *서버*로 다시 전송되며, 수신된 모든 "
#~ "파라미터 업데이트의 평균을 구합니다. 이는 연합 학습 "
#~ "프로세스의 한 라운드를 설명하며, 이 과정을 여러 "
#~ "라운드에 걸쳐 반복합니다."

#~ msgid ""
#~ "Finally, we will define our *client* "
#~ "logic in ``client.py`` and build upon"
#~ " the previously defined JAX training "
#~ "in ``jax_training.py``. Our *client* needs "
#~ "to import ``flwr``, but also ``jax`` "
#~ "and ``jaxlib`` to update the parameters"
#~ " on our JAX model:"
#~ msgstr ""
#~ "마지막으로, :code:`client.py`에서 *client* 로직을 정의하고"
#~ " :code:`jax_training.py`에서 이전에 정의한 JAX 교육을"
#~ " 기반으로 빌드합니다. *클라이언트*는 :code:`flwr`을 가져와야"
#~ " 하며, JAX 모델의 파라미터를 업데이트하기 위해 "
#~ ":code:`jax` 및 :code:`jaxlib`도 가져와야 합니다:"

#~ msgid ""
#~ "Implementing a Flower *client* basically "
#~ "means implementing a subclass of either"
#~ " ``flwr.client.Client`` or ``flwr.client.NumPyClient``."
#~ " Our implementation will be based on"
#~ " ``flwr.client.NumPyClient`` and we'll call "
#~ "it ``FlowerClient``. ``NumPyClient`` is "
#~ "slightly easier to implement than "
#~ "``Client`` if you use a framework "
#~ "with good NumPy interoperability (like "
#~ "JAX) because it avoids some of the"
#~ " boilerplate that would otherwise be "
#~ "necessary. ``FlowerClient`` needs to implement"
#~ " four methods, two methods for "
#~ "getting/setting model parameters, one method"
#~ " for training the model, and one "
#~ "method for testing the model:"
#~ msgstr ""
#~ "Flower *클라이언트*를 구현한다는 것은 기본적으로 "
#~ ":code:`flwr.client.Client` 또는 "
#~ ":code:`flwr.client.NumPyClient`의 서브클래스를 구현하는 것을 "
#~ "의미합니다. 구현은 :code:`flwr.client.NumPyClient`를 기반으로 "
#~ "하며, 이를 :code:`FlowerClient`라고 부를 것입니다. "
#~ ":code:`NumPyClient`는 필요한 일부 보일러플레이를 피할 수"
#~ " 있기 때문에 NumPy 상호 운용성이 좋은 "
#~ "프레임워크(예: JAX)를 사용하는 경우 :code:`Client`보다 "
#~ "구현하기가 약간 더 쉽습니다. code:`FlowerClient`는 모델"
#~ " 매개변수를 가져오거나 설정하는 메서드 2개, 모델 "
#~ "학습을 위한 메서드 1개, 모델 테스트를 위한 "
#~ "메서드 1개 등 총 4개의 메서드를 구현해야 "
#~ "합니다:"

#~ msgid "``set_parameters (optional)``"
#~ msgstr ":code:`set_parameters (선택사항)`"

#~ msgid "transform parameters to NumPy ``ndarray``'s"
#~ msgstr "매개 변수를 NumPy :code:`ndarray`로 변환"

#~ msgid "get the updated local model parameters and return them to the server"
#~ msgstr "업데이트된 로컬 모델 파라미터를 가져와 서버로 반환합니다"

#~ msgid "return the local loss to the server"
#~ msgstr "로컬 손실을 서버로 반환합니다"

#~ msgid ""
#~ "The challenging part is to transform "
#~ "the JAX model parameters from "
#~ "``DeviceArray`` to ``NumPy ndarray`` to "
#~ "make them compatible with `NumPyClient`."
#~ msgstr ""
#~ "어려운 부분은 JAX 모델 매개변수를 "
#~ ":code:`DeviceArray`에서 :code:`NumPy ndarray`로 변환하여"
#~ " `NumPyClient`와 호환되도록 하는 것입니다."

#~ msgid ""
#~ "The two ``NumPyClient`` methods ``fit`` "
#~ "and ``evaluate`` make use of the "
#~ "functions ``train()`` and ``evaluate()`` "
#~ "previously defined in ``jax_training.py``. So"
#~ " what we really do here is we"
#~ " tell Flower through our ``NumPyClient``"
#~ " subclass which of our already "
#~ "defined functions to call for training"
#~ " and evaluation. We included type "
#~ "annotations to give you a better "
#~ "understanding of the data types that "
#~ "get passed around."
#~ msgstr ""
#~ "두 개의 :code:`NumPyClient` 메서드인 :code:`fit`과 "
#~ ":code:`evaluate`는 이전에 :code:`jax_training.py`에 정의된"
#~ " 함수 :code:`train()`과 :code:`evaluate()`를 사용합니다."
#~ " 따라서 여기서 우리가 실제로 하는 일은 이미 "
#~ "정의된 함수 중 훈련과 평가를 위해 호출할 함수를"
#~ " :code:`NumPyClient` 서브클래스를 통해 Flower에게 "
#~ "알려주는 것입니다. 전달되는 데이터 유형을 더 잘 "
#~ "이해할 수 있도록 유형 type annotation을 "
#~ "포함했습니다."

#~ msgid "Having defined the federation process, we can run it."
#~ msgstr "연합 프로세스를 정의했으면 이제 실행할 수 있습니다."

#~ msgid ""
#~ "in each window (make sure that the"
#~ " server is still running before you"
#~ " do so) and see your JAX "
#~ "project run federated learning across "
#~ "two clients. Congratulations!"
#~ msgstr ""
#~ "를 입력하고(그 전에 서버가 계속 실행 중인지 "
#~ "확인하세요) 두 클라이언트에서 연합 학습을 실행하는 JAX"
#~ " 프로젝트를 확인합니다. 축하합니다!"

#~ msgid ""
#~ "The source code of this example "
#~ "was improved over time and can be"
#~ " found here: `Quickstart JAX "
#~ "<https://github.com/adap/flower/blob/main/examples/quickstart-"
#~ "jax>`_. Our example is somewhat over-"
#~ "simplified because both clients load the"
#~ " same dataset."
#~ msgstr ""
#~ "이 예제의 소스 코드는 시간이 지남에 따라 "
#~ "개선되었으며 여기에서 확인할 수 있습니다: 'Quickstart "
#~ "JAX <https://github.com/adap/flower/blob/main/examples"
#~ "/quickstart-jax>`_. 두 클라이언트가 동일한 데이터 "
#~ "세트를 로드하기 때문에 이 예제는 다소 단순화되어 "
#~ "있습니다."

#~ msgid ""
#~ "You're now prepared to explore this "
#~ "topic further. How about using a "
#~ "more sophisticated model or using a "
#~ "different dataset? How about adding more"
#~ " clients?"
#~ msgstr ""
#~ "이제 이 주제를 더 자세히 살펴볼 준비가 "
#~ "되었습니다. 더 정교한 모델을 사용하거나 다른 데이터 "
#~ "집합을 사용해 보는 것은 어떨까요? 클라이언트를 더 "
#~ "추가하는 것은 어떨까요?"

#~ msgid ""
#~ "In this tutorial, we will learn "
#~ "how to train a ``Logistic Regression``"
#~ " model on MNIST using Flower and "
#~ "scikit-learn."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to create a "
#~ "virtual environment and run everything "
#~ "within this :doc:`virtualenv <contributor-"
#~ "how-to-set-up-a-virtual-env>`."
#~ msgstr ""

#~ msgid ""
#~ "Our example consists of one *server* "
#~ "and two *clients* all having the "
#~ "same model."
#~ msgstr ""

#~ msgid ""
#~ "*Clients* are responsible for generating "
#~ "individual model parameter updates for "
#~ "the model based on their local "
#~ "datasets. These updates are then sent"
#~ " to the *server* which will aggregate"
#~ " them to produce an updated global"
#~ " model. Finally, the *server* sends "
#~ "this improved version of the model "
#~ "back to each *client*. A complete "
#~ "cycle of parameters updates is called"
#~ " a *round*."
#~ msgstr ""

#~ msgid ""
#~ "Now that we have a rough idea "
#~ "of what is going on, let's get "
#~ "started. We first need to install "
#~ "Flower. You can do this by "
#~ "running:"
#~ msgstr ""

#~ msgid "Since we want to use scikit-learn, let's go ahead and install it:"
#~ msgstr ""

#~ msgid "Or simply install all dependencies using Poetry:"
#~ msgstr ""

#~ msgid ""
#~ "Now that we have all our "
#~ "dependencies installed, let's run a "
#~ "simple distributed training with two "
#~ "clients and one server. However, before"
#~ " setting up the client and server,"
#~ " we will define all functionalities "
#~ "that we need for our federated "
#~ "learning setup within ``utils.py``. The "
#~ "``utils.py`` contains different functions "
#~ "defining all the machine learning "
#~ "basics:"
#~ msgstr ""

#~ msgid "``get_model_parameters()``"
#~ msgstr "모델 매개변수."

#~ msgid "Returns the parameters of a ``sklearn`` LogisticRegression model"
#~ msgstr ""

#~ msgid "``set_model_params()``"
#~ msgstr ""

#~ msgid "Sets the parameters of a ``sklearn`` LogisticRegression model"
#~ msgstr ""

#~ msgid "``set_initial_params()``"
#~ msgstr ""

#~ msgid "Initializes the model parameters that the Flower server will ask for"
#~ msgstr ""

#~ msgid ""
#~ "Please check out ``utils.py`` `here "
#~ "<https://github.com/adap/flower/blob/main/examples/sklearn-"
#~ "logreg-mnist/utils.py>`_ for more details. "
#~ "The pre-defined functions are used "
#~ "in the ``client.py`` and imported. The"
#~ " ``client.py`` also requires to import "
#~ "several packages such as Flower and "
#~ "scikit-learn:"
#~ msgstr ""

#~ msgid ""
#~ "Prior to local training, we need "
#~ "to load the MNIST dataset, a "
#~ "popular image classification dataset of "
#~ "handwritten digits for machine learning, "
#~ "and partition the dataset for FL. "
#~ "This can be conveniently achieved using"
#~ " `Flower Datasets <https://flower.ai/docs/datasets>`_."
#~ " The ``FederatedDataset.load_partition()`` method "
#~ "loads the partitioned training set for"
#~ " each partition ID defined in the "
#~ "``--partition-id`` argument."
#~ msgstr ""

#~ msgid ""
#~ "Next, the logistic regression model is"
#~ " defined and initialized with "
#~ "``utils.set_initial_params()``."
#~ msgstr ""

#~ msgid ""
#~ "The Flower server interacts with clients"
#~ " through an interface called ``Client``."
#~ " When the server selects a particular"
#~ " client for training, it sends "
#~ "training instructions over the network. "
#~ "The client receives those instructions "
#~ "and calls one of the ``Client`` "
#~ "methods to run your code (i.e., to"
#~ " fit the logistic regression we "
#~ "defined earlier)."
#~ msgstr ""

#~ msgid ""
#~ "Flower provides a convenience class "
#~ "called ``NumPyClient`` which makes it "
#~ "easier to implement the ``Client`` "
#~ "interface when your workload uses "
#~ "scikit-learn. Implementing ``NumPyClient`` "
#~ "usually means defining the following "
#~ "methods (``set_parameters`` is optional "
#~ "though):"
#~ msgstr ""

#~ msgid "return the model weight as a list of NumPy ndarrays"
#~ msgstr ""

#~ msgid "``set_parameters`` (optional)"
#~ msgstr ":code:`set_parameters (선택사항)`"

#~ msgid ""
#~ "update the local model weights with "
#~ "the parameters received from the server"
#~ msgstr ""

#~ msgid "is directly imported with ``utils.set_model_params()``"
#~ msgstr ""

#~ msgid "set the local model weights"
#~ msgstr ""

#~ msgid "train the local model"
#~ msgstr ""

#~ msgid "return the updated local model weights"
#~ msgstr "현재 로컬 모델 파라미터를 반환합니다."

#~ msgid "test the local model"
#~ msgstr ""

#~ msgid "The methods can be implemented in the following way:"
#~ msgstr ""

#~ msgid ""
#~ "We can now create an instance of"
#~ " our class ``MnistClient`` and add "
#~ "one line to actually run this "
#~ "client:"
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement ``Client`` or "
#~ "``NumPyClient`` and call "
#~ "``fl.client.start_client()``. If you implement "
#~ "a client of type ``NumPyClient`` you'll"
#~ " need to first call its "
#~ "``to_client()`` method. The string "
#~ "``\"0.0.0.0:8080\"`` tells the client which"
#~ " server to connect to. In our "
#~ "case we can run the server and "
#~ "the client on the same machine, "
#~ "therefore we use ``\"0.0.0.0:8080\"``. If "
#~ "we run a truly federated workload "
#~ "with the server and clients running "
#~ "on different machines, all that needs"
#~ " to change is the ``server_address`` "
#~ "we pass to the client."
#~ msgstr ""

#~ msgid ""
#~ "The following Flower server is a "
#~ "little bit more advanced and returns "
#~ "an evaluation function for the "
#~ "server-side evaluation. First, we import"
#~ " again all required libraries such as"
#~ " Flower and scikit-learn."
#~ msgstr ""

#~ msgid "``server.py``, import Flower and start the server:"
#~ msgstr ""

#~ msgid ""
#~ "The number of federated learning rounds"
#~ " is set in ``fit_round()`` and the"
#~ " evaluation is defined in "
#~ "``get_evaluate_fn()``. The evaluation function "
#~ "is called after each federated learning"
#~ " round and gives you information "
#~ "about loss and accuracy. Note that "
#~ "we also make use of Flower "
#~ "Datasets here to load the test "
#~ "split of the MNIST dataset for "
#~ "server-side evaluation."
#~ msgstr ""

#~ msgid ""
#~ "The ``main`` contains the server-side"
#~ " parameter initialization "
#~ "``utils.set_initial_params()`` as well as the"
#~ " aggregation strategy ``fl.server.strategy:FedAvg()``."
#~ " The strategy is the default one, "
#~ "federated averaging (or FedAvg), with "
#~ "two clients and evaluation after each"
#~ " federated learning round. The server "
#~ "can be started with the command "
#~ "``fl.server.start_server(server_address=\"0.0.0.0:8080\", "
#~ "strategy=strategy, "
#~ "config=fl.server.ServerConfig(num_rounds=3))``."
#~ msgstr ""

#~ msgid ""
#~ "With both client and server ready, "
#~ "we can now run everything and see"
#~ " federated learning in action. Federated"
#~ " learning systems usually have a "
#~ "server and multiple clients. We, "
#~ "therefore, have to start the server "
#~ "first:"
#~ msgstr ""

#~ msgid ""
#~ "Once the server is running we can"
#~ " start the clients in different "
#~ "terminals. Open a new terminal and "
#~ "start the first client:"
#~ msgstr ""

#~ msgid "Open another terminal and start the second client:"
#~ msgstr ""

#~ msgid ""
#~ "Each client will have its own "
#~ "dataset. You should now see how "
#~ "the training does in the very "
#~ "first terminal (the one that started "
#~ "the server):"
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated learning "
#~ "system. The full `source code "
#~ "<https://github.com/adap/flower/tree/main/examples/sklearn-"
#~ "logreg-mnist>`_ for this example can "
#~ "be found in ``examples/sklearn-logreg-"
#~ "mnist``."
#~ msgstr ""

#~ msgid "Federated XGBoost"
#~ msgstr ""

#~ msgid "Why federated XGBoost?"
#~ msgstr ""

#~ msgid ""
#~ "Indeed, as the demand for data "
#~ "privacy and decentralized learning grows, "
#~ "there's an increasing requirement to "
#~ "implement federated XGBoost systems for "
#~ "specialised applications, like survival "
#~ "analysis and financial fraud detection."
#~ msgstr ""

#~ msgid ""
#~ "Federated learning ensures that raw data"
#~ " remains on the local device, making"
#~ " it an attractive approach for "
#~ "sensitive domains where data security "
#~ "and privacy are paramount. Given the "
#~ "robustness and efficiency of XGBoost, "
#~ "combining it with federated learning "
#~ "offers a promising solution for these"
#~ " specific challenges."
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial we will learn how"
#~ " to train a federated XGBoost model"
#~ " on HIGGS dataset using Flower and"
#~ " ``xgboost`` package. We use a simple"
#~ " example (`full code xgboost-quickstart "
#~ "<https://github.com/adap/flower/tree/main/examples/xgboost-"
#~ "quickstart>`_) with two *clients* and "
#~ "one *server* to demonstrate how "
#~ "federated XGBoost works, and then we "
#~ "dive into a more complex example "
#~ "(`full code xgboost-comprehensive "
#~ "<https://github.com/adap/flower/tree/main/examples/xgboost-"
#~ "comprehensive>`_) to run various experiments."
#~ msgstr ""

#~ msgid ""
#~ "First of all, it is recommended to"
#~ " create a virtual environment and run"
#~ " everything within a :doc:`virtualenv "
#~ "<contributor-how-to-set-up-a-virtual-env>`."
#~ msgstr ""

#~ msgid ""
#~ "*Clients* are responsible for generating "
#~ "individual weight-updates for the model"
#~ " based on their local datasets. Now"
#~ " that we have all our dependencies"
#~ " installed, let's run a simple "
#~ "distributed training with two clients "
#~ "and one server."
#~ msgstr ""

#~ msgid ""
#~ "In a file called ``client.py``, import"
#~ " xgboost, Flower, Flower Datasets and "
#~ "other related functions:"
#~ msgstr ""

#~ msgid "Dataset partition and hyper-parameter selection"
#~ msgstr ""

#~ msgid ""
#~ "Prior to local training, we require "
#~ "loading the HIGGS dataset from Flower"
#~ " Datasets and conduct data partitioning "
#~ "for FL:"
#~ msgstr ""

#~ msgid ""
#~ "In this example, we split the "
#~ "dataset into 30 partitions with uniform"
#~ " distribution (``IidPartitioner(num_partitions=30)``). "
#~ "Then, we load the partition for "
#~ "the given client based on "
#~ "``partition_id``:"
#~ msgstr ""

#~ msgid ""
#~ "After that, we do train/test splitting"
#~ " on the given partition (client's "
#~ "local data), and transform data format"
#~ " for ``xgboost`` package."
#~ msgstr ""

#~ msgid "Finally, we define the hyper-parameters used for XGBoost training."
#~ msgstr ""

#~ msgid ""
#~ "The ``num_local_round`` represents the number"
#~ " of iterations for local tree boost."
#~ " We use CPU for the training in"
#~ " default. One can shift it to "
#~ "GPU by setting ``tree_method`` to "
#~ "``gpu_hist``. We use AUC as evaluation"
#~ " metric."
#~ msgstr ""

#~ msgid "Flower client definition for XGBoost"
#~ msgstr ""

#~ msgid ""
#~ "After loading the dataset we define "
#~ "the Flower client. We follow the "
#~ "general rule to define ``XgbClient`` "
#~ "class inherited from ``fl.client.Client``."
#~ msgstr ""

#~ msgid ""
#~ "All required parameters defined above "
#~ "are passed to ``XgbClient``'s constructor."
#~ msgstr ""

#~ msgid ""
#~ "Then, we override ``get_parameters``, ``fit``"
#~ " and ``evaluate`` methods insides "
#~ "``XgbClient`` class as follows."
#~ msgstr ""

#~ msgid ""
#~ "Unlike neural network training, XGBoost "
#~ "trees are not started from a "
#~ "specified random weights. In this case,"
#~ " we do not use ``get_parameters`` and"
#~ " ``set_parameters`` to initialise model "
#~ "parameters for XGBoost. As a result, "
#~ "let's return an empty tensor in "
#~ "``get_parameters`` when it is called by"
#~ " the server at the first round."
#~ msgstr ""

#~ msgid ""
#~ "In ``fit``, at the first round, we"
#~ " call ``xgb.train()`` to build up the"
#~ " first set of trees. From the "
#~ "second round, we load the global "
#~ "model sent from server to new "
#~ "build Booster object, and then update"
#~ " model weights on local training data"
#~ " with function ``local_boost`` as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Now, we can create an instance of"
#~ " our class ``XgbClient`` and add one"
#~ " line to actually run this client:"
#~ msgstr ""

#~ msgid ""
#~ "That's it for the client. We only"
#~ " have to implement ``Client`` and "
#~ "call ``fl.client.start_client()``. The string "
#~ "``\"[::]:8080\"`` tells the client which "
#~ "server to connect to. In our case"
#~ " we can run the server and the"
#~ " client on the same machine, "
#~ "therefore we use ``\"[::]:8080\"``. If "
#~ "we run a truly federated workload "
#~ "with the server and clients running "
#~ "on different machines, all that needs"
#~ " to change is the ``server_address`` "
#~ "we point the client at."
#~ msgstr ""

#~ msgid ""
#~ "These updates are then sent to the"
#~ " *server* which will aggregate them "
#~ "to produce a better model. Finally, "
#~ "the *server* sends this improved version"
#~ " of the model back to each "
#~ "*client* to finish a complete FL "
#~ "round."
#~ msgstr ""

#~ msgid ""
#~ "In a file named ``server.py``, import"
#~ " Flower and FedXgbBagging from "
#~ "``flwr.server.strategy``."
#~ msgstr ""

#~ msgid "We first define a strategy for XGBoost bagging aggregation."
#~ msgstr ""

#~ msgid ""
#~ "We use two clients for this "
#~ "example. An ``evaluate_metrics_aggregation`` "
#~ "function is defined to collect and "
#~ "wighted average the AUC values from "
#~ "clients. The ``config_func`` function is "
#~ "to return the current FL round "
#~ "number to client's ``fit()`` and "
#~ "``evaluate()`` methods."
#~ msgstr ""

#~ msgid "Then, we start the server:"
#~ msgstr ""

#~ msgid "Tree-based bagging aggregation"
#~ msgstr ""

#~ msgid ""
#~ "After traversal of all clients' models,"
#~ " a new global model is generated, "
#~ "followed by the serialisation, and "
#~ "sending back to each client."
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated XGBoost "
#~ "system. The AUC values can be "
#~ "checked in ``metrics_distributed``. One can"
#~ " see that the average AUC increases"
#~ " over FL rounds."
#~ msgstr ""

#~ msgid ""
#~ "The full `source code "
#~ "<https://github.com/adap/flower/blob/main/examples/xgboost-"
#~ "quickstart/>`_ for this example can be"
#~ " found in ``examples/xgboost-quickstart``."
#~ msgstr ""

#~ msgid ""
#~ "Now that you have known how "
#~ "federated XGBoost work with Flower, it's"
#~ " time to run some more comprehensive"
#~ " experiments by customising the "
#~ "experimental settings. In the xgboost-"
#~ "comprehensive example (`full code "
#~ "<https://github.com/adap/flower/tree/main/examples/xgboost-"
#~ "comprehensive>`_), we provide more options "
#~ "to define various experimental setups, "
#~ "including aggregation strategies, data "
#~ "partitioning and centralised/distributed evaluation."
#~ " We also support :doc:`Flower simulation"
#~ " <how-to-run-simulations>` making it"
#~ " easy to simulate large client "
#~ "cohorts in a resource-aware manner. "
#~ "Let's take a look!"
#~ msgstr ""

#~ msgid "Cyclic training"
#~ msgstr ""

#~ msgid ""
#~ "To do this, we first customise a"
#~ " ``ClientManager`` in ``server_utils.py``:"
#~ msgstr ""

#~ msgid ""
#~ "The customised ``ClientManager`` samples all"
#~ " available clients in each FL round"
#~ " based on the order of connection "
#~ "to the server. Then, we define a"
#~ " new strategy ``FedXgbCyclic`` in "
#~ "``flwr.server.strategy.fedxgb_cyclic.py``, in order "
#~ "to sequentially select only one client"
#~ " in given round and pass the "
#~ "received model to next client."
#~ msgstr ""

#~ msgid "Customised data partitioning"
#~ msgstr ""

#~ msgid ""
#~ "In ``dataset.py``, we have a function"
#~ " ``instantiate_partitioner`` to instantiate the"
#~ " data partitioner based on the given"
#~ " ``num_partitions`` and ``partitioner_type``. "
#~ "Currently, we provide four supported "
#~ "partitioner type to simulate the "
#~ "uniformity/non-uniformity in data quantity "
#~ "(uniform, linear, square, exponential)."
#~ msgstr ""

#~ msgid "Customised centralised/distributed evaluation"
#~ msgstr ""

#~ msgid ""
#~ "To facilitate centralised evaluation, we "
#~ "define a function in ``server_utils.py``:"
#~ msgstr ""

#~ msgid ""
#~ "This function returns a evaluation "
#~ "function which instantiates a ``Booster`` "
#~ "object and loads the global model "
#~ "weights to it. The evaluation is "
#~ "conducted by calling ``eval_set()`` method,"
#~ " and the tested AUC value is "
#~ "reported."
#~ msgstr ""

#~ msgid ""
#~ "As for distributed evaluation on the "
#~ "clients, it's same as the quick-"
#~ "start example by overriding the "
#~ "``evaluate()`` method insides the "
#~ "``XgbClient`` class in ``client_utils.py``."
#~ msgstr ""

#~ msgid "Flower simulation"
#~ msgstr ""

#~ msgid ""
#~ "We also provide an example code "
#~ "(``sim.py``) to use the simulation "
#~ "capabilities of Flower to simulate "
#~ "federated XGBoost training on either a"
#~ " single machine or a cluster of "
#~ "machines."
#~ msgstr ""

#~ msgid ""
#~ "After importing all required packages, "
#~ "we define a ``main()`` function to "
#~ "perform the simulation process:"
#~ msgstr ""

#~ msgid ""
#~ "We first load the dataset and "
#~ "perform data partitioning, and the "
#~ "pre-processed data is stored in a "
#~ "``list``. After the simulation begins, "
#~ "the clients won't need to pre-"
#~ "process their partitions again."
#~ msgstr ""

#~ msgid "Then, we define the strategies and other hyper-parameters:"
#~ msgstr ""

#~ msgid ""
#~ "After that, we start the simulation "
#~ "by calling ``fl.simulation.start_simulation``:"
#~ msgstr ""

#~ msgid ""
#~ "One of key parameters for "
#~ "``start_simulation`` is ``client_fn`` which "
#~ "returns a function to construct a "
#~ "client. We define it as follows:"
#~ msgstr ""

#~ msgid "Arguments parser"
#~ msgstr ""

#~ msgid ""
#~ "In ``utils.py``, we define the arguments"
#~ " parsers for clients, server and "
#~ "simulation, allowing users to specify "
#~ "different experimental settings. Let's first"
#~ " see the sever side:"
#~ msgstr ""

#~ msgid ""
#~ "This allows user to specify training "
#~ "strategies / the number of total "
#~ "clients / FL rounds / participating "
#~ "clients / clients for evaluation, and"
#~ " evaluation fashion. Note that with "
#~ "``--centralised-eval``, the sever will do"
#~ " centralised evaluation and all "
#~ "functionalities for client evaluation will "
#~ "be disabled."
#~ msgstr ""

#~ msgid "Then, the argument parser on client side:"
#~ msgstr ""

#~ msgid ""
#~ "This defines various options for client"
#~ " data partitioning. Besides, clients also"
#~ " have an option to conduct evaluation"
#~ " on centralised test set by setting"
#~ " ``--centralised-eval``, as well as "
#~ "an option to perform scaled learning "
#~ "rate based on the number of "
#~ "clients by setting ``--scaled-lr``."
#~ msgstr ""

#~ msgid "We also have an argument parser for simulation:"
#~ msgstr ""

#~ msgid "This integrates all arguments for both client and server sides."
#~ msgstr ""

#~ msgid "Example commands"
#~ msgstr ""

#~ msgid ""
#~ "To run a centralised evaluated "
#~ "experiment with bagging strategy on 5"
#~ " clients with exponential distribution for"
#~ " 50 rounds, we first start the "
#~ "server as below:"
#~ msgstr ""

#~ msgid "Then, on each client terminal, we start the clients:"
#~ msgstr ""

#~ msgid "To run the same experiment with Flower simulation:"
#~ msgstr ""

#~ msgid ""
#~ "The full `code "
#~ "<https://github.com/adap/flower/blob/main/examples/xgboost-"
#~ "comprehensive/>`_ for this comprehensive "
#~ "example can be found in ``examples"
#~ "/xgboost-comprehensive``."
#~ msgstr ""

#~ msgid "|ac0a9766e26044d6aea222a829859b20|"
#~ msgstr ""

#~ msgid "|36cd6e248b1443ce8a82b5a025bba368|"
#~ msgstr ""

#~ msgid "|bf4fb057f4774df39e1dcb5c71fd804a|"
#~ msgstr ""

#~ msgid "|71bb9f3c74c04f959b9bc1f02b736c95|"
#~ msgstr ""

#~ msgid "|7605632e1b0f49599ffacf841491fcfb|"
#~ msgstr ""

#~ msgid "|91b1b5a7d3484eb7a2350c1923f18307|"
#~ msgstr ""

#~ msgid "|5405ed430e4746e28b083b146fb71731|"
#~ msgstr ""

#~ msgid "|a389e87dab394eb48a8949aa2397687b|"
#~ msgstr ""

#~ msgid "|89c412136a5146ec8dc32c0973729f12|"
#~ msgstr ""

#~ msgid "|9503d3dc3a144e8aa295f8800cd8a766|"
#~ msgstr ""

#~ msgid "|aadb59e29b9e445d8e239d9a8a7045cb|"
#~ msgstr ""

#~ msgid "|a7579ad7734347508e959d9e14f2f53d|"
#~ msgstr ""

#~ msgid "|73d15dd1d4fc41678b2d54815503fbe8|"
#~ msgstr ""

#~ msgid "|55472eef61274ba1b739408607e109df|"
#~ msgstr ""

#~ msgid ""
#~ "When operating in a production "
#~ "environment, it is strongly recommended "
#~ "to enable Transport Layer Security (TLS)"
#~ " for each Flower Component to ensure"
#~ " secure communication."
#~ msgstr ""

#~ msgid ""
#~ "Assuming all files we need are in"
#~ " the local ``certificates`` directory, we"
#~ " can use the flag ``--volume`` to "
#~ "mount the local directory into the "
#~ "``/app/certificates/`` directory of the "
#~ "container:"
#~ msgstr ""

#~ msgid ""
#~ "``--volume ./certificates/:/app/certificates/:ro``: Mount"
#~ " the ``certificates`` directory in"
#~ msgstr ""

#~ msgid ""
#~ "the current working directory of the "
#~ "host machine as a read-only volume"
#~ " at the"
#~ msgstr ""

#~ msgid "``/app/certificates`` directory inside the container."
#~ msgstr ""

#~ msgid ""
#~ "``--volume ./ca.crt:/app/ca.crt/:ro``: Mount the "
#~ "``ca.crt`` file from the"
#~ msgstr ""

#~ msgid ""
#~ "current working directory of the host"
#~ " machine as a read-only volume "
#~ "at the ``/app/ca.crt``"
#~ msgstr ""

#~ msgid "SuperExec"
#~ msgstr ""

#~ msgid ""
#~ "Assuming all files we need are in"
#~ " the local ``certificates`` directory where"
#~ " the SuperExec will be executed from,"
#~ " we can use the flag ``--volume`` "
#~ "to mount the local directory into "
#~ "the ``/app/certificates/`` directory of the"
#~ " container:"
#~ msgstr ""

#~ msgid ""
#~ ":substitution-code:`flwr/superexec:|stable_flwr_version|`: "
#~ "The name of the image to be "
#~ "run and the specific"
#~ msgstr ""

#~ msgid "SuperExec."
#~ msgstr ""

#~ msgid ""
#~ "``--ssl-certfile certificates/server.pem``: Specify"
#~ " the location of the SuperExec's"
#~ msgstr ""

#~ msgid ""
#~ "The ``certificates/server.pem`` file is used"
#~ " to identify the SuperExec and to "
#~ "encrypt the"
#~ msgstr ""

#~ msgid ""
#~ "``--ssl-keyfile certificates/server.key``: Specify"
#~ " the location of the SuperExec's"
#~ msgstr ""

#~ msgid ""
#~ "``--executor-config root-"
#~ "certificates=\\\"certificates/superlink_ca.crt\\\"``: Specify"
#~ " the"
#~ msgstr ""

#~ msgid ""
#~ "location of the CA certificate file "
#~ "inside the container that the SuperExec"
#~ " executor"
#~ msgstr ""

#~ msgid "should use to verify the SuperLink's identity."
#~ msgstr ""

#~ msgid ""
#~ "In this mode, the ClientApp is "
#~ "executed as a subprocess within the "
#~ "SuperNode Docker container, rather than "
#~ "running in a separate container. This"
#~ " approach reduces the number of "
#~ "running containers, which can be "
#~ "beneficial for environments with limited "
#~ "resources. However, it also means that"
#~ " the ClientApp is no longer isolated"
#~ " from the SuperNode, which may "
#~ "introduce additional security concerns."
#~ msgstr ""

#~ msgid ""
#~ "Before running the ClientApp as a "
#~ "subprocess, ensure that the FAB "
#~ "dependencies have been installed in the"
#~ " SuperNode images. This can be done"
#~ " by extending the SuperNode image:"
#~ msgstr ""

#~ msgid "Dockerfile.supernode"
#~ msgstr "Flower SuperNode"

#~ msgid "Run the ClientApp as a Subprocess"
#~ msgstr ""

#~ msgid ""
#~ "Start the SuperNode with the flag "
#~ "``--isolation subprocess``, which tells the"
#~ " SuperNode to execute the ClientApp "
#~ "as a subprocess:"
#~ msgstr ""

#~ msgid "Run the example and follow the logs of the ServerApp:"
#~ msgstr ""

#~ msgid ""
#~ "That is all it takes! You can "
#~ "monitor the progress of the run "
#~ "through the logs of the SuperExec."
#~ msgstr ""

#~ msgid ""
#~ "You will learn how to run the "
#~ "Flower client and server components on"
#~ " two separate machines, with Flower "
#~ "configured to use TLS encryption and "
#~ "persist SuperLink state across restarts. "
#~ "A server consists of a SuperLink "
#~ "and ``SuperExec``. For more details "
#~ "about the Flower architecture, refer to"
#~ " the :doc:`../explanation-flower-architecture`"
#~ " explainer page."
#~ msgstr ""

#~ msgid ""
#~ "First, set the environment variables "
#~ "``SUPERLINK_IP`` and ``SUPEREXEC_IP`` with the"
#~ " IP address from the remote machine."
#~ " For example, if the IP is "
#~ "``192.168.2.33``, execute:"
#~ msgstr ""

#~ msgid ""
#~ "Log into the remote machine using "
#~ "``ssh`` and run the following command"
#~ " to start the SuperLink and SuperExec"
#~ " services:"
#~ msgstr ""

#~ msgid ""
#~ "Specify the remote SuperExec IP "
#~ "addresses and the path to the root"
#~ " certificate in the ``[tool.flwr.federations"
#~ ".remote-superexec]`` table in the "
#~ "``pyproject.toml`` file. Here, we have "
#~ "named our remote federation ``remote-"
#~ "superexec``:"
#~ msgstr ""

#~ msgid "Run the project and follow the ServerApp logs:"
#~ msgstr ""

#~ msgid ""
#~ "``-p 9091:9091 -p 9092:9092``: Map port"
#~ " ``9091`` and ``9092`` of the "
#~ "container to the same port of"
#~ msgstr ""

#~ msgid "the host machine, allowing other services to access the Driver API on"
#~ msgstr ""

#~ msgid ""
#~ "``http://localhost:9091`` and the Fleet API"
#~ " on ``http://localhost:9092``."
#~ msgstr ""

#~ msgid "Step 3: Start the SuperNode"
#~ msgstr ""

#~ msgid ""
#~ "``flwr/supernode:|stable_flwr_version|``: This is "
#~ "the name of the image to be "
#~ "run and the specific tag"
#~ msgstr ""

#~ msgid ""
#~ "``--supernode-address 0.0.0.0:9094``: Set the"
#~ " address and port number that the "
#~ "SuperNode"
#~ msgstr ""

#~ msgid "is listening on."
#~ msgstr ""

#~ msgid "Step 4: Start the ClientApp"
#~ msgstr ""

#~ msgid ""
#~ "The ClientApp Docker image comes with"
#~ " a pre-installed version of Flower"
#~ " and serves as a base for "
#~ "building your own ClientApp image. In"
#~ " order to install the FAB "
#~ "dependencies, you will need to create"
#~ " a Dockerfile that extends the "
#~ "ClientApp image and installs the "
#~ "required dependencies."
#~ msgstr ""

#~ msgid ""
#~ "Create a ClientApp Dockerfile called "
#~ "``Dockerfile.clientapp`` and paste the "
#~ "following code into it:"
#~ msgstr ""

#~ msgid "Dockerfile.clientapp"
#~ msgstr "flower 클라이언트 앱"

#~ msgid ""
#~ "to be built from is the "
#~ "``flwr/clientapp image``, version :substitution-"
#~ "code:`|stable_flwr_version|`."
#~ msgstr ""

#~ msgid ""
#~ "``--supernode supernode-1:9094``: Connect to "
#~ "the SuperNode's Fleet API at the "
#~ "address"
#~ msgstr ""

#~ msgid "``supernode-1:9094``."
#~ msgstr ""

#~ msgid "Step 5: Start the SuperExec"
#~ msgstr ""

#~ msgid ""
#~ "Similar to the ClientApp image, you "
#~ "will need to create a Dockerfile "
#~ "that extends the SuperExec image and "
#~ "installs the required FAB dependencies."
#~ msgstr ""

#~ msgid ""
#~ "Create a SuperExec Dockerfile called "
#~ "``Dockerfile.superexec`` and paste the "
#~ "following code in:"
#~ msgstr ""

#~ msgid "Dockerfile.superexec"
#~ msgstr ""

#~ msgid ""
#~ ":substitution-code:`FROM "
#~ "flwr/superexec:|stable_flwr_version|`: This line "
#~ "specifies that the Docker image"
#~ msgstr ""

#~ msgid ""
#~ "to be built from is the "
#~ "``flwr/superexec image``, version :substitution-"
#~ "code:`|stable_flwr_version|`."
#~ msgstr ""

#~ msgid ""
#~ "``ENTRYPOINT [\"flower-superexec\"``: Set the"
#~ " command ``flower-superexec`` to be"
#~ msgstr ""

#~ msgid "``\"--executor\", \"flwr.superexec.deployment:executor\"]`` Use the"
#~ msgstr ""

#~ msgid "``flwr.superexec.deployment:executor`` executor to run the ServerApps."
#~ msgstr ""

#~ msgid ""
#~ "Afterward, in the directory that holds"
#~ " the Dockerfile, execute this Docker "
#~ "command to build the SuperExec image:"
#~ msgstr ""

#~ msgid "Start the SuperExec container:"
#~ msgstr ""

#~ msgid ""
#~ "``-p 9093:9093``: Map port ``9093`` of"
#~ " the container to the same port "
#~ "of"
#~ msgstr ""

#~ msgid ""
#~ "the host machine, allowing you to "
#~ "access the SuperExec API on "
#~ "``http://localhost:9093``."
#~ msgstr ""

#~ msgid "``--name superexec``: Assign the name ``superexec`` to the container."
#~ msgstr ""

#~ msgid ""
#~ "``--executor-config superlink=\\\"superlink:9091\\\"``:"
#~ " Configure the SuperExec executor to"
#~ msgstr ""

#~ msgid "connect to the SuperLink running on port ``9091``."
#~ msgstr ""

#~ msgid "Launch two new ClientApp containers based on the newly built image:"
#~ msgstr ""

#~ msgid ""
#~ "Setting the ``PROJECT_DIR`` helps Docker "
#~ "Compose locate the ``pyproject.toml`` file,"
#~ " allowing it to install dependencies "
#~ "in the SuperExec and SuperNode images"
#~ " correctly."
#~ msgstr ""

#~ msgid ""
#~ "To ensure the ``flwr`` CLI connects "
#~ "to the SuperExec, you need to "
#~ "specify the SuperExec addresses in the"
#~ " ``pyproject.toml`` file."
#~ msgstr ""

#~ msgid ""
#~ "Run the quickstart example, monitor the"
#~ " ServerApp logs and wait for the "
#~ "summary to appear:"
#~ msgstr ""

#~ msgid "In the SuperExec logs, you should find the ``Get weights`` line:"
#~ msgstr ""

#~ msgid "Step 7: Add another SuperNode"
#~ msgstr ""

#~ msgid ""
#~ "You can add more SuperNodes and "
#~ "ClientApps by duplicating their definitions"
#~ " in the ``compose.yml`` file."
#~ msgstr ""

#~ msgid ""
#~ "Just give each new SuperNode and "
#~ "ClientApp service a unique service name"
#~ " like ``supernode-3``, ``clientapp-3``, etc."
#~ msgstr ""

#~ msgid "In ``compose.yml``, add the following:"
#~ msgstr ""

#~ msgid ""
#~ "If you also want to enable TLS "
#~ "for the new SuperNodes, duplicate the"
#~ " SuperNode definition for each new "
#~ "SuperNode service in the ``with-"
#~ "tls.yml`` file."
#~ msgstr ""

#~ msgid ""
#~ "Make sure that the names of the"
#~ " services match with the one in "
#~ "the ``compose.yml`` file."
#~ msgstr ""

#~ msgid "In ``with-tls.yml``, add the following:"
#~ msgstr ""

#~ msgid "Comment out the lines 2-4 and uncomment the lines 5-9:"
#~ msgstr ""

#~ msgid ""
#~ "This guide is for users who have"
#~ " already worked with Flower 0.x and"
#~ " want to upgrade to Flower 1.0. "
#~ "Newer versions of Flower (1.12+) are "
#~ "based on a new architecture (previously"
#~ " called Flower Next) and not covered"
#~ " in this guide. After upgrading "
#~ "Flower 0.x projects to Flower 1.0, "
#~ "please refer to :doc:`Upgrade to Flower"
#~ " Next <how-to-upgrade-to-flower-"
#~ "next>` to make your project compatible"
#~ " with the lastest version of Flower."
#~ msgstr ""

#~ msgid "Upgrade to Flower Next"
#~ msgstr "Flower Next 업그레이드"

#~ msgid ""
#~ "This guide shows how to reuse "
#~ "pre-``1.8`` Flower code with minimum "
#~ "code changes by using the *compatibility"
#~ " layer* in Flower Next. In another"
#~ " guide, we will show how to run"
#~ " Flower Next end-to-end with "
#~ "pure Flower Next APIs."
#~ msgstr ""
#~ "이 가이드에서는 Flower Next의 *호환성 레이어*를 "
#~ "사용하여 최소한의 코드 변경으로 ``1.8`` 이전의 "
#~ "Flower 코드를 재사용하는 방법을 보여줍니다. 다른 "
#~ "가이드에서는 순수한 Flower Next API로 Flower "
#~ "Next를 end-to-end로 실행하는 방법을 "
#~ "보여드리겠습니다."

#~ msgid "Using Poetry"
#~ msgstr "Poetry 사용"

#~ msgid ""
#~ "Update the ``flwr`` dependency in "
#~ "``pyproject.toml`` and then reinstall (don't"
#~ " forget to delete ``poetry.lock`` via "
#~ "``rm poetry.lock`` before running ``poetry "
#~ "install``)."
#~ msgstr ""
#~ "``pyproject.toml``에서 ``flwr`` 의존성를 업데이트한 다음"
#~ " 다시 설치하세요(``poetry install``을 실행하기 전에 "
#~ "``rm poetry.lock``을 통해 ``poetry.lock``을 삭제하는"
#~ " 것을 잊지 마세요)."

#~ msgid ""
#~ "Ensure you set the following version "
#~ "constraint in your ``pyproject.toml``:"
#~ msgstr "``pyproject.toml``에 다음 버전 제약 조건을 설정했는지 확인하세요:"

#~ msgid ""
#~ "This function is deprecated since "
#~ "1.13.0. Use :code: `flwr run` to "
#~ "start a Flower simulation."
#~ msgstr ""

#~ msgid "|c9344c3dfee24383908fabaac40a8504|"
#~ msgstr ""

#~ msgid "|c10cd8f2177641bd8091c7b76d318ff9|"
#~ msgstr ""

#~ msgid "|3c59c315e67945ea8b839381c5deb6c2|"
#~ msgstr ""

#~ msgid "|eadf87e1e20549789512f7aa9199fcff|"
#~ msgstr ""

#~ msgid "|66ce8f21aeb443fca1fc88f727458417|"
#~ msgstr ""

#~ msgid "|f5768015a1014396b4761bb6cb3677f5|"
#~ msgstr ""

#~ msgid "|a746aa3f56064617a4e00f4c6a0cb140|"
#~ msgstr ""

#~ msgid "|cf8f676dd3534a44995c1b40910fd030|"
#~ msgstr ""

#~ msgid "|d1c0e3a4c9dc4bfd88ee6f1fe626edaf|"
#~ msgstr ""

#~ msgid "|1d8d6298a4014ec3a717135bcc7a94f9|"
#~ msgstr ""

#~ msgid "|e3ea79200ff44d459358b9f4713e582b|"
#~ msgstr ""

#~ msgid "|3e1061718a4a49d485764d30a4bfecdd|"
#~ msgstr ""

#~ msgid "|7750e597d1ea4e319f7e0a40539bf214|"
#~ msgstr ""

#~ msgid "|dd4434075f374e99ac07f509a883778f|"
#~ msgstr ""

#~ msgid "Unreleased"
#~ msgstr "릴리즈 빌드"

#~ msgid "Other changes"
#~ msgstr "**변경사항 스테이징**"

#~ msgid "|cf5fe148406b44b9a8b842fb01b5a7ea|"
#~ msgstr ""

#~ msgid "|ba25c91426d64cc1ae2d3febc5715b35|"
#~ msgstr ""

#~ msgid "|fca67f83aaab4389aa9ebb4d9c5cd75e|"
#~ msgstr ""

#~ msgid "|6f2e8f95c95443379b0df00ca9824654|"
#~ msgstr ""

#~ msgid "|c0ab3a1a733d4dbc9e1677aa608e8038|"
#~ msgstr ""

#~ msgid "|8f0491bde07341ab9f2e23d50593c0be|"
#~ msgstr ""

#~ msgid "|762fc099899943688361562252c5e600|"
#~ msgstr ""

#~ msgid "|f62d365fd0ae405b975d3ca01e7183fd|"
#~ msgstr ""

#~ msgid "|2c78fc1816b143289f4d909388f92a80|"
#~ msgstr ""

#~ msgid "|4230725aeebe497d8ad84a3efc2a912b|"
#~ msgstr ""

#~ msgid "|64b66a88417240eabe52f5cc55d89d0b|"
#~ msgstr ""

#~ msgid "|726c8eca58bc4f859b06aa24a587b253|"
#~ msgstr ""

#~ msgid "|f9d869e4b33c4093b29cf24ed8dff80a|"
#~ msgstr ""

#~ msgid "|4ab50bc01a9f426a91a2c0cbc3ab7a84|"
#~ msgstr ""

#~ msgid "Request for examples"
#~ msgstr "예시 요청"

#~ msgid "Llama 2 fine-tuning, with Hugging Face Transformers and PyTorch"
#~ msgstr "Llama 2 미세 조정, Hugging Face Transformer와 파이토치 포함"

#~ msgid "Android ONNX on-device training"
#~ msgstr "Android ONNX 온디바이스 훈련"

#~ msgid "|f150b8d6e0074250822c9f6f7a8de3e0|"
#~ msgstr ""

#~ msgid "|72772d10debc4abd8373c0bc82985422|"
#~ msgstr ""

#~ msgid "|5815398552ad41d290a3a2631fe8f6ca|"
#~ msgstr ""

#~ msgid "|e6ac20744bf149378be20ac3dc309356|"
#~ msgstr ""

#~ msgid "|a4011ef443c14725b15a8cf33b0e3443|"
#~ msgstr ""

#~ msgid "|a22faa3617404c06803731525e1c609f|"
#~ msgstr ""

#~ msgid "|84a5c9b5041c43c3beab9786197c3e4e|"
#~ msgstr ""

#~ msgid "|b5c4be0b52d4493ba8c4af14d7c2db97|"
#~ msgstr ""

#~ msgid "|c1c784183d18481186ff65dc261d1335|"
#~ msgstr ""

#~ msgid "|669fcd1f44ab42f5bbd196c3cf1ecbc2|"
#~ msgstr ""

#~ msgid "|edfb08758c9441afb6736045a59e154c|"
#~ msgstr ""

#~ msgid "|82338b8bbad24d5ea9df3801aab37852|"
#~ msgstr ""

#~ msgid "|518d994dd2c844898b441da03b858326|"
#~ msgstr ""

#~ msgid "|7bfcfcb57ae5403f8e18486f45ca48b4|"
#~ msgstr ""

#~ msgid "|80152fa658904be08c849b4a594b76e1|"
#~ msgstr ""

#~ msgid "|35b60a1068f944ce937ac2988661aad5|"
#~ msgstr ""

#~ msgid "|efead7f2c2224b60b7b42705004c15e6|"
#~ msgstr ""

#~ msgid "|5421fee4e7ed450c903cbcd8a9d8a5d4|"
#~ msgstr ""

#~ msgid "|811fcf35e9214bd5b4e613e41f7c0a27|"
#~ msgstr ""

#~ msgid "|e61d38b0948f4c07a7257755f3799b54|"
#~ msgstr ""

#~ msgid "|e82c29351e2e480087c61b939eb7c041|"
#~ msgstr ""

#~ msgid "|21ca40f4fb1a405c89098fd1d24880a4|"
#~ msgstr ""

#~ msgid "|1351a2629c2c46d981b13b19f9fa45f0|"
#~ msgstr ""

#~ msgid "|124c2c188b994c7ab1c862cfdb326923|"
#~ msgstr ""

#~ msgid "|42e1951c36f2406e93c7ae0ec5b299f9|"
#~ msgstr ""

#~ msgid "|ec637b8a84234d068995ee1ccb2dd3b1|"
#~ msgstr ""

#~ msgid "|5bceb9d16b1a4d2db18d8a5b2f0cacb3|"
#~ msgstr ""

#~ msgid "|502b10044e864ca2b15282a393ab7faf|"
#~ msgstr ""

#~ msgid "|dbd9718fb89b4e219a54b72b6eecf502|"
#~ msgstr ""

#~ msgid "|18916394e69e4fdaafbb56f7bba690d3|"
#~ msgstr ""

#~ msgid "|20988fac7e2e497ea15f786730279299|"
#~ msgstr ""

#~ msgid "|5d612ca92b074af4a034bf4c0f498d2e|"
#~ msgstr ""

#~ msgid "|6721ae86e3f348e2bce58d358a2ee79c|"
#~ msgstr ""

#~ msgid "|d255f931abb44ca8a7eba0d90dfcf6a1|"
#~ msgstr ""

#~ msgid "|f98da3b55eca452390fb33429a7d7ebe|"
#~ msgstr ""

#~ msgid "|10dc1f84d36b432e95d7f61fcd25a701|"
#~ msgstr ""

#~ msgid "|f963159664b54e40a64a7f1c19414349|"
#~ msgstr ""

#~ msgid "|3647c3b36916415ab40c1597a3ddd4b0|"
#~ msgstr ""

#~ msgid "|a3c07b2cf1214488a99267b3757d9426|"
#~ msgstr ""

#~ msgid "|2f6bce3bfacf4c85ac3a7e0fd1d5aa84|"
#~ msgstr ""

#~ msgid "|19ebdce05cab40d791a2117f743290c3|"
#~ msgstr ""

#~ msgid "|dd729f8776d640ffb136545f3f26210f|"
#~ msgstr ""

#~ msgid "|6102f514742c4211b093aae3a5a74e51|"
#~ msgstr ""

#~ msgid "|24080db3b13d4b0c8546096de73ac82a|"
#~ msgstr ""

#~ msgid "|9087a1f0e9ab41c083f5209a3f17e600|"
#~ msgstr ""

#~ msgid "|a5d1853a0b3c44d4bdd408d15a89e7ac|"
#~ msgstr ""

#~ msgid "|8e6e9164d7414c39bf37f67e2fda59bd|"
#~ msgstr ""

#~ msgid "|e8b1d08849514de1b09fee325db970d0|"
#~ msgstr ""

#~ msgid "|ca0b3cb207164665b5bef1d869c37dff|"
#~ msgstr ""

#~ msgid "|977cb114b97047329a7bb908afbac2cd|"
#~ msgstr ""

#~ msgid "|9f497b02d2634af2925a65244cc0eb1b|"
#~ msgstr ""

#~ msgid "|938ae2cd4fae49ce9292e6e2d9bd880d|"
#~ msgstr ""

#~ msgid "|47cd7c6cb4094846833faff5b05e0d46|"
#~ msgstr ""

#~ msgid "|c90d6613b0a34a42bf3023ca5a81c8e2|"
#~ msgstr ""

#~ msgid "|91c29c3c9b1b411590de3983d94ed76a|"
#~ msgstr ""

#~ msgid "|e4adf0f92ebf4c3d9e6e64355204f897|"
#~ msgstr ""

#~ msgid ""
#~ "There are many ways to deploy "
#~ "Flower on Microst Azure. The "
#~ "instructions provided in this guide is"
#~ " just a basic walkthrough, step-"
#~ "by-step guide on how to quickly "
#~ "setup and run a Flower application "
#~ "on a Federated Learning environment on"
#~ " Microst Azure."
#~ msgstr ""

#~ msgid ""
#~ "In this how-to guide, we want "
#~ "to create a Federated Learning "
#~ "environment on Microst Azure using three"
#~ " Virtual Machines (VMs). From the "
#~ "three machines, one machine will be "
#~ "used as the Federation server and "
#~ "two as the Federation clients. Our "
#~ "goal is to create a Flower "
#~ "federation on Microst Azure where we "
#~ "can run Flower apps from our local"
#~ " machine, e.g., laptop."
#~ msgstr ""

#~ msgid ""
#~ "Assuming we are already inside the "
#~ "Microst Azure portal, we navigate to "
#~ "the ``Create`` page and we select "
#~ "``Azure virtual machine``. In the new"
#~ " page, for each VM we edit the"
#~ " properties as follows:"
#~ msgstr ""

#~ msgid "List runs."
#~ msgstr ""

#~ msgid ":py:obj:`get_context <flwr.client.Client.get_context>`\\ \\(\\)"
#~ msgstr ":py:obj:`get_context <flwr.client.Client.get_context>`\\ \\(\\)"

#~ msgid "Get the run context from this client."
#~ msgstr "이 클라이언트에서 실행 컨텍스트를 가져옵니다."

#~ msgid ":py:obj:`set_context <flwr.client.Client.set_context>`\\ \\(context\\)"
#~ msgstr ":py:obj:`set_context <flwr.client.Client.set_context>`\\ \\(context\\)"

#~ msgid "Apply a run context to this client."
#~ msgstr "이 클라이언트에 실행 컨텍스트를 적용합니다."

#~ msgid ":py:obj:`context <flwr.client.Client.context>`\\"
#~ msgstr ":py:obj:`context <flwr.client.Client.context>`\\"

#~ msgid "Getter for `Context` client attribute."
#~ msgstr ""

#~ msgid ":py:obj:`get_context <flwr.client.NumPyClient.get_context>`\\ \\(\\)"
#~ msgstr ":py:obj:`get_context <flwr.client.NumPyClient.get_context>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`set_context <flwr.client.NumPyClient.set_context>`\\"
#~ " \\(context\\)"
#~ msgstr ""
#~ ":py:obj:`set_context <flwr.client.NumPyClient.set_context>`\\"
#~ " \\(context\\)"

#~ msgid ":py:obj:`context <flwr.client.NumPyClient.context>`\\"
#~ msgstr ":py:obj:`context <flwr.client.NumPyClient.context>`\\"

#~ msgid "|ae2337ba61dd4efc818e63933fd81666|"
#~ msgstr ""

#~ msgid "|14a8d3feda794591a601daaaaa79d0b6|"
#~ msgstr ""

#~ msgid "|c67497f1afa84a30a3901418c6c0bb62|"
#~ msgstr ""

#~ msgid "|d4ce55da082146d7ad13ec4f73d427a2|"
#~ msgstr ""

#~ msgid "|0a0c4ca9de6549c1b35225c6e1183bc0|"
#~ msgstr ""

#~ msgid "|f2f5e8cc5594472c842192ec38ab9bbe|"
#~ msgstr ""

#~ msgid "|4e7b0cd854064aab9895573a612a0f06|"
#~ msgstr ""

#~ msgid "|e121faa35b114a0da17cf4bc42e74ce9|"
#~ msgstr ""

#~ msgid "|e7a57a83812c4dc8933fbb93cd0e46dc|"
#~ msgstr ""

#~ msgid "|a0283fe3cd0c4f3cb5d119f424c657fd|"
#~ msgstr ""

#~ msgid "|debbe320f2c741388902ebabfb6fc705|"
#~ msgstr ""

#~ msgid "|8be6ce669d3148f9af6272ca27a98197|"
#~ msgstr ""

#~ msgid "|47c4a06eafbb4e2fa1c62b5ca47d3411|"
#~ msgstr ""

#~ msgid "|5e84b181879b4bcda37b672215325b30|"
#~ msgstr ""

#~ msgid ""
#~ "By default, the SuperLink container runs"
#~ " with a non-root user called "
#~ "``app`` with the user ID ``49999``. "
#~ "It is recommended to create a new"
#~ " directory and change the user ID "
#~ "of the directory to ``49999`` to "
#~ "ensure the mounted directory has the "
#~ "proper permissions."
#~ msgstr ""

#~ msgid "|31d9fb7c284a414ba34e32ced3b17b11|"
#~ msgstr ""

#~ msgid "|32af43ffb54a421d8cfe59939c34206b|"
#~ msgstr ""

#~ msgid "|34c462a3cde341389422badb2077fc36|"
#~ msgstr ""

#~ msgid "|3a2ded531a9a4b86af3e743490e78172|"
#~ msgstr ""

#~ msgid "|52e91c4927884d7293956a379489d8c3|"
#~ msgstr ""

#~ msgid "|2bb7af14de844e40bd4186c902800ff5|"
#~ msgstr ""

#~ msgid "|c7538d5f23f142e693a8879fb03e3932|"
#~ msgstr ""

#~ msgid "|44f9182037b141868306b5c7d2d7bdf6|"
#~ msgstr ""

#~ msgid "|e198f643aecc4cd58ca665e6979b5bb3|"
#~ msgstr ""

#~ msgid "|3e52791d62db46e0b0485e4f05a71070|"
#~ msgstr ""

#~ msgid "|eeb43ec811934701963187e3822826ae|"
#~ msgstr ""

#~ msgid "|b1642f82fc774ff3a1f7b2f077844291|"
#~ msgstr ""

#~ msgid "|17ab6ee928b54a02afcac8d896a3a637|"
#~ msgstr ""

#~ msgid "|1bd7ba9475d44bdbb4d4a4a40d3e2267|"
#~ msgstr ""

#~ msgid "|fd03dc24279440f299c591b59b228438|"
#~ msgstr ""

#~ msgid "|5a0a72bb6d3a4e3fb578185f780e3f3d|"
#~ msgstr ""

#~ msgid "|9607dbebfb2d4d389c996a678cf2f5a1|"
#~ msgstr ""

#~ msgid "|6cf3fb6dc7504f29893b7a3e7c3ef81f|"
#~ msgstr ""

#~ msgid "|90fef4f0d9aa418fb96b245fb62f5660|"
#~ msgstr ""

#~ msgid "|933a3b6b5602441dbfbcce426f8b4c61|"
#~ msgstr ""

#~ msgid "|782b65bd48c74e4dab140622f844d5a9|"
#~ msgstr ""

#~ msgid "|5f168acb52014c079c5b3c6c31467f53|"
#~ msgstr ""

#~ msgid "|a884ff248d9b40acaaab7a5e6ad9d426|"
#~ msgstr ""

#~ msgid "|a666a814c57d4853b4c4aca56b9ade08|"
#~ msgstr ""

#~ msgid "|3de37d82bce14db4a1830b36fb41b3f9|"
#~ msgstr ""

#~ msgid "|426f23a87a3a4f0b864128eb1db22a56|"
#~ msgstr ""

#~ msgid "|0a713fc6c2984f94a63def2288d449a1|"
#~ msgstr ""

#~ msgid "|2a721cef360b4f64a96d2647381767d1|"
#~ msgstr ""

#~ msgid ""
#~ "For increased security, node authentication"
#~ " can only be used when encrypted "
#~ "connections (SSL/TLS) are enabled."
#~ msgstr "보안을 강화하기 위해 노드 인증은 암호화된 연결(SSL/TLS)을 사용하도록 설정한 경우에만 사용할 수 있습니다."

#~ msgid ""
#~ "To enable node authentication, first you"
#~ " need to configure SSL/TLS connections "
#~ "to secure the SuperLink<>SuperNode "
#~ "communication. You can find the complete"
#~ " guide `here <https://flower.ai/docs/framework/how-"
#~ "to-enable-ssl-connections.html>`_. After "
#~ "configuring secure connections, you can "
#~ "enable client authentication in a "
#~ "long-running Flower ``SuperLink``. Use the"
#~ " following terminal command to start "
#~ "a Flower ``SuperNode`` that has both "
#~ "secure connections and node authentication "
#~ "enabled:"
#~ msgstr ""
#~ "노드 인증을 활성화하려면 먼저 SuperLink<>SuperNode "
#~ "통신을 보호하기 위해 SSL/TLS 연결을 구성해야 합니다."
#~ " 전체 가이드는 `여기 <https://flower.ai/docs/framework"
#~ "/how-to-enable-ssl-connections.html>`_에서 "
#~ "확인할 수 있습니다. 보안 연결을 구성한 후, 장기"
#~ " 실행하는 Flower :code:`SuperLink`에서 클라이언트 인증을"
#~ " 활성화할 수 있습니다. 다음 터미널 명령을 사용하여"
#~ " 보안 연결과 노드 인증이 모두 활성화된 Flower"
#~ " :code:`SuperNode`를 시작하세요:"

#~ msgid "Let's break down the authentication flags:"
#~ msgstr "인증 플래그를 세분화해 보겠습니다:"

#~ msgid ""
#~ "The first flag ``--auth-list-public-"
#~ "keys`` expects a path to a CSV "
#~ "file storing all known node public "
#~ "keys. You need to store all known"
#~ " node public keys that are allowed"
#~ " to participate in a federation in"
#~ " one CSV file (``.csv``)."
#~ msgstr ""
#~ "첫 번째 플래그 :code:`--auth-list-public-"
#~ "keys`는 알려진 모든 노드 공개키를 저장하는 CSV "
#~ "파일의 경로를 기대합니다. federation에 참여하도록 허용된 "
#~ "모든 알려진 노드 공개 키를 하나의 CSV "
#~ "파일(:code:`.csv`)에 저장해야 합니다."

#~ msgid ""
#~ "The second and third flags ``--auth-"
#~ "superlink-private-key`` and ``--auth-"
#~ "superlink-public-key`` expect paths to "
#~ "the server's private and public keys."
#~ " For development purposes, you can "
#~ "generate a private and public key "
#~ "pair using ``ssh-keygen -t ecdsa "
#~ "-b 384``."
#~ msgstr ""
#~ "두 번째 및 세 번째 플래그 :code:`--auth-"
#~ "superlink-private-key` 및 :code:`--auth-"
#~ "superlink-public-key`는 서버의 개인 및 공개"
#~ " 키의 경로를 예상합니다. 개발 목적으로 :code:`ssh-"
#~ "keygen -t ecdsa -b 384`를 사용하여 개인"
#~ " 및 공개 키 쌍을 생성할 수 있습니다."

#~ msgid ""
#~ "In Flower 1.9, there is no support"
#~ " for dynamically removing, editing, or "
#~ "adding known node public keys to "
#~ "the SuperLink. To change the set "
#~ "of known nodes, you need to shut"
#~ " the server down, edit the CSV "
#~ "file, and start the server again. "
#~ "Support for dynamically changing the set"
#~ " of known nodes is on the "
#~ "roadmap to be released in Flower "
#~ "1.10 (ETA: June)."
#~ msgstr ""
#~ "Flower 1.9에서는 알려진 노드 공개키를 SuperLink에 "
#~ "동적으로 제거, 편집 또는 추가하는 기능이 지원되지 "
#~ "않습니다. 알려진 노드 집합을 변경하려면 서버를 종료하고"
#~ " CSV 파일을 편집한 다음 서버를 다시 시작해야 "
#~ "합니다. 알려진 노드 집합을 동적으로 변경하는 기능은 "
#~ "Flower 1.10(출시 예정일: 6월)에서 로드맵에 포함되어 "
#~ "있습니다."

#~ msgid ""
#~ "Similar to the long-running Flower "
#~ "server (``SuperLink``), you can easily "
#~ "enable node authentication in the "
#~ "long-running Flower client (``SuperNode``). "
#~ "Use the following terminal command to"
#~ " start an authenticated ``SuperNode``:"
#~ msgstr ""
#~ "장기 실행 중인 Flower 서버(:code:`SuperLink`)와 "
#~ "마찬가지로, 장기 실행 중인 Flower "
#~ "클라이언트(:code:`SuperNode`)에서도 노드 인증을 쉽게 활성화할 "
#~ "수 있습니다. 다음 터미널 명령을 사용하여 인증된 "
#~ ":code:`SuperNode`를 시작하세요:"

#~ msgid ""
#~ "The ``--auth-supernode-private-key`` "
#~ "flag expects a path to the node's"
#~ " private key file and the "
#~ "``--auth-supernode-public-key`` flag "
#~ "expects a path to the node's "
#~ "public key file. For development "
#~ "purposes, you can generate a private "
#~ "and public key pair using ``ssh-"
#~ "keygen -t ecdsa -b 384``."
#~ msgstr ""
#~ ":code:`--auth-supernode-private-key` 플래그는 "
#~ "노드의 개인 키 파일 경로를, :code:`--auth-"
#~ "supernode-public-key` 플래그는 노드의 공개 키"
#~ " 파일 경로를 예상합니다. 개발 목적으로 :code:`ssh-"
#~ "keygen -t ecdsa -b 384`를 사용하여 개인"
#~ " 및 공개 키 쌍을 생성할 수 있습니다."

#~ msgid ""
#~ "This guide describes how to a "
#~ "TLS-enabled secure Flower server "
#~ "(``SuperLink``) can be started and how"
#~ " a Flower client (``SuperNode``) can "
#~ "establish a secure connections to it."
#~ msgstr ""
#~ "이 가이드에서는 SSL을 지원하는 보안 Flower "
#~ "서버(:코드:`SuperLink`)를 시작하는 방법과 Flower "
#~ "클라이언트(:코드:`SuperNode`)가 이 서버에 보안 연결을 "
#~ "설정하는 방법을 설명합니다."

#~ msgid ""
#~ "A complete code example demonstrating a"
#~ " secure connection can be found `here"
#~ " <https://github.com/adap/flower/tree/main/examples/advanced-"
#~ "tensorflow>`_."
#~ msgstr ""
#~ "보안 연결을 보여주는 전체 코드 예제는 '여기 "
#~ "<https://github.com/adap/flower/tree/main/examples/advanced-"
#~ "tensorflow>`_'에서 확인할 수 있습니다."

#~ msgid ""
#~ "The code example comes with a "
#~ "``README.md`` file which explains how to"
#~ " start it. Although it is already "
#~ "TLS-enabled, it might be less "
#~ "descriptive on how it does so. "
#~ "Stick to this guide for a deeper"
#~ " introduction to the topic."
#~ msgstr ""
#~ "코드 예제에는 시작 방법을 설명하는 :code:`README.md`"
#~ " 파일이 함께 제공됩니다. 이미 SSL을 사용하도록 "
#~ "설정되어 있지만 그 방법에 대한 설명이 부족할 수"
#~ " 있습니다. 이 가이드를 참고하여 이 주제에 대해 "
#~ "자세히 알아보세요."

#~ msgid ""
#~ "Using TLS-enabled connections requires "
#~ "certificates to be passed to the "
#~ "server and client. For the purpose "
#~ "of this guide we are going to "
#~ "generate self-signed certificates. As "
#~ "this can become quite complex we "
#~ "are going to ask you to run "
#~ "the script in ``examples/advanced-"
#~ "tensorflow/certificates/generate.sh`` with the "
#~ "following command sequence:"
#~ msgstr ""
#~ "SSL 사용 연결을 사용하려면 서버와 클라이언트에 인증서를"
#~ " 전달해야 합니다. 이 가이드에서는 자체 서명된 인증서를"
#~ " 생성하겠습니다. 이 과정은 상당히 복잡할 수 있으므로"
#~ " 다음 명령 시퀀스를 사용하여 :code:`examples"
#~ "/advanced-tensorflow/certificates/generate.sh`에서 스크립트를 "
#~ "실행하도록 요청하겠습니다:"

#~ msgid ""
#~ "This will generate the certificates in"
#~ " ``examples/advanced-tensorflow/.cache/certificates``."
#~ msgstr ""
#~ "이렇게 하면 :code:`examples/advanced-"
#~ "tensorflow/.cache/certificates`에 인증서가 생성됩니다."

#~ msgid "Server (SuperLink)"
#~ msgstr "서버(SuperLink)"

#~ msgid ""
#~ "Navigate to the ``examples/advanced-"
#~ "tensorflow`` folder (`here "
#~ "<https://github.com/adap/flower/tree/main/examples/advanced-"
#~ "tensorflow>`_) and use the following "
#~ "terminal command to start a server "
#~ "(SuperLink) that uses the previously "
#~ "generated certificates:"
#~ msgstr "다음 터미널 명령을 사용하여 이전에 생성한 인증서를 사용하는 서버(SuperLink)를 시작합니다:"

#~ msgid ""
#~ "When providing certificates, the server "
#~ "expects a tuple of three certificates"
#~ " paths: CA certificate, server certificate"
#~ " and server private key."
#~ msgstr "인증서를 제공할 때 서버는 세 가지 인증서 경로의 튜플을 기대합니다: CA 인증서, 서버 인증서 및 서버 개인 키입니다."

#~ msgid "Clients (SuperNode)"
#~ msgstr "클라이언트(SuperNode)"

#~ msgid ""
#~ "Use the following terminal command to"
#~ " start a client (SuperNode) that uses"
#~ " the previously generated certificates:"
#~ msgstr "다음 터미널 명령을 사용하여 이전에 생성한 인증서를 사용하는 클라이언트(SuperNode)를 시작합니다:"

#~ msgid ""
#~ "When setting ``root_certificates``, the client"
#~ " expects a file path to PEM-"
#~ "encoded root certificates."
#~ msgstr "코드:`root_certificates`를 설정하면 클라이언트는 PEM 인코딩된 루트 인증서의 파일 경로를 예상합니다."

#~ msgid ""
#~ "In another terminal, start a second "
#~ "SuperNode that uses the same "
#~ "certificates:"
#~ msgstr "다음 터미널 명령을 사용하여 이전에 생성한 인증서를 사용하는 클라이언트(SuperNode)를 시작합니다:"

#~ msgid ""
#~ "Note that in the second SuperNode, "
#~ "if you run both on the same "
#~ "machine, you must specify a different"
#~ " port for the ``ClientAppIO`` API "
#~ "address to avoid clashing with the "
#~ "first SuperNode."
#~ msgstr ""

#~ msgid "Executing ``flwr run`` with TLS"
#~ msgstr ""

#~ msgid ""
#~ "The root certificates used for executing"
#~ " ``flwr run`` is specified in the "
#~ "``pyproject.toml`` of your app."
#~ msgstr ""

#~ msgid ""
#~ "Note that the path to the "
#~ "``root-certificates`` is relative to the"
#~ " root of the project. Now, you "
#~ "can run the example by executing "
#~ "the following:"
#~ msgstr ""

#~ msgid ""
#~ "For running a Docker setup with "
#~ "TLS enabled, please refer to "
#~ ":doc:`docker/enable-tls`."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federating Learning "
#~ "quickstart tutorial for using Flower "
#~ "with 🤗 HuggingFace Transformers in order"
#~ " to fine-tune an LLM."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with PyTorch to train a CNN model"
#~ " on MNIST."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with TensorFlow to train a CNN "
#~ "model on CIFAR-10."
#~ msgstr ""

#~ msgid "|2de22ebd50a840dba14a673c6fed3ed5|"
#~ msgstr ""

#~ msgid "|40524cd4aa474db2992d8a8c40807297|"
#~ msgstr ""

#~ msgid "|9da60840ee0644b092f05ba73173f33a|"
#~ msgstr ""

#~ msgid "|11e0092cabe6445aad58eb94008d2200|"
#~ msgstr ""

#~ msgid "|4de4dc335c4e4f7d9295ca4b428cbfd6|"
#~ msgstr ""

#~ msgid "|ac43194992e34215bfc57033a6166801|"
#~ msgstr ""

#~ msgid "|7ff78e3c16f14ec1ac0282d2fad76719|"
#~ msgstr ""

#~ msgid "|09aa0d8c374148f3908afce241381f58|"
#~ msgstr ""

#~ msgid "|caf1e69f45ff4824853d1f4bc9b083bb|"
#~ msgstr ""

#~ msgid "|8972366fab9a408b8162ddb6475e1095|"
#~ msgstr ""

#~ msgid "|67860439ceff4a16a055b8b51cda19b9|"
#~ msgstr ""

#~ msgid "|f9ca6f1bc91a4f1397f77ed3bf27ac3e|"
#~ msgstr ""

#~ msgid "|65a316b05fef4a7bbfe03a9c9aa84b4f|"
#~ msgstr ""

#~ msgid "|09111c31a80a4af5a651312e46ee31b5|"
#~ msgstr ""

#~ msgid "|ab47426a03a540aab6d401a2e00e630e|"
#~ msgstr ""

#~ msgid "|0d8c9ad409714074ae083557fab3f34b|"
#~ msgstr ""

#~ msgid "|20d6250fb8cc4abf9442570fd93706e3|"
#~ msgstr ""

#~ msgid "|02a05be7352e4233baec107c46e4ace4|"
#~ msgstr ""

#~ msgid "|043c0e55eb7a4411933bfa341890e0b6|"
#~ msgstr ""

#~ msgid "|ca81526a51a940cba568ec4dd9ce4137|"
#~ msgstr ""

#~ msgid "|d1e5d1d8fc3642069b869a6f656d99a0|"
#~ msgstr ""

#~ msgid "|227f062dc4844a5bb8055f47cfb36e5d|"
#~ msgstr ""

#~ msgid "|e5b34296888f44e982a4ae1e3d29c4f0|"
#~ msgstr ""

#~ msgid "|396ef4bc3df74a3b94142f6e96719951|"
#~ msgstr ""

#~ msgid "|3557c0ad777c453dad5df7be537236d8|"
#~ msgstr ""

#~ msgid "|30d31cc898e0476f9e72f9984d5223b8|"
#~ msgstr ""

#~ msgid "|6115667841094c2b9c5e5dc12b3aeea0|"
#~ msgstr ""

#~ msgid "|6347089b6d794100af39cc2f5efc2a1b|"
#~ msgstr ""

#~ msgid "|bc27456848e64eab91d9c28ac80836f8|"
#~ msgstr ""

#~ msgid "|af7ab090b8ca4a3ea5f91376cf92f169|"
#~ msgstr ""

#~ msgid "|9081c3b024ae4b729477daa854968460|"
#~ msgstr ""

#~ msgid "|b4783612fdcd4e3590acd2caa9c226a0|"
#~ msgstr ""

#~ msgid "|5d4a7868bf284987b4cb8103d2e853d0|"
#~ msgstr ""

#~ msgid "|ac1f30abf656450bbc12430097c8773a|"
#~ msgstr ""

#~ msgid "|9e893e9099c04a5fb47ce94203d7b286|"
#~ msgstr ""

#~ msgid "|bf91fef9dd494fa0bfe3334d71af54d0|"
#~ msgstr ""

#~ msgid "|9e783a90144a43b38e7c6a1326318c0a|"
#~ msgstr ""

#~ msgid "|90a2cfd3d470407daef02a61de7f551c|"
#~ msgstr ""

#~ msgid "|a7bbca4dc8f9409c87df77a68dcc85b5|"
#~ msgstr ""

#~ msgid "|565ca369f6d0451e8a8abbda9a93bdd8|"
#~ msgstr ""

#~ msgid "|c839c0da8e7a4e76ad21c72a5311d2e7|"
#~ msgstr ""

#~ msgid "|07d4d06f1bf746989510c85dbe96f4e3|"
#~ msgstr ""

#~ msgid "**Common exit codes (500-)**: Shared across multiple components."
#~ msgstr ""

#~ msgid "[500] COMMON_ADDRESS_INVALID"
#~ msgstr ""

#~ msgid "[501] COMMON_MISSING_EXTRA_REST"
#~ msgstr ""

#~ msgid "[502] COMMON_TLS_NOT_SUPPORTED"
#~ msgstr ""

#~ msgid "|fb54a2bb9135460a80655c253e9f6180|"
#~ msgstr ""

#~ msgid "|dbb29ab4fa1c4634b84f10fcf5ddd35e|"
#~ msgstr ""

#~ msgid "|385792b816c5453db447d379d4970aee|"
#~ msgstr ""

#~ msgid "|608cf1b5aad34ed78ae9defeefd9603c|"
#~ msgstr ""

#~ msgid "|8d464285997143f8a6d1cff66c67abda|"
#~ msgstr ""

#~ msgid "|d5683c1caa9e42e29b888e3112a90a85|"
#~ msgstr ""

#~ msgid "|476afa181eed4ce98a5231f375a61c29|"
#~ msgstr ""

#~ msgid "|ead51ebc3bc84dde8bdee09ecb7df092|"
#~ msgstr ""

#~ msgid "|159e64a77db1476d86c2c39ce4d59023|"
#~ msgstr ""

#~ msgid "|2063d930771c480fbc09efe29550a35c|"
#~ msgstr ""

#~ msgid "|cfccf70ecc234e3eafc4b85714f3d369|"
#~ msgstr ""

#~ msgid "|c853749d35204647bd6a66b4be4ed9dd|"
#~ msgstr ""

#~ msgid "|424b774c02284dfd97cc6abc2e7e5016|"
#~ msgstr ""

#~ msgid "|01432c2b27de47ab987fef35e497e4d3|"
#~ msgstr ""

#~ msgid "|ad5e283383fd4f1c8a4d51a63ff9cfc6|"
#~ msgstr ""

#~ msgid "|8e9e1155906a4bd095cab209207d698e|"
#~ msgstr ""

#~ msgid "|9decc6d7bb0147dcbce540f7332c69c9|"
#~ msgstr ""

#~ msgid "|3e476dc22aa4464d802d0d0596cdb3a9|"
#~ msgstr ""

#~ msgid "|8e0b4f6256554d57a85d490117e03fb4|"
#~ msgstr ""

#~ msgid "|895339f112c54ae49bbeb69f01d6bfc6|"
#~ msgstr ""

#~ msgid "|563f54e700664e23b33fc7039a380c93|"
#~ msgstr ""

#~ msgid "|e72c6e0772034e639ff3e8486493f103|"
#~ msgstr ""

#~ msgid "|42c7784cc4504dfd847f004a6a459918|"
#~ msgstr ""

#~ msgid "|2ae00797633e45e7b1753e54356038b4|"
#~ msgstr ""

#~ msgid "|1d82ec63ef90404f8c19dc925f757ca4|"
#~ msgstr ""

#~ msgid "|0fb9c15b018445ce9505737b111255ec|"
#~ msgstr ""

#~ msgid "|c1b86d4c1f574731976a92221b9ccbb6|"
#~ msgstr ""

#~ msgid "|19c7a73ef14a43b9bb0ed84011a0367d|"
#~ msgstr ""

#~ msgid ""
#~ "Using ECDH, both SuperNode and SuperLink"
#~ " independently derive a shared secret"
#~ msgstr "SuperNode와 SuperLink는 ECDH를 사용하여 독립적으로 공유된 비밀을 도출합니다"

#~ msgid ""
#~ "Shared secret is used to compute "
#~ "the HMAC value of the message sent"
#~ " from SuperNode to SuperLink as a "
#~ "token"
#~ msgstr "비밀 공유는 SuperNode에서 SuperLink로 토큰으로 전송된 메시지의 HMAC 값을 계산하는 데 사용됩니다"

#~ msgid "SuperLink verifies the token"
#~ msgstr "SuperLink가 토큰을 확인합니다"

#~ msgid "``--auth-superlink-private-key``: the private key of the SuperLink."
#~ msgstr ""

#~ msgid "``--auth-superlink-public-key``: the public key of the SuperLink."
#~ msgstr ""

#~ msgid "|d8f98c8f80fc4a7e94e6855ac6fbc7fc|"
#~ msgstr ""

#~ msgid "|e86d5e237c1840c39e3f41b4ac7b124f|"
#~ msgstr ""

#~ msgid "|9afc14c1605148018d62740b4ccb5832|"
#~ msgstr ""

#~ msgid "|d3fc35ce213a4e58af6094dc17767eff|"
#~ msgstr ""

#~ msgid "|1ea218a90c064790b8c279ad52e125b8|"
#~ msgstr ""

#~ msgid "|97cc23c9f87f4a4ea250d9ef18cbf470|"
#~ msgstr ""

#~ msgid "|6b93cc04ab444cebbd4ba95eae0b7131|"
#~ msgstr ""

#~ msgid "|9218bb2c309a4954b9dbbf1cbcc378ac|"
#~ msgstr ""

#~ msgid "|69c59d7ad4504b878678896392413bc9|"
#~ msgstr ""

#~ msgid "|e8ec4e15c93b410481809047487792ee|"
#~ msgstr ""

#~ msgid "|a0d2236676b34653a63d638648555a8e|"
#~ msgstr ""

#~ msgid "|84e52841ac4e47de8bd64e2a36803ce8|"
#~ msgstr ""

#~ msgid "|3b94c4986bf7458fbd2c19506712c68e|"
#~ msgstr ""

#~ msgid "|ab451c891332411989c05b3e0ce9e269|"
#~ msgstr ""

#~ msgid "|8a32c27e093c420c9a04f2ccb6411781|"
#~ msgstr ""

#~ msgid "|c4e577ebf8814c3db899b7859e554ad0|"
#~ msgstr ""

#~ msgid "|1ebbc50e7c5b4e43a758e3b27e5f32a4|"
#~ msgstr ""

#~ msgid "|2751e68c73f84ee8b49205e9b398c029|"
#~ msgstr ""

#~ msgid "|ba6aa4bb6d144eecbf7b345103976d5d|"
#~ msgstr ""

#~ msgid "|c232cf09eaf54c11a1e3d0b8ee4f1715|"
#~ msgstr ""

#~ msgid "|3d7f51fb8a0f492a8e9414382ade7878|"
#~ msgstr ""

#~ msgid "|1c475b7b6b3649769f4d234b30c924a6|"
#~ msgstr ""

#~ msgid "|e64f2b578dd549d9bed0c691dd490c82|"
#~ msgstr ""

#~ msgid "|503c43bc67944dfa8325fc729fd43e20|"
#~ msgstr ""

#~ msgid "|f347ea4acdce4f48bdaf44e720e66bfe|"
#~ msgstr ""

#~ msgid "|cd91e0ea312f4ff8a571dddd7c25737f|"
#~ msgstr ""

#~ msgid "|0f02baf4a2594209845b7181381cb0c0|"
#~ msgstr ""

#~ msgid "|6c43269d50c448dab831fbd7e4d37a55|"
#~ msgstr ""

#~ msgid ""
#~ "Explore the federated learning architecture"
#~ " of the Flower framework, featuring "
#~ "multi-run, concurrent execution, and "
#~ "scalable, secure machine learning while "
#~ "preserving data privacy."
#~ msgstr ""

#~ msgid "|e513c53249574a7ab9046cc8352b7510|"
#~ msgstr ""

#~ msgid "|bd41897cd0074390a236966b3f9f5ee1|"
#~ msgstr ""

#~ msgid "|d8abfd5e3ae648d6a62792b75531fb48|"
#~ msgstr ""

#~ msgid "|4df8553bc6d946febceec9b15e1cb03a|"
#~ msgstr ""

#~ msgid "|59158ba420384424bef75993a91b288e|"
#~ msgstr ""

#~ msgid "|f0b31eeddd3e4006bd41cd54d8f1c40d|"
#~ msgstr ""

#~ msgid "|205ce4de0fa842ba9f5a0d4ad1260023|"
#~ msgstr ""

#~ msgid "|b32e2105fba64a9ba185a8b0934329ce|"
#~ msgstr ""

#~ msgid "|bb454c69eb16424babce129a30e47271|"
#~ msgstr ""

#~ msgid "|bdb3c58c93a44794a8d3eff87c254102|"
#~ msgstr ""

#~ msgid "|0383294bcdce4379adf790497bfe1588|"
#~ msgstr ""

#~ msgid "|329340ee2de443c78fdcdc4a43a55562|"
#~ msgstr ""

#~ msgid "|d7d1094c52f741ea830675e877293adb|"
#~ msgstr ""

#~ msgid "|df3ec0ca8a314f6ea4af3ac23a39ce3c|"
#~ msgstr ""

#~ msgid ""
#~ "By default, the Flower logger uses "
#~ "logging level ``INFO``. This can be "
#~ "changed via the ``PYTHONLOGLEVEL`` environment"
#~ " variable to any other levels that"
#~ " Python's `logging module "
#~ "<https://docs.python.org/3/library/logging.html#logging-"
#~ "levels>`_ supports. For example, to "
#~ "launch your ``SuperLink`` showing ``DEBUG``"
#~ " logs do:"
#~ msgstr ""

#~ msgid ""
#~ "You can make use of the "
#~ "``PYTHONLOGLEVEL`` environment variable when "
#~ "executing other Flower commands to "
#~ "provision the different components in a"
#~ " Flower Federation (see :doc:`how-to-"
#~ "run-flower-with-deployment-engine`) or "
#~ "using the `flwr CLI <ref-api-"
#~ "cli.html>`_."
#~ msgstr ""

#~ msgid "|370ce238c1874c3b86c8a0b031da5535|"
#~ msgstr ""

#~ msgid "|33722de695c8489991b0b4c6fd3f1be5|"
#~ msgstr ""

#~ msgid "|83f02921297743e2952253541405689a|"
#~ msgstr ""

#~ msgid "|1d5320cc498f4dfaae37f1fd002f1ff1|"
#~ msgstr ""

#~ msgid "|43c990ef195743b0ad59008926404c8f|"
#~ msgstr ""

#~ msgid "|9fe8ef4893ab47eebc8f7c8b5af5ef20|"
#~ msgstr ""

#~ msgid "|2142bba001c14f56b9091dab30f436a0|"
#~ msgstr ""

#~ msgid "|552b4b06568344e6bbfa2bcc2bb8b751|"
#~ msgstr ""

#~ msgid "|fe1ddbea96ab4ab7a2ecddba38ef339d|"
#~ msgstr ""

#~ msgid "|121df5d9556e400c83d37bb9a00a794b|"
#~ msgstr ""

#~ msgid "|c43e4c175380485d8a38d3d79474084f|"
#~ msgstr ""

#~ msgid "|a041beb26f0747ee9cdb8b0be4b7de73|"
#~ msgstr ""

#~ msgid "|80ca4aba84fc4e4ca0212c57304c3d8e|"
#~ msgstr ""

#~ msgid "|eb867687936d4a00b568da114f5ce282|"
#~ msgstr ""

#~ msgid "|e90888cebb6d4791b9e2849849c55bd0|"
#~ msgstr ""

#~ msgid "|2cc316dacb0646df9c06bad17c29696b|"
#~ msgstr ""

#~ msgid "|d1b819841f6f42da9763a730296431a1|"
#~ msgstr ""

#~ msgid "|c7ba7c6bbbf346a1b151426b9da1c42a|"
#~ msgstr ""

#~ msgid "|11e94adb0b2348b394bf6b31c923b7bc|"
#~ msgstr ""

#~ msgid "|602b293637a04c37a5ec713415c563e7|"
#~ msgstr ""

#~ msgid "|1a05e52c0dee4820bcbf29e6da96fd63|"
#~ msgstr ""

#~ msgid "|62364ebe2b86427bb86f7d82325114ea|"
#~ msgstr ""

#~ msgid "|b622f3cb31a54cc195af90c255277d79|"
#~ msgstr ""

#~ msgid "|c2609c65a91f4062959125c080d606ad|"
#~ msgstr ""

#~ msgid "|13c05c70e6e64b4b93686dbc4a4900bc|"
#~ msgstr ""

#~ msgid "|44aa775e2a604c32932c3e7c05493a1c|"
#~ msgstr ""

#~ msgid "|4294dbf0796a4fb68ecfe4f89461ed9f|"
#~ msgstr ""

#~ msgid "|1cf0f3d2d44e47c7bfaa71cecf7a0fe4|"
#~ msgstr ""

#~ msgid "quickstart-tabnet"
#~ msgstr "빠른 시작 튜토리얼"

#~ msgid "We also made video tutorials for PyTorch:"
#~ msgstr "파이토치용 동영상 튜토리얼도 만들었습니다:"

#~ msgid "And TensorFlow:"
#~ msgstr "그리고 TensorFlow도:"

#~ msgid "|2375819ef1ec4145a4c91492343eb475|"
#~ msgstr ""

#~ msgid "|ce375b86764b446d8f33a01d32909a4d|"
#~ msgstr ""

#~ msgid "|b2facc1f0966468b962e3d66c1e454f2|"
#~ msgstr ""

#~ msgid "|2361a45884fe41bf8825175b31880a9c|"
#~ msgstr ""

#~ msgid "|d0b86ab6b5cc49e1a3e6b031594bf7fe|"
#~ msgstr ""

#~ msgid "|c06175382a73496b968d94d01cd9bdd3|"
#~ msgstr ""

#~ msgid "|80f03044b21b472e866ae9c31202a8ad|"
#~ msgstr ""

#~ msgid "|dfc8acb1c72b4572a3632e2f198da658|"
#~ msgstr ""

#~ msgid "|4b6dc916acdc499dad963b52d56fd602|"
#~ msgstr ""

#~ msgid "|3efa977622c34263ac76d6d5adcb641c|"
#~ msgstr ""

#~ msgid "|a2d6ccc96e214863831cb2eff5b6f81a|"
#~ msgstr ""

#~ msgid "|7f089ba5b4c34189b974daf1ce3c3bd0|"
#~ msgstr ""

#~ msgid "|7468ad3dbeea44079c56a11d3c741a1b|"
#~ msgstr ""

#~ msgid "|c79e686ab53847f1a476c3d45f574a80|"
#~ msgstr ""

#~ msgid ""
#~ "Flower has built-in support for "
#~ "authenticated SuperNodes, allowing you to "
#~ "verify the identity of each SuperNode"
#~ " connecting to a SuperLink. To "
#~ "enhance security, node authentication is "
#~ "only available when encrypted connections "
#~ "(SSL/TLS) are enabled."
#~ msgstr ""
#~ "Flower는 SuperLink에 연결하는 각 SuperNodes의 "
#~ "신원을 확인하는 데 사용할 수 있는 인증된 "
#~ "SuperNodes에 대한 기본 지원을 제공합니다. Flower "
#~ "노드 인증은 GitHub SSH 인증 방식과 유사하게 "
#~ "작동합니다:"

#~ msgid ""
#~ "Flower's node authentication leverages a "
#~ "signature-based mechanism to verify each"
#~ " node's identity:"
#~ msgstr ""

#~ msgid "|8121c8d231f04cce80d7d4a749d05fad|"
#~ msgstr ""

#~ msgid "|63d7d57ea2d14e1fa565edc5f8e6d0c3|"
#~ msgstr ""

#~ msgid "|034829480fa740afbbc7453e5b1fd345|"
#~ msgstr ""

#~ msgid "|525ed0f9bbae4478abd6a50130254461|"
#~ msgstr ""

#~ msgid "|ad35e1ba0252470fa69bd391f60354b9|"
#~ msgstr ""

#~ msgid "|686da575bf794c5d8609e37d8211329b|"
#~ msgstr ""

#~ msgid "|c58b4e957826408db980c238687ab898|"
#~ msgstr ""

#~ msgid "|c081e06494f04261a29467861ad8d746|"
#~ msgstr ""

#~ msgid "|2ba32b63692d48bb995937727cc3d76f|"
#~ msgstr ""

#~ msgid "|8995fb47885b4240aa063f1c1189d0a6|"
#~ msgstr ""

#~ msgid "|e0f6b07c2a9d47e68041fec453aa5098|"
#~ msgstr ""

#~ msgid "|fd69260872954015a8a4b3b7a0a0b27f|"
#~ msgstr ""

#~ msgid "|335c4f36d8c64f2eb468a30b4d424b24|"
#~ msgstr ""

#~ msgid "|0e3cb3b010bd4cea901b3dbd34efa139|"
#~ msgstr ""

#~ msgid "|e0c556c281e7463baa4def45f4d5ba73|"
#~ msgstr ""

#~ msgid "|b8279f54fc34406fb52f5820102bc6fa|"
#~ msgstr ""

#~ msgid "|ee2d8bc330a54cdeb58ee44948637374|"
#~ msgstr ""

#~ msgid "|34696a7cce9e48d3b640b1c045dc40cb|"
#~ msgstr ""

#~ msgid "|d8b0bd62872f45319f166e1f0d623b36|"
#~ msgstr ""

#~ msgid "|f7d64ff25bb345e996383356b0d3845f|"
#~ msgstr ""

#~ msgid "|de37efd40fd04b98a1036e2a261a2ab2|"
#~ msgstr ""

#~ msgid "|343d0891c7b34d50bfe949f6b5559f41|"
#~ msgstr ""

#~ msgid "|6043540856ae47b7902fc686586c8389|"
#~ msgstr ""

#~ msgid "|9cd87cbb59654bff8ff40bb9c999d5c2|"
#~ msgstr ""

#~ msgid "|c9012bcdc7fc484490035ff2c9dfc4a4|"
#~ msgstr ""

#~ msgid "|e32a6f59455948cb9fead864eb338272|"
#~ msgstr ""

#~ msgid "|10d5549c02f64a3d90f08aeebeab58a2|"
#~ msgstr ""

#~ msgid "|1e958be1c6084878b6428ba77df935d9|"
#~ msgstr ""

#~ msgid "First, import the built-in mod you intend to use:"
#~ msgstr "먼저 사용하려는 기본 제공 mod를 가져옵니다:"

#~ msgid "2. Define your client function"
#~ msgstr "2. 클라이언트 기능 정의"

#~ msgid ""
#~ "Define your client function (``client_fn``)"
#~ " that will be wrapped by the "
#~ "mod(s):"
#~ msgstr "mod(s)로 래핑할 클라이언트 함수('``client_fn``)를 정의합니다:"

#~ msgid "``example_mod_2`` (on the way back)"
#~ msgstr "``example_mod_2``(돌아가는 방법)"

#~ msgid "``example_mod_1`` (outermost mod on the way back)"
#~ msgstr "``example_mod_1``(돌아가는 방법에 가장 바깥쪽 모드)"

#~ msgid ""
#~ ":py:obj:`Array <flwr.common.Array>`\\ \\(dtype\\, "
#~ "shape\\, stype\\, data\\)"
#~ msgstr ""
#~ ":py:obj:`Array <flwr.common.Array>`\\ \\(dtype\\, "
#~ "shape\\, stype\\, data\\)"

#~ msgid "A buffer of bytes containing the data."
#~ msgstr "데이터를 포함하는 바이트 버퍼입니다."

#~ msgid "|83b0823dc3de42c897cc17d10e35d858|"
#~ msgstr ""

#~ msgid "|5523523e553a40149b559312b19058b3|"
#~ msgstr ""

#~ msgid "|99c6daf1b1264db1915f77c494e5a220|"
#~ msgstr ""

#~ msgid "|224b064fc6b344deb1bd4a7f09708ddb|"
#~ msgstr ""

#~ msgid "|69898d2bd8ee4ca9a3f0847bc2b433d5|"
#~ msgstr ""

#~ msgid "|4f1ee0c35efc43e5914d46e3f57cdb5b|"
#~ msgstr ""

#~ msgid "|3535418499ce4fd7852299a0d1287623|"
#~ msgstr ""

#~ msgid "|fd28b8249fc245dfa7410a0c99352eb9|"
#~ msgstr ""

#~ msgid "|5a1283ee62f84abc967590cbf70c37c6|"
#~ msgstr ""

#~ msgid "|e5a54625939c4cfc85f3be7bfa2ebf88|"
#~ msgstr ""

#~ msgid "|a98b576927e3442a8c988fa23470a3ed|"
#~ msgstr ""

#~ msgid "|45a4a0072a9940d5b8ca10364f1adfbe|"
#~ msgstr ""

#~ msgid "|55e61b1632c94257b9b992c329802a58|"
#~ msgstr ""

#~ msgid "|5e21d585962646039c8e8dcd2f87a642|"
#~ msgstr ""

#~ msgid ""
#~ "A :code:`RecordSet` is the unified "
#~ "mechanism by which parameters, metrics "
#~ "and configs can be either stored "
#~ "as part of a `flwr.common.Context "
#~ "<flwr.common.Context.html>`_ in your apps or"
#~ " communicated as part of a "
#~ "`flwr.common.Message <flwr.common.Message.html>`_ between"
#~ " your apps."
#~ msgstr ""

#~ msgid "|31e8ed7261994dc881557612e85f8207|"
#~ msgstr ""

#~ msgid "|19a2a648692846e39c942ac51bf40ea3|"
#~ msgstr ""

#~ msgid "|33b0c37f798e427583aef4032aa52e39|"
#~ msgstr ""

#~ msgid "|e15ce114533941a4be540d7e6cfa7531|"
#~ msgstr ""

#~ msgid "|0c7f996837384b739f7a761e54da3c31|"
#~ msgstr ""

#~ msgid "|963ded2b6c194e5d9b28667ff6989a2c|"
#~ msgstr ""

#~ msgid "|39256fb2dcbd41ad9b03ab30028277ab|"
#~ msgstr ""

#~ msgid "|ba8f9208c62d43cf9b5f00d9c723794b|"
#~ msgstr ""

#~ msgid "|6208b7b5deda468e8bed9ba7b5e569f7|"
#~ msgstr ""

#~ msgid "|04b3276cbc9f40baa7ea5340e024352c|"
#~ msgstr ""

#~ msgid "|7eec24b6ad9049c198e268cbd4c02b95|"
#~ msgstr ""

#~ msgid "|3492030ff2c94181baf7d0e3623f5d73|"
#~ msgstr ""

#~ msgid "|17add690b1504dc7bbd26f01dc778a68|"
#~ msgstr ""

#~ msgid "|5a87ee8d448a47018603ade607cb1c95|"
#~ msgstr ""

#~ msgid "|171c61e7972b4a4e8bf29e1bb5186428|"
#~ msgstr ""

#~ msgid "|2ad37ed4d2e4435f997d6e0196404cdb|"
#~ msgstr ""

#~ msgid "|7d8f84e49846404dbd031d31be28a908|"
#~ msgstr ""

#~ msgid "|dd633a0ddc4149699845c709c1ca6f55|"
#~ msgstr ""

#~ msgid "|c4de77415dbc48fca2ef85f2e4f00e6a|"
#~ msgstr ""

#~ msgid "|7d662652f5c54d1f8cf5f7283b044a88|"
#~ msgstr ""

#~ msgid "|0468e2e3dc3a4c06a4e544f6be325593|"
#~ msgstr ""

#~ msgid "|88ff3aefb4d543558980da26dac15835|"
#~ msgstr ""

#~ msgid "|f3bd4694ab25446fa5a506732b926ccb|"
#~ msgstr ""

#~ msgid "|4233ea0666684e888eb0636880ab73eb|"
#~ msgstr ""

#~ msgid "|fbeab078b0ec4e4fb765fb73e4457dbc|"
#~ msgstr ""

#~ msgid "|499447d6d69b43c0a78185cb20a42e28|"
#~ msgstr ""

#~ msgid "|293685098e6d49e0b548285cff9f90d4|"
#~ msgstr ""

#~ msgid "|4bf48bb217bd4d8b991bd8e17125c86c|"
#~ msgstr ""

#~ msgid "|2329735928e24e6997b66d00a6673dfb|"
#~ msgstr ""

#~ msgid "|1ce02c827fbe4f238d75159b6f159375|"
#~ msgstr ""

#~ msgid "|bed4f0981cd44ea2a6eea6acf524e69e|"
#~ msgstr ""

#~ msgid "|ebf695cdcdfb43da9c516b6cb86944cb|"
#~ msgstr ""

#~ msgid "|5108d9207a6c41d9ae4cf5347681ef8c|"
#~ msgstr ""

#~ msgid "|1deed7f68aa346fda00eb9513879f18d|"
#~ msgstr ""

#~ msgid "|a1a83e4ae4c94cbab322d89d1e67ecc0|"
#~ msgstr ""

#~ msgid "|4c5cef91dc0e43e0baee7cd21c651254|"
#~ msgstr ""

#~ msgid "|e4378c950685478eac99bdfe68ee2e3a|"
#~ msgstr ""

#~ msgid "|66542e737de949dba5f38aeb40912994|"
#~ msgstr ""

#~ msgid "|3ebdb53b040745f8bb9864baadbd70f5|"
#~ msgstr ""

#~ msgid "|8ea2d19a54794c21aaeb6defd31f8a9c|"
#~ msgstr ""

#~ msgid "|fa008e80b8a94d2b988d76b67cdb2b36|"
#~ msgstr ""

#~ msgid "|32a58c35a9e24a499343f38bbdef365f|"
#~ msgstr ""

#~ msgid "|6c1ddc3b62224a2cba79a67d9e690a97|"
#~ msgstr ""

#~ msgid "|104a91aab4a540048987cf2eae2c131c|"
#~ msgstr ""

#~ msgid "|fddf3e557abe4531bf09dcb9c85b5fe5|"
#~ msgstr ""

#~ msgid "|e7def1b171644623b8a0f4c01105ec19|"
#~ msgstr ""

#~ msgid "|a29e6cd86e70453b8d005cae9b35d007|"
#~ msgstr ""

#~ msgid "|1e9493dfcd1f423b8609ea74c520a135|"
#~ msgstr ""

#~ msgid "|4428f9cc87424aef9a140fd5b5cf4e1f|"
#~ msgstr ""

#~ msgid "|c2693a817d9c44f8bb0cd32414aaaf36|"
#~ msgstr ""

#~ msgid "|96d0287f19cc4fe3a4181cf8e960df49|"
#~ msgstr ""

#~ msgid "|17540fe769194881b02c1ee427517adb|"
#~ msgstr ""

#~ msgid "|8a771dd552ac418eb3d3608499b9fa74|"
#~ msgstr ""

#~ msgid "|bb1ae12451cd41868ec9d8eb78afc511|"
#~ msgstr ""

#~ msgid "|9f99c66f3b0d4a58b263f1a940ece9eb|"
#~ msgstr ""

#~ msgid "|628675ce4c6249baa36ed0fb146e5a51|"
#~ msgstr ""

#~ msgid "Deprecated Commands"
#~ msgstr ""

#~ msgid "``flower-server-app``"
#~ msgstr "flower 서버 프로그램"

#~ msgid ""
#~ "Note that from version ``1.13.0``, "
#~ "``flower-server-app`` is deprecated. "
#~ "Instead, you only need to execute "
#~ "|flwr_run_link|_ to start the run."
#~ msgstr ""

#~ msgid "``flower-superexec``"
#~ msgstr "flower 초연결"

#~ msgid ""
#~ "Note that from version ``1.13.0``, "
#~ "``flower-superexec`` is deprecated. Instead, "
#~ "you only need to execute "
#~ "|flower_superlink_link|_."
#~ msgstr ""

#~ msgid ""
#~ "If the above code is in a "
#~ "Python module called `client`, it can"
#~ " be started as follows:"
#~ msgstr "위의 코드가 'client'라는 Python 모듈에 있는 경우 다음과 같이 시작할 수 있습니다:"

#~ msgid ""
#~ "In this `client:app` example, `client` "
#~ "refers to the Python module `client.py`"
#~ " in which the previous code lives "
#~ "in and `app` refers to the global"
#~ " attribute `app` that points to an"
#~ " object of type `ClientApp`."
#~ msgstr ""
#~ "이 `client:app` 예제에서 `client`는 이전 코드가 "
#~ "있는 Python 모듈 `client.py`를 가리키고 `app`는"
#~ " `ClientApp` 유형의 객체를 가리키는 전역 속성 "
#~ "`app`을 가리킵니다."

#~ msgid ""
#~ ":py:obj:`RUN_SERVER_APP_ENTER "
#~ "<flwr.common.EventType.RUN_SERVER_APP_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SERVER_APP_ENTER "
#~ "<flwr.common.EventType.RUN_SERVER_APP_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_SERVER_APP_LEAVE "
#~ "<flwr.common.EventType.RUN_SERVER_APP_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SERVER_APP_LEAVE "
#~ "<flwr.common.EventType.RUN_SERVER_APP_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_CLIENT_APP_ENTER "
#~ "<flwr.common.EventType.RUN_CLIENT_APP_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_CLIENT_APP_ENTER "
#~ "<flwr.common.EventType.RUN_CLIENT_APP_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_CLIENT_APP_LEAVE "
#~ "<flwr.common.EventType.RUN_CLIENT_APP_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_CLIENT_APP_LEAVE "
#~ "<flwr.common.EventType.RUN_CLIENT_APP_LEAVE>`\\"

#~ msgid "|63fbce1fb62c400483894094a87c8d36|"
#~ msgstr ""

#~ msgid "|4655cc200212431ebcc6bf80dba20043|"
#~ msgstr ""

#~ msgid "|146c54cf31d6487e9491786cb1cb0c36|"
#~ msgstr ""

#~ msgid "|f30b3756a62c4df3a3573cfef1a910af|"
#~ msgstr ""

#~ msgid "|8c12b3d6e674476fb437616ae1cf8e16|"
#~ msgstr ""

#~ msgid "|69893f27159043a8b51b7420679c81be|"
#~ msgstr ""

#~ msgid "|f6295244a4734cdb8f05e37e80f79bc3|"
#~ msgstr ""

#~ msgid "|198fda1867554b2e98f910a9d27c4bb6|"
#~ msgstr ""

#~ msgid "|03950c828dfc40f38283cad114ec4061|"
#~ msgstr ""

#~ msgid "|dfec22fe0770404d90799a2837897986|"
#~ msgstr ""

#~ msgid "|447e49fbe0e2483ea733835f4f926d8d|"
#~ msgstr ""

#~ msgid "|2f008951c2fa4f4b9238794654bb0c30|"
#~ msgstr ""

#~ msgid "|76a58888c919400bb64d8b03c46ba76a|"
#~ msgstr ""

#~ msgid "|c3ddf0e3c97b46419197af99321e74d6|"
#~ msgstr ""

#~ msgid ""
#~ "**Update FlowerTuneLLM Leaderboard evaluation "
#~ "scripts** ([#4919](https://github.com/adap/flower/pull/4910))"
#~ msgstr ""

#~ msgid ""
#~ "**General improvements** "
#~ "([#1872](https://github.com/adap/flower/pull/1872), "
#~ "[#1866](https://github.com/adap/flower/pull/1866), "
#~ "[#1884](https://github.com/adap/flower/pull/1884), "
#~ "[#1837](https://github.com/adap/flower/pull/1837), "
#~ "[#1477](https://github.com/adap/flower/pull/1477), "
#~ "[#2171](https://github.com/adap/flower/pull/2171))"
#~ msgstr ""

#~ msgid ""
#~ "**General improvements** "
#~ "([#1659](https://github.com/adap/flower/pull/1659), "
#~ "[#1646](https://github.com/adap/flower/pull/1646), "
#~ "[#1647](https://github.com/adap/flower/pull/1647), "
#~ "[#1471](https://github.com/adap/flower/pull/1471), "
#~ "[#1648](https://github.com/adap/flower/pull/1648), "
#~ "[#1651](https://github.com/adap/flower/pull/1651), "
#~ "[#1652](https://github.com/adap/flower/pull/1652), "
#~ "[#1653](https://github.com/adap/flower/pull/1653), "
#~ "[#1659](https://github.com/adap/flower/pull/1659), "
#~ "[#1665](https://github.com/adap/flower/pull/1665), "
#~ "[#1670](https://github.com/adap/flower/pull/1670), "
#~ "[#1672](https://github.com/adap/flower/pull/1672), "
#~ "[#1677](https://github.com/adap/flower/pull/1677), "
#~ "[#1684](https://github.com/adap/flower/pull/1684), "
#~ "[#1683](https://github.com/adap/flower/pull/1683), "
#~ "[#1686](https://github.com/adap/flower/pull/1686), "
#~ "[#1682](https://github.com/adap/flower/pull/1682), "
#~ "[#1685](https://github.com/adap/flower/pull/1685), "
#~ "[#1692](https://github.com/adap/flower/pull/1692), "
#~ "[#1705](https://github.com/adap/flower/pull/1705), "
#~ "[#1708](https://github.com/adap/flower/pull/1708), "
#~ "[#1711](https://github.com/adap/flower/pull/1711), "
#~ "[#1713](https://github.com/adap/flower/pull/1713), "
#~ "[#1714](https://github.com/adap/flower/pull/1714), "
#~ "[#1718](https://github.com/adap/flower/pull/1718), "
#~ "[#1716](https://github.com/adap/flower/pull/1716), "
#~ "[#1723](https://github.com/adap/flower/pull/1723), "
#~ "[#1735](https://github.com/adap/flower/pull/1735), "
#~ "[#1678](https://github.com/adap/flower/pull/1678), "
#~ "[#1750](https://github.com/adap/flower/pull/1750), "
#~ "[#1753](https://github.com/adap/flower/pull/1753), "
#~ "[#1736](https://github.com/adap/flower/pull/1736), "
#~ "[#1766](https://github.com/adap/flower/pull/1766), "
#~ "[#1760](https://github.com/adap/flower/pull/1760), "
#~ "[#1775](https://github.com/adap/flower/pull/1775), "
#~ "[#1776](https://github.com/adap/flower/pull/1776), "
#~ "[#1777](https://github.com/adap/flower/pull/1777), "
#~ "[#1779](https://github.com/adap/flower/pull/1779), "
#~ "[#1784](https://github.com/adap/flower/pull/1784), "
#~ "[#1773](https://github.com/adap/flower/pull/1773), "
#~ "[#1755](https://github.com/adap/flower/pull/1755), "
#~ "[#1789](https://github.com/adap/flower/pull/1789), "
#~ "[#1788](https://github.com/adap/flower/pull/1788), "
#~ "[#1798](https://github.com/adap/flower/pull/1798), "
#~ "[#1799](https://github.com/adap/flower/pull/1799), "
#~ "[#1739](https://github.com/adap/flower/pull/1739), "
#~ "[#1800](https://github.com/adap/flower/pull/1800), "
#~ "[#1804](https://github.com/adap/flower/pull/1804), "
#~ "[#1805](https://github.com/adap/flower/pull/1805))"
#~ msgstr ""

#~ msgid ""
#~ "**General improvements** "
#~ "([#1638](https://github.com/adap/flower/pull/1638), "
#~ "[#1634](https://github.com/adap/flower/pull/1634), "
#~ "[#1636](https://github.com/adap/flower/pull/1636), "
#~ "[#1635](https://github.com/adap/flower/pull/1635), "
#~ "[#1633](https://github.com/adap/flower/pull/1633), "
#~ "[#1632](https://github.com/adap/flower/pull/1632), "
#~ "[#1631](https://github.com/adap/flower/pull/1631), "
#~ "[#1630](https://github.com/adap/flower/pull/1630), "
#~ "[#1627](https://github.com/adap/flower/pull/1627), "
#~ "[#1593](https://github.com/adap/flower/pull/1593), "
#~ "[#1616](https://github.com/adap/flower/pull/1616), "
#~ "[#1615](https://github.com/adap/flower/pull/1615), "
#~ "[#1607](https://github.com/adap/flower/pull/1607), "
#~ "[#1609](https://github.com/adap/flower/pull/1609), "
#~ "[#1608](https://github.com/adap/flower/pull/1608), "
#~ "[#1603](https://github.com/adap/flower/pull/1603), "
#~ "[#1590](https://github.com/adap/flower/pull/1590), "
#~ "[#1580](https://github.com/adap/flower/pull/1580), "
#~ "[#1599](https://github.com/adap/flower/pull/1599), "
#~ "[#1600](https://github.com/adap/flower/pull/1600), "
#~ "[#1601](https://github.com/adap/flower/pull/1601), "
#~ "[#1597](https://github.com/adap/flower/pull/1597), "
#~ "[#1595](https://github.com/adap/flower/pull/1595), "
#~ "[#1591](https://github.com/adap/flower/pull/1591), "
#~ "[#1588](https://github.com/adap/flower/pull/1588), "
#~ "[#1589](https://github.com/adap/flower/pull/1589), "
#~ "[#1587](https://github.com/adap/flower/pull/1587), "
#~ "[#1573](https://github.com/adap/flower/pull/1573), "
#~ "[#1581](https://github.com/adap/flower/pull/1581), "
#~ "[#1578](https://github.com/adap/flower/pull/1578), "
#~ "[#1574](https://github.com/adap/flower/pull/1574), "
#~ "[#1572](https://github.com/adap/flower/pull/1572), "
#~ "[#1586](https://github.com/adap/flower/pull/1586))"
#~ msgstr ""

#~ msgid ""
#~ "**Updated documentation** "
#~ "([#1355](https://github.com/adap/flower/pull/1355), "
#~ "[#1558](https://github.com/adap/flower/pull/1558), "
#~ "[#1379](https://github.com/adap/flower/pull/1379), "
#~ "[#1380](https://github.com/adap/flower/pull/1380), "
#~ "[#1381](https://github.com/adap/flower/pull/1381), "
#~ "[#1332](https://github.com/adap/flower/pull/1332), "
#~ "[#1391](https://github.com/adap/flower/pull/1391), "
#~ "[#1403](https://github.com/adap/flower/pull/1403), "
#~ "[#1364](https://github.com/adap/flower/pull/1364), "
#~ "[#1409](https://github.com/adap/flower/pull/1409), "
#~ "[#1419](https://github.com/adap/flower/pull/1419), "
#~ "[#1444](https://github.com/adap/flower/pull/1444), "
#~ "[#1448](https://github.com/adap/flower/pull/1448), "
#~ "[#1417](https://github.com/adap/flower/pull/1417), "
#~ "[#1449](https://github.com/adap/flower/pull/1449), "
#~ "[#1465](https://github.com/adap/flower/pull/1465), "
#~ "[#1467](https://github.com/adap/flower/pull/1467))"
#~ msgstr ""

#~ msgid ""
#~ "**Rename built-in strategy parameters "
#~ "for clarity** "
#~ "([#1334](https://github.com/adap/flower/pull/1334))"
#~ msgstr ""

#~ msgid ""
#~ "**Add** `server_round` **to** `Strategy.evaluate`"
#~ " ([#1334](https://github.com/adap/flower/pull/1334))"
#~ msgstr ""

#~ msgid ""
#~ "**Add** `server_round` **and** `config` "
#~ "**parameters to** `evaluate_fn` "
#~ "([#1334](https://github.com/adap/flower/pull/1334))"
#~ msgstr ""

#~ msgid ""
#~ "**Rename** `Weights` **to** `NDArrays` "
#~ "([#1258](https://github.com/adap/flower/pull/1258), "
#~ "[#1259](https://github.com/adap/flower/pull/1259))"
#~ msgstr ""

#~ msgid ""
#~ "**Remove antiquated** `force_final_distributed_eval` "
#~ "**from** `start_server` "
#~ "([#1258](https://github.com/adap/flower/pull/1258), "
#~ "[#1259](https://github.com/adap/flower/pull/1259))"
#~ msgstr ""

#~ msgid ""
#~ "**Replace** `num_rounds` **in** `start_simulation`"
#~ " **with new** `config` **parameter** "
#~ "([#1281](https://github.com/adap/flower/pull/1281))"
#~ msgstr ""

#~ msgid ""
#~ "The `start_simulation` function now accepts"
#~ " a configuration dictionary `config` "
#~ "instead of the `num_rounds` integer. "
#~ "This improves the consistency between "
#~ "`start_simulation` and `start_server` and "
#~ "makes transitioning between the two "
#~ "easier."
#~ msgstr ""

#~ msgid ""
#~ "**Enable passing a** `Server` **instance "
#~ "to** `start_simulation` "
#~ "([#1281](https://github.com/adap/flower/pull/1281))"
#~ msgstr ""

#~ msgid ""
#~ "Add secure gRPC connection to the "
#~ "`advanced_tensorflow` code example "
#~ "([#847](https://github.com/adap/flower/pull/847))"
#~ msgstr ""

#~ msgid ""
#~ "**Remove deprecated proto fields from** "
#~ "`FitRes` **and** `EvaluateRes` "
#~ "([#869](https://github.com/adap/flower/pull/869))"
#~ msgstr ""

#~ msgid ""
#~ "**Remove deprecated support for eval_fn "
#~ "accuracy return value** "
#~ "([#1142](https://github.com/adap/flower/pull/1142))"
#~ msgstr ""

#~ msgid ""
#~ "**Remove deprecated support for passing "
#~ "initial parameters as NumPy ndarrays** "
#~ "([#1142](https://github.com/adap/flower/pull/1142))"
#~ msgstr ""

#~ msgid ""
#~ "**Improved Virtual Client Engine compatibility"
#~ " with Jupyter Notebook / Google "
#~ "Colab** ([#866](https://github.com/adap/flower/pull/866), "
#~ "[#872](https://github.com/adap/flower/pull/872), "
#~ "[#833](https://github.com/adap/flower/pull/833), "
#~ "[#1036](https://github.com/adap/flower/pull/1036))"
#~ msgstr ""

#~ msgid ""
#~ "SSL enables secure encrypted connections "
#~ "between clients and servers. This "
#~ "release open-sources the Flower secure"
#~ " gRPC implementation to make encrypted "
#~ "communication channels accessible to all "
#~ "Flower users."
#~ msgstr ""

#~ msgid ""
#~ "**Experimental virtual client engine** "
#~ "([#781](https://github.com/adap/flower/pull/781) "
#~ "[#790](https://github.com/adap/flower/pull/790) "
#~ "[#791](https://github.com/adap/flower/pull/791))"
#~ msgstr ""

#~ msgid ""
#~ "Built-in strategies implement this "
#~ "approach by handling serialization and "
#~ "deserialization to/from `Weights` internally. "
#~ "Custom/3rd-party Strategy implementations "
#~ "should update to the slightly changed"
#~ " Strategy method definitions. Strategy "
#~ "authors can consult PR "
#~ "[#721](https://github.com/adap/flower/pull/721) to see "
#~ "how strategies can easily migrate to "
#~ "the new format."
#~ msgstr ""

#~ msgid ""
#~ "Deprecated `flwr.server.Server.evaluate`, use "
#~ "`flwr.server.Server.evaluate_round` instead "
#~ "([#717](https://github.com/adap/flower/pull/717))"
#~ msgstr ""

#~ msgid ""
#~ "New example: PyTorch From Centralized To"
#~ " Federated ([#549](https://github.com/adap/flower/pull/549))"
#~ msgstr ""

#~ msgid ""
#~ "Updated examples documentation "
#~ "([#549](https://github.com/adap/flower/pull/549))"
#~ msgstr ""

#~ msgid "|8869f4d59e144c718ac3d7f2fb70f0c5|"
#~ msgstr ""

#~ msgid "|4db491d8af5143e3b3fadfc2a370c87c|"
#~ msgstr ""

#~ msgid "|603698944fca4d3188b8f45d7bd22fb7|"
#~ msgstr ""

#~ msgid "|6f749ab29c5b43e09f0a95019826c24d|"
#~ msgstr ""

#~ msgid "|e511316757634140a030e6b3b68ff3ea|"
#~ msgstr ""

#~ msgid "|0b978d791bec4b5a865010dcbfabca36|"
#~ msgstr ""

#~ msgid "|1aff3c6a1ae94fc090061ca411dd688f|"
#~ msgstr ""

#~ msgid "|7993e78e8ef84336baedb5cea1877433|"
#~ msgstr ""

#~ msgid "|6b4861f0a7b44ae3b44517127a032258|"
#~ msgstr ""

#~ msgid "|372becfd4ce4452c9a51547d7cfa8ff7|"
#~ msgstr ""

#~ msgid "|51693b3cfc5546dfaed2f8255866234f|"
#~ msgstr ""

#~ msgid "|eb95dcaf723f4dd1952be307e7d16d14|"
#~ msgstr ""

#~ msgid "|e98cc271f6804e0b922b4999d1627c98|"
#~ msgstr ""

#~ msgid "|4cdb176fbef14897b58a4289e494be63|"
#~ msgstr ""

#~ msgid "Registering an evaluate function with a function-specific modifier:"
#~ msgstr ""

#~ msgid "Registering a query function with a function-specific modifier:"
#~ msgstr ""

#~ msgid "Registering a train function with a function-specific modifier:"
#~ msgstr ""

#~ msgid "|da8a064587764437aa744321c646ed8a|"
#~ msgstr ""

#~ msgid "|83edff6447e84fa3ba7ae438fdb0bec8|"
#~ msgstr ""

#~ msgid "|d09ebdaec63c4feab1a6c422105d60ad|"
#~ msgstr ""

#~ msgid "|fa6b319a95964903958b591133ce3f0f|"
#~ msgstr ""

#~ msgid "|5a77403301d94f828c664fef30916d51|"
#~ msgstr ""

#~ msgid "|e5a8491fcc48461f9b2a1009d32cb0d2|"
#~ msgstr ""

#~ msgid "|fbd662e5ccd84430940b56cc7daf82e8|"
#~ msgstr ""

#~ msgid "|fdd4aaee8ab041d79e7e89da84cf4b75|"
#~ msgstr ""

#~ msgid "|25e597a052c749c39c69ed61d390e194|"
#~ msgstr ""

#~ msgid "|7678b911560f43ccb50ae352028af2eb|"
#~ msgstr ""

#~ msgid "|5fc4f7141ea6409cbbb5bf5f5f51622b|"
#~ msgstr ""

#~ msgid "|429bc6acd3634c68aa0e39fa68626cc9|"
#~ msgstr ""

#~ msgid "|862985bea398410a9b2362d6bad7d2d5|"
#~ msgstr ""

#~ msgid "|dd64555e826940ffa0bb245a88fa0aa8|"
#~ msgstr ""

#~ msgid ""
#~ "In scenario (2), the `dtype`, `shape`,"
#~ " `stype`, and `data` are automatically "
#~ "derived from the input. In scenario "
#~ "(1), these fields must be specified "
#~ "manually."
#~ msgstr ""

#~ msgid ""
#~ "A buffer of bytes containing the "
#~ "data. Only required if you are not"
#~ " passing in a ndarray."
#~ msgstr ""

#~ msgid ""
#~ "A dataclass storing named Arrays in "
#~ "order. This means that it holds "
#~ "entries as an OrderedDict[str, Array]. "
#~ "ParametersRecord objects can be viewed "
#~ "as an equivalent to PyTorch's "
#~ "state_dict, but holding serialised tensors "
#~ "instead. A :code:`ParametersRecord`  is one"
#~ " of the types of records that a"
#~ " `flwr.common.RecordSet "
#~ "<flwr.common.RecordSet.html#recordset>`_ supports and "
#~ "can therefore be used to construct "
#~ ":code:`common.Message` objects."
#~ msgstr ""
#~ "Arrays라는 이름의 데이터 클래스를 순서대로 저장합니다. "
#~ "즉, OrderedDict[str, Array]로 항목을 보유합니다. "
#~ "ParametersRecord 객체는 파이토치의 state_dict와 동등한 "
#~ "것으로 볼 수 있지만, 대신 직렬화된 텐서를 "
#~ "보유합니다."

#~ msgid "A dictionary that stores serialized array-like or tensor-like objects."
#~ msgstr ""

#~ msgid ""
#~ "A boolean indicating whether parameters "
#~ "should be deleted from the input "
#~ "dictionary immediately after adding them "
#~ "to the record. If False, the "
#~ "dictionary passed to `set_parameters()` will"
#~ " be empty once exiting from that "
#~ "function. This is the desired behaviour"
#~ " when working with very large "
#~ "models/tensors/arrays. However, if you plan"
#~ " to continue working with your "
#~ "parameters after adding it to the "
#~ "record, set this flag to True. "
#~ "When set to True, the data is "
#~ "duplicated in memory."
#~ msgstr ""

#~ msgid ""
#~ "The usage of :code:`ParametersRecord` is "
#~ "envisioned for storing data arrays (e.g."
#~ " parameters of a machine learning "
#~ "model). These first need to be "
#~ "serialized into a :code:`flwr.common.Array` "
#~ "data structure."
#~ msgstr ""

#~ msgid "Let's see some examples:"
#~ msgstr "몇 가지 예를 살펴보겠습니다:"

#~ msgid ""
#~ "Now that the NumPy array is "
#~ "embedded into a :code:`ParametersRecord` it"
#~ " could be sent if added as part"
#~ " of a :code:`common.Message` or it "
#~ "could be saved as a persistent "
#~ "state of a :code:`ClientApp` via its "
#~ "context. Regardless of the usecase, we"
#~ " will sooner or later want to "
#~ "recover the array in its original "
#~ "NumPy representation. For the example "
#~ "above, where the array was serialized"
#~ " using the built-in utility function,"
#~ " deserialization can be done as "
#~ "follows:"
#~ msgstr ""

#~ msgid ""
#~ "If you need finer control on how"
#~ " your arrays are serialized and "
#~ "deserialized, you can construct :code:`Array`"
#~ " objects directly like this:"
#~ msgstr ""

#~ msgid ""
#~ "Note that different arrays (e.g. from"
#~ " PyTorch, Tensorflow) might require "
#~ "different serialization mechanism. Howerver, "
#~ "they often support a conversion to "
#~ "NumPy, therefore allowing to use the "
#~ "same or similar steps as in the"
#~ " example above."
#~ msgstr ""

#~ msgid "|6423c63301254f07bf93b90f0f627340|"
#~ msgstr ""

#~ msgid "|921b9e2224d8462fba7e9157686102f8|"
#~ msgstr ""

#~ msgid "|66ca4b87ee3e495389a0de3504b4cf04|"
#~ msgstr ""

#~ msgid "|eec7936921d14f04885827df45ff1c04|"
#~ msgstr ""

#~ msgid "|36e7408103ee4f158b4e1e835728f86a|"
#~ msgstr ""

#~ msgid "|b0c827a728c24730b9d61063da20f281|"
#~ msgstr ""

#~ msgid "|77ef7c9994bb4bcca3d1dcda1924bdcd|"
#~ msgstr ""

#~ msgid "|ed58eec163c14d1a8a501bac2511a797|"
#~ msgstr ""

#~ msgid "|af8a7f17a37f45948c49f9ab2d2d81d9|"
#~ msgstr ""

#~ msgid "|6cc75f03a88d47b4b688da695bce38d5|"
#~ msgstr ""

#~ msgid "|fd8d87bd3690448ab443a574ba0f7bff|"
#~ msgstr ""

#~ msgid "|8cae3c4603a746aa99a152e2ecb33b43|"
#~ msgstr ""

#~ msgid "|57fd4aa1641e458cb6fc78fe1ca31c08|"
#~ msgstr ""

#~ msgid "|1b03cf8b3d9845dc960d71eaa08299cc|"
#~ msgstr ""

#~ msgid ""
#~ "We also use this to define the "
#~ "public API of private subpackages. "
#~ "Public, in this context, means the "
#~ "API that other ``flwr`` subpackages "
#~ "should use. For example, "
#~ "``flwr.server.driver`` is a private subpackage"
#~ " (it's not exported via "
#~ "``src/py/flwr/server/__init__.py``'s ``__all__``)."
#~ msgstr ""

#~ msgid ""
#~ "Still, the private sub-package "
#~ "``flwr.server.driver`` defines a \"public\" "
#~ "API using ``__all__`` in "
#~ "``src/py/flwr/server/driver/__init__.py``:"
#~ msgstr ""

#~ msgid ""
#~ "The interesting part is that both "
#~ "``GrpcDriver`` and ``InMemoryDriver`` are "
#~ "never used by Flower framework users,"
#~ " only by other parts of the "
#~ "Flower framework codebase. Those other "
#~ "parts of the codebase import, for "
#~ "example, ``InMemoryDriver`` using ``from "
#~ "flwr.server.driver import InMemoryDriver`` (i.e.,"
#~ " the ``InMemoryDriver`` exported via "
#~ "``__all__``), not ``from "
#~ "flwr.server.driver.in_memory_driver import "
#~ "InMemoryDriver`` (``in_memory_driver.py`` is the "
#~ "module containing the actual "
#~ "``InMemoryDriver`` class definition)."
#~ msgstr ""

#~ msgid ""
#~ "This method constructs a new `Message`"
#~ " with given content and metadata. The"
#~ " `run_id` and `src_node_id` will be "
#~ "set automatically."
#~ msgstr ""

#~ msgid ""
#~ "The ID of the group to which "
#~ "this message is associated. In some "
#~ "settings, this is used as the FL"
#~ " round."
#~ msgstr ""

#~ msgid ""
#~ "Time-to-live for the round trip"
#~ " of this message, i.e., the time "
#~ "from sending this message to receiving"
#~ " a reply. It specifies in seconds "
#~ "the duration for which the message "
#~ "and its potential reply are considered"
#~ " valid. If unset, the default TTL "
#~ "(i.e., `common.DEFAULT_TTL`) will be used."
#~ msgstr ""

#~ msgid ""
#~ "This method takes an iterable of "
#~ "messages and sends each message to "
#~ "the node specified in `dst_node_id`."
#~ msgstr ""

#~ msgid ""
#~ "This method uses `push_messages` to send"
#~ " the messages and `pull_messages` to "
#~ "collect the replies. If `timeout` is "
#~ "set, the method may not return "
#~ "replies for all sent messages. A "
#~ "message remains valid until its TTL, "
#~ "which is not affected by `timeout`."
#~ msgstr ""

#~ msgid ""
#~ "If a Run with the specified "
#~ "`run_id` exists, a local Run object "
#~ "will be created. It enables further "
#~ "functionality in the driver, such as "
#~ "sending `Messages`."
#~ msgstr ""

#~ msgid "The `run_id` of the Run this Driver object operates in."
#~ msgstr ""

#~ msgid "Use the `ServerApp` with an existing `Strategy`:"
#~ msgstr ""

#~ msgid "Use the `ServerApp` with a custom main function:"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`collect_masked_vectors_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.collect_masked_vectors_stage>`\\"
#~ " \\(driver\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`setup_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.setup_stage>`\\ "
#~ "\\(driver\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`share_keys_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.share_keys_stage>`\\ "
#~ "\\(driver\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`unmask_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.unmask_stage>`\\ "
#~ "\\(driver\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`collect_masked_vectors_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.collect_masked_vectors_stage>`\\"
#~ " \\(driver\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`setup_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.setup_stage>`\\ "
#~ "\\(driver\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`share_keys_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.share_keys_stage>`\\ "
#~ "\\(driver\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`unmask_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.unmask_stage>`\\ "
#~ "\\(driver\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ "Number of nodes that run a "
#~ "ClientApp. They can be sampled by "
#~ "a Driver in the ServerApp and "
#~ "receive a Message describing what the"
#~ " ClientApp should perform."
#~ msgstr ""

#~ msgid "|4586b350eba14c60a377118db345b088|"
#~ msgstr ""

#~ msgid "|14cd96a1aadb4e16b87ba7d9a15a7145|"
#~ msgstr ""

#~ msgid "|c6fb95522f7a4cad910b0dd4c48714e3|"
#~ msgstr ""

#~ msgid "|6d473f9cc3fe400fb5fbcdde11177250|"
#~ msgstr ""

#~ msgid "|e2dfc41bbd2a469297964671f6a065b6|"
#~ msgstr ""

#~ msgid "|5d889cc375d94f758e7cf6a6c777ad58|"
#~ msgstr ""

#~ msgid "|de6c7a9943164f498001e7fffecf2408|"
#~ msgstr ""

#~ msgid "|419d6b7fd9214ac9a756b608a928bfac|"
#~ msgstr ""

#~ msgid "|f69cdf2c229a4090b99e8d3c8010400c|"
#~ msgstr ""

#~ msgid "|678788e3434c4a91adfbb11320b5f7ea|"
#~ msgstr ""

#~ msgid "|383d325b915449e2a6ce550956a1fb50|"
#~ msgstr ""

#~ msgid "|581fe037e8364291889e459d66dba7de|"
#~ msgstr ""

#~ msgid "|91e211659a464c70864b2440158893a1|"
#~ msgstr ""

#~ msgid "|1eb9389cb6ea4e34ae4b98476a69ae90|"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Message <flwr.common.Message>`\\ "
#~ "\\(metadata\\[\\, content\\, error\\]\\)"
#~ msgstr ""
#~ ":py:obj:`Message <flwr.common.Message>`\\ "
#~ "\\(metadata\\[\\, content\\, error\\]\\)"

#~ msgid "State of your application from the viewpoint of the entity using it."
#~ msgstr "애플리케이션을 사용하는 엔티티의 관점에서 애플리케이션의 상태입니다."

#~ msgid ""
#~ "A :code:`ConfigsRecord` is a Python "
#~ "dictionary designed to ensure that each"
#~ " key-value pair adheres to specified"
#~ " data types. A :code:`ConfigsRecord` is "
#~ "one of the types of records that"
#~ " a `flwr.common.RecordSet "
#~ "<flwr.common.RecordSet.html#recordset>`_ supports and "
#~ "can therefore be used to construct "
#~ ":code:`common.Message` objects."
#~ msgstr ""

#~ msgid ""
#~ "Just like the other types of "
#~ "records in a :code:`flwr.common.RecordSet`, "
#~ "types are enforced. If you need to"
#~ " add a custom data structure or "
#~ "object, we recommend to serialise it "
#~ "into bytes and save it as such "
#~ "(bytes are allowed in a "
#~ ":code:`ConfigsRecord`)"
#~ msgstr ""

#~ msgid ""
#~ "A :code:`MetricsRecord` is a Python "
#~ "dictionary designed to ensure that each"
#~ " key-value pair adheres to specified"
#~ " data types. A :code:`MetricsRecord` is "
#~ "one of the types of records that"
#~ " a `flwr.common.RecordSet "
#~ "<flwr.common.RecordSet.html#recordset>`_ supports and "
#~ "can therefore be used to construct "
#~ ":code:`common.Message` objects."
#~ msgstr ""

#~ msgid ""
#~ "This object is one of the record"
#~ " types supported by :class:`RecordSet` and"
#~ " can therefore be stored in the "
#~ "``content`` of a :class:`Message` or the"
#~ " ``state`` of a :class:`Context`."
#~ msgstr ""

#~ msgid ""
#~ "A :class:`RecordSet` is the unified "
#~ "mechanism by which parameters, metrics "
#~ "and configs can be either stored "
#~ "as part of a :class:`Context` in "
#~ "your apps or communicated as part "
#~ "of a :class:`Message` between your apps."
#~ msgstr ""

#~ msgid ""
#~ "A :code:`RecordSet` can hold three types"
#~ " of records, each designed with an"
#~ " specific purpose. What is common to"
#~ " all of them is that they are"
#~ " Python dictionaries designed to ensure "
#~ "that each key-value pair adheres "
#~ "to specified data types."
#~ msgstr ""

#~ msgid "|462a5ddc7b2d4b73819bdeffde19f2fc|"
#~ msgstr ""

#~ msgid "|1cd9d5b3c0f743849d81024f6bb79f0f|"
#~ msgstr ""

#~ msgid "|23545c677a484fa3aabfa186b446bcea|"
#~ msgstr ""

#~ msgid "|af0433fa018d41a0b0599dbd696e5de3|"
#~ msgstr ""

#~ msgid "|b68387deaa794ce2b323a08910c92d22|"
#~ msgstr ""

#~ msgid "|a64fb69d1b6e4581a9a7f0cfc7310e22|"
#~ msgstr ""

#~ msgid "|84867c1c32224df1916988ad35c2c80d|"
#~ msgstr ""

#~ msgid "|bcfb9adf14aa48a394d8afd097ba15f1|"
#~ msgstr ""

#~ msgid "|88026b46352a48688bffdb17496ae6c6|"
#~ msgstr ""

#~ msgid "|1a75b5702f854894ae170dddd7bdcd1d|"
#~ msgstr ""

#~ msgid "|9553a34443934a26921e584c98a51f38|"
#~ msgstr ""

#~ msgid "|848dd486de4e45349dc126455021891b|"
#~ msgstr ""

#~ msgid "|be39f3bca1a0445495c0bd6a2da84e34|"
#~ msgstr ""

#~ msgid "|91a73d3573224a32ba04b015071bba4a|"
#~ msgstr ""

#~ msgid ""
#~ "Initialise the appropiate record type "
#~ "(in this example we use ConfigsRecord_)"
#~ " and save/read your entry when "
#~ "required."
#~ msgstr ""

#~ msgid ""
#~ "Using ConfigsRecord_ or MetricsRecord_ to "
#~ "save \"simple\" components is fine "
#~ "(e.g., float, integer, boolean, string, "
#~ "bytes, and lists of these types. "
#~ "Note that MetricsRecord_ only supports "
#~ "float, integer, and lists of these "
#~ "types) Flower has a specific type "
#~ "of record, a ParametersRecord_, for "
#~ "storing model parameters or more "
#~ "generally data arrays."
#~ msgstr ""

#~ msgid ""
#~ "A :code:`ConfigsRecord` is a Python "
#~ "dictionary designed to ensure that each"
#~ " key-value pair adheres to specified"
#~ " data types. A :code:`ConfigsRecord` is "
#~ "one of the types of records that"
#~ " a `flwr.common.RecordDict "
#~ "<flwr.common.RecordDict.html#recorddict>`_ supports and"
#~ " can therefore be used to construct"
#~ " :code:`common.Message` objects."
#~ msgstr ""

#~ msgid ""
#~ "The usage of a :code:`ConfigsRecord` is"
#~ " envisioned for sending configuration "
#~ "values telling the target node how "
#~ "to perform a certain action (e.g. "
#~ "train/evaluate a model ). You can "
#~ "use standard Python built-in types "
#~ "such as :code:`float`, :code:`str` , "
#~ ":code:`bytes`. All types allowed are "
#~ "defined in :code:`flwr.common.ConfigsRecordValues`. "
#~ "While lists are supported, we encourage"
#~ " you to use a :code:`ParametersRecord` "
#~ "instead if these are of high "
#~ "dimensionality."
#~ msgstr ""

#~ msgid ""
#~ "Let's see some examples of how to"
#~ " construct a :code:`ConfigsRecord` from "
#~ "scratch:"
#~ msgstr ""

#~ msgid ""
#~ "Just like the other types of "
#~ "records in a :code:`flwr.common.RecordDict`, "
#~ "types are enforced. If you need to"
#~ " add a custom data structure or "
#~ "object, we recommend to serialise it "
#~ "into bytes and save it as such "
#~ "(bytes are allowed in a "
#~ ":code:`ConfigsRecord`)"
#~ msgstr ""

#~ msgid ""
#~ "A :code:`MetricsRecord` is a Python "
#~ "dictionary designed to ensure that each"
#~ " key-value pair adheres to specified"
#~ " data types. A :code:`MetricsRecord` is "
#~ "one of the types of records that"
#~ " a `flwr.common.RecordDict "
#~ "<flwr.common.RecordDict.html#recorddict>`_ supports and"
#~ " can therefore be used to construct"
#~ " :code:`common.Message` objects."
#~ msgstr ""

#~ msgid ""
#~ "A dictionary that stores basic types "
#~ "(i.e. `int`, `float` as defined in "
#~ "`MetricsScalar`) and list of such types"
#~ " (see `MetricsScalarList`)."
#~ msgstr ""

#~ msgid ""
#~ "The usage of a :code:`MetricsRecord` is"
#~ " envisioned for communicating results "
#~ "obtained when a node performs an "
#~ "action. A few typical examples include:"
#~ " communicating the training accuracy after"
#~ " a model is trained locally by "
#~ "a :code:`ClientApp`, reporting the validation"
#~ " loss obtained at a :code:`ClientApp`, "
#~ "or, more generally, the output of "
#~ "executing a query by the "
#~ ":code:`ClientApp`. Common to these examples"
#~ " is that the output can be "
#~ "typically represented by a single scalar"
#~ " (:code:`int`, :code:`float`) or list of"
#~ " scalars."
#~ msgstr ""

#~ msgid ""
#~ "Let's see some examples of how to"
#~ " construct a :code:`MetricsRecord` from "
#~ "scratch:"
#~ msgstr ""

#~ msgid ""
#~ "Since types are enforced, the types "
#~ "of the objects inserted are checked. "
#~ "For a :code:`MetricsRecord`, value types "
#~ "allowed are those in defined in "
#~ ":code:`flwr.common.MetricsRecordValues`. Similarly, only"
#~ " :code:`str` keys are allowed."
#~ msgstr ""

#~ msgid ""
#~ "If you need a more versatily type"
#~ " of record try :code:`ConfigsRecord` or "
#~ ":code:`ParametersRecord`."
#~ msgstr ""

#~ msgid ""
#~ "A typed dictionary (``str`` to "
#~ ":class:`Array`) that can store named "
#~ "parameters as serialized tensors. Internally,"
#~ " this behaves similarly to an "
#~ "``OrderedDict[str, Array]``. A ``ParametersRecord``"
#~ " can be viewed as an equivalent "
#~ "to PyTorch's ``state_dict``, but it "
#~ "holds arrays in serialized form."
#~ msgstr ""

#~ msgid "Create ParametersRecord from a dictionary of :class:`Array`."
#~ msgstr ""

#~ msgid "Create ParametersRecord from PyTorch ``state_dict``."
#~ msgstr ""

#~ msgid "Return the ParametersRecord as a PyTorch ``state_dict``."
#~ msgstr ""

#~ msgid ""
#~ "A :class:`RecordDict` is the unified "
#~ "mechanism by which parameters, metrics "
#~ "and configs can be either stored "
#~ "as part of a :class:`Context` in "
#~ "your apps or communicated as part "
#~ "of a :class:`Message` between your apps."
#~ msgstr ""

#~ msgid ""
#~ "A dictionary of :code:`ParametersRecords` that"
#~ " can be used to record and "
#~ "communicate model parameters and high-"
#~ "dimensional arrays."
#~ msgstr ""

#~ msgid ""
#~ "A dictionary of :code:`MetricsRecord` that "
#~ "can be used to record and "
#~ "communicate scalar-valued metrics that "
#~ "are the result of performing and "
#~ "action, for example, by a "
#~ ":code:`ClientApp`."
#~ msgstr ""

#~ msgid ""
#~ "A dictionary of :code:`ConfigsRecord` that "
#~ "can be used to record and "
#~ "communicate configuration values to an "
#~ "entity (e.g. to a :code:`ClientApp`) for"
#~ " it to adjust how an action is"
#~ " performed."
#~ msgstr ""

#~ msgid ""
#~ "Adding a :code:`ParametersRecord` follows the"
#~ " same steps as above but first, "
#~ "the array needs to be serialized "
#~ "and represented as a "
#~ ":code:`flwr.common.Array`. If the array is "
#~ "a :code:`NumPy` array, you can use "
#~ "the built-in utility function "
#~ "`array_from_numpy <flwr.common.array_from_numpy.html>`_. "
#~ "It is often possible to convert an"
#~ " array first to :code:`NumPy` and "
#~ "then use the aforementioned function."
#~ msgstr ""

#~ msgid ""
#~ "For additional examples on how to "
#~ "construct each of the records types "
#~ "shown above, please refer to the "
#~ "documentation for :code:`ConfigsRecord`, "
#~ ":code:`MetricsRecord` and :code:`ParametersRecord`."
#~ msgstr ""

#~ msgid ""
#~ "'A dictionary to configure a backend."
#~ " Separate dictionaries to configure "
#~ "different elements of backend. Supported "
#~ "top-level keys are `init_args` for "
#~ "values parsed to initialisation of "
#~ "backend, `client_resources` to define the "
#~ "resources for clients, and `actor` to"
#~ " define the actor parameters. Values "
#~ "supported in <value> are those included"
#~ " by `flwr.common.typing.ConfigsRecordValues`."
#~ msgstr ""

#~ msgid "|b6d7f89f3808402b9292d88245973eff|"
#~ msgstr ""

#~ msgid "|cb5e4b961f084019b6ce414c35f3f37a|"
#~ msgstr ""

#~ msgid "|97ea8cf65d1f407590d4c61e1d5352aa|"
#~ msgstr ""

#~ msgid "|96ac0b873a014a3abcf6dbe09c62d4c6|"
#~ msgstr ""

#~ msgid "|ef28711094124e239fc69cf7283466e5|"
#~ msgstr ""

#~ msgid "|87a5b00db468471aaaaadc5477704e15|"
#~ msgstr ""

#~ msgid "|af29375956aa473f944c9fb6ea0bfc92|"
#~ msgstr ""

#~ msgid "|d9bea29a75c7465da99a0f29b6d5735a|"
#~ msgstr ""

#~ msgid "|35eb9147612b492c97879287bad7b231|"
#~ msgstr ""

#~ msgid "|27e06a29cff64206af6d3695238c5977|"
#~ msgstr ""

#~ msgid "|6bd42f6566f949a8a157fcb68272490d|"
#~ msgstr ""

#~ msgid "|688be4d36b13400fa5c454e2ef1500f5|"
#~ msgstr ""

#~ msgid "|58b84ee017db4b3ba25506c9bf503c4c|"
#~ msgstr ""

#~ msgid "|cffbf5f7fb6146e887e89765d6f590bd|"
#~ msgstr ""

#~ msgid "Contributor how-to guides"
#~ msgstr "기여자 사용법 가이드"

#~ msgid "|46c1cee57f3b48b0826837c9ca24bb70|"
#~ msgstr ""

#~ msgid "|55b99ed6645549a38fedbca1511c6982|"
#~ msgstr ""

#~ msgid "|dbf325234cc54792862992a51d558acb|"
#~ msgstr ""

#~ msgid "|5b34655e2fc743078d8c3382c3d0511a|"
#~ msgstr ""

#~ msgid "|7683104db7e7499884b2199518a8e71d|"
#~ msgstr ""

#~ msgid "|9646296ec388473d95a2c52534611fe7|"
#~ msgstr ""

#~ msgid "|0b8c81d07c8b4e4b86ab37eaa45197be|"
#~ msgstr ""

#~ msgid "|071d15eeb3fe457f9119b104763aad4f|"
#~ msgstr ""

#~ msgid "|5ad5aa46a4844f4ea18a1e611e66db54|"
#~ msgstr ""

#~ msgid "|8c9a5d290e534161a2e14ede889bcb1b|"
#~ msgstr ""

#~ msgid "|c9562154b9a446b1bb7d924d55c4e074|"
#~ msgstr ""

#~ msgid "|a18099299bfa4828a3ac984a2de970c2|"
#~ msgstr ""

#~ msgid "|ed7d7dbbcf174cd284c15801b0e6f51f|"
#~ msgstr ""

#~ msgid "|334758e020494858a71c419d752d05a5|"
#~ msgstr ""

#~ msgid "|206dd64c5da04db0bb2db93bbcd6f89b|"
#~ msgstr ""

#~ msgid "|d135fd8de2b64f0496180c8020debaac|"
#~ msgstr ""

#~ msgid "|4e22564b974748f795c963f0319373f6|"
#~ msgstr ""

#~ msgid "|1aaa0816eaee46a984362e32c1ae30c4|"
#~ msgstr ""

#~ msgid "|617269e9f7004bdea6491c76a651ed9d|"
#~ msgstr ""

#~ msgid "|771bc1e18acb4c0ba0af598c2eda03f1|"
#~ msgstr ""

#~ msgid "|50e44ed8cf634e72826249d84af65fc8|"
#~ msgstr ""

#~ msgid "|e6d7a63ce00144078fcbf8421048fe3b|"
#~ msgstr ""

#~ msgid "|18866b10ba3d4c5787e63505ac52267f|"
#~ msgstr ""

#~ msgid "|0215d475c1674a8e904fe52d9b170e9b|"
#~ msgstr ""

#~ msgid "|676a3d07780c471ab85b643908f15bce|"
#~ msgstr ""

#~ msgid "|b9587e6e17ad464a884acd4acc46bb40|"
#~ msgstr ""

#~ msgid "|77356653b95542f1916bcd325ae70634|"
#~ msgstr ""

#~ msgid "|2717bf202b09498b90f9eacc1728f1d4|"
#~ msgstr ""

#~ msgid ""
#~ "``--auth-list-public-keys``: Specify the"
#~ " path to a CSV file storing the"
#~ " public keys of all SuperNodes that"
#~ " should be allowed to connect with"
#~ " the SuperLink."
#~ msgstr ""

#~ msgid "Request a run to the SuperLink with a given `run_id`."
#~ msgstr ""

#~ msgid ""
#~ "If a ``Run`` with the specified "
#~ "``run_id`` exists, a local ``Run`` "
#~ "object will be created. It enables "
#~ "further functionality in the grid, such"
#~ " as sending ``Message``s."
#~ msgstr ""

#~ msgid "A simulation backend that runs `ClientApp`s."
#~ msgstr ""

#~ msgid ""
#~ ":doc:`PyTorch: From Centralized To Federated"
#~ " (Tutorial) <example-pytorch-from-"
#~ "centralized-to-federated>`"
#~ msgstr ""

#~ msgid "|50dc70ec1a934c9392b49ee2ab55d803|"
#~ msgstr ""

#~ msgid "|d07049edbba148dd97dd3080491f2ae7|"
#~ msgstr ""

#~ msgid "|5bc3219a90ed4b59aed96f1ac1a40002|"
#~ msgstr ""

#~ msgid "|de3f42c539be48249739b7dbe08c8fa3|"
#~ msgstr ""

#~ msgid "|9f9f2a7adeb941db84f8f9a6d3f07e9b|"
#~ msgstr ""

#~ msgid "|d6d33b77bb5245e28dbce90ceb23b82b|"
#~ msgstr ""

#~ msgid "|b14d23b166744f2690a147859055eb11|"
#~ msgstr ""

#~ msgid "|dc936f126a4b40a6aa3b5f6c46c47ff0|"
#~ msgstr ""

#~ msgid "|c0b47a9970cf4cd3ae45baf64c891ca0|"
#~ msgstr ""

#~ msgid "|6c479d9f8f484708afce183472a700e2|"
#~ msgstr ""

#~ msgid "|325757228b544ff393baf66965f58c92|"
#~ msgstr ""

#~ msgid "|deb296df2c28457aa8f6957487e2ba20|"
#~ msgstr ""

#~ msgid "|cf8321d0d84c409d857ecd4736171334|"
#~ msgstr ""

#~ msgid "|476b8f5bd0f04b63bdbac6b5edcfee25|"
#~ msgstr ""

#~ msgid "Registering an evaluate function:"
#~ msgstr ""

#~ msgid "Registering an evaluate function with a custom action name:"
#~ msgstr ""

#~ msgid "Registering an evaluate function with a function-specific Flower Mod:"
#~ msgstr ""

#~ msgid "Registering a query function:"
#~ msgstr ""

#~ msgid "Registering a query function with a custom action name:"
#~ msgstr ""

#~ msgid "Registering a query function with a function-specific Flower Mod:"
#~ msgstr ""

#~ msgid "Registering a train function:"
#~ msgstr ""

#~ msgid "Registering a train function with a custom action name:"
#~ msgstr ""

#~ msgid "Registering a train function with a function-specific Flower Mod:"
#~ msgstr ""

#~ msgid "Initializing by specifying all fields directly:"
#~ msgstr ""

#~ msgid "Initializing with a NumPy ndarray:"
#~ msgstr ""

#~ msgid "Initializing with a PyTorch tensor:"
#~ msgstr ""

#~ msgid "Initializing with a dictionary of :class:`Array`:"
#~ msgstr ""

#~ msgid "Initializing with a list of NumPy arrays:"
#~ msgstr ""

#~ msgid "Initializing with a PyTorch model state_dict:"
#~ msgstr ""

#~ msgid "Initializing with a TensorFlow model weights (a list of NumPy arrays):"
#~ msgstr ""

#~ msgid ""
#~ "Let's see some examples of how to"
#~ " construct a :code:`ConfigRecord` from "
#~ "scratch:"
#~ msgstr ""

#~ msgid ""
#~ "Let's see some examples of how to"
#~ " construct a :code:`MetricRecord` from "
#~ "scratch:"
#~ msgstr ""

#~ msgid ""
#~ "Since types are enforced, the types "
#~ "of the objects inserted are checked. "
#~ "For a :code:`MetricRecord`, value types "
#~ "allowed are those in defined in "
#~ ":code:`flwr.common.MetricRecordValues`. Similarly, only"
#~ " :code:`str` keys are allowed."
#~ msgstr ""

#~ msgid ""
#~ "Adding an :code:`ArrayRecord` follows the "
#~ "same steps as above but first, the"
#~ " array needs to be serialized and "
#~ "represented as a :code:`flwr.common.Array`. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "``Driver`` is deprecated and will be "
#~ "removed in a future release. Use "
#~ "`Grid` in the signature of your "
#~ "ServerApp."
#~ msgstr ""

#~ msgid "Use the ``ServerApp`` with a custom main function:"
#~ msgstr ""

#~ msgid "Starting an insecure server:"
#~ msgstr ""

#~ msgid "Starting an SSL-enabled server:"
#~ msgstr ""

#~ msgid "Create a strategy:"
#~ msgstr ""

#~ msgid ""
#~ "Wrap the strategy with the "
#~ "`DifferentialPrivacyClientSideAdaptiveClipping` wrapper:"
#~ msgstr ""

#~ msgid "On the client, add the `adaptiveclipping_mod` to the client-side mods:"
#~ msgstr ""

#~ msgid ""
#~ "Wrap the strategy with the "
#~ "`DifferentialPrivacyClientSideFixedClipping` wrapper:"
#~ msgstr ""

#~ msgid "On the client, add the `fixedclipping_mod` to the client-side mods:"
#~ msgstr ""

#~ msgid ""
#~ "Wrap the strategy with the "
#~ "DifferentialPrivacyServerSideAdaptiveClipping wrapper"
#~ msgstr ""

#~ msgid ""
#~ "Wrap the strategy with the "
#~ "DifferentialPrivacyServerSideFixedClipping wrapper"
#~ msgstr ""

#~ msgid "|662665a552f64c9bb53cbf01198765cc|"
#~ msgstr ""

#~ msgid "|7f4c9c8c2d7045208ac1e513f75b8a32|"
#~ msgstr ""

#~ msgid "|548e011b458142e5be8cf6497d03e22e|"
#~ msgstr ""

#~ msgid "|32d5d8c2e9314a91a9a17bb04a7fde41|"
#~ msgstr ""

#~ msgid "|c5c8eabc28c741e79ab46c61271c18ba|"
#~ msgstr ""

#~ msgid "|aebc2e212169439683d3134c7dbda324|"
#~ msgstr ""

#~ msgid "|5b888e20d5f64ec38bf924db4b999a3c|"
#~ msgstr ""

#~ msgid "|f5dd3e6215104689a365dd7e01e421d0|"
#~ msgstr ""

#~ msgid "|e90c03c1caab4f229359c1e8877da2a2|"
#~ msgstr ""

#~ msgid "|3e26e26712bb475ba024442148c1171a|"
#~ msgstr ""

#~ msgid "|650f8f02c84f4af381ab58cd7394aff1|"
#~ msgstr ""

#~ msgid "|bfab5d09d0bd46dba040500475755079|"
#~ msgstr ""

#~ msgid "|1412b6b05b744c159b9531f3a1202d46|"
#~ msgstr ""

#~ msgid "|918baeda7d744d0dbd5d55f6c8083a6a|"
#~ msgstr ""

#~ msgid ""
#~ "Run ``python3 ./dev/update_changelog.py "
#~ "<YOUR_GH_TOKEN>`` in order to add every"
#~ " new change to the changelog (feel"
#~ " free to make manual changes to "
#~ "the changelog afterwards until it looks"
#~ " good)."
#~ msgstr ""
#~ "모든 새로운 변경 사항을 변경 로그에 추가하기 "
#~ "위해``python3 src/py/flwr_tool/update_changelog.py "
#~ "<YOUR_GH_TOKEN>``을 실행합니다 (변경 로그가 만족스러워질 "
#~ "때까지 수동으로 변경해도 됩니다)."

#~ msgid ""
#~ "Once the changelog has been updated "
#~ "with all the changes, run ``./dev"
#~ "/prepare-release-changelog.sh v<NEW_VERSION>``, "
#~ "where ``<NEW_VERSION>`` is the version "
#~ "stated in ``pyproject.toml`` (notice the "
#~ "``v`` added before it). This will "
#~ "replace the ``Unreleased`` header of the"
#~ " changelog by the version and current"
#~ " date, and it will add a "
#~ "thanking message for the contributors. "
#~ "Open a pull request with those "
#~ "changes."
#~ msgstr ""
#~ "모든 변경 사항으로 변경 로그가 업데이트되면,``./dev"
#~ "/prepare-release-changelog.sh v<NEW_VERSION>``을 "
#~ "실행합니다. 여기서 ``<NEW_VERSION>``은 ``pyproject.toml``에"
#~ " 명시된 버전 번호입니다 (앞에 ``v``가 추가된 것을"
#~ " 주의하세요). 이 명령어는 변경 로그의 "
#~ "``Unreleased``헤더를 해당 버전과 현재 날짜로 교체하고,"
#~ " 기여자들에게 감사 메시지가 추가됩니다. 이러한 변경 "
#~ "사항으로 pull request합니다."

#~ msgid "Increase the minor version in ``pyproject.toml`` by one."
#~ msgstr "``pyproject.toml``의 마이너 버전을 하나씩 늘립니다."

#~ msgid "Update all files which contain the current version number if necessary."
#~ msgstr "필요한 경우 현재 버전 번호가 포함된 모든 파일을 업데이트합니다."

#~ msgid "Add a new ``Unreleased`` section in ``changelog.md``."
#~ msgstr "``changelog.md``에 ``Unreleased`` 섹션을 새로 추가합니다."

#~ msgid "And then?"
#~ msgstr "그다음은?"

#~ msgid ""
#~ "As soon as you created your "
#~ "virtual environment you clone one of "
#~ "the `Flower examples "
#~ "<https://github.com/adap/flower/tree/main/examples/>`_."
#~ msgstr ""
#~ "가상 환경을 생성하자마자 'Flower examples "
#~ "<https://github.com/adap/flower/tree/main/examples/>`_ 중 "
#~ "하나를 클론합니다."

#~ msgid ""
#~ "Let's create the Python environment for"
#~ " all-things Flower. If you wish "
#~ "to use ``pyenv``, we provide two "
#~ "convenience scripts that you can use."
#~ " If you prefer using something else"
#~ " than ``pyenv``, create a new "
#~ "environment, activate and skip to the"
#~ " last point where all packages are"
#~ " installed."
#~ msgstr ""
#~ "Flower의 모든 것을 위한 파이썬 환경을 만들어 "
#~ "보겠습니다.:code:`pyenv`를 사용하고자 하는 경우 사용할 수"
#~ " 있는 두 가지 편의 스크립트를 "
#~ "제공합니다.:code:`pyenv`가 아닌 다른 것을 사용하려면 새"
#~ " 환경을 생성하고 활성화한 후 모든 패키지가 설치된"
#~ " 마지막 지점으로 건너뛰세요."

#~ msgid ""
#~ "If you don't have ``pyenv`` installed,"
#~ " the following script that will "
#~ "install it, set it up, and create"
#~ " the virtual environment (with "
#~ ":substitution-code:`Python |python_full_version|` by"
#~ " default):"
#~ msgstr ""
#~ ":code:`pyenv`가 설치되어 있지 않은 경우 다음 "
#~ "스크립트를 사용하여 설치, 설정 및 가상 환경을 "
#~ "생성합니다(기본적으로 :code:`Python 3.10.19` 사용):"

#~ msgid ""
#~ "If you already have ``pyenv`` installed"
#~ " (along with the ``pyenv-virtualenv`` "
#~ "plugin), you can use the following "
#~ "convenience script (with :substitution-"
#~ "code:`Python |python_full_version|` by default):"
#~ msgstr ""
#~ ":code:`pyenv`가 이미 설치되어 있는 경우( :code"
#~ ":`pyenv-virtualenv` 플러그인과 함께) 다음과 같은 "
#~ "편의 스크립트를 사용할 수 있습니다(기본적으로 코드:`Python "
#~ "3.9.20` 사용):"

#~ msgid ""
#~ "3. Install the Flower package in "
#~ "development mode (think ``pip install "
#~ "-e``) along with all necessary "
#~ "dependencies:"
#~ msgstr ""
#~ "3. 필요한 모든 dependencies와 함께 개발 모드에서"
#~ " Flower 패키지를 설치합니다(예:code:`pip install "
#~ "-e`)::"

#~ msgid "Create/Delete Virtual Environment"
#~ msgstr "가상 환경 생성/삭제"

#~ msgid "|1dbe7ef5f86045228c22d76d20494c1c|"
#~ msgstr ""

#~ msgid "|0c52a329791a42c9891adee11a3c9ec6|"
#~ msgstr ""

#~ msgid "|0af7f9c988464e6d9988f938f7722cb1|"
#~ msgstr ""

#~ msgid "|c4fec40358df4c91b8dacba706affdfc|"
#~ msgstr ""

#~ msgid "|fffd51185653489082b5587359813c79|"
#~ msgstr ""

#~ msgid "|b9f3e0459a704a459d52ae3fca9c72d3|"
#~ msgstr ""

#~ msgid "|5e4f22fdf7cb4373882354252e21f385|"
#~ msgstr ""

#~ msgid "|6e225ec341c643a58ce12c7c1c4f531d|"
#~ msgstr ""

#~ msgid "|371d89f1268b4ba9af58576635ca724e|"
#~ msgstr ""

#~ msgid "|b64a9a44fd5745cc91b6aa9fdca1aa28|"
#~ msgstr ""

#~ msgid "|b9efd6eda007427a92190b989d035b45|"
#~ msgstr ""

#~ msgid "|61474cd6cd8642968bd5f0d963fa56df|"
#~ msgstr ""

#~ msgid "|ff52a36f0cad426bb452cfa49b73350a|"
#~ msgstr ""

#~ msgid "|3d62057de8c64752921d1eab65741d54|"
#~ msgstr ""

#~ msgid "|2e3a8dd8625a48a080386b56f6143b3c|"
#~ msgstr ""

#~ msgid "|7c96683b1c2042c796e76c4ef095f4a6|"
#~ msgstr ""

#~ msgid "|eccacc874336420ab6a338024bdcdcf0|"
#~ msgstr ""

#~ msgid "|c26cd0ddba7d45c58daefc7741c3c21c|"
#~ msgstr ""

#~ msgid "|55ad49291b07427b9cd15cf45ca12c66|"
#~ msgstr ""

#~ msgid "|1ecea76fb58d490593e0ebaae474b0b4|"
#~ msgstr ""

#~ msgid "|ac0ae32f88a343aca8bff2bd6d7be924|"
#~ msgstr ""

#~ msgid "|ec672277bede4c358eab8bf606c0bc18|"
#~ msgstr ""

#~ msgid "|4dfc1ccf0f52485cb630e2c42205e8cd|"
#~ msgstr ""

#~ msgid "|054b39036f4241779cee8b856535ef8c|"
#~ msgstr ""

#~ msgid "|f36b0843a8404bd994c12d417791639e|"
#~ msgstr ""

#~ msgid "|267ba4ef820c4a18ba17a3cf6baa2328|"
#~ msgstr ""

#~ msgid "|cd58650e67ea4d51a6796f6290adc7a3|"
#~ msgstr ""

#~ msgid "|42fe13229c9e47459cd10173391681fd|"
#~ msgstr ""

#~ msgid ""
#~ "``pip install "
#~ "flwr@git+https://github.com/adap/flower.git`` (without "
#~ "extras)"
#~ msgstr "``pip install flwr@git+https://github.com/adap/flower.git`` (extras 제외)"

#~ msgid ""
#~ "``pip install "
#~ "'flwr[simulation]@git+https://github.com/adap/flower.git'`` "
#~ "(with extras)"
#~ msgstr ""
#~ "``pip install "
#~ "'flwr[simulation]@git+https://github.com/adap/flower.git'`` "
#~ "(extras 포함)"

#~ msgid "|35abe9fd99c947f1ada188587b79300e|"
#~ msgstr ""

#~ msgid "|4113569203ae40448098ee4d094f3898|"
#~ msgstr ""

#~ msgid "|387a5b42b212438499d45e9545122a3f|"
#~ msgstr ""

#~ msgid "|9980c661d483419486cc5c92296ea5a3|"
#~ msgstr ""

#~ msgid "|13990a7326864e5ca3f17c6d3d2df761|"
#~ msgstr ""

#~ msgid "|ee72a0d726ec4a78a5feadbbde4376d2|"
#~ msgstr ""

#~ msgid "|fe6cc4783d4741d2949b5145c2d1848e|"
#~ msgstr ""

#~ msgid "|a933b3b132b24a3594cde735e8b43079|"
#~ msgstr ""

#~ msgid "|68c15a5030284837b7e016a137c19180|"
#~ msgstr ""

#~ msgid "|01c13ed6a53447308c58f88229ef9beb|"
#~ msgstr ""

#~ msgid "|fe377cbc92784c30985c932bbf566a02|"
#~ msgstr ""

#~ msgid "|d3a955bbdbb24d4a9e050066191f8dc2|"
#~ msgstr ""

#~ msgid "|39aeb361f8c546f48d1284c50feeb527|"
#~ msgstr ""

#~ msgid "|6fca30cdace54e97b95aaec19b3a3e1d|"
#~ msgstr ""

#~ msgid "|c3948edd518e4c9887dab02c006a3e36|"
#~ msgstr ""

#~ msgid "|d64d4c79ad9f410bb03cbcd69c6da70e|"
#~ msgstr ""

#~ msgid "|3738e18136fe4bba89dc4c47319cb808|"
#~ msgstr ""

#~ msgid "|fc5c4f02bb934b28a37bfd6df154a642|"
#~ msgstr ""

#~ msgid "|c869eb32a01d40d78006597420906052|"
#~ msgstr ""

#~ msgid "|0261ba22f8fa465cb8b7b37d726b3cfe|"
#~ msgstr ""

#~ msgid "|03231a4c1fb8484c8eedcabd132ca5cf|"
#~ msgstr ""

#~ msgid "|977af6151d6d4069b137d77a2fa9df0d|"
#~ msgstr ""

#~ msgid "|d9fc712009944b9ca98d4891d3a27998|"
#~ msgstr ""

#~ msgid "|759b57b6021d476c8bf25f6d8b7f76df|"
#~ msgstr ""

#~ msgid "|05cd636b195a4eafbe63db37c85fb3e3|"
#~ msgstr ""

#~ msgid "|4eca74e8a0b6465bb11a430b954b8bab|"
#~ msgstr ""

#~ msgid "|5d9452a565e2456189fea166e5e43a8f|"
#~ msgstr ""

#~ msgid "|41499fa436654887b7ce84b0d0642118|"
#~ msgstr ""

#~ msgid "v1.18.0 (2025-04-22)"
#~ msgstr ""

#~ msgid ""
#~ "Switching to the new structure is "
#~ "straightforward and should require only "
#~ "minimal adjustments for most contributors, "
#~ "though this is a breaking change—refer"
#~ " to the [contributor "
#~ "guide](https://flower.ai/docs/framework/v1.17.0/en/contribute.html)"
#~ " for updated instructions."
#~ msgstr ""

#~ msgid "|bacbd696f50e4fd8acf14b8585473c19|"
#~ msgstr ""

#~ msgid "|7e85cf58d77048ff8f79330576790fd3|"
#~ msgstr ""

#~ msgid "|182a68ccd12046d691f8f5ee793f036e|"
#~ msgstr ""

#~ msgid "|d88e734fd1ea40268c9e44a23a033ca2|"
#~ msgstr ""

#~ msgid "|c7db45fc2a1e48179b3c611027d20832|"
#~ msgstr ""

#~ msgid "|375b4a262cbe4d9db6992b7d5a28d7a6|"
#~ msgstr ""

#~ msgid "|5cfb403e762047e78790048cf545a06e|"
#~ msgstr ""

#~ msgid "|187ef72b83d24fd78271fa64ce0640f7|"
#~ msgstr ""

#~ msgid "|02d0e4699f13417b98a4c24d9a58e78a|"
#~ msgstr ""

#~ msgid "|b44b8c5f21ad411bb90639c97e68422f|"
#~ msgstr ""

#~ msgid "|a01fc724354c47fa9538d88011027481|"
#~ msgstr ""

#~ msgid "|382d4166910841bc837c24cd505c1113|"
#~ msgstr ""

#~ msgid "|7ca1a80a09724d78837c0da326fbc268|"
#~ msgstr ""

#~ msgid "|a644fa5b1d314256a1ab5ffc3ccd71fe|"
#~ msgstr ""

#~ msgid "|df330ba2ecc7486095020e6377558bba|"
#~ msgstr ""

#~ msgid "|43ccc14243b84cd79df2d253d80de4fb|"
#~ msgstr ""

#~ msgid "|8da4a971b2b44e108f7a3c0391faca33|"
#~ msgstr ""

#~ msgid "|56a4b95333534d8092396b254c10bffa|"
#~ msgstr ""

#~ msgid "|d8a1fe22416c4fed8692a8273b281133|"
#~ msgstr ""

#~ msgid "|854f959d4f744c058a3dc32af5ae3d25|"
#~ msgstr ""

#~ msgid "|3dc0f4bc03e84fa5ae805329c71c0552|"
#~ msgstr ""

#~ msgid "|27275a6071dc4614aa0734708a543110|"
#~ msgstr ""

#~ msgid "|726048ff954444ffb3a7c94a9613260a|"
#~ msgstr ""

#~ msgid "|c233bf3f187d40e7a2a23b60db60d970|"
#~ msgstr ""

#~ msgid "|7c46e573e01b4c71bb5ef1cd79042379|"
#~ msgstr ""

#~ msgid "|f374276c878a40208ae57cb64611d663|"
#~ msgstr ""

#~ msgid "|4d1d8e9719ab4ce7aa48eaf3ba4d3f45|"
#~ msgstr ""

#~ msgid "|65f6155df55d44bda98d7cf140a0a4ca|"
#~ msgstr ""

#~ msgid "|b489956f3f574a109fad2836faf622e4|"
#~ msgstr ""

#~ msgid "|e8061fdb5ec94141bc7526ea8060a9ab|"
#~ msgstr ""

#~ msgid "|741286a5ab8b4703919f32525e6b7ffa|"
#~ msgstr ""

#~ msgid "|0ae5263f7b4d45cca55b69d341f8c83d|"
#~ msgstr ""

#~ msgid "|74ef57e47ce544c8b5700f7c6b213f76|"
#~ msgstr ""

#~ msgid "|f49a5dad3448407ea4480d186235b295|"
#~ msgstr ""

#~ msgid "|142636086022481fba92d32b78caa0f7|"
#~ msgstr ""

#~ msgid "|49cc792ae168402d9917cab825e7def4|"
#~ msgstr ""

#~ msgid "|82d2085f891e4906a7f3b2fbd94640b4|"
#~ msgstr ""

#~ msgid "|0de634679a2b4b958aa20f8d427e4311|"
#~ msgstr ""

#~ msgid "|564c1ebbb05945939f4fcf814facdad4|"
#~ msgstr ""

#~ msgid "|fe2ef144276f40e79a7cf4ecebe97b2e|"
#~ msgstr ""

#~ msgid "|0cac13f2a4834bc5917cff64f23c0105|"
#~ msgstr ""

#~ msgid "|d66f63e57bab4d7a9eafcae9a70d238d|"
#~ msgstr ""

#~ msgid "|450f5fd286984c7b9cf26b1cfc7c6c5a|"
#~ msgstr ""

#~ msgid "|eb64ca89d00a46818780245bef0d9950|"
#~ msgstr ""

#~ msgid "|a711c3264bdb46bdbb9535f668951a9b|"
#~ msgstr ""

#~ msgid "|cb0d905bafcf47b3beb2148744af5b90|"
#~ msgstr ""

#~ msgid "|41cb4736601f4b4e8da3108fd3fc9dd1|"
#~ msgstr ""

#~ msgid "|efc7105fab324accadb050560bbb9956|"
#~ msgstr ""

#~ msgid "|85b42a41b88a48a08d174ce7fbd133dc|"
#~ msgstr ""

#~ msgid "|d05f53bd0b46413aa91b1e7b20eff8af|"
#~ msgstr ""

#~ msgid "|d96743a5729441ca8baeb9d07ea28337|"
#~ msgstr ""

#~ msgid "|64c013ad98634d8cab49cace2215b65f|"
#~ msgstr ""

#~ msgid "|fc74b460576e444c85baf34a38f97b20|"
#~ msgstr ""

#~ msgid "|cfeae6f48fff4571af741752ccb21448|"
#~ msgstr ""

#~ msgid "|2224c9f05174456ea442fda695413392|"
#~ msgstr ""

#~ msgid "|6bcc2eed06b24833a7877563ec9f40c7|"
#~ msgstr ""

#~ msgid "|40ef7f2f1aaf4bd3a23870efddba5ef3|"
#~ msgstr ""

#~ msgid "|168960a2078a43858e627edcdecdf75f|"
#~ msgstr ""

#~ msgid "|650e6e01cb3244369e1139f79e60e172|"
#~ msgstr ""

#~ msgid "|2a0485dfa4d2416f89d8d38a59b3e1db|"
#~ msgstr ""

#~ msgid "|6055bb68397e416199c7bc6fda1b11d6|"
#~ msgstr ""

#~ msgid "|9c449256925849b0a2d98406818bb9b6|"
#~ msgstr ""

#~ msgid "|709d97d6f114426fb55ff5a136cb8d74|"
#~ msgstr ""

#~ msgid "|47e82670bcac47099edc2c22937972b4|"
#~ msgstr ""

#~ msgid "|abbc7a56a4024df8a38621445bd95bb5|"
#~ msgstr ""

#~ msgid "|5fc71ddcdc79460a9977dfe403be4cc4|"
#~ msgstr ""

#~ msgid "|bd8c9bf3c7304cb78b00db6c3f765890|"
#~ msgstr ""

#~ msgid "|313fe723caf843429564a13c3e776013|"
#~ msgstr ""

#~ msgid "|34c0cbcbee5e4926828eed40c64eb293|"
#~ msgstr ""

#~ msgid "|7c405b30c75543d1915c05bebff6313c|"
#~ msgstr ""

#~ msgid ""
#~ "Download the `compose.yml "
#~ "<https://github.com/adap/flower/blob/main/src/docker/complete/compose.yml>`_"
#~ " file into the example directory:"
#~ msgstr ""

#~ msgid "|4ee450862b1f41b8b36328d36134e8c8|"
#~ msgstr ""

#~ msgid "|a76df2fc6efc4340b0b0a8caa03dffe9|"
#~ msgstr ""

#~ msgid "|50b54340e4b9421c92e5016dd66c8355|"
#~ msgstr ""

#~ msgid "|f68042152bf34c54994fcebdc5d52d6f|"
#~ msgstr ""

#~ msgid "|1ea250d7f01b4efd988a7c5c8f6734a7|"
#~ msgstr ""

#~ msgid "|56352bd604f5486eaa9a95c6c6ee7b8f|"
#~ msgstr ""

#~ msgid "|06d0bceaa2e743be93b39c28b5190476|"
#~ msgstr ""

#~ msgid "|7216dd59d94846ed99c03684a2ad0a6c|"
#~ msgstr ""

#~ msgid "|0bcfd02f88784ad38f75a4caa92f05c2|"
#~ msgstr ""

#~ msgid "|d223a37d39f7468abb777b7cd5ee2fea|"
#~ msgstr ""

#~ msgid "|8b88feed06ae468aa85b4eda6656f7f4|"
#~ msgstr ""

#~ msgid "|12d7bf22d5a44820848e8d4078ccf868|"
#~ msgstr ""

#~ msgid "|2aa1be5fff654e3ca96a98b74bb2ae95|"
#~ msgstr ""

#~ msgid "|31cf3d419a3f432b8871ed48bb092db1|"
#~ msgstr ""

#~ msgid "|1e9960abe23a4045afa5298674ad3085|"
#~ msgstr ""

#~ msgid "|935c2faa5b6246e78309ee66d4f8e67a|"
#~ msgstr ""

#~ msgid "|2732344c7a464489972dd411fa151ede|"
#~ msgstr ""

#~ msgid "|a08cd4adac0d4bd0a89fa52e2b8d4043|"
#~ msgstr ""

#~ msgid "|d39ebdbbf7e6437aaf695ce7717c453e|"
#~ msgstr ""

#~ msgid "|d17184158b1143ff998a1090e045b4e8|"
#~ msgstr ""

#~ msgid "|8a4ad5bcbfe246c8a15084182f862583|"
#~ msgstr ""

#~ msgid "|978cc849947d41de87abeec99e401f93|"
#~ msgstr ""

#~ msgid "|281f579687904d10af5dc0afee5379fc|"
#~ msgstr ""

#~ msgid "|49a3268eba18415396cf6a9da7cbc6ff|"
#~ msgstr ""

#~ msgid "|03282d5b3691414a8084ff2ab69bc173|"
#~ msgstr ""

#~ msgid "|a30fedc5e9e54ff796cdc99d7004a9a7|"
#~ msgstr ""

#~ msgid "|794c04c2efa9435aad3ccc4b15d6433e|"
#~ msgstr ""

#~ msgid "|77a2ae94f6e24c1692f6e7b8997d4db1|"
#~ msgstr ""

#~ msgid "|78fff3204c3742c68d48864f44287827|"
#~ msgstr ""

#~ msgid "|bc08a4804db84be9977290dc7464fe7c|"
#~ msgstr ""

#~ msgid "|ebd5a7b8a51943389b874677725311ab|"
#~ msgstr ""

#~ msgid "|6568438e6cbc4794a6cd508d5a00ef61|"
#~ msgstr ""

#~ msgid "|0405ab79153047d4aaabc017e9599390|"
#~ msgstr ""

#~ msgid "|8e85ef8d54994b38bb953294af54024d|"
#~ msgstr ""

#~ msgid "|f0af739067674c95973768e57e5ab559|"
#~ msgstr ""

#~ msgid "|9958f885ad484663922ee5f3138bfc2d|"
#~ msgstr ""

#~ msgid "|7ea0ff7c3d494ae79e94e983df38625b|"
#~ msgstr ""

#~ msgid "|7951e9e7f8f240b7a7e77ecaa090e3bc|"
#~ msgstr ""

#~ msgid "|ce06be29ec894267aba51fe4351ad0e9|"
#~ msgstr ""

#~ msgid "|f988f40567d8459e9d776b39c5c113ab|"
#~ msgstr ""

#~ msgid "|4041d7e27af142a7b046fedf1107e6fb|"
#~ msgstr ""

#~ msgid "|6784a3e35b52433c997e1c23365ef089|"
#~ msgstr ""

#~ msgid "Video tutorial"
#~ msgstr "튜토리얼"

#~ msgid ""
#~ "The video shown below shows how to"
#~ " setup a PyTorch + Flower project "
#~ "using our previously recommended APIs. A"
#~ " new video tutorial will be released"
#~ " that shows the new APIs (as "
#~ "the content above does)"
#~ msgstr ""

#~ msgid ""
#~ "The video shown below shows how to"
#~ " setup a TensorFlow + Flower project"
#~ " using our previously recommended APIs. "
#~ "A new video tutorial will be "
#~ "released that shows the new APIs "
#~ "(as the content above does)"
#~ msgstr ""

#~ msgid "|fdddf98a0e4242a2a1ae5e5514f47dff|"
#~ msgstr ""

#~ msgid "|be53537e5d0541b88f511c0d85c62ab8|"
#~ msgstr ""

#~ msgid "|eae203170ed2414195dc0d760749d2e1|"
#~ msgstr ""

#~ msgid "|1fed92efb1c24be0a6b12b7d7cb69a87|"
#~ msgstr ""

#~ msgid "|82c4f5d4978648de91fa4f307defcc16|"
#~ msgstr ""

#~ msgid "|57086c10071943e99968d55d6972a799|"
#~ msgstr ""

#~ msgid "|801435c7b9314afabc35aaa9cf512f8e|"
#~ msgstr ""

#~ msgid "|f73c9b4adcf9414a9605996eb2b597af|"
#~ msgstr ""

#~ msgid "|d183568ca3344f72b0f198acfc6a4b8e|"
#~ msgstr ""

#~ msgid "|33858954857a4f41ab39463102a19013|"
#~ msgstr ""

#~ msgid "|8d14735cba704b908b908a595955611f|"
#~ msgstr ""

#~ msgid "|ab6d1c42314648d3a8aa6434b7895f45|"
#~ msgstr ""

#~ msgid "|bc903db0ab9f43f1a0c26a04ba5f3e51|"
#~ msgstr ""

#~ msgid "|09519054c2274a1194bc2c6154294192|"
#~ msgstr ""

#~ msgid "|691cc2446f8d4904b5eefbb2e422a00d|"
#~ msgstr ""

#~ msgid "|959ace9236d44a84b0352fa7abce0ae5|"
#~ msgstr ""

#~ msgid "|d08d86434b0a40d0ab9e970c9d3f26a3|"
#~ msgstr ""

#~ msgid "|c903d4610434415c893c2896cc44d1be|"
#~ msgstr ""

#~ msgid "|a8a127b5e77e40058d92534a98a1ac67|"
#~ msgstr ""

#~ msgid "|d94816ae0bb948a08d9c70fc40cdfe45|"
#~ msgstr ""

#~ msgid "|0df9b0b7bd7f49428a0f16986577e640|"
#~ msgstr ""

#~ msgid "|3ca2aec703e04914846468bdebbaa579|"
#~ msgstr ""

#~ msgid "|62c7197c979a425eae442a833817ad90|"
#~ msgstr ""

#~ msgid "|cec1ac1022eb49b6b4999a6fc0dc1692|"
#~ msgstr ""

#~ msgid "|ff4ad9f1c9d0454f82cd45e2237ec41f|"
#~ msgstr ""

#~ msgid "|263fa38c588a42b6b9b5bb6f1ab7e572|"
#~ msgstr ""

#~ msgid "|832fe0df0b4c44f9b7d1e170a8071363|"
#~ msgstr ""

#~ msgid "|db0ef1f7489c450e96abcfc32fae9b06|"
#~ msgstr ""

#~ msgid "|305404ff382b42e3afc1b27b11c732c1|"
#~ msgstr ""

#~ msgid "|64ab5026bd994c15a6c473a5652dcf1b|"
#~ msgstr ""

#~ msgid "|823bbd248f154e1bb640a5d0d93af4de|"
#~ msgstr ""

#~ msgid "|4709c7a2e15146fdbac896e9bc7e2354|"
#~ msgstr ""

#~ msgid "|3627003a08694bd3b6a4e11e48e9ae0c|"
#~ msgstr ""

#~ msgid "|8d9fe79d8c804dfd80a215699a1538dc|"
#~ msgstr ""

#~ msgid "|efd371c313c940f2b0bd75808a437742|"
#~ msgstr ""

#~ msgid "|e9f908c8fd754b22afdecd79d16a2288|"
#~ msgstr ""

#~ msgid "|0b00dbec410444c29339b6f4832261a7|"
#~ msgstr ""

#~ msgid "|afe9444cfc0b4872908db840c186dadc|"
#~ msgstr ""

#~ msgid "|306e3dd0b4434c1e9aa6dc3a096db3b2|"
#~ msgstr ""

#~ msgid "|ccf3d95299284d9e8c2825c233e88705|"
#~ msgstr ""

#~ msgid "|fec8c44eaca7456c9896fcec43d132df|"
#~ msgstr ""

#~ msgid "|bcde8581fb664c5faa45209fb9f30e19|"
#~ msgstr ""

#~ msgid ""
#~ "Start a Flower federation consisting of"
#~ " one ``SuperLink`` (\"the server\") and "
#~ "two ``SuperNodes`` (\"the clients\")."
#~ msgstr ""

#~ msgid ""
#~ "This guide also assumes that you "
#~ "are familiar with the basic components"
#~ " in a Flower deployment (i.e. "
#~ "``SuperLink`` and ``SuperNode``), what their"
#~ " roles are and how they interact "
#~ "with each other. Please refer to "
#~ "the :doc:`explanation-flower-architecture` "
#~ "guide and the :doc:`ref-flower-"
#~ "network-communication` for an overview of"
#~ " what each component does and how "
#~ "they interact with each other."
#~ msgstr ""

#~ msgid ""
#~ "In a real deployment you would "
#~ "typically run the ``SuperLink`` the "
#~ "``SuperNodes`` in different machines/servers "
#~ "from the one you develop your "
#~ "Flower app (i.e. from where you do"
#~ " ``flwr new`` and ``flwr run``). The"
#~ " guide presented below is still valid"
#~ " for such scenarios but you will "
#~ "need to have setup a Python "
#~ "environment with the right set of "
#~ "dependencies for ``SuperLink`` and "
#~ "``SuperNodes``. An often easier way to"
#~ " achieve such deployments is by means"
#~ " of Docker. Check the :doc:`docker/index`"
#~ " to gain a better understanding on"
#~ " how to do so."
#~ msgstr ""

#~ msgid ""
#~ "In this section you will learn how"
#~ " to launch a ``SuperLink`` and "
#~ "connect two ``SuperNodes`` to it."
#~ msgstr ""

#~ msgid ""
#~ "In a new terminal, activate your "
#~ "environment and start the ``SuperLink`` "
#~ "process in insecure mode:"
#~ msgstr ""

#~ msgid "``flower-superlink``: Name of the ``SuperLink`` binary."
#~ msgstr ""

#~ msgid ""
#~ "``--insecure``: This flag tells the "
#~ "SuperLink to operate in an insecure "
#~ "mode, allowing"
#~ msgstr ""

#~ msgid ""
#~ "unencrypted communication. Refer to the "
#~ ":doc:`how-to-enable-tls-connections` "
#~ "guide to learn how to run your "
#~ "``SuperLink`` with TLS."
#~ msgstr ""

#~ msgid ""
#~ "In this step, you will launch two"
#~ " ``SuperNodes`` and connect them to "
#~ "the ``SuperLink``. You will need two "
#~ "terminals for this step."
#~ msgstr ""

#~ msgid ""
#~ "**Terminal 1** Start the first "
#~ "``SuperNode`` after activating your "
#~ "environment:"
#~ msgstr ""

#~ msgid "``flower-supernode``: Name of the ``SuperNode`` binary."
#~ msgstr ""

#~ msgid ""
#~ "``--insecure``: This flag tells the "
#~ "``SuperNode`` to operate in an insecure"
#~ " mode, allowing"
#~ msgstr ""

#~ msgid ""
#~ "unencrypted communication. Refer to the "
#~ ":doc:`how-to-enable-tls-connections` "
#~ "guide to learn how to run your "
#~ "``SuperNode`` with TLS."
#~ msgstr ""

#~ msgid ""
#~ "``--superlink 127.0.0.1:9092``: Connect to the"
#~ " SuperLink's Fleet API at the address"
#~ msgstr ""

#~ msgid ""
#~ "``127.0.0.1:9092``. If you had launched "
#~ "the ``SuperLink`` in a different "
#~ "machine, you'd replace ``127.0.0.1`` with "
#~ "the public IP of that machine."
#~ msgstr ""

#~ msgid ""
#~ "``--clientappio-api-address 127.0.0.1:9094``: "
#~ "Set the address and port number "
#~ "where the"
#~ msgstr ""

#~ msgid "SuperNode is listening to communicate with the ``ClientApp``."
#~ msgstr ""

#~ msgid ""
#~ "``--node-config \"partition-id=0 num-"
#~ "partitions=2\"``: The ``ClientApp`` code "
#~ "generated via the ``flwr new`` template"
#~ " expects those two key-value pairs"
#~ " to be defined at run time. Set"
#~ " the partition ID to ``0`` and "
#~ "the number of partitions to ``2`` "
#~ "for the ``SuperNode`` configuration."
#~ msgstr ""

#~ msgid ""
#~ "**Terminal 2** Start the second "
#~ "``SuperNode`` after activating your "
#~ "environment:"
#~ msgstr ""

#~ msgid ""
#~ "``--clientappio-api-address 127.0.0.1:9095``: "
#~ "Note that a different port is "
#~ "being used. This is only needed "
#~ "because you are running two "
#~ "``SuperNodes`` on the same machine. "
#~ "Typically you would run one node "
#~ "per machine and therefore, the "
#~ "``--clientappio-api-address`` could be "
#~ "omitted all together and left with "
#~ "its default value."
#~ msgstr ""

#~ msgid ""
#~ "``--node-config \"partition-id=1 num-"
#~ "partitions=2\"```: Note here we indicate "
#~ "a different `partition-id`. In this "
#~ "way, a ``ClientApp`` will use a "
#~ "different data partition depending on "
#~ "which ``SuperNode`` runs in."
#~ msgstr ""

#~ msgid ""
#~ "At this point, you have launched "
#~ "two ``SuperNodes`` that are connected to"
#~ " the same ``SuperLink``. The system "
#~ "is idling waiting for a ``Run`` to"
#~ " be submitted. Before you can run "
#~ "your Flower App through the federation"
#~ " we need a way to tell ``flwr"
#~ " run`` that the App is to be"
#~ " executed via the SuperLink we just"
#~ " started, instead of using the local"
#~ " Simulation Engine (the default). Doing "
#~ "this is easy: define a new "
#~ "federation section in the ``pyproject.toml``,"
#~ " indicate the address of the "
#~ "``SuperLink`` and pass a certificate (if"
#~ " any) or set the insecure flag "
#~ "(only when testing locally, real "
#~ "deployments require TLS)."
#~ msgstr ""

#~ msgid "Get the shape of the array."
#~ msgstr "Flower 기본 이미지의 태그."

#~ msgid "|0ea48143db30437b919c47ae5b8ff9bf|"
#~ msgstr ""

#~ msgid "|ff8aa37ba237463a9475ce7312d8921f|"
#~ msgstr ""

#~ msgid "|ebd7d0a0c4964788a4bbe2dc145e30a3|"
#~ msgstr ""

#~ msgid "|4781d482ca224829a7c8e4843dae96dd|"
#~ msgstr ""

#~ msgid "|8528765b7fdd4cc59e72ddfe2fa5827d|"
#~ msgstr ""

#~ msgid "|fa5a4492a49a4f0097081b2610649f4d|"
#~ msgstr ""

#~ msgid "|9333bfd7117449bfb1b7a02e7282b3a2|"
#~ msgstr ""

#~ msgid "|018e85c87a56450d920091df27460f21|"
#~ msgstr ""

#~ msgid "|b875e957083647488294b44f6e60508e|"
#~ msgstr ""

#~ msgid "|f6ece9f07d354a01b09129256fd36d16|"
#~ msgstr ""

#~ msgid "|e8c23423c2dd49e9a5912b0d5c703a56|"
#~ msgstr ""

#~ msgid "|927a52ff98574b059fa2facb2af6c230|"
#~ msgstr ""

#~ msgid "|790b693a579946fe966dfc84cc8472fe|"
#~ msgstr ""

#~ msgid "|497ea844d8d947bcbb290cee1a70008c|"
#~ msgstr ""

#~ msgid ""
#~ "By default, the Flower logger uses "
#~ "logging level ``INFO``. This can be "
#~ "changed via the ``FLWR_LOG_LEVEL`` environment"
#~ " variable to any other levels that"
#~ " Python's `logging module "
#~ "<https://docs.python.org/3/library/logging.html#logging-"
#~ "levels>`_ supports. For example, to "
#~ "launch your ``SuperLink`` showing ``DEBUG``"
#~ " logs do:"
#~ msgstr ""

#~ msgid ""
#~ "When a ``ClientApp`` is executed it "
#~ "receives a Context_. This context is "
#~ "unique for each ``ClientApp``, meaning "
#~ "that subsequent executions of the same"
#~ " ``ClientApp`` from the same node "
#~ "will receive the same ``Context`` "
#~ "object. In the ``Context``, the "
#~ "``.state`` attribute can be used to "
#~ "store information that you would like"
#~ " the ``ClientApp`` to have access to"
#~ " for the duration of the run. "
#~ "This could be anything from intermediate"
#~ " results such as the history of "
#~ "training losses (e.g. as a list of"
#~ " `float` values with a new entry "
#~ "appended each time the ``ClientApp`` is"
#~ " executed), certain parts of the "
#~ "model that should persist at the "
#~ "client side, or some other arbitrary "
#~ "Python objects. These items would need"
#~ " to be serialized before saving them"
#~ " into the context."
#~ msgstr ""

#~ msgid "Make the ``context.state`` reachable withing your client class"
#~ msgstr ""

#~ msgid ""
#~ "Initialise the appropiate record type "
#~ "(in this example we use ConfigRecord_)"
#~ " and save/read your entry when "
#~ "required."
#~ msgstr ""

#~ msgid ""
#~ "**CLI to SuperLink (Exec API)**: The "
#~ "``flwr`` `CLI command <ref-api-"
#~ "cli.html>`_, typically run on the users"
#~ " workstation, is used to interface "
#~ "with a deployed Flower federation "
#~ "consisting of SuperLink and SuperNodes. "
#~ "From a networking perspective, the "
#~ "``flwr`` CLI acts as a gRPC client"
#~ " and the SuperLink acts as a "
#~ "gRPC server. The ``flwr`` CLI is "
#~ "the only way for a user (AI "
#~ "researchers, data scientist) to inferface "
#~ "with a deployed Flower federation. They"
#~ " cannot, for example, interface directly"
#~ " with SuperNodes connected to the "
#~ "SuperLink. The ``flwr`` CLI to SuperLink"
#~ " connection should always use TLS, "
#~ "but ``insecure`` mode is supported for"
#~ " local testing."
#~ msgstr ""

#~ msgid ""
#~ "The inspect Flower telemetry without "
#~ "sending any anonymous usage metrics, use"
#~ " both environment variables:"
#~ msgstr ""

#~ msgid ""
#~ "Check the `source code "
#~ "<https://github.com/adap/flower/tree/main/examples/quickstart-"
#~ "fastai>`_ of this tutorial in ``examples"
#~ "/quickstart-fasai`` in the Flower GitHub"
#~ " repository."
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that the "
#~ "``context`` enables you to get access"
#~ " to hyperparemeters defined in your "
#~ "``pyproject.toml`` to configure the run. "
#~ "In this tutorial we access the "
#~ "`local-epochs` setting to control the "
#~ "number of epochs a ``ClientApp`` will"
#~ " perform when running the ``fit()`` "
#~ "method. You could define additioinal "
#~ "hyperparameters in ``pyproject.toml`` and "
#~ "access them here."
#~ msgstr ""

#~ msgid "|967a8bf9d6c14cdd8948fce8b75ca6bc|"
#~ msgstr ""

#~ msgid "|ac7a8d58d51a41fabeaa868e5736ff67|"
#~ msgstr ""

#~ msgid "|dcff43e865c44d6a96b29fa499a6fc51|"
#~ msgstr ""

#~ msgid "|71cc359afa22476e92264e99292bd109|"
#~ msgstr ""

#~ msgid "|135933cea091442182b81324216f40ed|"
#~ msgstr ""

#~ msgid "|e484b55a0c9b426dbf3025eea769c973|"
#~ msgstr ""

#~ msgid "|098cb730392848bc860f4113150e2cd2|"
#~ msgstr ""

#~ msgid "|0b3b2de22eb3416582bb41bbe5f70a75|"
#~ msgstr ""

#~ msgid "|e053b98d409c46cbb290a525e911cf1e|"
#~ msgstr ""

#~ msgid "|5b9359f31d8f474ca35c53f64c012975|"
#~ msgstr ""

#~ msgid "|8920230c6e7d42aa8ab16489589c34ee|"
#~ msgstr ""

#~ msgid "|6a2c70ddd6e44cbdbf5053b74edd7141|"
#~ msgstr ""

#~ msgid "|d2e794a010b8458f8ef7a9566e5fe62d|"
#~ msgstr ""

#~ msgid "|4ff5cbd7b624471daca8b1c17933fa41|"
#~ msgstr ""

#~ msgid "|9ebe8262c4194c44ba4a2be53c980aee|"
#~ msgstr ""

#~ msgid "|c88f55f67d464e8d801e8b0439319406|"
#~ msgstr ""

#~ msgid "|eec321d625ed4b979c8b85739cba24a0|"
#~ msgstr ""

#~ msgid "|b5b85bb0f2e746b3b21bbc93064f1713|"
#~ msgstr ""

#~ msgid "|d3a699b267c24d189bbcd5c7d88aa24c|"
#~ msgstr ""

#~ msgid "|3f52e8713ba1464190546013d5071ca9|"
#~ msgstr ""

#~ msgid "|c900d15cd53c48fa9534b4f3b52e6a7c|"
#~ msgstr ""

#~ msgid "|24d650391e6b470bb8e3ca6bf72765a7|"
#~ msgstr ""

#~ msgid "|4ef0c0ddaf284853b908ec4826eda70e|"
#~ msgstr ""

#~ msgid "|6adf6e99472145168f733cd3cb69edbd|"
#~ msgstr ""

#~ msgid "|c61759bdc5a4499b89fe87ba431e3864|"
#~ msgstr ""

#~ msgid "|d3a42aea8c914a12b431caf494172210|"
#~ msgstr ""

#~ msgid "|406fac62cefb4c298cdb1a63db37ec87|"
#~ msgstr ""

#~ msgid "|9ffff0a65f2342a8bea9f0e9d282580d|"
#~ msgstr ""

#~ msgid "|16b74fb052cc4b93b11bb54f5a965637|"
#~ msgstr ""

#~ msgid "|3ab7f8d3932b4d9a9c5f93f52fb97183|"
#~ msgstr ""

#~ msgid "|d8809b99c8b1406987518fd2d588e98a|"
#~ msgstr ""

#~ msgid "|e6b97e49aa25444a8917ffeb41140493|"
#~ msgstr ""

#~ msgid "|2de181ad9c3b46f88b2e55be716ceeb9|"
#~ msgstr ""

#~ msgid "|1af177cb011a407198484e0a689b3483|"
#~ msgstr ""

#~ msgid "|04de4e1a24ef46a69b0c3fa107ba64d5|"
#~ msgstr ""

#~ msgid "|eefbcab399994d848017a865e3399861|"
#~ msgstr ""

#~ msgid "|e170f401b7954a12a00b529f54594fc5|"
#~ msgstr ""

#~ msgid "|fd3783347f4c448ea65a3e2747aea4da|"
#~ msgstr ""

#~ msgid "|a2f7c60a162e469e97445b3942dcc5f4|"
#~ msgstr ""

#~ msgid "|902c355a35404a16a3be39b692938451|"
#~ msgstr ""

#~ msgid "|63350c37183742fbb67a5e34b1c533ae|"
#~ msgstr ""

#~ msgid "|867a7872e4dd40a1811bfd20e4d6f62f|"
#~ msgstr ""

#~ msgid ""
#~ "Must be ``None``. ``Array`` does not "
#~ "support child objects. Providing any "
#~ "children will raise a ``ValueError``."
#~ msgstr ""

#~ msgid "|ab00717b4fcf4c4e88fbacebdb2e5104|"
#~ msgstr ""

#~ msgid "|35704bcb67b04aae88cf73d7789f84e9|"
#~ msgstr ""

#~ msgid "|4dbaa50ad7fb424ea1464f49a22fbd1b|"
#~ msgstr ""

#~ msgid "|ce96ff6f413b4bc48f67dd282cac3530|"
#~ msgstr ""

#~ msgid "|9a9e82799fac424cba1d5f74948681ee|"
#~ msgstr ""

#~ msgid "|84fb402f085348b5b3cace4bb6259ec2|"
#~ msgstr ""

#~ msgid "|b4469692621449e6a5eed641772b352b|"
#~ msgstr ""

#~ msgid "|cbae2e70533343d2801e4f5e93771349|"
#~ msgstr ""

#~ msgid "|9881cccc8a124ddcae73aea78eb7a42a|"
#~ msgstr ""

#~ msgid "|2a1779a818904423a30071e1e0c56dd9|"
#~ msgstr ""

#~ msgid "|c82f8049e9c14f5f8d86000f09775f15|"
#~ msgstr ""

#~ msgid "|e541665f503b4d7dbe1647d4b015b613|"
#~ msgstr ""

#~ msgid "|ad22c7c9041d4bb68e95276c87497743|"
#~ msgstr ""

#~ msgid "|df37c0910c6e4e11ac9d883480b20d39|"
#~ msgstr ""

#~ msgid "|fc57576a231747128ff75a61f1e9cd39|"
#~ msgstr ""

#~ msgid "|767520b7ffeb4d7d84e3516a0df30f33|"
#~ msgstr ""

#~ msgid "|e7952261d68d49168c6162814e1d5c43|"
#~ msgstr ""

#~ msgid "|92ae92ba3c614abf8f4dee65f60324ae|"
#~ msgstr ""

#~ msgid "|45ce570042ec49eeab9b77b509234534|"
#~ msgstr ""

#~ msgid "|5402b15bbe564f8e84624ad1972a0202|"
#~ msgstr ""

#~ msgid "|51d802738fa9409a819e56cc34188e4e|"
#~ msgstr ""

#~ msgid "|52f745311ab64879ab56a1e8ebe340ae|"
#~ msgstr ""

#~ msgid "|e1bcdcd42c6145bdb2d82d43c62838ee|"
#~ msgstr ""

#~ msgid "|53979a42c30f44b09629e09e16b29a8d|"
#~ msgstr ""

#~ msgid "|678bf760161d42f696df097625bf8292|"
#~ msgstr ""

#~ msgid "|b497d66068144c95a1333c8dd3bf3f8e|"
#~ msgstr ""

#~ msgid "|26357e35cb164955a9ffc069e14b5b42|"
#~ msgstr ""

#~ msgid "|69a7af741bd04e93954bc2707cebbdb0|"
#~ msgstr ""

#~ msgid "|2604e198ffb6467b84346ed001d58e10|"
#~ msgstr ""

#~ msgid "|a952cba05f064c959077b57e9da35467|"
#~ msgstr ""

#~ msgid "|101756e084b54422a2888f3f76dc86e8|"
#~ msgstr ""

#~ msgid "|84d5cef6b6824946ae972166b4642ece|"
#~ msgstr ""

#~ msgid "|9545638e72064cb29af65402f1c41b0f|"
#~ msgstr ""

#~ msgid "|a967f3afc23e4fb6b3f2a7210a28887d|"
#~ msgstr ""

#~ msgid "|29b5b0c728a64d9baf670c29e8f91870|"
#~ msgstr ""

#~ msgid "|932165be47b74d90a2c6675c900a3cb2|"
#~ msgstr ""

#~ msgid "|32198515baea40a7820ee635940f969a|"
#~ msgstr ""

#~ msgid "|ed94ce4ec07a4aa2ad9c27dd4b9d5f0d|"
#~ msgstr ""

#~ msgid "|e18ced1669ea45e2b6f5f39dca17cdd5|"
#~ msgstr ""

#~ msgid "|d7af74c68e934740aa09e348b6115413|"
#~ msgstr ""

#~ msgid "|08ee2e477cea420596d4695a66eacfb0|"
#~ msgstr ""

#~ msgid "|43f83028f1b048a98e353c79cabec221|"
#~ msgstr ""

#~ msgid ""
#~ "Configure the transport layer. Allowed "
#~ "values: - 'grpc-bidi': gRPC, "
#~ "bidirectional streaming - 'grpc-rere': "
#~ "gRPC, request-response (experimental) - "
#~ "'rest': HTTP (experimental)"
#~ msgstr ""
#~ "전송 계층을 구성합니다. 허용되는 값입니다: - "
#~ "'grpc-bidi': gRPC, 양방향 스트리밍 - "
#~ "'grpc-rere': gRPC, 요청-응답(실험적) - 'rest': "
#~ "HTTP(실험적)"

#~ msgid "|c6e75721b909437dbd1c2b35f78a9363|"
#~ msgstr ""

#~ msgid "|fb8c30a376b1473dbeeca583b3bb0d2b|"
#~ msgstr ""

#~ msgid "|e7529a9a3e7e456ab89807b88a368240|"
#~ msgstr ""

#~ msgid "|8b1a3ceda8aa474581fd38963291c0ec|"
#~ msgstr ""

#~ msgid "|4436660e4c024a5f8c28ed250c17783a|"
#~ msgstr ""

#~ msgid "|114bc2e95bf04b4c9024f0141f0d79cb|"
#~ msgstr ""

#~ msgid "|e0ba06bfaf424e84b75a6372a2629999|"
#~ msgstr ""

#~ msgid "|048551ac907545deb367036f8e4e076f|"
#~ msgstr ""

#~ msgid "|417094c62b1049d5abb3f7e2420dac73|"
#~ msgstr ""

#~ msgid "|7cce809e842c4edc8498e5d5a780b0c8|"
#~ msgstr ""

#~ msgid "|2df8e178f0a840dba801f41e0bfb0e61|"
#~ msgstr ""

#~ msgid "|c4a924a014384814a6f9182024bc39fd|"
#~ msgstr ""

#~ msgid "|cadb25fb8f4c485f92b6611f284ddd8a|"
#~ msgstr ""

#~ msgid "|7a5a9d002a514d8a9843386e653cf6ee|"
#~ msgstr ""

#~ msgid ""
#~ "``FLWR_LICENSE_KEY`` environment variable not "
#~ "set. This is required when starting "
#~ "the SuperLink Enterprise version."
#~ msgstr ""

#~ msgid ""
#~ "Set the ``FLWR_LICENSE_KEY`` as an "
#~ "environment variable when starting the "
#~ "SuperLink."
#~ msgstr ""

#~ msgid "Ensure the license key is valid."
#~ msgstr ""

#~ msgid "|7d728a54553a433a88f45356344afb8e|"
#~ msgstr ""

#~ msgid "|f9c4f489e9e14412b756262111e9eee4|"
#~ msgstr ""

#~ msgid "|3450ca269c194766b744d9b3901bba44|"
#~ msgstr ""

#~ msgid "|84f34d42d2334dd081280c0e1f73eb96|"
#~ msgstr ""

#~ msgid "|468c05b4e49d4820a2cee468a23173b5|"
#~ msgstr ""

#~ msgid "|bb495222283e485c985020449f7829cd|"
#~ msgstr ""

#~ msgid "|74647fee6eea4516a78c7d869deb7c46|"
#~ msgstr ""

#~ msgid "|393dd38092e34f5e9579757b15fe8eb8|"
#~ msgstr ""

#~ msgid "|2cb3eac40dd64841b80a3af6a6bf151a|"
#~ msgstr ""

#~ msgid "|a131ee2e5e044947808a0eee84ea1653|"
#~ msgstr ""

#~ msgid "|999f128dc3cb40a0a6e30aa183e17257|"
#~ msgstr ""

#~ msgid "|092143f39286443b887b59228bbecbba|"
#~ msgstr ""

#~ msgid "|05279604174540d195a7342584808109|"
#~ msgstr ""

#~ msgid "|155f796db77342c0a7bd5209eb448982|"
#~ msgstr ""

#~ msgid "|abf214ea9e0f4b50a1640e6e6417bd8d|"
#~ msgstr ""

#~ msgid "|14bef6e6736844bebc680805406a79c6|"
#~ msgstr ""

#~ msgid "|23f8cc0b06b440bb901f94afac26b3e7|"
#~ msgstr ""

#~ msgid "|3980fe2dcb974cdbbefa7ec199dadcda|"
#~ msgstr ""

#~ msgid "|cd7304d9aff64e5d93c2afb644f49006|"
#~ msgstr ""

#~ msgid "|c97e4782ef9f4a03ad2033469fed7335|"
#~ msgstr ""

#~ msgid "|fb20379f55f14e3dbec2be42bfe50a2d|"
#~ msgstr ""

#~ msgid "|35cc8dd5e27d47ffa5902fd89cef0c09|"
#~ msgstr ""

#~ msgid "|69c282cf6ddc491283db5cb6ee1338e1|"
#~ msgstr ""

#~ msgid "|1c83c06845364ef0aec9e9086e082ceb|"
#~ msgstr ""

#~ msgid "|d8b480068a224fec892766329137f7ba|"
#~ msgstr ""

#~ msgid "|6c438616cf2f459987c9e7d3190af659|"
#~ msgstr ""

#~ msgid "|8fdbc3ecaece46caac7718b04735bc37|"
#~ msgstr ""

#~ msgid "|372a348111ed4a5eb69894e2df3670a7|"
#~ msgstr ""

#~ msgid "|f1e4621e79bd4f7b9ca6b2c75224c9e6|"
#~ msgstr ""

#~ msgid "|1c1cdca5051440a4af27cb06832ac172|"
#~ msgstr ""

#~ msgid "|51e581baa4584cd1bea7f1d9d7910f75|"
#~ msgstr ""

#~ msgid "|a9274dd22b1649f2bcb645ddbc4c02ca|"
#~ msgstr ""

#~ msgid "|9a5789cc5e964312be973e040de1697b|"
#~ msgstr ""

#~ msgid "|fcb9e4f1ac604cfaa5564213f99c7ee7|"
#~ msgstr ""

#~ msgid "|6980cc3853294734b4d3e5a81663d6f0|"
#~ msgstr ""

#~ msgid "|40ddd46273cb4c64ae887559901e095c|"
#~ msgstr ""

#~ msgid "|666113235f8b4a9aaf311623610d0677|"
#~ msgstr ""

#~ msgid "|20a78eced7e644b09e14e21345f75824|"
#~ msgstr ""

#~ msgid "|048172da9aa442698bca1d1b09510561|"
#~ msgstr ""

#~ msgid "|87c5c604063f4459a5982f5e3b78b41c|"
#~ msgstr ""

#~ msgid "|3b89f9d679b24a7892283c7245004c77|"
#~ msgstr ""

#~ msgid "|454d3d15f4b54d7287ee0eb15153c65d|"
#~ msgstr ""

#~ msgid "the Exec API on ``http://localhost:9093``."
#~ msgstr ""

#~ msgid ""
#~ "In some cases, the server and "
#~ "client charts are deployed in the "
#~ "same cluster, while the exec API "
#~ "is accessible via the internet."
#~ msgstr ""

#~ msgid ""
#~ "Name of the servicer method, e.g. "
#~ "``ExecServicer.StartRun``/``FleetServicer.PullMessages``"
#~ msgstr ""

#~ msgid ""
#~ "Here is an example output when a"
#~ " user runs ``flwr run`` (note the "
#~ "``\"action\": \"ExecServicer.StartRun\"``):"
#~ msgstr ""

#~ msgid "``address``\\*: The address of the SuperLink Exec API to connect to."
#~ msgstr ""

#~ msgid ""
#~ "**CLI to SuperLink (Exec API)**: The "
#~ "``flwr`` `CLI command <ref-api-"
#~ "cli.html>`_, typically run on the users"
#~ " workstation, is used to interface "
#~ "with a deployed Flower federation "
#~ "consisting of SuperLink and SuperNodes. "
#~ "From a networking perspective, the "
#~ "``flwr`` CLI acts as a gRPC client"
#~ " and the SuperLink acts as a "
#~ "gRPC server. The ``flwr`` CLI is "
#~ "the only way for a user (AI "
#~ "researchers, data scientist) to interface "
#~ "with a deployed Flower federation. They"
#~ " cannot, for example, interface directly"
#~ " with SuperNodes connected to the "
#~ "SuperLink. The ``flwr`` CLI to SuperLink"
#~ " connection should always use TLS, "
#~ "but ``insecure`` mode is supported for"
#~ " local testing."
#~ msgstr ""

#~ msgid ""
#~ "All Flower components — SuperLink, "
#~ "ServerApp process (``flwr-serverapp``), "
#~ "SuperNode, and ClientApp process (``flwr-"
#~ "clientapp``) — expose APIs to interact"
#~ " with other Flower components. The "
#~ "SuperLink component includes three such "
#~ "APIs: the ServerAppIo API, Fleet API,"
#~ " and the Exec API. Similarly, the "
#~ "SuperNode component includes the ClientAppIo"
#~ " API. Each of these APIs serves "
#~ "a distinct purpose when running a "
#~ "Flower app using the deployment runtime,"
#~ " as summarized in the table below."
#~ msgstr ""

#~ msgid "Exec API"
#~ msgstr ""

#~ msgid "|23ba2065d2ca484bb0e96a6cd29a83cf|"
#~ msgstr ""

#~ msgid "Model and data"
#~ msgstr "모델과 데이터"

#~ msgid "|f95c1985d97c44598e2c4fbc8a6cc3cf|"
#~ msgstr ""

#~ msgid "Train model using data"
#~ msgstr "데이터를 이용한 모델 훈련"

#~ msgid "|7782961c1a954e50be6b4e3d8539648e|"
#~ msgstr ""

#~ msgid "Data on a phone"
#~ msgstr "핸드폰에 있는 데이터"

#~ msgid "|f92ce6fcfc8245338fc89d9e57324921|"
#~ msgstr ""

#~ msgid "Data is on many devices"
#~ msgstr "데이터가 여러 장치에 있습니다"

#~ msgid "|2bc8ea061eea42adba532f5ae9448687|"
#~ msgstr ""

#~ msgid "Central data collection"
#~ msgstr "중앙 데이터 수집"

#~ msgid "|aa7490b2144647cab562e9e22fb0d843|"
#~ msgstr ""

#~ msgid "Central model training"
#~ msgstr "중앙 데이터 훈련"

#~ msgid "|6cd35083537943fe8f87ded796e0a59c|"
#~ msgstr ""

#~ msgid "Centralized possible"
#~ msgstr "집중화 가능"

#~ msgid "|efcb217384e045518664dd7a0fdabc9d|"
#~ msgstr ""

#~ msgid "Centralized impossible"
#~ msgstr "집중화 불가능"

#~ msgid "|7fc6376bb87d42839f862de70a23928a|"
#~ msgstr ""

#~ msgid "Initialize global model"
#~ msgstr "글로벌 모델 초기화"

#~ msgid "|fa03f398b30046a488aac2bdc1faa258|"
#~ msgstr ""

#~ msgid "Send global model"
#~ msgstr "글로벌 모델 전송"

#~ msgid "|e08800f906cf452bae2d237f83aa5401|"
#~ msgstr ""

#~ msgid "Train on local data"
#~ msgstr "로컬 데이터에 대한 훈련"

#~ msgid "|e260983839cc4c56a371ae740f5ad72e|"
#~ msgstr ""

#~ msgid "Send model updates"
#~ msgstr "모델 업데이트 전송"

#~ msgid "|181245b5987b4e3a9daa7218839681b7|"
#~ msgstr ""

#~ msgid "Aggregate model updates"
#~ msgstr "모델 업데이트 집계"

#~ msgid "|97b3672bc9d74bd59c2d48a11cfa4cdd|"
#~ msgstr ""

#~ msgid ""
#~ "Flower federated learning server and "
#~ "client nodes (car, scooter, personal "
#~ "computer, roomba, and phone)"
#~ msgstr "Flower 연합 학습 서버 및 클라이언트 노드(자동차, 스쿠터, 개인용 컴퓨터, 룸바, 전화)"

#~ msgid ""
#~ "Before you continue, make sure to "
#~ "join the Flower community on Slack: "
#~ "`Join Slack <https://flower.ai/join-slack/>`__"
#~ msgstr ""

#~ msgid ""
#~ "For more details, visit: `Run "
#~ "simulations <https://flower.ai/docs/framework/how-to-"
#~ "run-simulations.html#run-simulations>`__ guide"
#~ msgstr ""

#~ msgid ""
#~ "The log verbosity level in Flower "
#~ "can be adjusted using the "
#~ "``FLWR_LOG_LEVEL`` environment variable. This "
#~ "helps control the level of detail "
#~ "included in logs, making debugging and"
#~ " monitoring easier."
#~ msgstr ""

#~ msgid ""
#~ "To enable detailed logging (e.g., "
#~ "``DEBUG`` level) for all services, add"
#~ " ``FLWR_LOG_LEVEL`` to the ``env`` "
#~ "parameter under the ``global`` section "
#~ "in your ``values.yml`` file:"
#~ msgstr ""

#~ msgid "**Setting Log Level for a Specific Service**"
#~ msgstr ""

#~ msgid ""
#~ "If you want to enable logging only"
#~ " for a specific service (e.g., "
#~ "``superlink``), you can specify it under"
#~ " the respective service section:"
#~ msgstr ""

#~ msgid ""
#~ "For more details on logging "
#~ "configuration, visit: `Flower Logging "
#~ "Documentation <https://flower.ai/docs/framework/how-to-"
#~ "configure-logging.html>`__"
#~ msgstr ""

#~ msgid ""
#~ "User authentication can be enabled if"
#~ " you’re using the Flower Enterprise "
#~ "Edition (EE) Docker images. This is "
#~ "configured in the ``global.userAuth`` section"
#~ " of your ``values.yml`` file."
#~ msgstr ""

#~ msgid "**Example: Enabling OpenID Connect (OIDC) Authentication**"
#~ msgstr ""

#~ msgid "``auth_type``: The authentication mechanism being used (e.g., OIDC)."
#~ msgstr ""

#~ msgid ""
#~ "``auth_url``: The OpenID Connect "
#~ "authentication endpoint where users "
#~ "authenticate."
#~ msgstr ""

#~ msgid "``token_url``: The URL for retrieving access tokens."
#~ msgstr ""

#~ msgid "``validate_url``: The endpoint for validating user authentication."
#~ msgstr ""

#~ msgid ""
#~ "``oidc_client_id``: The client ID issued "
#~ "by the authentication provider."
#~ msgstr ""

#~ msgid "``oidc_client_secret``: The secret key associated with the client ID."
#~ msgstr ""

#~ msgid ""
#~ "To use an existing secret that "
#~ "contains the user authentication "
#~ "configuration, set ``existingSecret`` to the"
#~ " name of the existing secret:"
#~ msgstr ""

#~ msgid ""
#~ "Note that the existing secret must "
#~ "contain the key ``user-auth-"
#~ "config.yml``:"
#~ msgstr ""

#~ msgid "**Configuring OpenFGA**"
#~ msgstr ""

#~ msgid ""
#~ "The chart component supports OpenFGA as"
#~ " a fine-grained authorization service, "
#~ "but it is disabled by default."
#~ msgstr ""

#~ msgid ""
#~ "To enable OpenFGA change the following"
#~ " value in your ``values.yml`` file:"
#~ msgstr ""

#~ msgid ""
#~ "To connect to an existing database, "
#~ "provide the appropriate connection details "
#~ "via Helm values (e.g., "
#~ "``openfga.datastore.uri``)."
#~ msgstr ""

#~ msgid ""
#~ "For more information visit the official"
#~ " `OpenFGA Helm Chart Documentation "
#~ "<https://artifacthub.io/packages/helm/openfga/openfga/0.2.30>`__."
#~ msgstr ""

#~ msgid "Authorization model file ``model.fga``"
#~ msgstr ""

#~ msgid "User permissions file ``tuples.fga``"
#~ msgstr ""

#~ msgid ""
#~ "The response will include an ``id`` "
#~ "field, which is the OpenFGA store "
#~ "ID associated with the ``OPENFGA_STORE_NAME``"
#~ " that was created."
#~ msgstr ""

#~ msgid ""
#~ "Add a new ``authorization`` section "
#~ "under your existing ``global.userAuth`` "
#~ "configuration or directly within your "
#~ "existing secret, depending on your "
#~ "setup. Set the ``OPENFGA_STORE_ID`` and "
#~ "``OPENFGA_MODEL_ID`` from the previous steps"
#~ " in the file:"
#~ msgstr ""

#~ msgid ""
#~ "The isolation mode determines how the"
#~ " SuperLink manages the ServerApp process"
#~ " execution. This setting can be "
#~ "adjusted using the ``superlink.isolationMode`` "
#~ "parameter:"
#~ msgstr ""

#~ msgid ""
#~ "``--ssl-ca-certfile``: ``/app/cert/ca.crt``, "
#~ "``--ssl-certfile``: ``/app/cert/tls.crt``, ``--ssl-"
#~ "keyfile``: ``/app/cert/tls.key``."
#~ msgstr ""

#~ msgid ""
#~ "For testing or internal use, you "
#~ "might want to deploy Flower without "
#~ "TLS. Be cautious as this exposes "
#~ "your deployment to potential security "
#~ "risks."
#~ msgstr ""

#~ msgid ""
#~ "If certificate creation is disabled, you"
#~ " must provide a pre-existing secret"
#~ " of type ``kubernetes.io/tls`` named "
#~ "``<flower-server.fullname>-server-tls``."
#~ msgstr ""

#~ msgid ""
#~ "When the ``tls`` option is set to"
#~ " ``true``, it expects the existence "
#~ "of the ``<flower-server.fullname>-server-tls``"
#~ " secret. Flower Framework components will"
#~ " load TLS certificates on startup."
#~ msgstr ""

#~ msgid ""
#~ "In this example, we use ``cert-"
#~ "manager`` to create a certificate. By"
#~ " default, the certificate will only "
#~ "include the DNS name specified in "
#~ "``common-name``."
#~ msgstr ""

#~ msgid ""
#~ "In some cases, the server and "
#~ "client charts are deployed in the "
#~ "same cluster, while the Control API "
#~ "is accessible via the internet."
#~ msgstr ""

#~ msgid ""
#~ "This will deploy 10 SuperNodes named "
#~ "``pytorch-flower-client-supernode-<random>``."
#~ msgstr ""

#~ msgid "For a TensorFlow setup, modify the values.yaml file as follows:"
#~ msgstr ""

#~ msgid ""
#~ "This will deploy 3 SuperNodes named "
#~ "``tensorflow-flower-client-supernode-<random>``."
#~ msgstr ""

#~ msgid ""
#~ "**Note:** If ``global.insecure`` is set "
#~ "to ``False``, you must pre-provide "
#~ "a secret of type ``kubernetes.io/tls`` "
#~ "named ``flower-client-tls``."
#~ msgstr ""

#~ msgid ""
#~ "To enable Node Authentication, you need"
#~ " to specify a private key in "
#~ "either PKCS8 or OpenSSH (PEM-like) "
#~ "format. This example assumes that the"
#~ " SuperLink is also configured for "
#~ "Node Authentication and recognizes the "
#~ "``ecdsa-sha2-nistp384 [...]`` public key of"
#~ " this SuperNode."
#~ msgstr ""

#~ msgid ""
#~ "To install SuperNode in isolation mode"
#~ " using the “process” configuration, both"
#~ " the ClientApp and SuperNode need to"
#~ " be enabled. By default, the "
#~ "ClientApp connects to the SuperNode "
#~ "internally within the cluster, so there"
#~ " is no need to set "
#~ "``supernode.address`` and ``supernode.port`` unless"
#~ " the connection is external. This "
#~ "setup assumes that both components are"
#~ " running within the same cluster."
#~ msgstr ""

#~ msgid ""
#~ "You can also deploy the SuperNode "
#~ "and ClientApp separately. To do this,"
#~ " you need to deploy the chart "
#~ "twice: once with ``supernode.enabled=true`` "
#~ "and once with ``clientapp.enabled=true``. To"
#~ " allow the ClientApp to connect to"
#~ " the SuperNode in this configuration, "
#~ "enable the SuperNode ingress by setting"
#~ " ``supernode.ingress.enabled=true``. This setup "
#~ "is intended for scenarios where the "
#~ "components run on different clusters or"
#~ " a hybrid environment involving Kubernetes"
#~ " and ClientApp native installations."
#~ msgstr ""

#~ msgid ""
#~ "Enables support for custom message types"
#~ " in `ServerApp` by allowing the "
#~ "`message_type` field to be set as "
#~ "`\"<action_type>.<action_name>\"`, where `<action_type>`"
#~ " is one of `train`, `evaluate`, or"
#~ " `query`, and `<action_name>` is a "
#~ "valid Python identifier.  Developers can "
#~ "now register handler functions for these"
#~ " custom message types using the "
#~ "decorator `@app.<action_type>(\"<action_name>\")`. For "
#~ "example, the `my_echo_fn` function is "
#~ "called when the `ServerApp` sends a "
#~ "message with `message_type` set to "
#~ "`\"query.echo\"`, and the `get_mean_value` "
#~ "function is called when it's "
#~ "`\"query.mean\"`:"
#~ msgstr ""

#~ msgid ""
#~ "The new `FedAvgM` strategy implements "
#~ "Federated Averaging with Server Momentum "
#~ "\\[Hsu et al., 2019\\]."
#~ msgstr ""

#~ msgid ""
#~ "**SSL-enabled server and client** "
#~ "([#842](https://github.com/adap/flower/pull/842),  "
#~ "[#844](https://github.com/adap/flower/pull/844),  "
#~ "[#845](https://github.com/adap/flower/pull/845), "
#~ "[#847](https://github.com/adap/flower/pull/847), "
#~ "[#993](https://github.com/adap/flower/pull/993), "
#~ "[#994](https://github.com/adap/flower/pull/994))"
#~ msgstr ""

#~ msgid ""
#~ "``-p 9091:9091 -p 9092:9092 -p "
#~ "9093:9093``: Map port ``9091``, ``9092`` "
#~ "and ``9093`` of the"
#~ msgstr ""

#~ msgid ""
#~ "container to the same port of the"
#~ " host machine, allowing other services "
#~ "to access the"
#~ msgstr ""

#~ msgid ""
#~ "ServerAppIO API on ``http://localhost:9091``, "
#~ "the Fleet API on ``http://localhost:9092`` "
#~ "and"
#~ msgstr ""

#~ msgid "the Control API on ``http://localhost:9093``."
#~ msgstr ""

#~ msgid ""
#~ "tag of the image. The tag "
#~ ":substitution-code:`|stable_flwr_version|` represents a"
#~ " :doc:`specific version <pin-version>` of"
#~ " the image."
#~ msgstr ""

#~ msgid ""
#~ "``--insecure``: This flag tells the "
#~ "container to operate in an insecure "
#~ "mode, allowing"
#~ msgstr ""

#~ msgid "unencrypted communication."
#~ msgstr ""

#~ msgid ""
#~ "independent process. The SuperLink does "
#~ "not attempt to create it. You can"
#~ " learn more about"
#~ msgstr ""

#~ msgid "the different process modes here: :doc:`run-as-subprocess`."
#~ msgstr ""

#~ msgid ""
#~ "``-p 9094:9094``: Map port ``9094`` of"
#~ " the container to the same port "
#~ "of"
#~ msgstr ""

#~ msgid ""
#~ "the host machine, allowing other "
#~ "services to access the SuperNode API "
#~ "on"
#~ msgstr ""

#~ msgid "``http://localhost:9094``."
#~ msgstr ""

#~ msgid ""
#~ ":substitution-code:`flwr/supernode:|stable_flwr_version|`: "
#~ "This is the name of the"
#~ msgstr ""

#~ msgid "image to be run and the specific tag of the image."
#~ msgstr ""

#~ msgid ""
#~ "``--superlink superlink:9092``: Connect to the"
#~ " SuperLink's Fleet API at the address"
#~ msgstr ""

#~ msgid "``superlink:9092``."
#~ msgstr ""

#~ msgid ""
#~ "``--node-config \"partition-id=0 num-"
#~ "partitions=2\"``: Set the partition ID "
#~ "to ``0`` and the"
#~ msgstr ""

#~ msgid "number of partitions to ``2`` for the SuperNode configuration."
#~ msgstr ""

#~ msgid ""
#~ "``--clientappio-api-address 0.0.0.0:9094``: "
#~ "Set the address and port number "
#~ "that the"
#~ msgstr ""

#~ msgid "SuperNode is listening on to communicate with the ClientApp. If"
#~ msgstr ""

#~ msgid ""
#~ "two SuperNodes are started on the "
#~ "same machine, set two different port "
#~ "numbers for each SuperNode."
#~ msgstr ""

#~ msgid ""
#~ "(E.g. In the next step, we set "
#~ "the second SuperNode container to listen"
#~ " on port 9095)"
#~ msgstr ""

#~ msgid "Step 4: Start a ServerApp"
#~ msgstr "서버(SuperLink)"

#~ msgid ""
#~ "The ServerApp Docker image comes with"
#~ " a pre-installed version of Flower"
#~ " and serves as a base for "
#~ "building your own ServerApp image. In"
#~ " order to install the FAB "
#~ "dependencies, you will need to create"
#~ " a Dockerfile that extends the "
#~ "ServerApp image and installs the "
#~ "required dependencies."
#~ msgstr ""

#~ msgid ""
#~ "Create a ServerApp Dockerfile called "
#~ "``serverapp.Dockerfile`` and paste the "
#~ "following code in:"
#~ msgstr ""

#~ msgid "serverapp.Dockerfile"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid ""
#~ ":substitution-code:`FROM "
#~ "flwr/serverapp:|stable_flwr_version|`: This line "
#~ "specifies that the Docker image"
#~ msgstr ""

#~ msgid ""
#~ "to be built from is the "
#~ "``flwr/serverapp`` image, version :substitution-"
#~ "code:`|stable_flwr_version|`."
#~ msgstr ""

#~ msgid ""
#~ "``WORKDIR /app``: Set the working "
#~ "directory for the container to ``/app``."
#~ msgstr ""

#~ msgid ""
#~ "Any subsequent commands that reference a"
#~ " directory will be relative to this"
#~ " directory."
#~ msgstr ""

#~ msgid "``COPY pyproject.toml .``: Copy the ``pyproject.toml`` file"
#~ msgstr ""

#~ msgid ""
#~ "from the current working directory into"
#~ " the container's ``/app`` directory."
#~ msgstr ""

#~ msgid ""
#~ "``RUN sed -i 's/.*flwr\\[simulation\\].*//' "
#~ "pyproject.toml``: Remove the ``flwr`` "
#~ "dependency"
#~ msgstr ""

#~ msgid "from the ``pyproject.toml``."
#~ msgstr "또는 ``pyproject.toml``:"

#~ msgid ""
#~ "``python -m pip install -U --no-"
#~ "cache-dir .``: Run the ``pip`` "
#~ "install command to"
#~ msgstr ""

#~ msgid "install the dependencies defined in the ``pyproject.toml`` file"
#~ msgstr ""

#~ msgid ""
#~ "The ``-U`` flag indicates that any "
#~ "existing packages should be upgraded, "
#~ "and"
#~ msgstr ""

#~ msgid ""
#~ "``--no-cache-dir`` prevents pip from "
#~ "using the cache to speed up the"
#~ " installation."
#~ msgstr ""

#~ msgid ""
#~ "``ENTRYPOINT [\"flwr-serverapp\"]``: Set the"
#~ " command ``flwr-serverapp`` to be"
#~ msgstr ""

#~ msgid "the default command run when the container is started."
#~ msgstr ""

#~ msgid ""
#~ "Note that `flwr <https://pypi.org/project/flwr/>`__"
#~ " is already installed in the "
#~ "``flwr/clientapp`` base image, so only "
#~ "other package dependencies such as "
#~ "``flwr-datasets``, ``torch``, etc., need to"
#~ " be installed. As a result, the "
#~ "``flwr`` dependency is removed from the"
#~ " ``pyproject.toml`` after it has been "
#~ "copied into the Docker image (see "
#~ "line 5)."
#~ msgstr ""

#~ msgid ""
#~ "Afterward, in the directory that holds"
#~ " the Dockerfile, execute this Docker "
#~ "command to build the ServerApp image:"
#~ msgstr ""

#~ msgid "``--name serverapp``: Assign the name ``serverapp`` to the container."
#~ msgstr ""

#~ msgid "of the image."
#~ msgstr ""

#~ msgid ""
#~ "``--serverappio-api-address superlink:9091``: "
#~ "Connect to the SuperLink's ServerAppIO "
#~ "API"
#~ msgstr ""

#~ msgid "at the address ``superlink:9091``."
#~ msgstr ""

#~ msgid ""
#~ "The procedure for building and running"
#~ " a ClientApp image is almost "
#~ "identical to the ServerApp image."
#~ msgstr "ServerApp 이미지를 빌드하고 실행하는 절차는 SuperNode 이미지와 거의 동일합니다."

#~ msgid ""
#~ "Similar to the ServerApp image, you "
#~ "will need to create a Dockerfile "
#~ "that extends the ClientApp image and "
#~ "installs the required FAB dependencies."
#~ msgstr ""

#~ msgid ""
#~ "Create a ClientApp Dockerfile called "
#~ "``clientapp.Dockerfile`` and paste the "
#~ "following code into it:"
#~ msgstr ""

#~ msgid "clientapp.Dockerfile"
#~ msgstr "클라이언트앱"

#~ msgid ""
#~ ":substitution-code:`FROM "
#~ "flwr/clientapp:|stable_flwr_version|`: This line "
#~ "specifies that the Docker image"
#~ msgstr ""

#~ msgid ""
#~ "``ENTRYPOINT [\"flwr-clientapp\"]``: Set the"
#~ " command ``flwr-clientapp`` to be"
#~ msgstr ""

#~ msgid ""
#~ "Next, build the ClientApp Docker image"
#~ " by running the following command in"
#~ " the directory where the Dockerfile "
#~ "is located:"
#~ msgstr ""
#~ "다음으로, Docker파일과 ServerApp 코드가 있는 디렉터리에서"
#~ " 다음 명령을 실행하여 ServerApp Docker 이미지를"
#~ " 빌드합니다."

#~ msgid ""
#~ "The image name was set as "
#~ "``flwr_clientapp`` with the tag ``0.0.1``. "
#~ "Remember that these values are merely"
#~ " examples, and you can customize them"
#~ " according to your requirements."
#~ msgstr ""
#~ "이미지에``flwr_serverapp``이라는 이름을 붙이고 ``0.0.1``이라는 "
#~ "태그를 붙였습니다. 여기서 선택한 값은 예시일 뿐이라는 "
#~ "점을 기억하세요. 필요에 따라 변경할 수 있습니다."

#~ msgid "Start the first ClientApp container:"
#~ msgstr ""

#~ msgid ""
#~ "``flwr_clientapp:0.0.1``: This is the name "
#~ "of the image to be run and "
#~ "the specific tag"
#~ msgstr "``flwr_serverapp:0.0.1``: 사용할 Docker 이미지의 태그 이름입니다."

#~ msgid ""
#~ "``--clientappio-api-address supernode-1:9094``: "
#~ "Connect to the SuperNode's ClientAppIO"
#~ msgstr ""

#~ msgid "API at the address ``supernode-1:9094``."
#~ msgstr ""

#~ msgid "Start the second ClientApp container:"
#~ msgstr ""

#~ msgid "Stop the current ServerApp and ClientApp containers:"
#~ msgstr "현재 클라이언트 속성입니다."

#~ msgid "If you haven’t made any changes, you can skip steps 2 through 4."
#~ msgstr ""

#~ msgid "Rebuild ServerApp and ClientApp images:"
#~ msgstr "기본 이미지 빌드"

#~ msgid ""
#~ "Launch one new ServerApp and two "
#~ "new ClientApp containers based on the"
#~ " newly built image:"
#~ msgstr ""

#~ msgid ""
#~ "A step-by-step guide to learn "
#~ "how to create, deploy and run a"
#~ " Flower app on the `Google Cloud "
#~ "Platform (GCP) <https://console.cloud.google.com>`_ "
#~ "using the `Google Kubernetes Engine "
#~ "(GKE) <https://cloud.google.com/kubernetes-engine>`_. "
#~ "The figure below presents an overview"
#~ " of the architecture of the Flower"
#~ " components we will deploy on GCP "
#~ "using GKE."
#~ msgstr ""

#~ msgid ""
#~ "The Google Cloud Artifact Registry is"
#~ " a fully managed, scalable, and "
#~ "private service for storing and managing"
#~ " software build artifacts and dependencies."
#~ " Consequently, to run our Flower app"
#~ " on the GKE cluster, we need to"
#~ " store the app's specific Flower "
#~ "Docker images within the registry, i.e.,"
#~ " ``ClientApp`` and ``ServerApp``, which we"
#~ " discuss in the next section. For "
#~ "typical use-cases, the Flower SuperLink"
#~ " and SuperNode Docker images do not"
#~ " need to be built and can be"
#~ " pulled directly from the official "
#~ "`Flower DockerHub repository "
#~ "<https://hub.docker.com/u/flwr>`_. This step is "
#~ "crucial as it enables the cluster, "
#~ "and subsequently the ``Pods``, to "
#~ "download the built Docker images and "
#~ "deploy the necessary Flower components. "
#~ "Please see below the instructions on "
#~ "how to create the repository using "
#~ "the ``gcloud`` CLI:"
#~ msgstr ""

#~ msgid ""
#~ "In order to proceed with this next"
#~ " step, first, we create a local "
#~ "Flower app, and then create a "
#~ "dedicated Dockerfile for the ServerApp "
#~ "and the ClientApp Docker images. Once"
#~ " we build the images, we tag "
#~ "them and push them to the newly"
#~ " created Google registry. Most of the"
#~ " steps on how to build Docker "
#~ "images discussed below are based on "
#~ "the `Flower Quickstart with Docker "
#~ "Tutorial <https://flower.ai/docs/framework/docker/tutorial-"
#~ "quickstart-docker.html>`_."
#~ msgstr ""

#~ msgid ""
#~ "Once the app is created, we "
#~ "navigate inside the app directory (i.e.,"
#~ " where the ``pyproject.toml`` file is) "
#~ "and create two ``Dockerfile``\\s one for"
#~ " the ``ClientApp`` component, named "
#~ "``clientapp.Dockerfile`` and one for the "
#~ "``ServerApp`` component, named "
#~ "``serverapp.Dockerfile``. We will use both "
#~ "files to build locally the necessary "
#~ "Docker images. We will be using "
#~ "the default images for ``SuperLink`` and"
#~ " ``SuperLink`` available in the `Flower "
#~ "DockerHub repository <https://hub.docker.com/u/flwr>`_."
#~ msgstr ""

#~ msgid ""
#~ "Even though the app you created "
#~ "has only ``NumPy`` as dependency, you"
#~ " can use the provided "
#~ "``clientapp.Dockerfile`` and ``serverapp.Dockerfile`` "
#~ "to create the corresponding images for"
#~ " any Flower app when going from "
#~ "simulation to deployment. The ``RUN`` "
#~ "command installs all the necessary "
#~ "dependencies for your app to run "
#~ "and removes the ``flwr[simulation]`` "
#~ "dependency while building the Docker "
#~ "images."
#~ msgstr ""

#~ msgid ""
#~ "Once we have created the required "
#~ "Dockerfiles, we build the Docker Images"
#~ " as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Before we are able to push our "
#~ "two newly locally created Docker images,"
#~ " we need to tag them with the"
#~ " Google Artifact Registry repository name"
#~ " and image name we created during "
#~ "the previous steps. If you have "
#~ "followed the earlier naming suggestions, "
#~ "the the repository name is ``flower-"
#~ "gcp-example-artifacts``, the local "
#~ "Docker images names are "
#~ "``flower_numpy_example_serverapp:0.0.1`` and "
#~ "``flower_numpy_example_numpy:0.0.1``, and the region"
#~ " is ``us-central1``. Please note that"
#~ " the ``<YOUR_PROJECT_ID>`` is different "
#~ "from user to user so in the "
#~ "commands below we use the "
#~ "``<YOUR_PROJECT_ID>`` placeholder. Putting all "
#~ "this together, the final commands you"
#~ " need to run to tag the "
#~ "``ServerApp`` and ``ClientApp`` Docker images"
#~ " are:"
#~ msgstr ""

#~ msgid ""
#~ "Once our images are tagged correctly,"
#~ " you can push them to your "
#~ "``Artifact Registry`` repository using the "
#~ "``docker push`` command with the tagged"
#~ " name:"
#~ msgstr ""

#~ msgid ""
#~ "In this step, we shall deploy six"
#~ " ``Pods``: 1x ``SuperLink``, 2x "
#~ "``SuperNode``, 2x ``ClientApp``, and 1x "
#~ "``ServerApp``. To achieve this, below we"
#~ " provide the definition of the six"
#~ " ``yaml`` files that are necessary to"
#~ " deploy the ``Pods`` on the cluster"
#~ " and which are passed to ``kubectl``,"
#~ " and a helper ``k8s-deploy.sh`` "
#~ "script, which will deploy the ``Pods``."
#~ msgstr ""

#~ msgid "serverapp-deployment.yaml"
#~ msgstr ""

#~ msgid "clientapp-1-deployment.yaml"
#~ msgstr ""

#~ msgid "clientapp-2-deployment.yaml"
#~ msgstr ""

#~ msgid "``flwr-serverapp``"
#~ msgstr "flower 서버 프로그램"

#~ msgid "``flwr-clientapp``"
#~ msgstr "Flower ClientApp."

#~ msgid "Technical Commands"
#~ msgstr ""

#~ msgid "``flower-simulation``"
#~ msgstr "flower 시뮬레이션"

#~ msgid ""
#~ "**ServerApp-specific exit codes (200-299)**:"
#~ " Specific to ``flwr-serverapp`` (ServerApp)"
#~ " errors."
#~ msgstr ""

#~ msgid ""
#~ "**ClientApp-specific exit codes (400-499)**:"
#~ " Specific to ``flwr-clientapp`` (ClientApp)"
#~ " errors."
#~ msgstr ""

#~ msgid ""
#~ "**Simulation-specific exit codes (500-599)**:"
#~ " Specific to ``flwr-simulation`` "
#~ "(Simulation Engine) errors."
#~ msgstr ""

#~ msgid "**Common exit codes (600-)**: Shared across multiple components."
#~ msgstr ""

#~ msgid ""
#~ "The ``flwr-serverapp`` and ``flwr-"
#~ "clientapp`` do not currently support "
#~ "TLS, as they are assumed to be "
#~ "executed within the same network as "
#~ "their respective long-running processes: "
#~ "``flower-superlink`` and ``flower-supernode``."
#~ " Please refer to the `Flower Network"
#~ " Communication <../ref-flower-network-"
#~ "communication.html>`_ guide for further "
#~ "details."
#~ msgstr ""

#~ msgid "A Flower `server` consists of **SuperLink** and ``ServerApp``:"
#~ msgstr ""

#~ msgid ""
#~ "**SuperLink**: a long-running process "
#~ "that forwards task instructions to "
#~ "clients (SuperNodes) and receives task "
#~ "results back."
#~ msgstr ""

#~ msgid ""
#~ "``ServerApp``: a short-lived process "
#~ "with project-spcific code that "
#~ "customizes all server-side aspects of"
#~ " federated learning systems (client "
#~ "selection, client configuration, result "
#~ "aggregation). This is what AI "
#~ "researchers and AI engineers write when"
#~ " they build Flower apps."
#~ msgstr ""

#~ msgid "A Flower `client` consists of **SuperNode** and ``ClientApp``:"
#~ msgstr ""

#~ msgid ""
#~ "**SuperNode**: a long-running process "
#~ "that connects to the SuperLink, asks "
#~ "for tasks, executes tasks (for example,"
#~ " \"train this model on your local "
#~ "data\") and returns task results back"
#~ " to the SuperLink."
#~ msgstr ""

#~ msgid ""
#~ "``ClientApp``: a short-lived process "
#~ "with project-specific code that "
#~ "customizes all client-side aspects of"
#~ " federated learning systems (local model"
#~ " training and evaluation, pre- and "
#~ "post-processing). This is what AI "
#~ "researchers and AI engineers write when"
#~ " they build Flower apps."
#~ msgstr ""

#~ msgid ""
#~ "Why SuperNode and SuperLink? Well, in"
#~ " federated learning, the clients are "
#~ "the actual stars of the show. They"
#~ " hold the training data and they "
#~ "run the actual training. This is "
#~ "why Flower decided to name them "
#~ "**SuperNode**. The **SuperLink** is then "
#~ "responsible for acting as the `missing"
#~ " link` between all those SuperNodes."
#~ msgstr ""

#~ msgid ""
#~ "In a Flower app project, users "
#~ "will typically develop the ``ServerApp`` "
#~ "and the ``ClientApp``. All the network"
#~ " communication between `server` and "
#~ "`clients` is taken care of by the"
#~ " SuperLink and SuperNodes."
#~ msgstr ""

#~ msgid ""
#~ "With *multi-run*, multiple ``ServerApp``\\s"
#~ " and ``ClientApp``\\s are now capable "
#~ "of running on the same federation "
#~ "consisting of a single long-running "
#~ "SuperLink and multiple long-running "
#~ "SuperNodes. This is sometimes referred "
#~ "to as `multi-tenancy` or `multi-"
#~ "job`."
#~ msgstr ""

#~ msgid ""
#~ "As shown in the figure below, two"
#~ " projects, each consisting of a "
#~ "``ServerApp`` and a ``ClientApp``, could "
#~ "share the same SuperLink and SuperNodes."
#~ msgstr ""

#~ msgid "Multi-tenancy federated learning architecture"
#~ msgstr ""

#~ msgid "Multi-tenancy federated learning architecture with Flower"
#~ msgstr ""

#~ msgid ""
#~ "However, in ``[run 2]``, only the "
#~ "first and third SuperNodes are selected"
#~ " to participate in the training:"
#~ msgstr ""

#~ msgid ""
#~ "Run 2 in a multi-run federated "
#~ "learning architecture with Flower. Only "
#~ "the first and third SuperNodes are "
#~ "selected to participate in the training"
#~ " round."
#~ msgstr ""

#~ msgid ""
#~ "Therefore, with Flower multi-run, "
#~ "different projects (each consisting of a"
#~ " ``ServerApp`` and ``ClientApp``) can run"
#~ " on different sets of clients."
#~ msgstr ""

#~ msgid ""
#~ "This explanation covers the Flower "
#~ "Deployment Engine. An explanation covering "
#~ "the Flower Simulation Engine will "
#~ "follow."
#~ msgstr ""

#~ msgid ""
#~ "All Flower components — SuperLink, "
#~ "ServerApp process (``flwr-serverapp``), "
#~ "SuperNode, and ClientApp process (``flwr-"
#~ "clientapp``) — expose APIs to interact"
#~ " with other Flower components. The "
#~ "SuperLink component includes three such "
#~ "APIs: the ServerAppIo API, Fleet API,"
#~ " and the Control API. Similarly, the"
#~ " SuperNode component includes the "
#~ "ClientAppIo API. Each of these APIs "
#~ "serves a distinct purpose when running"
#~ " a Flower app using the deployment"
#~ " runtime, as summarized in the table"
#~ " below."
#~ msgstr ""

#~ msgid "Communication between the SuperLink and the ``ServerApp`` process"
#~ msgstr ""

#~ msgid "Used by the SuperNodes to communicate with the SuperLink"
#~ msgstr ""

#~ msgid ""
#~ "Users interface with the SuperLink via"
#~ " this API using the `FlowerCLI "
#~ "<ref-api-cli.html>`_."
#~ msgstr ""

#~ msgid "Communication between the SuperNode and the ``ClientApp`` process"
#~ msgstr ""

#~ msgid ""
#~ "Both Flower SuperLink and Flower "
#~ "SuperNode can use different isolation "
#~ "modes. Isolation mode ``subprocess`` "
#~ "configures the SuperLink/SuperNode to run "
#~ "ServerApp/ClientApp in a sub-process. "
#~ "Isolation mode ``process`` expects ServerApp"
#~ " or ClientApp to run in separate "
#~ "externally-managed processes. This allows, "
#~ "for example, to run SuperNode and "
#~ "``ClientApp`` in separate Docker containers"
#~ " with different sets of dependencies "
#~ "installed. Check the :doc:`docker/index` guide"
#~ " to gain a better understanding on"
#~ " how to use both modes."
#~ msgstr ""

#~ msgid ""
#~ "In isolation mode ``process``, additional "
#~ "network connections are necessary to "
#~ "allow the external process running "
#~ "ServerApp or ClientApp to communicate "
#~ "with the long-running SuperLink or "
#~ "SuperNode:"
#~ msgstr ""

#~ msgid ""
#~ "**flwr-serverapp to SuperLink (ServerAppIO "
#~ "API)**: The process running the "
#~ "``ServerApp``, ``flwr-serveapp``, acts as "
#~ "a gRPC client and connects to the"
#~ " SuperLink's ServerAppIO API. This "
#~ "connection enables the ``flwr-serverapp`` "
#~ "process to pull the necessary inputs "
#~ "to execute the ``ServerApp``. It also"
#~ " allows the ``ServerApp``, once running,"
#~ " to do typical things like "
#~ "sending/receiving messages to/from available "
#~ "SuperNodes (via the SuperLink)."
#~ msgstr ""

#~ msgid ""
#~ "**flwr-clientapp to SuperNode (ClientAppIO "
#~ "API)**: The process running the "
#~ "``ClientApp``, ``flwr-clientapp``, acts as "
#~ "a gRPC client and connects to the"
#~ " SuperNode's ClientAppIO API. This "
#~ "connection enables the ``flwr-clientapp`` "
#~ "process to pull the necessary details"
#~ " (e.g., FAB file) to execute the "
#~ "``ClientApp``, execute the ``ClientApp`` "
#~ "(e.g., local model training) and return"
#~ " the execution results (e.g., locally "
#~ "update model parameters) to the "
#~ "SuperNode."
#~ msgstr ""

#~ msgid ""
#~ "In the current version of Flower, "
#~ "both of these connections are insecure"
#~ " because Flower expects SuperLink/SuperNode "
#~ "and ``flwr-serverapp`` / ``flwr-"
#~ "clientapp`` to be run in the same"
#~ " network. ``flwr-serverapp`` / ``flwr-"
#~ "clientapp`` and SuperLink/SuperNode should "
#~ "never communicate over untrusted networks "
#~ "(e.g., public internet)."
#~ msgstr ""

#~ msgid ""
#~ "**ServerApp to Database**: ``ServerApp`` "
#~ "instances might want to access the "
#~ "data to perform the action they "
#~ "have been designed for (e.g. evaluate"
#~ " a model on some data after "
#~ "aggregation). How this connection is "
#~ "established depends on what storage "
#~ "technology used at the client side. "
#~ "Note that in the diagram above we"
#~ " have omitted showing a DB connected"
#~ " to the ServerApp components."
#~ msgstr ""

#~ msgid "Note that the existing secret must contain the key `FLWR_LICENSE_KEY`:"
#~ msgstr ""

#~ msgid ""
#~ "To ensure TLS communication within the"
#~ " Flower Framework, you need to "
#~ "configure your deployment with proper "
#~ "TLS certificates."
#~ msgstr ""

#~ msgid ""
#~ "These paths can be overridden by "
#~ "specifying the flags in the extraArgs,"
#~ " as shown below."
#~ msgstr ""

#~ msgid ""
#~ "To deploy the Flower Framework simply,"
#~ " you need to configure your "
#~ "deployment as insecure."
#~ msgstr ""

#~ msgid "Pre-provide TLS Certificate"
#~ msgstr ""

#~ msgid ""
#~ "If certificate creation is disabled, you"
#~ " must provide a pre-existing secret"
#~ " of type `kubernetes.io/tls` named "
#~ "`<flower-server.fullname>-server-tls`."
#~ msgstr ""

#~ msgid ""
#~ "When the `tls` option is set to"
#~ " `true`, it expects the existence of"
#~ " the `<flower-server.fullname>-server-tls` "
#~ "secret. Flower Framework components will "
#~ "load TLS certificates on startup."
#~ msgstr ""

#~ msgid "**Pre-Provide TLS Certificate with Additional Hosts**"
#~ msgstr ""

#~ msgid ""
#~ "In this example, we use `cert-"
#~ "manager` to create a certificate. By "
#~ "default, the certificate will only "
#~ "include the DNS name specified in "
#~ "`common-name`."
#~ msgstr ""

#~ msgid ""
#~ "To allow SuperNodes to connect to "
#~ "the SuperLink via the internal service"
#~ " URL, you need to add an "
#~ "additional host, as shown below:"
#~ msgstr ""

#~ msgid "`global.certificateAnnotations`"
#~ msgstr ""

#~ msgid "Default Cert-Manager certificate annotations"
#~ msgstr ""

#~ msgid "Flower-TLS-Certificate parameters"
#~ msgstr "인증서"

#~ msgid "Can be disabled if a Secret already exists"
#~ msgstr ""

#~ msgid "`certificate.name`"
#~ msgstr "인증서"

#~ msgid "Certificate name"
#~ msgstr "인증서"

#~ msgid "`flower-server-tls`"
#~ msgstr "Flower 서버."

#~ msgid ""
#~ "The requested ‘duration’ (i.e. lifetime) "
#~ "of the Certificate. Default is 5 "
#~ "years."
#~ msgstr ""

#~ msgid "`certificate.renewBefore`"
#~ msgstr ""

#~ msgid ""
#~ "How long before the currently issued "
#~ "certificate’s expiry cert-manager should "
#~ "renew the certificate. Default is 15 "
#~ "days."
#~ msgstr ""

#~ msgid ""
#~ "Private key options. These include the"
#~ " key algorithm and size, the used "
#~ "encoding and the rotation policy."
#~ msgstr ""

#~ msgid "`certificate.additionalHosts`"
#~ msgstr ""

#~ msgid "Additional hosts you want to put into the SAN's of the certificate"
#~ msgstr ""

#~ msgid "Defaults to cert-Manager.io"
#~ msgstr ""

#~ msgid "Defaults to Issuer"
#~ msgstr ""

#~ msgid "`Issuer`"
#~ msgstr ""

#~ msgid "Name of the Issuer or Issuer to use"
#~ msgstr ""

#~ msgid "Ingress TLS configuration"
#~ msgstr "구성 값"

#~ msgid ""
#~ "To ensure TLS communication within the"
#~ " Flower framework, you need to "
#~ "configure your deployment with proper "
#~ "TLS certificates."
#~ msgstr ""

#~ msgid ""
#~ "**Note:** If `global.insecure` is set to"
#~ " `False`, you must pre-provide a "
#~ "secret of type `kubernetes.io/tls` named "
#~ "`flower-client-tls`."
#~ msgstr ""

#~ msgid "Example configuration for TLS deployment:"
#~ msgstr ""

#~ msgid ""
#~ "For testing or internal use, you "
#~ "might want to deploy the Flower "
#~ "framework without TLS. Be cautious as"
#~ " this exposes your deployment to "
#~ "potential security risks."
#~ msgstr ""

#~ msgid "Example configuration for insecure deployment:"
#~ msgstr ""

#~ msgid "`supernode.ingress.enabled`"
#~ msgstr ""

#~ msgid "`supernode.ingress.annotations`"
#~ msgstr ""

#~ msgid "`supernode.ingress.ingressClassName`"
#~ msgstr ""

#~ msgid "`supernode.ingress.tls`"
#~ msgstr ""

#~ msgid "`supernode.ingress.clientappio.enabled`"
#~ msgstr ""

#~ msgid "Enable an ingress resource for SuperNode ClientAppIO"
#~ msgstr ""

#~ msgid "`supernode.ingress.clientappio.hostname`"
#~ msgstr ""

#~ msgid "Ingress hostname for the SuperNode ClientAppIO ingress"
#~ msgstr "이미 *서버*를 시작할 수 있습니다:"

#~ msgid "`clientappio.example.com`"
#~ msgstr "클라이언트앱"

#~ msgid "`supernode.ingress.clientappio.path`"
#~ msgstr ""

#~ msgid "SuperNode ClientAppIO ingress path"
#~ msgstr ""

#~ msgid "`supernode.ingress.clientappio.pathType`"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.serverapp.FedAvg.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, replies\\)"
#~ msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`aggregate_train "
#~ "<flwr.serverapp.FedAvg.aggregate_train>`\\ \\(server\\_round\\,"
#~ " replies\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`start <flwr.serverapp.FedAvg.start>`\\ \\(grid\\,"
#~ " initial\\_arrays\\[\\, num\\_rounds\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`start_client <flwr.client.start_client>`\\ "
#~ "\\(\\*\\, server\\_address\\[\\, client\\_fn\\, "
#~ "...\\]\\)"

#~ msgid ":py:obj:`summary <flwr.serverapp.FedAvg.summary>`\\ \\(\\)"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ""
#~ ":py:obj:`aggregate_train "
#~ "<flwr.serverapp.Strategy.aggregate_train>`\\ "
#~ "\\(server\\_round\\, replies\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.serverapp.Strategy.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, arrays\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_train "
#~ "<flwr.serverapp.Strategy.configure_train>`\\ "
#~ "\\(server\\_round\\, arrays\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ "Let's use `flwr new` to create a"
#~ " complete Flower+PyTorch project. It will"
#~ " generate all the files needed to "
#~ "run, by default with the Flower "
#~ "Simulation Engine, a federation of 10"
#~ " nodes using `FedAvg "
#~ "<https://flower.ai/docs/framework/ref-"
#~ "api/flwr.server.strategy.FedAvg.html#flwr.server.strategy.FedAvg>`_."
#~ " The dataset will be partitioned "
#~ "using Flower Dataset's `IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
#~ msgstr ""

#~ msgid ""
#~ "Then, run the command below. You "
#~ "will be prompted to select one of"
#~ " the available templates (choose "
#~ "``PyTorch``), give a name to your "
#~ "project, and type in your developer "
#~ "name:"
#~ msgstr ""

#~ msgid ""
#~ "The main changes we have to make"
#~ " to use `PyTorch` with `Flower` will"
#~ " be found in the ``get_weights()`` "
#~ "and ``set_weights()`` functions. In "
#~ "``get_weights()`` PyTorch model parameters are"
#~ " extracted and represented as a list"
#~ " of NumPy arrays. The ``set_weights()`` "
#~ "function that's the oposite: given a "
#~ "list of NumPy arrays it applies "
#~ "them to an existing PyTorch model. "
#~ "Doing this in fairly easy in "
#~ "PyTorch."
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that the "
#~ "`context` enables you to get access "
#~ "to hyperparemeters defined in your "
#~ "``pyproject.toml`` to configure the run. "
#~ "In this tutorial we access the "
#~ "`local-epochs` setting to control the "
#~ "number of epochs a ``ClientApp`` will"
#~ " perform when running the ``fit()`` "
#~ "method. You could define additioinal "
#~ "hyperparameters in ``pyproject.toml`` and "
#~ "access them here."
#~ msgstr ""

#~ msgid ""
#~ "To construct a ``ServerApp`` we define"
#~ " a ``server_fn()`` callback with an "
#~ "identical signature to that of "
#~ "``client_fn()`` but the return type is"
#~ " `ServerAppComponents <https://flower.ai/docs/framework"
#~ "/ref-"
#~ "api/flwr.server.ServerAppComponents.html#serverappcomponents>`_ "
#~ "as opposed to a `Client "
#~ "<https://flower.ai/docs/framework/ref-"
#~ "api/flwr.client.Client.html#client>`_. In this "
#~ "example we use the `FedAvg`. To it"
#~ " we pass a randomly initialized model"
#~ " that will server as the global "
#~ "model to federated. Note that the "
#~ "value of ``fraction_fit`` is read from"
#~ " the run config. You can find "
#~ "the default value defined in the "
#~ "``pyproject.toml``."
#~ msgstr ""

#~ msgid "Override federation configuration values in the format:"
#~ msgstr ""

#~ msgid ""
#~ "`--federation-config 'key1=value1 key2=value2' "
#~ "--federation-config 'key3=value3'`"
#~ msgstr ""

#~ msgid ""
#~ "Values can be of any type "
#~ "supported in TOML, such as bool, "
#~ "int, float, or string. Ensure that "
#~ "the keys (`key1`, `key2`, `key3` in "
#~ "this example) exist in the federation"
#~ " configuration under the "
#~ "`[tool.flwr.federations.<YOUR_FEDERATION>]` table of "
#~ "the `pyproject.toml` for proper overriding."
#~ msgstr ""

#~ msgid "Override run configuration values in the format:"
#~ msgstr ""

#~ msgid "`--run-config 'key1=value1 key2=value2' --run-config 'key3=value3'`"
#~ msgstr ""

#~ msgid ""
#~ "Values can be of any type "
#~ "supported in TOML, such as bool, "
#~ "int, float, or string. Ensure that "
#~ "the keys (`key1`, `key2`, `key3` in "
#~ "this example) exist in `pyproject.toml` "
#~ "for proper overriding."
#~ msgstr ""

#~ msgid ""
#~ "When a ``ClientApp`` is executed it "
#~ "receives a Context_. This context is "
#~ "unique for each ``ClientApp``, meaning "
#~ "that subsequent executions of the same"
#~ " ``ClientApp`` from the same node "
#~ "will receive the same ``Context`` "
#~ "object. In the ``Context``, the "
#~ "``.state`` attribute can be used to "
#~ "store information that you would like"
#~ " the ``ClientApp`` to have access to"
#~ " for the duration of the run. "
#~ "This could be anything from intermediate"
#~ " results such as the history of "
#~ "training losses (e.g. as a list of"
#~ " `float` values with a new entry "
#~ "appended each time the ``ClientApp`` is"
#~ " executed), certain parts of the "
#~ "model that should persist on the "
#~ "client side, or some other arbitrary "
#~ "Python objects. These items would need"
#~ " to be serialized before saving them"
#~ " into the context."
#~ msgstr ""

#~ msgid ""
#~ "If you run the app, you'll see "
#~ "an output similar to the one "
#~ "below. See how after each round "
#~ "the `n_val` entry in the context "
#~ "gets one additional integer ? Note "
#~ "that the order in which the "
#~ "`ClientApp` logs these messages might "
#~ "differ slightly between rounds."
#~ msgstr ""

#~ msgid ""
#~ "Using ConfigRecord_ or MetricRecord_ to "
#~ "save \"simple\" components is fine "
#~ "(e.g., float, integer, boolean, string, "
#~ "bytes, and lists of these types. "
#~ "Note that MetricRecord_ only supports "
#~ "float, integer, and lists of these "
#~ "types) Flower has a specific type "
#~ "of record, a ParametersRecord_, for "
#~ "storing model parameters or more "
#~ "generally data arrays."
#~ msgstr ""

#~ msgid ""
#~ "The examples below omit the definition"
#~ " of a ``ClientApp`` to keep the "
#~ "code blocks concise. To make use "
#~ "of ``ParametersRecord`` objects in your "
#~ "``ClientApp`` you can follow the same"
#~ " principles as outlined earlier."
#~ msgstr ""

#~ msgid ""
#~ "Elements stored in a `ParametersRecord` "
#~ "are of type Array_, which is a "
#~ "data structure that holds ``bytes`` and"
#~ " metadata that can be used for "
#~ "deserialization. Let's see how to create"
#~ " an ``Array`` from a NumPy array "
#~ "and insert it into a "
#~ "``ParametersRecord``. Here we will make "
#~ "use of the built-in serialization "
#~ "and deserialization mechanisms in Flower, "
#~ "namely the ``flwr.common.array_from_numpy`` function"
#~ " and the `numpy()` method of an "
#~ "Array_ object."
#~ msgstr ""

#~ msgid ""
#~ "Array_ objects carry bytes as their "
#~ "main payload and additional metadata to"
#~ " use for deserialization. You can "
#~ "implement your own serialization/deserialization "
#~ "if the provided ``array_from_numpy`` doesn't"
#~ " fit your usecase."
#~ msgstr ""

#~ msgid ""
#~ "To extract the data in a "
#~ "``ParametersRecord``, you just need to "
#~ "deserialize the array if interest. For"
#~ " example, following the example above:"
#~ msgstr ""

#~ msgid ""
#~ "Following the NumPy example above, to"
#~ " save parameters of a PyTorch model"
#~ " a straightforward way of doing so"
#~ " is to transform the parameters into"
#~ " their NumPy representation and then "
#~ "proceed as shown earlier. Below is "
#~ "a simple self-contained example for "
#~ "how to do this."
#~ msgstr ""

#~ msgid "Deserialize each element in your specific ``ParametersRecord``"
#~ msgstr ""

#~ msgid ""
#~ "And that's it! Recall that even "
#~ "though this example shows how to "
#~ "store the entire ``state_dict`` in a "
#~ "``ParametersRecord``, you can just save "
#~ "part of it. The process would be"
#~ " identical, but you might need to "
#~ "adjust how it is loaded into an"
#~ " existing model using PyTorch APIs."
#~ msgstr ""

#~ msgid ""
#~ "Follow the same steps as done "
#~ "above but replace the ``state_dict`` "
#~ "logic with simply `get_weights() "
#~ "<https://www.tensorflow.org/api_docs/python/tf/keras/Layer#get_weights>`_"
#~ " to convert the model parameters to"
#~ " a list of NumPy arrays that "
#~ "can then be serialized into an "
#~ "``Array``. Then, after deserialization, use"
#~ " `set_weights() "
#~ "<https://www.tensorflow.org/api_docs/python/tf/keras/Layer#set_weights>`_"
#~ " to apply the new parameters to "
#~ "a model."
#~ msgstr ""

#~ msgid ""
#~ "Thousands of Flower Apps have been "
#~ "created using the Strategies and "
#~ "|numpyclient_link|_ abstractions. With the "
#~ "introduction of the Message API, these"
#~ " apps can now take advantage of "
#~ "a more powerful and flexible "
#~ "communication layer with the |message_link|_"
#~ " abstraction being its cornerstone. "
#~ "Messages replace the previous `FitIns` "
#~ "and `FitRes` data structures (and their"
#~ " equivalent for the other operations) "
#~ "into a single, unified and more "
#~ "versatile data structure."
#~ msgstr ""

#~ msgid ""
#~ "Update your |serverapp_link|_ to make "
#~ "use of the new `Message`-based "
#~ "strategies. You won't need to use "
#~ "the `server_fn` anymore. The new "
#~ "strategies make it easier to customize"
#~ " how the different federated learning "
#~ "rounds are executed, to retrieve results"
#~ " from your run, and more."
#~ msgstr ""

#~ msgid ""
#~ "Update your |clientapp_link|_ so it "
#~ "operates directly on `Message` objects "
#~ "received from the |serverapp_link|_. You "
#~ "will be able to keep most of "
#~ "the code from your |numpyclient_link|_ "
#~ "implementation but you won't need to "
#~ "create a new class anymore or use"
#~ " the helper `client_fn` function."
#~ msgstr ""

#~ msgid ""
#~ "Starting with Flower 1.21, the "
#~ "`ServerApp` no longer requires a "
#~ "`server_fn` function to make use of "
#~ "strategies. This is because a new "
#~ "collection of strategies (all sharing "
#~ "the common |strategy_link|_ base class) "
#~ "has been created to operate directly "
#~ "on `Message` objects, allowing for a "
#~ "more streamlined and flexible approach "
#~ "to federated learning rounds."
#~ msgstr ""

#~ msgid ""
#~ "The new `Message`-based strategies are "
#~ "located in the `flwr.serverapp.strate <ref-"
#~ "api/flwr.serverapp.Strategy.html>`_ module unlike "
#~ "the previous strategies which were "
#~ "located in the `flwr.server.strategy <ref-"
#~ "api/flwr.server.strategy.html>`_ module. Over time"
#~ " more strategies will be added to "
#~ "the `flwr.serverapp.strategy` module. Users "
#~ "are encouraged to use these new "
#~ "strategies."
#~ msgstr ""

#~ msgid ""
#~ "Since Flower 1.10, the recommended "
#~ "`ServerApp` implementation would look "
#~ "something like the code snippet below."
#~ " Naturally, more customization can be "
#~ "applied to the Strategy by, for "
#~ "example, reading the config from the "
#~ "`Context`. But to keep things focused,"
#~ " we will use a simple example "
#~ "and assume we are federating a "
#~ "PyTorch model."
#~ msgstr ""

#~ msgid ""
#~ "With Flower 1.21 and later, the "
#~ "equivalent `ServerApp` using the new "
#~ "Message API would look as shown "
#~ "below after following these steps:"
#~ msgstr ""

#~ msgid ""
#~ "Define the ``main`` method under the "
#~ "``@app.main()`` decorator. If your `server_fn`"
#~ " was reading config values from the"
#~ " ``Context`` you can still do so "
#~ "(consider copying those lines directly "
#~ "from your `server_fn` function)"
#~ msgstr ""

#~ msgid ""
#~ "Replace your existing strategy with one"
#~ " from the `flwr.serverapp.strategy` module. "
#~ "For example with |fedavg_link|_. Pass "
#~ "the arguments related to node sampling"
#~ " to the constructor of your strategy."
#~ msgstr ""

#~ msgid ""
#~ "Call the ``start`` method of the "
#~ "new strategy passing to it the "
#~ "`ArrayRecord` representing the initial state"
#~ " of your global model, the number "
#~ "of FL rounds and, the `Grid` "
#~ "object (which is used internally to "
#~ "communicate with the nodes executing the"
#~ " ``ClientApp``)."
#~ msgstr ""

#~ msgid ""
#~ "Note how we no longer need the "
#~ "`server_fn` function. The `Context` is "
#~ "still accessible, allowing you to "
#~ "customize how the `ServerApp` behaves at"
#~ " runtime. With the new strategies, a"
#~ " new ``start`` method is available. "
#~ "It defines a for loop which sets"
#~ " the steps involved in a round "
#~ "of FL. By default it behaves as"
#~ " the original strategies do, i.e. a"
#~ " round of FL training followed by "
#~ "one of FL evaluation and a stage"
#~ " to evaluate the global model. Note"
#~ " how the `start` method returns "
#~ "results. These are of type `Result` "
#~ "and by default contain the final "
#~ "global model (via ``result.arrays``) as "
#~ "well as aggregated |metricrecord_link|_ from"
#~ " federated stages and, optionally, metrics"
#~ " from evaluation stages done at the"
#~ " `ServerApp`."
#~ msgstr ""

#~ msgid ""
#~ "Similar to the `ServerApp`, the "
#~ "`ClientApp` no longer requires a helper"
#~ " function (i.e. ``client_fn`` ) that "
#~ "instantiates a |numpyclient_link|_ or base "
#~ "|client_link|_ object. Instead, with the "
#~ "Message API, you get to define "
#~ "directly how the ClientApp operates on"
#~ " `Message` objects received from the "
#~ "`ServerApp`."
#~ msgstr ""

#~ msgid ""
#~ "Remember `NumPyClient` came with two key"
#~ " built-in methods, ``fit`` and "
#~ "``evaluate``, that were respectively designed"
#~ " for doing federated training and "
#~ "evaluation using the client's local "
#~ "data. With the new Message API, "
#~ "you can define similar methods directly"
#~ " on the `ClientApp` via decorators to"
#~ " handle incoming `Message` objects."
#~ msgstr ""

#~ msgid ""
#~ "Let's see a basic example showing "
#~ "first a minimal `NumPyClient`-based "
#~ "`ClientApp` and then the upgraded design"
#~ " using the Message API."
#~ msgstr ""

#~ msgid ""
#~ "Upgrading a ClientApp designed around "
#~ "the `NumPyClient` and `client_fn` abstractions"
#~ " to the Message API would result "
#~ "in the following code. Note that "
#~ "the behavior of the `ClientApp` is "
#~ "defined directly in its methods (i.e."
#~ " a secondary class based on "
#~ "`NumPyClient` is no longer needed)."
#~ msgstr ""

#~ msgid ""
#~ "The |clientapp_link|_ abstraction comes with"
#~ " built-in ``@app.train`` and "
#~ "``@app.evaluate`` decorators. The arguments "
#~ "the associated methods receive have been"
#~ " unified and they both operate on "
#~ "`Message` objects. Each method is "
#~ "responsible for handling the incoming "
#~ "`Message` objects and returning the "
#~ "appropriate response (also as a "
#~ "`Message`). Note that you'll still be"
#~ " able to use the functions you "
#~ "might have written to, for example, "
#~ "train your model using the ML "
#~ "framework of your choice. In this "
#~ "example those are represented by "
#~ "``train_fn`` and ``test_fn``. Follow these "
#~ "steps to migrate your existing "
#~ "``ClientApp``:"
#~ msgstr ""

#~ msgid ""
#~ "Introduce the `@app.train` and `@app.evaluate`"
#~ " decorators and respective methods."
#~ msgstr ""

#~ msgid ""
#~ "Copy the lines of code you had "
#~ "in your `client_fn` reading config "
#~ "values from the `Context` into your "
#~ "`train` and `evaluate` methods implementations"
#~ " (created in step 1)."
#~ msgstr ""

#~ msgid ""
#~ "From the `Message` object, extract the"
#~ " relevant items (e.g. an ``ArrayRecord``"
#~ " defining the global model, a "
#~ "``ConfigRecord`` containing configs for the"
#~ " current round) to use in your "
#~ "training and evaluation logic."
#~ msgstr ""

#~ msgid ""
#~ "The payload that `Message` objects carry"
#~ " is of type |recorddict_link|_ which "
#~ "can contain records of type "
#~ "``ArrayRecord``, ``MetricRecord`` and "
#~ "``ConfigRecord``."
#~ msgstr ""

#~ msgid "This concludes the migration guide!"
#~ msgstr ""

#~ msgid ":py:obj:`flwr.app.error <flwr.app.error>`\\"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid "Error."
#~ msgstr "오류"

#~ msgid ":py:obj:`flwr.app.metadata <flwr.app.metadata>`\\"
#~ msgstr ":py:obj:`metadata <flwr.common.Message.metadata>`\\"

#~ msgid "Metadata."
#~ msgstr "Metadata"

#~ msgid "error"
#~ msgstr "오류"

#~ msgid "metadata"
#~ msgstr "Metadata"

#~ msgid ""
#~ ":py:obj:`validate_legacy_message_type "
#~ "<flwr.app.metadata.validate_legacy_message_type>`\\ "
#~ "\\(message\\_type\\)"
#~ msgstr ":py:obj:`message_type <flwr.common.Metadata.message_type>`\\"

#~ msgid "Validate if the legacy message type is valid."
#~ msgstr "레거시 메시지 타입."

#~ msgid ""
#~ ":py:obj:`validate_message_type "
#~ "<flwr.app.metadata.validate_message_type>`\\ "
#~ "\\(message\\_type\\)"
#~ msgstr ":py:obj:`message_type <flwr.common.Metadata.message_type>`\\"

#~ msgid "Validate if the message type is valid."
#~ msgstr ""

#~ msgid "validate\\_legacy\\_message\\_type"
#~ msgstr "레거시 메시지 타입."

#~ msgid "validate\\_message\\_type"
#~ msgstr "MessageType"

#~ msgid "A valid message type format must be one of the following:"
#~ msgstr ""

#~ msgid "\"<category>\""
#~ msgstr "속성"

#~ msgid "\"<category>.<action>\""
#~ msgstr ""

#~ msgid ""
#~ "where `category` must be one of "
#~ "\"train\", \"evaluate\", or \"query\", and "
#~ "`action` must be a valid Python "
#~ "identifier."
#~ msgstr ""

#~ msgid ""
#~ "Optional function for centralized evaluation"
#~ " of the global model. Takes server"
#~ " round number and array record, "
#~ "returns a MetricRecord. If provided, "
#~ "will be called before the first "
#~ "round and after each round. Defaults "
#~ "to None."
#~ msgstr ""

#~ msgid ""
#~ "The isolation mode determines how the"
#~ " SuperLink manages the ServerApp process"
#~ " execution. This setting can be "
#~ "adjusted using the `superlink.isolationMode` "
#~ "parameter:"
#~ msgstr ""

#~ msgid ""
#~ "By default, the Flower Framework is "
#~ "deployed without TLS. This means "
#~ "`global.insecure` is set to `true`."
#~ msgstr ""

#~ msgid ""
#~ "In this mode, the chart does not"
#~ " create any `cert-manager` `Issuer` "
#~ "or `Certificate` resources, and any "
#~ "TLS-related configuration on the `Ingress`"
#~ " resource is ignored."
#~ msgstr ""

#~ msgid ""
#~ "Regardless of the option you choose, "
#~ "TLS is only enabled when you set"
#~ " `global.insecure: false`."
#~ msgstr ""

#~ msgid ""
#~ "If you prefer to let `cert-"
#~ "manager` generate a `Certificate` through "
#~ "`Ingress` annotations, you can disable "
#~ "the chart’s built-in certificate "
#~ "management. To do this, set "
#~ "`tls.certificate.enabled` to `false` and leave"
#~ " `tls.existingSecret` empty. Also ensure "
#~ "`global.insecure` is set to `false`."
#~ msgstr ""

#~ msgid ""
#~ "In some deployments, the server and "
#~ "client charts may run inside the "
#~ "same Kubernetes cluster, while the Exec"
#~ " API is exposed publicly over the "
#~ "internet. In this scenario, the "
#~ "SuperNodes need to connect to the "
#~ "SuperLink using its internal service URL"
#~ " (e.g., `<superlink>.<namespace>.svc.cluster.local`)."
#~ msgstr ""

#~ msgid "`global.insecure`"
#~ msgstr ""

#~ msgid "Decide if you deploy the Flower Framework with TLS"
#~ msgstr "Flower 프레임워크"

#~ msgid "`superlink.executor.plugin`"
#~ msgstr ""

#~ msgid "The executer plugin of the SuperLink"
#~ msgstr "flower 초연결"

#~ msgid "`flwr.superexec.deployment:executor`"
#~ msgstr ""

#~ msgid "`superlink.executor.config`"
#~ msgstr ""

#~ msgid "Set executor config arguments"
#~ msgstr ""

#~ msgid "`superlink.service.servicePortApiName`"
#~ msgstr ""

#~ msgid "`api`"
#~ msgstr ""

#~ msgid "`superlink.service.servicePortApi`"
#~ msgstr ""

#~ msgid "`superlink.service.nodePortApi`"
#~ msgstr ""

#~ msgid "`superlink.service.servicePortDriverName`"
#~ msgstr ""

#~ msgid "Prefix of the SuperLink Driver API port"
#~ msgstr ""

#~ msgid "`driver`"
#~ msgstr ""

#~ msgid "`superlink.service.servicePortDriver`"
#~ msgstr ""

#~ msgid "Port to expose for the SuperLink Driver API"
#~ msgstr ""

#~ msgid "`superlink.service.nodePortDriver`"
#~ msgstr ""

#~ msgid "Node port for SuperLink Driver API"
#~ msgstr ""

#~ msgid "`superlink.containerPorts.api`"
#~ msgstr ""

#~ msgid "`superlink.containerPorts.driver`"
#~ msgstr ""

#~ msgid "Container port for SuperLink Driver API"
#~ msgstr ""

#~ msgid "`superlink.ingress.api.enabled`"
#~ msgstr ""

#~ msgid "`superlink.ingress.api.hostname`"
#~ msgstr ""

#~ msgid "`exec-api.example.com`"
#~ msgstr ""

#~ msgid "`superlink.ingress.api.path`"
#~ msgstr ""

#~ msgid "`superlink.ingress.api.pathType`"
#~ msgstr ""

#~ msgid "`superlink.ingress.driver.enabled`"
#~ msgstr ""

#~ msgid "Enable an ingress resource for SuperLink Driver API"
#~ msgstr ""

#~ msgid "`superlink.ingress.driver.hostname`"
#~ msgstr ""

#~ msgid "Ingress hostname for the SuperLink Driver API ingress"
#~ msgstr ""

#~ msgid "`driver.example.com`"
#~ msgstr ""

#~ msgid "`superlink.ingress.driver.path`"
#~ msgstr ""

#~ msgid "SuperLink Driver API ingress path"
#~ msgstr ""

#~ msgid "`superlink.ingress.driver.pathType`"
#~ msgstr ""

#~ msgid "`superlink.networkPolicy.driver.ingressPodMatchLabels`"
#~ msgstr ""

#~ msgid "`superlink.networkPolicy.driver.ingressNSMatchLabels`"
#~ msgstr ""

#~ msgid "`superlink.networkPolicy.driver.ingressNSPodMatchLabels`"
#~ msgstr ""

#~ msgid "`superlink.networkPolicy.api.ingressPodMatchLabels`"
#~ msgstr ""

#~ msgid "`superlink.networkPolicy.api.ingressNSMatchLabels`"
#~ msgstr ""

#~ msgid "`superlink.networkPolicy.api.ingressNSPodMatchLabels`"
#~ msgstr ""

#~ msgid "Component ServerApp"
#~ msgstr "Flower 서버앱"

#~ msgid "`serverapp.name`"
#~ msgstr "flower 서버 프로그램"

#~ msgid "Name of the ServerApp"
#~ msgstr "Flower 서버앱"

#~ msgid "`serverapp.enabled`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid "Enable or disable ServerApp"
#~ msgstr "현재 클라이언트 속성입니다."

#~ msgid "`serverapp.resources`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid "Address of the SuperLink the ServerApp should connect to"
#~ msgstr ""

#~ msgid "`serverapp.volumes`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid "Optionally specify list of volumes for the ServerApp pod(s)"
#~ msgstr ""

#~ msgid "`serverapp.volumeMounts`"
#~ msgstr ""

#~ msgid "`serverapp.automountServiceAccountToken`"
#~ msgstr ""

#~ msgid "`serverapp.serviceAccount.enabled`"
#~ msgstr ""

#~ msgid "`serverapp.serviceAccount.annotations`"
#~ msgstr ""

#~ msgid "`serverapp.serviceAccount.labels`"
#~ msgstr ""

#~ msgid "`serverapp.serviceAccount.automountServiceAccountToken`"
#~ msgstr ""

#~ msgid "`serverapp.podSecurityContext`"
#~ msgstr ""

#~ msgid "`serverapp.replicas`"
#~ msgstr "Flower 서버앱"

#~ msgid "The number of ServerApp pods to run"
#~ msgstr ""

#~ msgid "`serverapp.labels`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid "Extra labels for ServerApp pods"
#~ msgstr ""

#~ msgid "`serverapp.extraArgs`"
#~ msgstr ""

#~ msgid "Add extra arguments to the default arguments for the ServerApp"
#~ msgstr ""

#~ msgid "`serverapp.nodeSelector`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid "Node labels for ServerApp pods which merges with global.nodeSelector"
#~ msgstr ""

#~ msgid "`serverapp.tolerations`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid ""
#~ "Node tolerations for ServerApp pods "
#~ "which merges with global.tolerations"
#~ msgstr ""

#~ msgid "`serverapp.updateStrategy.type`"
#~ msgstr ""

#~ msgid "ServerApp deployment strategy type"
#~ msgstr ""

#~ msgid "`serverapp.updateStrategy.rollingUpdate`"
#~ msgstr ""

#~ msgid "ServerApp deployment rolling update configuration parameters"
#~ msgstr ""

#~ msgid "`serverapp.affinity`"
#~ msgstr "Flower 서버앱"

#~ msgid "Node affinity for ServerApp pods which merges with global.affinity"
#~ msgstr ""

#~ msgid "`serverapp.env`"
#~ msgstr "flower 서버 프로그램"

#~ msgid ""
#~ "Array with extra environment variables "
#~ "to add to ServerApp nodes which "
#~ "merges with global.env"
#~ msgstr ""

#~ msgid "`serverapp.lifecycle`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid ""
#~ "ServerApp container(s) to automate "
#~ "configuration before or after startup"
#~ msgstr ""

#~ msgid "`serverapp.annotations`"
#~ msgstr ""

#~ msgid "Additional custom annotations for ServerApp"
#~ msgstr ""

#~ msgid "`serverapp.selectorLabels`"
#~ msgstr ""

#~ msgid "Extra selectorLabels for ServerApp pods"
#~ msgstr ""

#~ msgid "`serverapp.podAnnotations`"
#~ msgstr ""

#~ msgid "Annotations for ServerApp pods"
#~ msgstr ""

#~ msgid "`serverapp.podLabels`"
#~ msgstr "SuperNode Dockerfile 만들기"

#~ msgid "Extra podLabels for ServerApp pods"
#~ msgstr ""

#~ msgid "`serverapp.imagePullSecrets`"
#~ msgstr ""

#~ msgid "ServerApp image pull secrets which overrides global.imagePullSecrets"
#~ msgstr ""

#~ msgid "`serverapp.image.registry`"
#~ msgstr ""

#~ msgid "`serverapp.image.repository`"
#~ msgstr ""

#~ msgid "ServerApp image repository"
#~ msgstr "레포지토리 설정하기"

#~ msgid "`flwr/serverapp`"
#~ msgstr "flower 서버 프로그램"

#~ msgid "`serverapp.image.tag`"
#~ msgstr "Flower 서버앱"

#~ msgid "Image tag of ServerApp"
#~ msgstr "Flower 서버앱"

#~ msgid "`1.20.0-py3.11-ubuntu24.04`"
#~ msgstr ""

#~ msgid "Image digest of ServerApp"
#~ msgstr "Flower 서버앱"

#~ msgid "`serverapp.image.pullPolicy`"
#~ msgstr ""

#~ msgid "`serverapp.networkPolicy.enabled`"
#~ msgstr ""

#~ msgid "`serverapp.networkPolicy.allowExternalEgress`"
#~ msgstr ""

#~ msgid "`serverapp.networkPolicy.extraEgress`"
#~ msgstr ""

#~ msgid ""
#~ "To provide the CA certificate, set "
#~ "`global.insecure` to `false` and create "
#~ "a `Secret` of type `kubernetes.io/tls` "
#~ "named `flower-client-tls`:"
#~ msgstr ""

#~ msgid ""
#~ "To install SuperNode in isolation mode"
#~ " using the \"process\" configuration, both"
#~ " the ClientApp and SuperNode need to"
#~ " be enabled. By default, the "
#~ "ClientApp connects to the SuperNode "
#~ "internally within the cluster, so there"
#~ " is no need to set "
#~ "`supernode.address` and `supernode.port` unless "
#~ "the connection is external. This setup"
#~ " assumes that both components are "
#~ "running within the same cluster."
#~ msgstr ""

#~ msgid ""
#~ "You can also deploy the SuperNode "
#~ "and ClientApp separately. To do this,"
#~ " you need to deploy the chart "
#~ "twice: once with `supernode.enabled=true` and"
#~ " once with `clientapp.enabled=true`. To "
#~ "allow the ClientApp to connect to "
#~ "the SuperNode in this configuration, "
#~ "enable the SuperNode ingress by setting"
#~ " `supernode.ingress.enabled=true`. This setup is"
#~ " intended for scenarios where the "
#~ "components run on different clusters or"
#~ " a hybrid environment involving Kubernetes"
#~ " and ClientApp native installations."
#~ msgstr ""

#~ msgid "`supernode.service.servicePortClientAppIOName`"
#~ msgstr ""

#~ msgid "Prefix of the SuperNode ClientAppIO API port"
#~ msgstr ""

#~ msgid "`supernode.service.servicePortClientAppIO`"
#~ msgstr ""

#~ msgid "Port to expose for the SuperNode ClientAppIO API"
#~ msgstr ""

#~ msgid "`supernode.service.nodePortClientAppIO`"
#~ msgstr ""

#~ msgid "Node port for SuperNode ClientAppIO API"
#~ msgstr ""

#~ msgid "`39094`"
#~ msgstr ""

#~ msgid "`supernode.containerPorts.clientappio`"
#~ msgstr ""

#~ msgid "Container port for SuperNode ClientAppIO API"
#~ msgstr ""

#~ msgid "Component ClientApp"
#~ msgstr "클라이언트앱"

#~ msgid "`clientapp.name`"
#~ msgstr "클라이언트앱"

#~ msgid "Name of the ClientApp"
#~ msgstr "클라이언트앱"

#~ msgid "`clientapp.enabled`"
#~ msgstr "클라이언트앱"

#~ msgid "`clientapp.node.config`"
#~ msgstr "클라이언트앱"

#~ msgid "`clientapp.resources`"
#~ msgstr "클라이언트 리소스 할당"

#~ msgid "`clientapp.supernode`"
#~ msgstr "클라이언트앱"

#~ msgid "Address of the supernode the ClientApp should connect to"
#~ msgstr ""

#~ msgid "`clientapp.volumes`"
#~ msgstr "클라이언트앱"

#~ msgid "Specify a list of volumes for the ClientApp pod(s)"
#~ msgstr ""

#~ msgid "`clientapp.volumeMounts`"
#~ msgstr ""

#~ msgid "`clientapp.automountServiceAccountToken`"
#~ msgstr ""

#~ msgid "`clientapp.serviceAccount.enabled`"
#~ msgstr ""

#~ msgid "`clientapp.serviceAccount.annotations`"
#~ msgstr ""

#~ msgid "`clientapp.serviceAccount.labels`"
#~ msgstr ""

#~ msgid "`clientapp.serviceAccount.automountServiceAccountToken`"
#~ msgstr ""

#~ msgid "`clientapp.service.type`"
#~ msgstr "클라이언트앱"

#~ msgid "`clientapp.service.servicePortClientAppIOName`"
#~ msgstr ""

#~ msgid "Prefix of the ClientApp ClientAppIO API port"
#~ msgstr ""

#~ msgid "`clientapp.service.servicePortClientAppIO`"
#~ msgstr ""

#~ msgid "Ports to expose for the ClientApp ClientAppIO API"
#~ msgstr ""

#~ msgid "`clientapp.service.nodePortClientAppIO`"
#~ msgstr ""

#~ msgid "Node port for ClientApp ClientAppIO API"
#~ msgstr ""

#~ msgid "`clientapp.containerPorts.clientappio`"
#~ msgstr ""

#~ msgid "Container port for ClientApp ClientAppIO API"
#~ msgstr ""

#~ msgid "`clientapp.podSecurityContext`"
#~ msgstr ""

#~ msgid "`clientapp.replicas`"
#~ msgstr "클라이언트앱"

#~ msgid "The number of ClientApp pods to run"
#~ msgstr ""

#~ msgid "`clientapp.labels`"
#~ msgstr "클라이언트앱"

#~ msgid "Extra labels for ClientApp pods"
#~ msgstr ""

#~ msgid "`clientapp.extraArgs`"
#~ msgstr "클라이언트앱"

#~ msgid "Add extra arguments to the default arguments for the ClientApp"
#~ msgstr ""

#~ msgid "`clientapp.nodeSelector`"
#~ msgstr "클라이언트앱"

#~ msgid "Node labels for ClientApp pods which merges with global.nodeSelector"
#~ msgstr ""

#~ msgid "`clientapp.tolerations`"
#~ msgstr "클라이언트앱"

#~ msgid ""
#~ "Node tolerations for ClientApp pods "
#~ "which merges with global.tolerations"
#~ msgstr ""

#~ msgid "`clientapp.updateStrategy.type`"
#~ msgstr ""

#~ msgid "ClientApp deployment strategy type"
#~ msgstr ""

#~ msgid "`clientapp.updateStrategy.rollingUpdate`"
#~ msgstr ""

#~ msgid "ClientApp deployment rolling update configuration parameters"
#~ msgstr ""

#~ msgid "`clientapp.affinity`"
#~ msgstr "클라이언트앱"

#~ msgid "Node affinity for ClientApp pods which merges with global.affinity"
#~ msgstr ""

#~ msgid "`clientapp.env`"
#~ msgstr "클라이언트앱"

#~ msgid ""
#~ "Array with extra environment variables "
#~ "to add to ClientApp nodes which "
#~ "merges with global.env"
#~ msgstr ""

#~ msgid "`clientapp.lifecycle`"
#~ msgstr "클라이언트앱"

#~ msgid ""
#~ "ClientApp container(s) to automate "
#~ "configuration before or after startup"
#~ msgstr ""

#~ msgid "`clientapp.annotations`"
#~ msgstr ""

#~ msgid "Additional custom annotations for ClientApp"
#~ msgstr ""

#~ msgid "`clientapp.selectorLabels`"
#~ msgstr ""

#~ msgid "Extra selectorLabels for ClientApp pods"
#~ msgstr ""

#~ msgid "`clientapp.podAnnotations`"
#~ msgstr ""

#~ msgid "Annotations for ClientApp pods"
#~ msgstr ""

#~ msgid "`clientapp.podLabels`"
#~ msgstr "클라이언트앱"

#~ msgid "Extra podLabels for ClientApp pods"
#~ msgstr ""

#~ msgid "`clientapp.imagePullSecrets`"
#~ msgstr ""

#~ msgid "ClientApp image pull secrets which overrides global.imagePullSecrets"
#~ msgstr ""

#~ msgid "`clientapp.image.registry`"
#~ msgstr ""

#~ msgid "ClientApp image registry"
#~ msgstr "클라이언트앱"

#~ msgid "`clientapp.image.repository`"
#~ msgstr ""

#~ msgid "ClientApp image repository"
#~ msgstr "레포지토리 설정하기"

#~ msgid "`flwr/clientapp`"
#~ msgstr "Flower ClientApp."

#~ msgid "`clientapp.image.tag`"
#~ msgstr "클라이언트앱"

#~ msgid "Image tag of ClientApp"
#~ msgstr "Flower 클라이언트 앱을 실행합니다."

#~ msgid "`clientapp.image.digest`"
#~ msgstr "클라이언트앱"

#~ msgid "Image digest of ClientApp"
#~ msgstr "Flower 클라이언트 앱을 실행합니다."

#~ msgid "`clientapp.image.pullPolicy`"
#~ msgstr ""

#~ msgid "`clientapp.networkPolicy.enabled`"
#~ msgstr ""

#~ msgid "`clientapp.networkPolicy.allowExternalEgress`"
#~ msgstr ""

#~ msgid "`clientapp.networkPolicy.extraEgress`"
#~ msgstr ""

#~ msgid ""
#~ "The new ``Message``-based strategies are "
#~ "located in the `flwr.serverapp.strate <ref-"
#~ "api/flwr.serverapp.Strategy.html>`_ module unlike "
#~ "the previous strategies which were "
#~ "located in the `flwr.server.strategy <ref-"
#~ "api/flwr.server.strategy.html>`_ module. Over time"
#~ " more strategies will be added to "
#~ "the `flwr.serverapp.strategy` module. Users "
#~ "are encouraged to use these new "
#~ "strategies."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`fixedclipping_mod <flwr.clientapp.fixedclipping_mod>`\\"
#~ " \\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`fixedclipping_mod "
#~ "<flwr.client.mod.fixedclipping_mod>`\\ \\(msg\\, ctxt\\,"
#~ " call\\_next\\)"

#~ msgid ""
#~ ":py:obj:`adaptiveclipping_mod "
#~ "<flwr.clientapp.mod.adaptiveclipping_mod>`\\ \\(msg\\, "
#~ "ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`adaptiveclipping_mod "
#~ "<flwr.client.mod.adaptiveclipping_mod>`\\ \\(msg\\, "
#~ "ctxt\\, call\\_next\\)"

#~ msgid ":py:obj:`make_ffn <flwr.clientapp.mod.make_ffn>`\\ \\(ffn\\, mods\\)"
#~ msgstr ":py:obj:`make_ffn <flwr.client.mod.make_ffn>`\\ \\(ffn\\, mods\\)"

#~ msgid ""
#~ ":py:obj:`secagg_mod <flwr.clientapp.mod.secagg_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`secagg_mod <flwr.client.mod.secagg_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"

#~ msgid ""
#~ ":py:obj:`secaggplus_mod <flwr.clientapp.mod.secaggplus_mod>`\\"
#~ " \\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`secaggplus_mod <flwr.client.mod.secaggplus_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"

#~ msgid ""
#~ ":py:obj:`LocalDpMod <flwr.clientapp.mod.LocalDpMod>`\\ "
#~ "\\(clipping\\_norm\\, sensitivity\\, ...\\)"
#~ msgstr ""
#~ ":py:obj:`LocalDpMod <flwr.client.mod.LocalDpMod>`\\ "
#~ "\\(clipping\\_norm\\, sensitivity\\, ...\\)"

#~ msgid "mod.LocalDpMod"
#~ msgstr "LocalDpMod"

#~ msgid ""
#~ "PyTorch | PyTorch (Message API) | "
#~ "TensorFlow | sklearn | HuggingFace | "
#~ "JAX | MLX | NumPy | FlowerTune "
#~ "| Flower Baseline"
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial, we'll continue to "
#~ "customize the federated learning system "
#~ "we built previously by creating a "
#~ "custom version of FedAvg using the "
#~ "Flower framework, Flower Datasets, and "
#~ "PyTorch."
#~ msgstr ""

#~ msgid ""
#~ "Let's overwrite the ``configure_fit`` method"
#~ " such that it passes a higher "
#~ "learning rate (potentially also other "
#~ "hyperparameters) to the optimizer of a"
#~ " fraction of the clients. We will "
#~ "keep the sampling of the clients "
#~ "as it is in ``FedAvg`` and then"
#~ " change the configuration dictionary (one"
#~ " of the ``FitIns`` attributes). Create "
#~ "a new module called ``strategy.py`` in"
#~ " the ``flower_tutorial`` directory. Next, "
#~ "we define a new class ``FedCustom`` "
#~ "that inherits from ``Strategy``. Copy "
#~ "and paste the following code into "
#~ "``strategy.py``:"
#~ msgstr ""

#~ msgid ""
#~ "The only thing left is to use "
#~ "the newly created custom Strategy "
#~ "``FedCustom`` when starting the experiment."
#~ " In the ``server_app.py`` file, import "
#~ "the custom strategy and use it in"
#~ " ``server_fn``:"
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial, we've seen how "
#~ "to implement a custom strategy. A "
#~ "custom strategy enables granular control "
#~ "over client node configuration, result "
#~ "aggregation, and more. To define a "
#~ "custom strategy, you only have to "
#~ "overwrite the abstract methods of the"
#~ " (abstract) base class ``Strategy``. To "
#~ "make custom strategies even more "
#~ "powerful, you can pass custom functions"
#~ " to the constructor of your new "
#~ "class (``__init__``) and then call these"
#~ " functions whenever needed."
#~ msgstr ""

#~ msgid ""
#~ "The :doc:`Flower Federated Learning Tutorial"
#~ " - Part 4 <tutorial-series-"
#~ "customize-the-client-pytorch>` introduces "
#~ "``Client``, the flexible API underlying "
#~ "``NumPyClient``."
#~ msgstr ""

#~ msgid ""
#~ "In this final tutorial, we revisit "
#~ "``NumPyClient`` and introduce a new "
#~ "baseclass for building clients, simply "
#~ "named ``Client``. In previous parts of"
#~ " this tutorial, we've based our "
#~ "client on ``NumPyClient``, a convenience "
#~ "class which makes it easy to work"
#~ " with machine learning libraries that "
#~ "have good NumPy interoperability. With "
#~ "``Client``, we gain a lot of "
#~ "flexibility that we didn't have before,"
#~ " but we'll also have to do a"
#~ " few things that we didn't have "
#~ "to do before."
#~ msgstr ""

#~ msgid ""
#~ "So far, we've implemented our client "
#~ "by subclassing ``flwr.client.NumPyClient``. The "
#~ "two methods that were implemented in "
#~ "``client_app.py`` are ``fit`` and "
#~ "``evaluate``."
#~ msgstr ""

#~ msgid ""
#~ "Then, we have the function ``client_fn``"
#~ " that is used by Flower to "
#~ "create the ``FlowerClient`` instances on "
#~ "demand. Finally, we create the "
#~ "``ClientApp`` and pass the ``client_fn`` "
#~ "to it."
#~ msgstr ""

#~ msgid ""
#~ "We've seen this before, there's nothing"
#~ " new so far. Next, in "
#~ "``server_app.py``, the number of federated "
#~ "learning rounds are preconfigured in the"
#~ " ``ServerConfig`` and in the same "
#~ "module, the ``ServerApp`` is created "
#~ "with this config:"
#~ msgstr ""

#~ msgid "Finally, we run the simulation to see the output we get:"
#~ msgstr "Flower 시뮬레이션."

#~ msgid ""
#~ "Let's dive a little bit deeper and"
#~ " discuss how Flower executes this "
#~ "simulation. Whenever a client is "
#~ "selected to do some work, under "
#~ "the hood, Flower launches the "
#~ "``ClientApp`` object which in turn calls"
#~ " the function ``client_fn`` to create "
#~ "an instance of our ``FlowerClient`` "
#~ "(along with loading the model and "
#~ "the data)."
#~ msgstr ""

#~ msgid ""
#~ "But here's the perhaps surprising part:"
#~ " Flower doesn't actually use the "
#~ "``FlowerClient`` object directly. Instead, it"
#~ " wraps the object to makes it "
#~ "look like a subclass of "
#~ "``flwr.client.Client``, not ``flwr.client.NumPyClient``."
#~ " In fact, the Flower core framework"
#~ " doesn't know how to handle "
#~ "``NumPyClient``'s, it only knows how to"
#~ " handle ``Client``'s. ``NumPyClient`` is "
#~ "just a convenience abstraction built on"
#~ " top of ``Client``."
#~ msgstr ""

#~ msgid "Moving from ``NumPyClient`` to ``Client``"
#~ msgstr ""

#~ msgid ""
#~ "Let's try to do the same thing "
#~ "using ``Client`` instead of ``NumPyClient``."
#~ " Create a new file called "
#~ "``custom_client_app.py`` and copy the "
#~ "following code into it:"
#~ msgstr ""

#~ msgid ""
#~ "Next, we update the ``pyproject.toml`` "
#~ "so that Flower uses the new "
#~ "module:"
#~ msgstr ""

#~ msgid ""
#~ "Before we discuss the code in more"
#~ " detail, let's try to run it! "
#~ "Gotta make sure our new ``Client``-based"
#~ " client works, right? We run the "
#~ "simulation as follows:"
#~ msgstr ""

#~ msgid "Custom serialization"
#~ msgstr "사용자 정의 전략"

#~ msgid ""
#~ "But first what is serialization? "
#~ "Serialization is just the process of "
#~ "converting an object into raw bytes, "
#~ "and equally as important, deserialization "
#~ "is the process of converting raw "
#~ "bytes back into an object. This is"
#~ " very useful for network communication. "
#~ "Indeed, without serialization, you could "
#~ "not just send a Python object "
#~ "through the internet."
#~ msgstr ""

#~ msgid ""
#~ "This is where the real "
#~ "serialization/deserialization will happen, "
#~ "especially in ``ndarray_to_sparse_bytes`` for "
#~ "serialization and ``sparse_bytes_to_ndarray`` for"
#~ " deserialization. First we add the "
#~ "following code to ``task.py``:"
#~ msgstr ""

#~ msgid ""
#~ "In ``evaluate``, we will only need "
#~ "to deserialize the global parameters "
#~ "with our custom function. In a new"
#~ " file called ``serde_client_app.py``, copy "
#~ "the following code into it:"
#~ msgstr ""

#~ msgid "In a new file called ``strategy.py``, copy the following code into it:"
#~ msgstr ""

#~ msgid ""
#~ "We can now import our new "
#~ "``FedSparse`` strategy into ``server_app.py`` "
#~ "and update our ``server_fn`` to use "
#~ "it:"
#~ msgstr ""

#~ msgid ""
#~ "If you'd like to follow along with"
#~ " tutorial notebooks, check out the "
#~ ":doc:`Tutorial notebooks <notebooks/index>`. Note"
#~ " that the notebooks use the "
#~ "``run_simulation`` approach, whereas the "
#~ "recommended way to run simulations in"
#~ " Flower is using the ``flwr run`` "
#~ "approach as shown in this tutorial."
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial, we'll build a "
#~ "federated learning system using the "
#~ "Flower framework, Flower Datasets and "
#~ "PyTorch. In part 1, we use PyTorch"
#~ " for the model training pipeline and"
#~ " data loading. In part 2, we "
#~ "federate the PyTorch project using "
#~ "Flower."
#~ msgstr ""

#~ msgid ""
#~ "We simulate having multiple datasets "
#~ "from multiple organizations (also called "
#~ "the “cross-silo” setting in federated"
#~ " learning) by splitting the original "
#~ "CIFAR-10 dataset into multiple partitions. "
#~ "Each partition will represent the data"
#~ " from a single organization. We're "
#~ "doing this purely for experimentation "
#~ "purposes, in the real world there's "
#~ "no need for data splitting because "
#~ "each organization already has their own"
#~ " data (the data is naturally "
#~ "partitioned)."
#~ msgstr ""

#~ msgid "The model"
#~ msgstr "릴리즈 동안에"

#~ msgid ""
#~ "The PyTorch template has also provided"
#~ " us with the usual training and "
#~ "test functions:"
#~ msgstr ""

#~ msgid ""
#~ "We need two helper functions to "
#~ "get the updated model parameters from"
#~ " the local model and to update "
#~ "the local model with parameters received"
#~ " from the server: ``get_weights`` and "
#~ "``set_weights``. The following two functions"
#~ " do just that for the PyTorch "
#~ "model above and are predefined in "
#~ "``task.py``."
#~ msgstr ""

#~ msgid ""
#~ "The details of how this works are"
#~ " not really important here (feel free"
#~ " to consult the PyTorch documentation "
#~ "if you want to learn more). In "
#~ "essence, we use ``state_dict`` to access"
#~ " PyTorch model parameter tensors. The "
#~ "parameter tensors are then converted "
#~ "to/from a list of NumPy ``ndarray``\\s"
#~ " (which the Flower ``NumPyClient`` knows"
#~ " how to serialize/deserialize):"
#~ msgstr ""

#~ msgid ""
#~ "The first step toward creating a "
#~ "``ClientApp`` is to implement a "
#~ "subclasses of ``flwr.client.Client`` or "
#~ "``flwr.client.NumPyClient``. We use ``NumPyClient``"
#~ " in this tutorial because it is "
#~ "easier to implement and requires us "
#~ "to write less boilerplate. To implement"
#~ " ``NumPyClient``, we create a subclass "
#~ "that implements the three methods "
#~ "``get_weights``, ``fit``, and ``evaluate``:"
#~ msgstr ""

#~ msgid "``get_weights``: Return the current local model parameters"
#~ msgstr "현재 로컬 모델 파라미터를 반환합니다."

#~ msgid ""
#~ "We mentioned that our clients will "
#~ "use the previously defined PyTorch "
#~ "components for model training and "
#~ "evaluation. Let's see a simple Flower"
#~ " client implementation that brings "
#~ "everything together. Note that all of"
#~ " this boilerplate implementation has "
#~ "already been done for us in our"
#~ " Flower project:"
#~ msgstr ""

#~ msgid ""
#~ "In this project, we want to "
#~ "simulate a federated learning system "
#~ "with 10 clients *on a single "
#~ "machine*. This means that the server "
#~ "and all 10 clients will live on"
#~ " a single machine and share resources"
#~ " such as CPU, GPU, and memory. "
#~ "Having 10 clients would mean having "
#~ "10 instances of ``FlowerClient`` in "
#~ "memory. Doing this on a single "
#~ "machine can quickly exhaust the "
#~ "available memory resources, even if only"
#~ " a subset of these clients "
#~ "participates in a single round of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ "In addition to the regular capabilities"
#~ " where server and clients run on "
#~ "multiple machines, Flower, therefore, provides"
#~ " special simulation capabilities that "
#~ "create ``FlowerClient`` instances only when"
#~ " they are actually necessary for "
#~ "training or evaluation. To enable the"
#~ " Flower framework to create clients "
#~ "when necessary, we need to implement "
#~ "a function that creates a "
#~ "``FlowerClient`` instance on demand. We "
#~ "typically call this function ``client_fn``."
#~ " Flower calls ``client_fn`` whenever it "
#~ "needs an instance of one particular "
#~ "client to call ``fit`` or ``evaluate``"
#~ " (those instances are usually discarded "
#~ "after use, so they should not keep"
#~ " any local state). In federated "
#~ "learning experiments using Flower, clients "
#~ "are identified by a partition ID, "
#~ "or ``partition_id``. This ``partition_id`` is"
#~ " used to load different local data"
#~ " partitions for different clients, as "
#~ "can be seen below. The value of"
#~ " ``partition_id`` is retrieved from the "
#~ "``node_config`` dictionary in the ``Context``"
#~ " object, which holds the information "
#~ "that persists throughout each training "
#~ "round."
#~ msgstr ""

#~ msgid ""
#~ "With this, we have the class "
#~ "``FlowerClient`` which defines client-side "
#~ "training/evaluation and ``client_fn`` which "
#~ "allows Flower to create ``FlowerClient`` "
#~ "instances whenever it needs to call "
#~ "``fit`` or ``evaluate`` on one "
#~ "particular client. Last, but definitely "
#~ "not least, we create an instance "
#~ "of ``ClientApp`` and pass it the "
#~ "``client_fn``. ``ClientApp`` is the entrypoint"
#~ " that a running Flower client uses"
#~ " to call your code (as defined "
#~ "in, for example, ``FlowerClient.fit``). The"
#~ " following code is reproduced from "
#~ "``client_app.py`` with additional comments:"
#~ msgstr ""

#~ msgid ""
#~ "Similar to ``ClientApp``, we create a"
#~ " ``ServerApp`` using a utility function "
#~ "``server_fn``. This function is predefined "
#~ "for us in ``server_app.py``. In "
#~ "``server_fn``, we pass an instance of"
#~ " ``ServerConfig`` for defining the number"
#~ " of federated learning rounds "
#~ "(``num_rounds``) and we also pass the"
#~ " previously created ``strategy``. The "
#~ "``server_fn`` returns a ``ServerAppComponents`` "
#~ "object containing the settings that "
#~ "define the ``ServerApp`` behaviour. "
#~ "``ServerApp`` is the entrypoint that "
#~ "Flower uses to call all your "
#~ "server-side code (for example, the "
#~ "strategy)."
#~ msgstr ""

#~ msgid ""
#~ "This will execute the federated learning"
#~ " simulation with 10 clients, or "
#~ "SuperNodes, defined in the "
#~ "``[tool.flwr.federations.local-simulation]`` section "
#~ "in the ``pyproject.toml``. You can also"
#~ " override the parameters defined in "
#~ "the ``[tool.flwr.app.config]`` section in "
#~ "``pyproject.toml`` like this:"
#~ msgstr ""

#~ msgid ""
#~ "When we execute ``flwr run``, we "
#~ "tell Flower that there are 10 "
#~ "clients (``options.num-supernodes = 10``, "
#~ "where 1 ``SuperNode`` launches 1 "
#~ "``ClientApp``)."
#~ msgstr ""

#~ msgid ""
#~ "Flower then goes ahead and asks "
#~ "the ``ServerApp`` to issue instructions "
#~ "to those nodes using the ``FedAvg`` "
#~ "strategy. ``FedAvg`` knows that it "
#~ "should select 50% of the available "
#~ "clients (``fraction-fit=0.5``), so it "
#~ "goes ahead and selects 5 random "
#~ "clients (i.e., 50% of 10)."
#~ msgstr ""

#~ msgid ""
#~ "Flower then asks the selected 5 "
#~ "clients to train the model. Each "
#~ "of the 5 ``ClientApp`` instances "
#~ "receives a message, which causes it "
#~ "to call ``client_fn`` to create an "
#~ "instance of ``FlowerClient``. It then "
#~ "calls ``.fit()`` on each of the "
#~ "``FlowerClient`` instances and returns the "
#~ "resulting model parameter updates to the"
#~ " ``ServerApp``. When the ``ServerApp`` "
#~ "receives the model parameter updates "
#~ "from the clients, it hands those "
#~ "updates over to the strategy (*FedAvg*)"
#~ " for aggregation. The strategy aggregates"
#~ " those updates and returns the new"
#~ " global model, which then gets used"
#~ " in the next round of federated "
#~ "learning."
#~ msgstr ""

#~ msgid ""
#~ "Let's create a simple weighted averaging"
#~ " function to aggregate the ``accuracy`` "
#~ "metric we return from ``evaluate``. Copy"
#~ " the following ``weighted_average()`` function"
#~ " to ``task.py``:"
#~ msgstr ""

#~ msgid ""
#~ "Now, in ``server_app.py``, we import the"
#~ " function and pass it to the "
#~ "``FedAvg`` strategy:"
#~ msgstr ""

#~ msgid ""
#~ "In the next tutorial, we're going "
#~ "to cover some more advanced concepts."
#~ " Want to customize your strategy? "
#~ "Initialize parameters on the server "
#~ "side? Or evaluate the aggregated model"
#~ " on the server side? We'll cover "
#~ "all this and more in the next "
#~ "tutorial."
#~ msgstr ""

#~ msgid ""
#~ "In part 1, we created a "
#~ "``ServerApp`` (in ``server_app.py``) using the"
#~ " ``server_fn``. In it, we defined the"
#~ " strategy and number of training "
#~ "rounds."
#~ msgstr ""

#~ msgid ""
#~ "The strategy encapsulates the federated "
#~ "learning approach/algorithm, for example, "
#~ "``FedAvg`` or ``FedAdagrad``. Let's try "
#~ "to use a different strategy this "
#~ "time. Add this line to the top "
#~ "of your ``server_app.py``: ``from "
#~ "flwr.server.strategy import FedAdagrad`` and "
#~ "replace the ``server_fn()`` with the "
#~ "following code:"
#~ msgstr ""

#~ msgid ""
#~ "We've seen how federated evaluation "
#~ "works on the client side (i.e., by"
#~ " implementing the ``evaluate`` method in"
#~ " ``FlowerClient``). Now let's see how "
#~ "we can evaluate aggregated model "
#~ "parameters on the server-side. First "
#~ "we define a new function ``evaluate``"
#~ " in ``task.py``:"
#~ msgstr ""

#~ msgid ""
#~ "Next, in ``server_app.py``, we pass the"
#~ " ``evaluate`` function to the "
#~ "``evaluate_fn`` parameter of the ``FedAvg``"
#~ " strategy:"
#~ msgstr ""

#~ msgid ""
#~ "In some situations, we want to "
#~ "configure client-side execution (training, "
#~ "evaluation) from the server-side. One"
#~ " example for that is the server "
#~ "asking the clients to train for a"
#~ " certain number of local epochs. "
#~ "Flower provides a way to send "
#~ "configuration values from the server to"
#~ " the clients using a dictionary. "
#~ "Let's look at an example where the"
#~ " clients receive values from the "
#~ "server through the ``config`` parameter "
#~ "in ``fit`` (``config`` is also available"
#~ " in ``evaluate``). The ``fit`` method "
#~ "receives the configuration dictionary through"
#~ " the ``config`` parameter and can "
#~ "then read values from this dictionary."
#~ " In this example, it reads "
#~ "``server_round`` and ``local_epochs`` and uses"
#~ " those values to improve the logging"
#~ " and configure the number of local"
#~ " training epochs. In our ``client_app.py``,"
#~ " replace the ``FlowerClient()`` class and"
#~ " ``client_fn()`` with the following code:"
#~ msgstr ""

#~ msgid ""
#~ "So how can we send this config "
#~ "dictionary from server to clients? The"
#~ " built-in Flower Strategies provide "
#~ "way to do this, and it works "
#~ "similarly to the way server-side "
#~ "evaluation works. We provide a callback"
#~ " to the strategy, and the strategy"
#~ " calls this callback for every round"
#~ " of federated learning. Add the "
#~ "following to your ``server_app.py``:"
#~ msgstr ""

#~ msgid ""
#~ "Next, we'll pass this function to "
#~ "the FedAvg strategy before starting the"
#~ " simulation. Change the ``server_fn()`` "
#~ "function in ``server_app.py`` to the "
#~ "following:"
#~ msgstr ""

#~ msgid "Finally, run the training with the following command:"
#~ msgstr "다음 명령을 실행하여 가상 환경을 활성화합니다:"

#~ msgid ""
#~ "Clients can also return arbitrary values"
#~ " to the server. To do so, they"
#~ " return a dictionary from ``fit`` "
#~ "and/or ``evaluate``. We have seen and"
#~ " used this concept throughout this "
#~ "tutorial without mentioning it explicitly: "
#~ "our ``FlowerClient`` returns a dictionary "
#~ "containing a custom key/value pair as"
#~ " the third return value in "
#~ "``evaluate``."
#~ msgstr ""

#~ msgid ""
#~ "Note that we can reuse the "
#~ "``ClientApp`` for different ``num-supernodes``"
#~ " since the Context is defined by "
#~ "the ``num-partitions`` argument in the"
#~ " ``client_fn()`` and for simulations with"
#~ " Flower, the number of partitions is"
#~ " equal to the number of SuperNodes."
#~ msgstr ""

#~ msgid ""
#~ "We now have 1000 partitions, each "
#~ "holding 45 training and 5 validation "
#~ "examples. Given that the number of "
#~ "training examples on each client is "
#~ "quite small, we should probably train"
#~ " the model a bit longer, so we"
#~ " configure the clients to perform 3"
#~ " local training epochs. We should "
#~ "also adjust the fraction of clients "
#~ "selected for training during each round"
#~ " (we don't want all 1000 clients "
#~ "participating in every round), so we "
#~ "adjust ``fraction_fit`` to ``0.025``, which"
#~ " means that only 2.5% of available"
#~ " clients (so 25 clients) will be "
#~ "selected for training each round. We "
#~ "update the ``fraction-fit`` value in "
#~ "the ``pyproject.toml``:"
#~ msgstr ""

#~ msgid ""
#~ "Then, we update the ``fit_config`` and"
#~ " ``server_fn`` functions in ``server_app.py`` "
#~ "to the following:"
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial, we've seen how "
#~ "we can gradually enhance our system "
#~ "by customizing the strategy, initializing "
#~ "parameters on the server side, choosing"
#~ " a different strategy, and evaluating "
#~ "models on the server-side. That's "
#~ "quite a bit of flexibility with so"
#~ " little code, right?"
#~ msgstr ""

#~ msgid ""
#~ "In the later sections, we've seen "
#~ "how we can communicate arbitrary values"
#~ " between server and clients to fully"
#~ " customize client-side execution. With "
#~ "that capability, we built a large-"
#~ "scale Federated Learning simulation using "
#~ "the Flower Virtual Client Engine and "
#~ "ran an experiment involving 1000 clients"
#~ " in the same workload - all in"
#~ " the same Flower project!"
#~ msgstr ""

#~ msgid "Run the Flower Federated Learning Tutorial in Notebooks"
#~ msgstr ""

#~ msgid "Tutorial Notebooks"
#~ msgstr "튜토리얼"

#~ msgid ""
#~ "Instead of following the main tutorials"
#~ " in the documentation, you can also"
#~ " run them in interactive Jupyter "
#~ "notebooks. This allows you to execute"
#~ " code snippets and experiment with "
#~ "running Flower in a more interactive "
#~ "way."
#~ msgstr ""

#~ msgid ""
#~ "The notebooks use the ``run_simulation`` "
#~ "approach, but the preferred way to "
#~ "run simulations is using the ``flwr "
#~ "run`` approach. For a comprehensive "
#~ "guide on how to setup and run "
#~ "Flower simulations please read the "
#~ "`how-to run simulations <../how-to-"
#~ "run-simulations.html>`_ guide."
#~ msgstr ""

#~ msgid ""
#~ "`Get started with Flower and PyTorch "
#~ "<https://github.com/adap/flower/blob/main/framework/docs/source/notebooks"
#~ "/tutorial-series-get-started-with-"
#~ "flower-pytorch.ipynb>`_"
#~ msgstr ""
#~ "https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
#~ "/tutorial-series-get-started-with-"
#~ "flower-pytorch.ipynb"

#~ msgid ""
#~ "`Use a Federated Learning Strategy "
#~ "<https://github.com/adap/flower/blob/main/framework/docs/source/notebooks"
#~ "/tutorial-series-use-a-federated-learning-"
#~ "strategy-pytorch.ipynb>`_"
#~ msgstr ""
#~ "https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
#~ "/tutorial-series-get-started-with-"
#~ "flower-pytorch.ipynb"

#~ msgid ""
#~ "`Build a Strategy from Scratch "
#~ "<https://github.com/adap/flower/blob/main/framework/docs/source/notebooks"
#~ "/tutorial-series-build-a-strategy-from-"
#~ "scratch-pytorch.ipynb>`_"
#~ msgstr ""
#~ "https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
#~ "/tutorial-series-get-started-with-"
#~ "flower-pytorch.ipynb"

#~ msgid ""
#~ "`Customize the Client "
#~ "<https://github.com/adap/flower/blob/main/framework/docs/source/notebooks"
#~ "/tutorial-series-customize-the-client-"
#~ "pytorch.ipynb>`_"
#~ msgstr ""
#~ "https://colab.research.google.com/github/adap/flower/blob/main/framework/docs/source"
#~ "/tutorial-series-get-started-with-"
#~ "flower-pytorch.ipynb"

#~ msgid ""
#~ "Additionally, you can follow the 30 "
#~ "mins notebook tutorial on `how to "
#~ "run Flower simulation with PyTorch "
#~ "<https://github.com/adap/flower/tree/main/examples/flower-"
#~ "in-30-minutes>`_."
#~ msgstr ""

#~ msgid "Build a strategy from scratch"
#~ msgstr ""

#~ msgid ""
#~ "Welcome to the third part of the"
#~ " Flower federated learning tutorial. In "
#~ "previous parts of this tutorial, we "
#~ "introduced federated learning with PyTorch "
#~ "and the Flower framework (`part 1 "
#~ "<https://flower.ai/docs/framework/tutorial-get-started-"
#~ "with-flower-pytorch.html>`__) and we "
#~ "learned how strategies can be used "
#~ "to customize the execution on both "
#~ "the server and the clients (`part "
#~ "2 <https://flower.ai/docs/framework/tutorial-use-a"
#~ "-federated-learning-strategy-pytorch.html>`__)."
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we'll continue to "
#~ "customize the federated learning system "
#~ "we built previously by creating a "
#~ "custom version of FedAvg using the "
#~ "Flower framework, Flower Datasets, and "
#~ "PyTorch."
#~ msgstr ""

#~ msgid ""
#~ "`Star Flower on GitHub "
#~ "<https://github.com/adap/flower>`__ ⭐️ and join "
#~ "the Flower community on Flower Discuss"
#~ " and the Flower Slack to connect, "
#~ "ask questions, and get help: - "
#~ "`Join Flower Discuss <https://discuss.flower.ai/>`__"
#~ " We'd love to hear from you in"
#~ " the ``Introduction`` topic! If anything"
#~ " is unclear, post in ``Flower Help"
#~ " - Beginners``. - `Join Flower Slack"
#~ " <https://flower.ai/join-slack>`__ We'd love "
#~ "to hear from you in the "
#~ "``#introductions`` channel! If anything is "
#~ "unclear, head over to the ``#questions``"
#~ " channel."
#~ msgstr ""
#~ "`Star Flower on GitHub "
#~ "<https://github.com/adap/flower>`__ ⭐️ Slack의 오픈소스"
#~ " Flower 커뮤니티에 가입하여 소통하고 질문하고 도움을 "
#~ "받을 수 있습니다: `Slack 가입<https://flower.ai"
#~ "/join-slack>`__ 🌼 ``#introductions``채널에서 당신의 "
#~ "목소리를 듣고 싶습니다! 궁금한 점이 있으시면``#questions``"
#~ " 채널로 방문해 주시기 바랍니다."

#~ msgid "Let's build a new ``Strategy`` from scratch! 🌼"
#~ msgstr ""

#~ msgid "First, we install the necessary packages:"
#~ msgstr ""

#~ msgid ""
#~ "Now that we have all dependencies "
#~ "installed, we can import everything we"
#~ " need for this tutorial:"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to switch to a "
#~ "runtime that has GPU acceleration "
#~ "enabled (on Google Colab: ``Runtime >"
#~ " Change runtime type > Hardware "
#~ "acclerator: GPU > Save``). Note, "
#~ "however, that Google Colab is not "
#~ "always able to offer GPU acceleration."
#~ " If you see an error related to"
#~ " GPU availability in one of the "
#~ "following sections, consider switching back"
#~ " to CPU-based execution by setting"
#~ " ``DEVICE = torch.device(\"cpu\")``. If the"
#~ " runtime has GPU acceleration enabled, "
#~ "you should see the output ``Training "
#~ "on cuda``, otherwise it'll say "
#~ "``Training on cpu``."
#~ msgstr ""

#~ msgid "Data loading"
#~ msgstr ""

#~ msgid ""
#~ "Let's now load the CIFAR-10 training "
#~ "and test set, partition them into "
#~ "ten smaller datasets (each split into"
#~ " training and validation set), and "
#~ "wrap everything in their own "
#~ "``DataLoader``."
#~ msgstr ""

#~ msgid "Model training/evaluation"
#~ msgstr ""

#~ msgid ""
#~ "Let's continue with the usual model "
#~ "definition (including ``set_parameters`` and "
#~ "``get_parameters``), training and test "
#~ "functions:"
#~ msgstr ""

#~ msgid "Flower client"
#~ msgstr ""

#~ msgid ""
#~ "To implement the Flower client, we "
#~ "(again) create a subclass of "
#~ "``flwr.client.NumPyClient`` and implement the "
#~ "three methods ``get_parameters``, ``fit``, and"
#~ " ``evaluate``. Here, we also pass the"
#~ " ``partition_id`` to the client and "
#~ "use it log additional details. We "
#~ "then create an instance of ``ClientApp``"
#~ " and pass it the ``client_fn``."
#~ msgstr ""

#~ msgid "Let's test what we have so far before we continue:"
#~ msgstr ""

#~ msgid "Build a Strategy from scratch"
#~ msgstr ""

#~ msgid ""
#~ "Let’s overwrite the ``configure_fit`` method"
#~ " such that it passes a higher "
#~ "learning rate (potentially also other "
#~ "hyperparameters) to the optimizer of a"
#~ " fraction of the clients. We will "
#~ "keep the sampling of the clients "
#~ "as it is in ``FedAvg`` and then"
#~ " change the configuration dictionary (one"
#~ " of the ``FitIns`` attributes)."
#~ msgstr ""

#~ msgid ""
#~ "The only thing left is to use "
#~ "the newly created custom Strategy "
#~ "``FedCustom`` when starting the experiment:"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we’ve seen how "
#~ "to implement a custom strategy. A "
#~ "custom strategy enables granular control "
#~ "over client node configuration, result "
#~ "aggregation, and more. To define a "
#~ "custom strategy, you only have to "
#~ "overwrite the abstract methods of the"
#~ " (abstract) base class ``Strategy``. To "
#~ "make custom strategies even more "
#~ "powerful, you can pass custom functions"
#~ " to the constructor of your new "
#~ "class (``__init__``) and then call these"
#~ " functions whenever needed."
#~ msgstr ""

#~ msgid ""
#~ "There's a dedicated ``#questions`` channel "
#~ "if you need help, but we'd also"
#~ " love to hear who you are in"
#~ " ``#introductions``!"
#~ msgstr ""

#~ msgid ""
#~ "The `Flower Federated Learning Tutorial "
#~ "- Part 4 <https://flower.ai/docs/framework"
#~ "/tutorial-customize-the-client-pytorch.html>`__"
#~ " introduces ``Client``, the flexible API"
#~ " underlying ``NumPyClient``."
#~ msgstr ""

#~ msgid "Customize the client"
#~ msgstr ""

#~ msgid ""
#~ "Welcome to the fourth part of the"
#~ " Flower federated learning tutorial. In "
#~ "the previous parts of this tutorial, "
#~ "we introduced federated learning with "
#~ "PyTorch and Flower (`part 1 "
#~ "<https://flower.ai/docs/framework/tutorial-get-started-"
#~ "with-flower-pytorch.html>`__), we learned "
#~ "how strategies can be used to "
#~ "customize the execution on both the "
#~ "server and the clients (`part 2 "
#~ "<https://flower.ai/docs/framework/tutorial-use-a-federated-"
#~ "learning-strategy-pytorch.html>`__), and we"
#~ " built our own custom strategy from"
#~ " scratch (`part 3 "
#~ "<https://flower.ai/docs/framework/tutorial-build-a-strategy-"
#~ "from-scratch-pytorch.html>`__)."
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we revisit "
#~ "``NumPyClient`` and introduce a new "
#~ "baseclass for building clients, simply "
#~ "named ``Client``. In previous parts of"
#~ " this tutorial, we've based our "
#~ "client on ``NumPyClient``, a convenience "
#~ "class which makes it easy to work"
#~ " with machine learning libraries that "
#~ "have good NumPy interoperability. With "
#~ "``Client``, we gain a lot of "
#~ "flexibility that we didn't have before,"
#~ " but we'll also have to do a"
#~ " few things the we didn't have "
#~ "to do before."
#~ msgstr ""

#~ msgid ""
#~ "Let's go deeper and see what it"
#~ " takes to move from ``NumPyClient`` "
#~ "to ``Client``! 🌼"
#~ msgstr ""

#~ msgid "Step 0: Preparation"
#~ msgstr ""

#~ msgid ""
#~ "Let's now define a loading function "
#~ "for the CIFAR-10 training and test "
#~ "set, partition them into ``num_partitions``"
#~ " smaller datasets (each split into "
#~ "training and validation set), and wrap"
#~ " everything in their own ``DataLoader``."
#~ msgstr ""

#~ msgid "Step 1: Revisiting NumPyClient"
#~ msgstr ""

#~ msgid ""
#~ "So far, we've implemented our client "
#~ "by subclassing ``flwr.client.NumPyClient``. The "
#~ "three methods we implemented are "
#~ "``get_parameters``, ``fit``, and ``evaluate``."
#~ msgstr ""

#~ msgid ""
#~ "Then, we define the function "
#~ "``numpyclient_fn`` that is used by "
#~ "Flower to create the ``FlowerNumpyClient`` "
#~ "instances on demand. Finally, we create"
#~ " the ``ClientApp`` and pass the "
#~ "``numpyclient_fn`` to it."
#~ msgstr ""

#~ msgid ""
#~ "We've seen this before, there's nothing"
#~ " new so far. The only *tiny* "
#~ "difference compared to the previous "
#~ "notebook is naming, we've changed "
#~ "``FlowerClient`` to ``FlowerNumPyClient`` and "
#~ "``client_fn`` to ``numpyclient_fn``. Next, we"
#~ " configure the number of federated "
#~ "learning rounds using ``ServerConfig`` and "
#~ "create the ``ServerApp`` with this "
#~ "config:"
#~ msgstr ""

#~ msgid ""
#~ "Finally, we specify the resources for"
#~ " each client and run the simulation"
#~ " to see the output we get:"
#~ msgstr ""

#~ msgid ""
#~ "This works as expected, ten clients "
#~ "are training for three rounds of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ "Let's dive a little bit deeper and"
#~ " discuss how Flower executes this "
#~ "simulation. Whenever a client is "
#~ "selected to do some work, "
#~ "``run_simulation`` launches the ``ClientApp`` "
#~ "object which in turn calls the "
#~ "function ``numpyclient_fn`` to create an "
#~ "instance of our ``FlowerNumPyClient`` (along"
#~ " with loading the model and the "
#~ "data)."
#~ msgstr ""

#~ msgid ""
#~ "But here's the perhaps surprising part:"
#~ " Flower doesn't actually use the "
#~ "``FlowerNumPyClient`` object directly. Instead, "
#~ "it wraps the object to makes it"
#~ " look like a subclass of "
#~ "``flwr.client.Client``, not ``flwr.client.NumPyClient``."
#~ " In fact, the Flower core framework"
#~ " doesn't know how to handle "
#~ "``NumPyClient``'s, it only knows how to"
#~ " handle ``Client``'s. ``NumPyClient`` is "
#~ "just a convenience abstraction built on"
#~ " top of ``Client``."
#~ msgstr ""

#~ msgid ""
#~ "Instead of building on top of "
#~ "``NumPyClient``, we can directly build "
#~ "on top of ``Client``."
#~ msgstr ""

#~ msgid "Step 2: Moving from ``NumPyClient`` to ``Client``"
#~ msgstr ""

#~ msgid ""
#~ "Let's try to do the same thing "
#~ "using ``Client`` instead of ``NumPyClient``."
#~ msgstr ""

#~ msgid ""
#~ "Before we discuss the code in more"
#~ " detail, let's try to run it! "
#~ "Gotta make sure our new ``Client``-based"
#~ " client works, right?"
#~ msgstr ""

#~ msgid ""
#~ "That's it, we're now using ``Client``."
#~ " It probably looks similar to what"
#~ " we've done with ``NumPyClient``. So "
#~ "what's the difference?"
#~ msgstr ""

#~ msgid ""
#~ "First of all, it's more code. But"
#~ " why? The difference comes from the"
#~ " fact that ``Client`` expects us to"
#~ " take care of parameter serialization "
#~ "and deserialization. For Flower to be"
#~ " able to send parameters over the "
#~ "network, it eventually needs to turn "
#~ "these parameters into ``bytes``. Turning "
#~ "parameters (e.g., NumPy ``ndarray``'s) into"
#~ " raw bytes is called serialization. "
#~ "Turning raw bytes into something more"
#~ " useful (like NumPy ``ndarray``'s) is "
#~ "called deserialization. Flower needs to "
#~ "do both: it needs to serialize "
#~ "parameters on the server-side and "
#~ "send them to the client, the "
#~ "client needs to deserialize them to "
#~ "use them for local training, and "
#~ "then serialize the updated parameters "
#~ "again to send them back to the "
#~ "server, which (finally!) deserializes them "
#~ "again in order to aggregate them "
#~ "with the updates received from other "
#~ "clients."
#~ msgstr ""

#~ msgid ""
#~ "The only *real* difference between "
#~ "Client and NumPyClient is that "
#~ "NumPyClient takes care of serialization "
#~ "and deserialization for you. It can "
#~ "do so because it expects you to"
#~ " return parameters as NumPy ndarray's, "
#~ "and it knows how to handle these."
#~ " This makes working with machine "
#~ "learning libraries that have good NumPy"
#~ " support (most of them) a breeze."
#~ msgstr ""

#~ msgid ""
#~ "In terms of API, there's one major"
#~ " difference: all methods in Client "
#~ "take exactly one argument (e.g., "
#~ "``FitIns`` in ``Client.fit``) and return "
#~ "exactly one value (e.g., ``FitRes`` in"
#~ " ``Client.fit``). The methods in "
#~ "``NumPyClient`` on the other hand have"
#~ " multiple arguments (e.g., ``parameters`` "
#~ "and ``config`` in ``NumPyClient.fit``) and "
#~ "multiple return values (e.g., ``parameters``,"
#~ " ``num_example``, and ``metrics`` in "
#~ "``NumPyClient.fit``) if there are multiple "
#~ "things to handle. These ``*Ins`` and "
#~ "``*Res`` objects in ``Client`` wrap all"
#~ " the individual values you're used to"
#~ " from ``NumPyClient``."
#~ msgstr ""

#~ msgid "Step 3: Custom serialization"
#~ msgstr ""

#~ msgid ""
#~ "Here we will explore how to "
#~ "implement custom serialization with a "
#~ "simple example."
#~ msgstr ""

#~ msgid ""
#~ "But first what is serialization? "
#~ "Serialization is just the process of "
#~ "converting an object into raw bytes, "
#~ "and equally as important, deserialization "
#~ "is the process of converting raw "
#~ "bytes back into an object. This is"
#~ " very useful for network communication. "
#~ "Indeed, without serialization, you could "
#~ "not just a Python object through "
#~ "the internet."
#~ msgstr ""

#~ msgid ""
#~ "Federated Learning relies heavily on "
#~ "internet communication for training by "
#~ "sending Python objects back and forth"
#~ " between the clients and the server."
#~ " This means that serialization is an"
#~ " essential part of Federated Learning."
#~ msgstr ""

#~ msgid ""
#~ "In the following section, we will "
#~ "write a basic example where instead "
#~ "of sending a serialized version of "
#~ "our ``ndarray``\\ s containing our "
#~ "parameters, we will first convert the"
#~ " ``ndarray`` into sparse matrices, before"
#~ " sending them. This technique can be"
#~ " used to save bandwidth, as in "
#~ "certain cases where the weights of "
#~ "a model are sparse (containing many "
#~ "0 entries), converting them to a "
#~ "sparse matrix can greatly improve their"
#~ " bytesize."
#~ msgstr ""

#~ msgid "Our custom serialization/deserialization functions"
#~ msgstr ""

#~ msgid ""
#~ "This is where the real "
#~ "serialization/deserialization will happen, "
#~ "especially in ``ndarray_to_sparse_bytes`` for "
#~ "serialization and ``sparse_bytes_to_ndarray`` for"
#~ " deserialization."
#~ msgstr ""

#~ msgid ""
#~ "Note that we imported the "
#~ "``scipy.sparse`` library in order to "
#~ "convert our arrays."
#~ msgstr ""

#~ msgid "Client-side"
#~ msgstr ""

#~ msgid ""
#~ "To be able to serialize our "
#~ "``ndarray``\\ s into sparse parameters, "
#~ "we will just have to call our "
#~ "custom functions in our "
#~ "``flwr.client.Client``."
#~ msgstr ""

#~ msgid ""
#~ "Indeed, in ``get_parameters`` we need to"
#~ " serialize the parameters we got from"
#~ " our network using our custom "
#~ "``ndarrays_to_sparse_parameters`` defined above."
#~ msgstr ""

#~ msgid ""
#~ "In ``fit``, we first need to "
#~ "deserialize the parameters coming from "
#~ "the server using our custom "
#~ "``sparse_parameters_to_ndarrays`` and then we "
#~ "need to serialize our local results "
#~ "with ``ndarrays_to_sparse_parameters``."
#~ msgstr ""

#~ msgid ""
#~ "In ``evaluate``, we will only need "
#~ "to deserialize the global parameters "
#~ "with our custom function."
#~ msgstr ""

#~ msgid "Server-side"
#~ msgstr ""

#~ msgid ""
#~ "For this example, we will just use"
#~ " ``FedAvg`` as a strategy. To change"
#~ " the serialization and deserialization "
#~ "here, we only need to reimplement "
#~ "the ``evaluate`` and ``aggregate_fit`` "
#~ "functions of ``FedAvg``. The other "
#~ "functions of the strategy will be "
#~ "inherited from the super class "
#~ "``FedAvg``."
#~ msgstr ""

#~ msgid "As you can see only one line as change in ``evaluate``:"
#~ msgstr ""

#~ msgid ""
#~ "And for ``aggregate_fit``, we will first"
#~ " deserialize every result we received:"
#~ msgstr ""

#~ msgid "And then serialize the aggregated result:"
#~ msgstr ""

#~ msgid "We can now run our custom serialization example!"
#~ msgstr ""

#~ msgid ""
#~ "In this part of the tutorial, "
#~ "we've seen how we can build "
#~ "clients by subclassing either ``NumPyClient``"
#~ " or ``Client``. ``NumPyClient`` is a "
#~ "convenience abstraction that makes it "
#~ "easier to work with machine learning "
#~ "libraries that have good NumPy "
#~ "interoperability. ``Client`` is a more "
#~ "flexible abstraction that allows us to"
#~ " do things that are not possible "
#~ "in ``NumPyClient``. In order to do "
#~ "so, it requires us to handle "
#~ "parameter serialization and deserialization "
#~ "ourselves."
#~ msgstr ""

#~ msgid ""
#~ "`Watch Flower AI Summit 2024 videos "
#~ "<https://flower.ai/conf/flower-ai-summit-2024/>`__"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we'll build a "
#~ "federated learning system using the "
#~ "Flower framework, Flower Datasets and "
#~ "PyTorch. In part 1, we use PyTorch"
#~ " for the model training pipeline and"
#~ " data loading. In part 2, we "
#~ "federate the PyTorch project using "
#~ "Flower."
#~ msgstr ""

#~ msgid ""
#~ "Next, we install the necessary packages"
#~ " for PyTorch (``torch`` and "
#~ "``torchvision``), Flower Datasets (``flwr-"
#~ "datasets``) and Flower (``flwr``):"
#~ msgstr ""

#~ msgid ""
#~ "It is possible to switch to a "
#~ "runtime that has GPU acceleration "
#~ "enabled (on Google Colab: ``Runtime >"
#~ " Change runtime type > Hardware "
#~ "accelerator: GPU > Save``). Note, "
#~ "however, that Google Colab is not "
#~ "always able to offer GPU acceleration."
#~ " If you see an error related to"
#~ " GPU availability in one of the "
#~ "following sections, consider switching back"
#~ " to CPU-based execution by setting"
#~ " ``DEVICE = torch.device(\"cpu\")``. If the"
#~ " runtime has GPU acceleration enabled, "
#~ "you should see the output ``Training "
#~ "on cuda``, otherwise it'll say "
#~ "``Training on cpu``."
#~ msgstr ""

#~ msgid "Load the data"
#~ msgstr ""

#~ msgid ""
#~ "We simulate having multiple datasets "
#~ "from multiple organizations (also called "
#~ "the \"cross-silo\" setting in federated"
#~ " learning) by splitting the original "
#~ "CIFAR-10 dataset into multiple partitions. "
#~ "Each partition will represent the data"
#~ " from a single organization. We're "
#~ "doing this purely for experimentation "
#~ "purposes, in the real world there's "
#~ "no need for data splitting because "
#~ "each organization already has their own"
#~ " data (the data is naturally "
#~ "partitioned)."
#~ msgstr ""

#~ msgid ""
#~ "We use the Flower Datasets library "
#~ "(``flwr-datasets``) to partition CIFAR-10 "
#~ "into ten partitions using "
#~ "``FederatedDataset``. We will create a "
#~ "small training and test set for "
#~ "each of the ten organizations and "
#~ "wrap each of these into a PyTorch"
#~ " ``DataLoader``:"
#~ msgstr ""

#~ msgid ""
#~ "Let's take a look at the first "
#~ "batch of images and labels in the"
#~ " first training set (i.e., ``trainloader``"
#~ " from ``partition_id=0``) before we move"
#~ " on:"
#~ msgstr ""

#~ msgid ""
#~ "The output above shows a random "
#~ "batch of images from the ``trainloader``"
#~ " from the first of ten partitions."
#~ " It also prints the labels associated"
#~ " with each image (i.e., one of "
#~ "the ten possible labels we've seen "
#~ "above). If you run the cell again,"
#~ " you should see another batch of "
#~ "images."
#~ msgstr ""

#~ msgid "Step 1: Centralized Training with PyTorch"
#~ msgstr ""

#~ msgid ""
#~ "Next, we're going to use PyTorch "
#~ "to define a simple convolutional neural"
#~ " network. This introduction assumes basic"
#~ " familiarity with PyTorch, so it "
#~ "doesn't cover the PyTorch-related "
#~ "aspects in full detail. If you "
#~ "want to dive deeper into PyTorch, "
#~ "we recommend `DEEP LEARNING WITH "
#~ "PYTORCH: A 60 MINUTE BLITZ "
#~ "<https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html>`__."
#~ msgstr ""

#~ msgid "Define the model"
#~ msgstr ""

#~ msgid ""
#~ "We use the simple CNN described in"
#~ " the `PyTorch tutorial "
#~ "<https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#define-a"
#~ "-convolutional-neural-network>`__:"
#~ msgstr ""

#~ msgid "Let's continue with the usual training and test functions:"
#~ msgstr ""

#~ msgid "Train the model"
#~ msgstr "릴리즈 동안에"

#~ msgid ""
#~ "We now have all the basic building"
#~ " blocks we need: a dataset, a "
#~ "model, a training function, and a "
#~ "test function. Let's put them together"
#~ " to train the model on the "
#~ "dataset of one of our organizations "
#~ "(``partition_id=0``). This simulates the "
#~ "reality of most machine learning "
#~ "projects today: each organization has "
#~ "their own data and trains models "
#~ "only on this internal data:"
#~ msgstr ""

#~ msgid ""
#~ "Training the simple CNN on our "
#~ "CIFAR-10 split for 5 epochs should "
#~ "result in a test set accuracy of"
#~ " about 41%, which is not good, "
#~ "but at the same time, it doesn't"
#~ " really matter for the purposes of"
#~ " this tutorial. The intent was just"
#~ " to show a simple centralized "
#~ "training pipeline that sets the stage"
#~ " for what comes next - federated "
#~ "learning!"
#~ msgstr ""

#~ msgid "Step 2: Federated Learning with Flower"
#~ msgstr ""

#~ msgid ""
#~ "Step 1 demonstrated a simple centralized"
#~ " training pipeline. All data was in"
#~ " one place (i.e., a single "
#~ "``trainloader`` and a single ``valloader``)."
#~ " Next, we'll simulate a situation "
#~ "where we have multiple datasets in "
#~ "multiple organizations and where we "
#~ "train a model over these organizations"
#~ " using federated learning."
#~ msgstr ""

#~ msgid "Update model parameters"
#~ msgstr "모델 매개변수."

#~ msgid ""
#~ "We need two helper functions to "
#~ "update the local model with parameters"
#~ " received from the server and to "
#~ "get the updated model parameters from"
#~ " the local model: ``set_parameters`` and"
#~ " ``get_parameters``. The following two "
#~ "functions do just that for the "
#~ "PyTorch model above."
#~ msgstr ""

#~ msgid ""
#~ "The details of how this works are"
#~ " not really important here (feel free"
#~ " to consult the PyTorch documentation "
#~ "if you want to learn more). In "
#~ "essence, we use ``state_dict`` to access"
#~ " PyTorch model parameter tensors. The "
#~ "parameter tensors are then converted "
#~ "to/from a list of NumPy ndarray's "
#~ "(which the Flower ``NumPyClient`` knows "
#~ "how to serialize/deserialize):"
#~ msgstr ""

#~ msgid ""
#~ "With that out of the way, let's"
#~ " move on to the interesting part. "
#~ "Federated learning systems consist of a"
#~ " server and multiple clients. In "
#~ "Flower, we create a ``ServerApp`` and"
#~ " a ``ClientApp`` to run the "
#~ "server-side and client-side code, "
#~ "respectively."
#~ msgstr ""

#~ msgid ""
#~ "The first step toward creating a "
#~ "``ClientApp`` is to implement a "
#~ "subclasses of ``flwr.client.Client`` or "
#~ "``flwr.client.NumPyClient``. We use ``NumPyClient``"
#~ " in this tutorial because it is "
#~ "easier to implement and requires us "
#~ "to write less boilerplate. To implement"
#~ " ``NumPyClient``, we create a subclass "
#~ "that implements the three methods "
#~ "``get_parameters``, ``fit``, and ``evaluate``:"
#~ msgstr ""

#~ msgid "``get_parameters``: Return the current local model parameters"
#~ msgstr ""

#~ msgid ""
#~ "``fit``: Receive model parameters from "
#~ "the server, train the model on the"
#~ " local data, and return the updated"
#~ " model parameters to the server"
#~ msgstr ""

#~ msgid ""
#~ "``evaluate``: Receive model parameters from"
#~ " the server, evaluate the model on"
#~ " the local data, and return the "
#~ "evaluation result to the server"
#~ msgstr ""

#~ msgid ""
#~ "We mentioned that our clients will "
#~ "use the previously defined PyTorch "
#~ "components for model training and "
#~ "evaluation. Let's see a simple Flower"
#~ " client implementation that brings "
#~ "everything together:"
#~ msgstr ""

#~ msgid ""
#~ "Our class ``FlowerClient`` defines how "
#~ "local training/evaluation will be performed"
#~ " and allows Flower to call the "
#~ "local training/evaluation through ``fit`` and"
#~ " ``evaluate``. Each instance of "
#~ "``FlowerClient`` represents a *single client*"
#~ " in our federated learning system. "
#~ "Federated learning systems have multiple "
#~ "clients (otherwise, there's not much to"
#~ " federate), so each client will be"
#~ " represented by its own instance of"
#~ " ``FlowerClient``. If we have, for "
#~ "example, three clients in our workload,"
#~ " then we'd have three instances of"
#~ " ``FlowerClient`` (one on each of the"
#~ " machines we'd start the client on)."
#~ " Flower calls ``FlowerClient.fit`` on the"
#~ " respective instance when the server "
#~ "selects a particular client for training"
#~ " (and ``FlowerClient.evaluate`` for evaluation)."
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we want to "
#~ "simulate a federated learning system "
#~ "with 10 clients *on a single "
#~ "machine*. This means that the server "
#~ "and all 10 clients will live on"
#~ " a single machine and share resources"
#~ " such as CPU, GPU, and memory. "
#~ "Having 10 clients would mean having "
#~ "10 instances of ``FlowerClient`` in "
#~ "memory. Doing this on a single "
#~ "machine can quickly exhaust the "
#~ "available memory resources, even if only"
#~ " a subset of these clients "
#~ "participates in a single round of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ "In addition to the regular capabilities"
#~ " where server and clients run on "
#~ "multiple machines, Flower, therefore, provides"
#~ " special simulation capabilities that "
#~ "create ``FlowerClient`` instances only when"
#~ " they are actually necessary for "
#~ "training or evaluation. To enable the"
#~ " Flower framework to create clients "
#~ "when necessary, we need to implement "
#~ "a function that creates a "
#~ "``FlowerClient`` instance on demand. We "
#~ "typically call this function ``client_fn``."
#~ " Flower calls ``client_fn`` whenever it "
#~ "needs an instance of one particular "
#~ "client to call ``fit`` or ``evaluate``"
#~ " (those instances are usually discarded "
#~ "after use, so they should not keep"
#~ " any local state). In federated "
#~ "learning experiments using Flower, clients "
#~ "are identified by a partition ID, "
#~ "or ``partition-id``. This ``partition-"
#~ "id`` is used to load different "
#~ "local data partitions for different "
#~ "clients, as can be seen below. The"
#~ " value of ``partition-id`` is "
#~ "retrieved from the ``node_config`` dictionary"
#~ " in the ``Context`` object, which "
#~ "holds the information that persists "
#~ "throughout each training round."
#~ msgstr ""

#~ msgid ""
#~ "With this, we have the class "
#~ "``FlowerClient`` which defines client-side "
#~ "training/evaluation and ``client_fn`` which "
#~ "allows Flower to create ``FlowerClient`` "
#~ "instances whenever it needs to call "
#~ "``fit`` or ``evaluate`` on one "
#~ "particular client. Last, but definitely "
#~ "not least, we create an instance "
#~ "of ``ClientApp`` and pass it the "
#~ "``client_fn``. ``ClientApp`` is the entrypoint"
#~ " that a running Flower client uses"
#~ " to call your code (as defined "
#~ "in, for example, ``FlowerClient.fit``)."
#~ msgstr ""

#~ msgid ""
#~ "On the server side, we need to "
#~ "configure a strategy which encapsulates "
#~ "the federated learning approach/algorithm, for"
#~ " example, *Federated Averaging* (FedAvg). "
#~ "Flower has a number of built-in"
#~ " strategies, but we can also use "
#~ "our own strategy implementations to "
#~ "customize nearly all aspects of the "
#~ "federated learning approach. For this "
#~ "example, we use the built-in "
#~ "``FedAvg`` implementation and customize it "
#~ "using a few basic parameters:"
#~ msgstr ""

#~ msgid ""
#~ "Similar to ``ClientApp``, we create a"
#~ " ``ServerApp`` using a utility function "
#~ "``server_fn``. In ``server_fn``, we pass "
#~ "an instance of ``ServerConfig`` for "
#~ "defining the number of federated "
#~ "learning rounds (``num_rounds``) and we "
#~ "also pass the previously created "
#~ "``strategy``. The ``server_fn`` returns a "
#~ "``ServerAppComponents`` object containing the "
#~ "settings that define the ``ServerApp`` "
#~ "behaviour. ``ServerApp`` is the entrypoint "
#~ "that Flower uses to call all your"
#~ " server-side code (for example, the"
#~ " strategy)."
#~ msgstr ""

#~ msgid ""
#~ "In simulation, we often want to "
#~ "control the amount of resources each "
#~ "client can use. In the next cell,"
#~ " we specify a ``backend_config`` dictionary"
#~ " with the ``client_resources`` key "
#~ "(required) for defining the amount of"
#~ " CPU and GPU resources each client"
#~ " can access."
#~ msgstr ""

#~ msgid ""
#~ "The last step is the actual call"
#~ " to ``run_simulation`` which - you "
#~ "guessed it - runs the simulation. "
#~ "``run_simulation`` accepts a number of "
#~ "arguments: - ``server_app`` and "
#~ "``client_app``: the previously created "
#~ "``ServerApp`` and ``ClientApp`` objects, "
#~ "respectively - ``num_supernodes``: the number"
#~ " of ``SuperNodes`` to simulate which "
#~ "equals the number of clients for "
#~ "Flower simulation - ``backend_config``: the"
#~ " resource allocation used in this "
#~ "simulation"
#~ msgstr ""

#~ msgid ""
#~ "When we call ``run_simulation``, we tell"
#~ " Flower that there are 10 clients "
#~ "(``num_supernodes=10``, where 1 ``SuperNode`` "
#~ "launches 1 ``ClientApp``). Flower then "
#~ "goes ahead an asks the ``ServerApp`` "
#~ "to issue an instructions to those "
#~ "nodes using the ``FedAvg`` strategy. "
#~ "``FedAvg`` knows that it should select"
#~ " 100% of the available clients "
#~ "(``fraction_fit=1.0``), so it goes ahead "
#~ "and selects 10 random clients (i.e., "
#~ "100% of 10)."
#~ msgstr ""

#~ msgid ""
#~ "Flower then asks the selected 10 "
#~ "clients to train the model. Each "
#~ "of the 10 ``ClientApp`` instances "
#~ "receives a message, which causes it "
#~ "to call ``client_fn`` to create an "
#~ "instance of ``FlowerClient``. It then "
#~ "calls ``.fit()`` on each the "
#~ "``FlowerClient`` instances and returns the "
#~ "resulting model parameter updates to the"
#~ " ``ServerApp``. When the ``ServerApp`` "
#~ "receives the model parameter updates "
#~ "from the clients, it hands those "
#~ "updates over to the strategy (*FedAvg*)"
#~ " for aggregation. The strategy aggregates"
#~ " those updates and returns the new"
#~ " global model, which then gets used"
#~ " in the next round of federated "
#~ "learning."
#~ msgstr ""

#~ msgid "Where's the accuracy?"
#~ msgstr ""

#~ msgid ""
#~ "You may have noticed that all "
#~ "metrics except for ``losses_distributed`` are"
#~ " empty. Where did the ``{\"accuracy\": "
#~ "float(accuracy)}`` go?"
#~ msgstr ""

#~ msgid ""
#~ "Flower can automatically aggregate losses "
#~ "returned by individual clients, but it"
#~ " cannot do the same for metrics "
#~ "in the generic metrics dictionary (the"
#~ " one with the ``accuracy`` key). "
#~ "Metrics dictionaries can contain very "
#~ "different kinds of metrics and even "
#~ "key/value pairs that are not metrics "
#~ "at all, so the framework does not"
#~ " (and can not) know how to "
#~ "handle these automatically."
#~ msgstr ""

#~ msgid ""
#~ "As users, we need to tell the "
#~ "framework how to handle/aggregate these "
#~ "custom metrics, and we do so by"
#~ " passing metric aggregation functions to"
#~ " the strategy. The strategy will then"
#~ " call these functions whenever it "
#~ "receives fit or evaluate metrics from"
#~ " clients. The two possible functions "
#~ "are ``fit_metrics_aggregation_fn`` and "
#~ "``evaluate_metrics_aggregation_fn``."
#~ msgstr ""

#~ msgid ""
#~ "Let's create a simple weighted averaging"
#~ " function to aggregate the ``accuracy`` "
#~ "metric we return from ``evaluate``:"
#~ msgstr ""

#~ msgid ""
#~ "We now have a full system that "
#~ "performs federated training and federated "
#~ "evaluation. It uses the ``weighted_average``"
#~ " function to aggregate custom evaluation"
#~ " metrics and calculates a single "
#~ "``accuracy`` metric across all clients "
#~ "on the server side."
#~ msgstr ""

#~ msgid ""
#~ "The other two categories of metrics "
#~ "(``losses_centralized`` and ``metrics_centralized``) "
#~ "are still empty because they only "
#~ "apply when centralized evaluation is "
#~ "being used. Part two of the Flower"
#~ " tutorial will cover centralized "
#~ "evaluation."
#~ msgstr ""

#~ msgid ""
#~ "Congratulations, you just trained a "
#~ "convolutional neural network, federated over"
#~ " 10 clients! With that, you "
#~ "understand the basics of federated "
#~ "learning with Flower. The same approach"
#~ " you've seen can be used with "
#~ "other machine learning frameworks (not "
#~ "just PyTorch) and tasks (not just "
#~ "CIFAR-10 images classification), for example"
#~ " NLP with Hugging Face Transformers "
#~ "or speech with SpeechBrain."
#~ msgstr ""

#~ msgid ""
#~ "In the next notebook, we're going "
#~ "to cover some more advanced concepts."
#~ " Want to customize your strategy? "
#~ "Initialize parameters on the server "
#~ "side? Or evaluate the aggregated model"
#~ " on the server side? We'll cover "
#~ "all this and more in the next "
#~ "tutorial."
#~ msgstr ""

#~ msgid ""
#~ "The `Flower Federated Learning Tutorial "
#~ "- Part 2 <https://flower.ai/docs/framework"
#~ "/tutorial-use-a-federated-learning-strategy-"
#~ "pytorch.html>`__ goes into more depth "
#~ "about strategies and all the advanced"
#~ " things you can build with them."
#~ msgstr ""

#~ msgid ""
#~ "Welcome to the next part of the"
#~ " federated learning tutorial. In previous"
#~ " parts of this tutorial, we "
#~ "introduced federated learning with PyTorch "
#~ "and Flower (`part 1 "
#~ "<https://flower.ai/docs/framework/tutorial-get-started-"
#~ "with-flower-pytorch.html>`__)."
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we'll begin to "
#~ "customize the federated learning system "
#~ "we built in the introductory notebook"
#~ " again, using the Flower framework, "
#~ "Flower Datasets, and PyTorch."
#~ msgstr ""

#~ msgid ""
#~ "Let's now load the CIFAR-10 training "
#~ "and test set, partition them into "
#~ "ten smaller datasets (each split into"
#~ " training and validation set), and "
#~ "wrap everything in their own "
#~ "``DataLoader``. We introduce a new "
#~ "parameter ``num_partitions`` which allows us"
#~ " to call ``load_datasets`` with different"
#~ " numbers of partitions."
#~ msgstr ""

#~ msgid "Strategy customization"
#~ msgstr ""

#~ msgid ""
#~ "So far, everything should look familiar"
#~ " if you've worked through the "
#~ "introductory notebook. With that, we're "
#~ "ready to introduce a number of new"
#~ " features."
#~ msgstr ""

#~ msgid "Server-side parameter **initialization**"
#~ msgstr ""

#~ msgid ""
#~ "Flower, by default, initializes the "
#~ "global model by asking one random "
#~ "client for the initial parameters. In"
#~ " many cases, we want more control "
#~ "over parameter initialization though. Flower"
#~ " therefore allows you to directly "
#~ "pass the initial parameters to the "
#~ "Strategy. We create an instance of "
#~ "``Net()`` and get the paramaters as "
#~ "follows:"
#~ msgstr ""

#~ msgid ""
#~ "Next, we create a ``server_fn`` that "
#~ "returns the components needed for the"
#~ " server. Within ``server_fn``, we create"
#~ " a Strategy that uses the initial "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "Passing ``initial_parameters`` to the "
#~ "``FedAvg`` strategy prevents Flower from "
#~ "asking one of the clients for the"
#~ " initial parameters. In ``server_fn``, we"
#~ " pass this new ``strategy`` and a "
#~ "``ServerConfig`` for defining the number "
#~ "of federated learning rounds (``num_rounds``)."
#~ msgstr ""

#~ msgid ""
#~ "Similar to the ``ClientApp``, we now "
#~ "create the ``ServerApp`` using the "
#~ "``server_fn``:"
#~ msgstr ""

#~ msgid ""
#~ "Last but not least, we specify the"
#~ " resources for each client and run"
#~ " the simulation."
#~ msgstr ""

#~ msgid ""
#~ "If we look closely, we can see "
#~ "that the logs do not show any "
#~ "calls to the ``FlowerClient.get_parameters`` "
#~ "method."
#~ msgstr ""

#~ msgid "Starting with a customized strategy"
#~ msgstr ""

#~ msgid ""
#~ "We've seen the function ``run_simulation`` "
#~ "before. It accepts a number of "
#~ "arguments, amongst them the ``server_app`` "
#~ "which wraps around the strategy and "
#~ "number of training rounds, ``client_app`` "
#~ "which wraps around the ``client_fn`` "
#~ "used to create ``FlowerClient`` instances, "
#~ "and the number of clients to "
#~ "simulate which equals ``num_supernodes``."
#~ msgstr ""

#~ msgid ""
#~ "The strategy encapsulates the federated "
#~ "learning approach/algorithm, for example, "
#~ "``FedAvg`` or ``FedAdagrad``. Let's try "
#~ "to use a different strategy this "
#~ "time:"
#~ msgstr ""

#~ msgid ""
#~ "Flower can evaluate the aggregated model"
#~ " on the server-side or on the"
#~ " client-side. Client-side and "
#~ "server-side evaluation are similar in "
#~ "some ways, but different in others."
#~ msgstr ""

#~ msgid ""
#~ "We've seen how federated evaluation "
#~ "works on the client side (i.e., by"
#~ " implementing the ``evaluate`` method in"
#~ " ``FlowerClient``). Now let's see how "
#~ "we can evaluate aggregated model "
#~ "parameters on the server-side:"
#~ msgstr ""

#~ msgid ""
#~ "We create a ``FedAvg`` strategy and "
#~ "pass ``evaluate_fn`` to it. Then, we "
#~ "create a ``ServerApp`` that uses this"
#~ " strategy."
#~ msgstr ""

#~ msgid "Sending/receiving arbitrary values to/from clients"
#~ msgstr ""

#~ msgid ""
#~ "In some situations, we want to "
#~ "configure client-side execution (training, "
#~ "evaluation) from the server-side. One"
#~ " example for that is the server "
#~ "asking the clients to train for a"
#~ " certain number of local epochs. "
#~ "Flower provides a way to send "
#~ "configuration values from the server to"
#~ " the clients using a dictionary. "
#~ "Let's look at an example where the"
#~ " clients receive values from the "
#~ "server through the ``config`` parameter "
#~ "in ``fit`` (``config`` is also available"
#~ " in ``evaluate``). The ``fit`` method "
#~ "receives the configuration dictionary through"
#~ " the ``config`` parameter and can "
#~ "then read values from this dictionary."
#~ " In this example, it reads "
#~ "``server_round`` and ``local_epochs`` and uses"
#~ " those values to improve the logging"
#~ " and configure the number of local"
#~ " training epochs:"
#~ msgstr ""

#~ msgid ""
#~ "So how can we send this config "
#~ "dictionary from server to clients? The"
#~ " built-in Flower Strategies provide "
#~ "way to do this, and it works "
#~ "similarly to the way server-side "
#~ "evaluation works. We provide a function"
#~ " to the strategy, and the strategy"
#~ " calls this function for every round"
#~ " of federated learning:"
#~ msgstr ""

#~ msgid ""
#~ "Next, we'll pass this function to "
#~ "the FedAvg strategy before starting the"
#~ " simulation:"
#~ msgstr ""

#~ msgid ""
#~ "As we can see, the client logs "
#~ "now include the current round of "
#~ "federated learning (which they read from"
#~ " the ``config`` dictionary). We can "
#~ "also configure local training to run "
#~ "for one epoch during the first and"
#~ " second round of federated learning, "
#~ "and then for two epochs during the"
#~ " third round."
#~ msgstr ""

#~ msgid ""
#~ "Clients can also return arbitrary values"
#~ " to the server. To do so, they"
#~ " return a dictionary from ``fit`` "
#~ "and/or ``evaluate``. We have seen and"
#~ " used this concept throughout this "
#~ "notebook without mentioning it explicitly: "
#~ "our ``FlowerClient`` returns a dictionary "
#~ "containing a custom key/value pair as"
#~ " the third return value in "
#~ "``evaluate``."
#~ msgstr ""

#~ msgid ""
#~ "As a last step in this notebook,"
#~ " let's see how we can use "
#~ "Flower to experiment with a large "
#~ "number of clients."
#~ msgstr ""

#~ msgid ""
#~ "Note that we can reuse the "
#~ "``ClientApp`` for different ``num-partitions``"
#~ " since the Context is defined by "
#~ "the ``num_supernodes`` argument in "
#~ "``run_simulation()``."
#~ msgstr ""

#~ msgid ""
#~ "We now have 1000 partitions, each "
#~ "holding 45 training and 5 validation "
#~ "examples. Given that the number of "
#~ "training examples on each client is "
#~ "quite small, we should probably train"
#~ " the model a bit longer, so we"
#~ " configure the clients to perform 3"
#~ " local training epochs. We should "
#~ "also adjust the fraction of clients "
#~ "selected for training during each round"
#~ " (we don't want all 1000 clients "
#~ "participating in every round), so we "
#~ "adjust ``fraction_fit`` to ``0.025``, which"
#~ " means that only 2.5% of available"
#~ " clients (so 25 clients) will be "
#~ "selected for training each round:"
#~ msgstr ""

#~ msgid ""
#~ "In this notebook, we've seen how "
#~ "we can gradually enhance our system "
#~ "by customizing the strategy, initializing "
#~ "parameters on the server side, choosing"
#~ " a different strategy, and evaluating "
#~ "models on the server-side. That's "
#~ "quite a bit of flexibility with so"
#~ " little code, right?"
#~ msgstr ""

#~ msgid ""
#~ "In the later sections, we've seen "
#~ "how we can communicate arbitrary values"
#~ " between server and clients to fully"
#~ " customize client-side execution. With "
#~ "that capability, we built a large-"
#~ "scale Federated Learning simulation using "
#~ "the Flower Virtual Client Engine and "
#~ "ran an experiment involving 1000 clients"
#~ " in the same workload - all in"
#~ " a Jupyter Notebook!"
#~ msgstr ""

#~ msgid ""
#~ "The `Flower Federated Learning Tutorial "
#~ "- Part 3 <https://flower.ai/docs/framework"
#~ "/tutorial-build-a-strategy-from-scratch-"
#~ "pytorch.html>`__ shows how to build a"
#~ " fully custom ``Strategy`` from scratch."
#~ msgstr ""

#~ msgid ""
#~ "PyTorch | TensorFlow | sklearn | "
#~ "HuggingFace | JAX | MLX | NumPy"
#~ " | FlowerTune | Flower Baseline | "
#~ "PyTorch (Legacy API, deprecated)"
#~ msgstr ""

#~ msgid ""
#~ "This will use the default arguments "
#~ "where each ``ClientApp`` will use 2 "
#~ "CPUs and at most 4 ``ClientApp``\\s "
#~ "will run in a given GPU."
#~ msgstr ""

#~ msgid ""
#~ "The main changes we have to make"
#~ " to use 🤗 Hugging Face with "
#~ "Flower will be found in the "
#~ "``get_weights()`` and ``set_weights()`` functions."
#~ " Under the hood, the ``transformers`` "
#~ "library uses PyTorch, which means we "
#~ "can reuse the ``get_weights()`` and "
#~ "``set_weights()`` code that we defined "
#~ "in the :doc:`Quickstart PyTorch <tutorial-"
#~ "quickstart-pytorch>` tutorial. As a "
#~ "reminder, in ``get_weights()``, PyTorch model"
#~ " parameters are extracted and represented"
#~ " as a list of NumPy arrays. The"
#~ " ``set_weights()`` function that's the "
#~ "opposite: given a list of NumPy "
#~ "arrays it applies them to an "
#~ "existing PyTorch model. Doing this in"
#~ " fairly easy in PyTorch."
#~ msgstr ""

#~ msgid ""
#~ "The specific implementation of "
#~ "``get_weights()`` and ``set_weights()`` depends "
#~ "on the type of models you use. "
#~ "The ones shown below work for a"
#~ " wide range of PyTorch models but "
#~ "you might need to adjust them if"
#~ " you have more exotic model "
#~ "architectures."
#~ msgstr ""

#~ msgid ""
#~ "The rest of the functionality is "
#~ "directly inspired by the centralized "
#~ "case. The ``fit()`` method in the "
#~ "client trains the model using the "
#~ "local dataset. Similarly, the ``evaluate()``"
#~ " method is used to evaluate the "
#~ "model received on a held-out "
#~ "validation set that the client might "
#~ "have:"
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that the "
#~ "`context` enables you to get access "
#~ "to hyperparemeters defined in your "
#~ "``pyproject.toml`` to configure the run. "
#~ "In this tutorial we access the "
#~ "``local-epochs`` setting to control the "
#~ "number of epochs a ``ClientApp`` will"
#~ " perform when running the ``fit()`` "
#~ "method. You could define additional "
#~ "hyperparameters in ``pyproject.toml`` and "
#~ "access them here."
#~ msgstr ""

#~ msgid ""
#~ "To construct a ``ServerApp`` we define"
#~ " a ``server_fn()`` callback with an "
#~ "identical signature to that of "
#~ "``client_fn()`` but the return type is"
#~ " |serverappcomponents|_ as opposed to a "
#~ "|client|_ In this example we use "
#~ "the `FedAvg` strategy. To it we "
#~ "pass a randomly initialized model that"
#~ " will server as the global model "
#~ "to federated. Note that the value "
#~ "of ``fraction_fit`` is read from the "
#~ "run config. You can find the "
#~ "default value defined in the "
#~ "``pyproject.toml``."
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with Jax to train a linear "
#~ "regression model on a scikit-learn "
#~ "dataset."
#~ msgstr ""

#~ msgid ""
#~ "The main changes we have to make"
#~ " to use JAX with Flower will be"
#~ " found in the ``get_params()`` and "
#~ "``set_params()`` functions. In ``get_params()``, "
#~ "JAX model parameters are extracted and"
#~ " represented as a list of NumPy "
#~ "arrays. The ``set_params()`` function is "
#~ "the opposite: given a list of "
#~ "NumPy arrays it applies them to an"
#~ " existing JAX model."
#~ msgstr ""

#~ msgid ""
#~ "The ``get_params()`` and ``set_params()`` "
#~ "functions here are conceptually similar "
#~ "to the ``get_weights()`` and ``set_weights()``"
#~ " functions that we defined in the "
#~ ":doc:`QuickStart PyTorch <tutorial-quickstart-"
#~ "pytorch>` tutorial."
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that the "
#~ "`context` enables you to get access "
#~ "to hyperparemeters defined in your "
#~ "``pyproject.toml`` to configure the run. "
#~ "In this tutorial we access the "
#~ "``local-epochs`` setting to control the "
#~ "number of epochs a ``ClientApp`` will"
#~ " perform when running the ``fit()`` "
#~ "method. You could define additioinal "
#~ "hyperparameters in ``pyproject.toml`` and "
#~ "access them here."
#~ msgstr ""

#~ msgid ""
#~ "To construct a ``ServerApp`` we define"
#~ " a ``server_fn()`` callback with an "
#~ "identical signature to that of "
#~ "``client_fn()`` but the return type is"
#~ " |serverappcomponents|_ as opposed to a "
#~ "|client|_ In this example we use "
#~ "the ``FedAvg`` strategy. To it we "
#~ "pass a randomly initialized model that"
#~ " will server as the global model "
#~ "to federated. Note that the value "
#~ "of ``input_dim`` is read from the "
#~ "run config. You can find the "
#~ "default value defined in the "
#~ "``pyproject.toml``."
#~ msgstr ""

#~ msgid ""
#~ "In this federated learning tutorial we"
#~ " will learn how to train simple "
#~ "MLP on MNIST using Flower and MLX."
#~ " It is recommended to create a "
#~ "virtual environment and run everything "
#~ "within a :doc:`virtualenv <contributor-how-"
#~ "to-set-up-a-virtual-env>`."
#~ msgstr ""

#~ msgid ""
#~ "Let's use `flwr new` to create a"
#~ " complete Flower+MLX project. It will "
#~ "generate all the files needed to "
#~ "run, by default with the Simulation "
#~ "Engine, a federation of 10 nodes "
#~ "using `FedAvg <https://flower.ai/docs/framework/ref-"
#~ "api/flwr.server.strategy.FedAvg.html#flwr.server.strategy.FedAvg>`_."
#~ " The dataset will be partitioned "
#~ "using Flower Dataset's `IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
#~ msgstr ""

#~ msgid ""
#~ "Then, run the command below. You "
#~ "will be prompted to select of the"
#~ " available templates (choose ``MLX``), give"
#~ " a name to your project, and "
#~ "type in your developer name:"
#~ msgstr ""

#~ msgid ""
#~ "You can also override the parameters "
#~ "defined in ``[tool.flwr.app.config]`` section "
#~ "in the ``pyproject.toml`` like this:"
#~ msgstr ""

#~ msgid ""
#~ "We will use `Flower Datasets "
#~ "<https://flower.ai/docs/datasets/>`_ to easily "
#~ "download and partition the `MNIST` "
#~ "dataset. In this example you'll make "
#~ "use of the `IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_"
#~ " to generate `num_partitions` partitions. "
#~ "You can choose `other partitioners "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.html>`_ available in "
#~ "Flower Datasets:"
#~ msgstr ""

#~ msgid ""
#~ "The main changes we have to make"
#~ " to use `MLX` with `Flower` will "
#~ "be found in the ``get_params()`` and "
#~ "``set_params()`` functions. Indeed, MLX "
#~ "doesn't provide an easy way to "
#~ "convert the model parameters into a "
#~ "list of ``np.array`` objects (the format"
#~ " we need for the serialization of "
#~ "the messages to work)."
#~ msgstr ""

#~ msgid "The way MLX stores its parameters is as follows:"
#~ msgstr ""

#~ msgid ""
#~ "Therefore, to get our list of "
#~ "``np.array`` objects, we need to extract"
#~ " each array and convert them into "
#~ "a NumPy array:"
#~ msgstr ""

#~ msgid ""
#~ "For the ``set_params()`` function, we "
#~ "perform the reverse operation. We "
#~ "receive a list of NumPy arrays and"
#~ " want to convert them into MLX "
#~ "parameters. Therefore, we iterate through "
#~ "pairs of parameters and assign them "
#~ "to the `weight` and `bias` keys of"
#~ " each layer dict:"
#~ msgstr ""

#~ msgid ""
#~ "The rest of the functionality is "
#~ "directly inspired by the centralized "
#~ "case. The ``fit()`` method in the "
#~ "client trains the model using the "
#~ "local dataset:"
#~ msgstr ""

#~ msgid ""
#~ "Here, after updating the parameters, we"
#~ " perform the training as in the "
#~ "centralized case, and return the new "
#~ "parameters."
#~ msgstr ""

#~ msgid "And for the ``evaluate()`` method of the client:"
#~ msgstr ""

#~ msgid ""
#~ "We also begin by updating the "
#~ "parameters with the ones sent by "
#~ "the server, and then we compute "
#~ "the loss and accuracy using the "
#~ "functions defined above. In the "
#~ "constructor of the ``FlowerClient`` we "
#~ "instantiate the `MLP` model as well "
#~ "as other components such as the "
#~ "optimizer."
#~ msgstr ""

#~ msgid "Putting everything together we have:"
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that "
#~ "``context`` enables you to get access"
#~ " to hyperparemeters defined in "
#~ "``pyproject.toml`` to configure the run. "
#~ "In this tutorial we access, among "
#~ "other hyperparameters, the ``local-epochs``"
#~ " setting to control the number of "
#~ "epochs a ``ClientApp`` will perform when"
#~ " running the ``fit()`` method."
#~ msgstr ""

#~ msgid ""
#~ "To construct a ``ServerApp``, we define"
#~ " a ``server_fn()`` callback with an "
#~ "identical signature to that of "
#~ "``client_fn()``, but the return type is"
#~ " `ServerAppComponents <https://flower.ai/docs/framework"
#~ "/ref-"
#~ "api/flwr.server.ServerAppComponents.html#serverappcomponents>`_ "
#~ "as opposed to `Client "
#~ "<https://flower.ai/docs/framework/ref-"
#~ "api/flwr.client.Client.html#client>`_. In this "
#~ "example we use the ``FedAvg`` strategy."
#~ msgstr ""

#~ msgid ""
#~ "Let's use `flwr new` to create a"
#~ " complete Flower+PyTorch project. It will"
#~ " generate all the files needed to "
#~ "run, by default with the Flower "
#~ "Simulation Engine, a federation of 10"
#~ " nodes using `FedAvg <ref-"
#~ "api/flwr.serverapp.FedAvg.html>`_. The dataset will"
#~ " be partitioned using Flower Dataset's "
#~ "`IidPartitioner <https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
#~ msgstr ""

#~ msgid ""
#~ "Then, run the command below. You "
#~ "will be prompted to select one of"
#~ " the available templates (choose ``PyTorch"
#~ " (Message API)``), give a name to "
#~ "your project, and type in your "
#~ "developer name:"
#~ msgstr ""

#~ msgid ""
#~ "By default, Flower Simulation Engine "
#~ "will be started and it will create"
#~ " a federation of 4 nodes using "
#~ "`FedAvg <https://flower.ai/docs/framework/ref-"
#~ "api/flwr.server.strategy.FedAvg.html#flwr.server.strategy.FedAvg>`_"
#~ " as the aggregation strategy. The "
#~ "dataset will be partitioned using Flower"
#~ " Dataset's `IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
#~ " To run the project, do:"
#~ msgstr ""

#~ msgid ""
#~ "Let's use ``flwr new`` to create a"
#~ " complete Flower+scikit-learn project. It"
#~ " will generate all the files needed"
#~ " to run, by default with the "
#~ "Flower Simulation Engine, a federation "
#~ "of 10 nodes using |fedavg|_ The "
#~ "dataset will be partitioned using "
#~ "|flowerdatasets|_'s |iidpartitioner|_"
#~ msgstr ""

#~ msgid ""
#~ "To perform the training and evaluation,"
#~ " we will make use of the "
#~ "``.fit()`` and ``.score()`` methods available"
#~ " in the ``LogisticRegression`` class."
#~ msgstr ""

#~ msgid ""
#~ "The main changes we have to make"
#~ " to use scikit-learn with Flower "
#~ "will be found in the "
#~ "``get_model_params()``, ``set_model_params()``, and "
#~ "``set_initial_params()`` functions. In "
#~ "``get_model_params()``, the coefficients and "
#~ "intercept of the logistic regression "
#~ "model are extracted and represented as"
#~ " a list of NumPy arrays. In "
#~ "``set_model_params()``, that's the opposite: "
#~ "given a list of NumPy arrays it"
#~ " applies them to an existing "
#~ "``LogisticRegression`` model. Finally, in "
#~ "``set_initial_params()``, we initialize the "
#~ "model parameters based on the MNIST "
#~ "dataset, which has 10 classes "
#~ "(corresponding to the 10 digits) and "
#~ "784 features (corresponding to the size"
#~ " of the MNIST image array, which "
#~ "is 28 × 28). Doing this is "
#~ "fairly easy in scikit-learn."
#~ msgstr ""

#~ msgid ""
#~ "The rest of the functionality is "
#~ "directly inspired by the centralized "
#~ "case:"
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that the "
#~ "``context`` enables you to get access"
#~ " to hyperparameters defined in your "
#~ "``pyproject.toml`` to configure the run. "
#~ "In this tutorial we access the "
#~ "`local-epochs` setting to control the "
#~ "number of epochs a ``ClientApp`` will"
#~ " perform when running the ``fit()`` "
#~ "method. You could define additional "
#~ "hyperparameters in ``pyproject.toml`` and "
#~ "access them here."
#~ msgstr ""

#~ msgid ""
#~ "To construct a ``ServerApp`` we define"
#~ " a ``server_fn()`` callback with an "
#~ "identical signature to that of "
#~ "``client_fn()`` but the return type is"
#~ " |serverappcomponents|_ as opposed to a "
#~ "|client|_ In this example we use "
#~ "the `FedAvg` strategy. To it we "
#~ "pass a zero-initialized model that "
#~ "will server as the global model to"
#~ " be federated. Note that the values"
#~ " of ``num-server-rounds``, ``penalty``, "
#~ "and ``local-epochs`` are read from "
#~ "the run config. You can find the"
#~ " default values defined in the "
#~ "``pyproject.toml``."
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated learning "
#~ "system in scikit-learn."
#~ msgstr ""

#~ msgid ""
#~ "Check the source code of the "
#~ "extended version of this tutorial in "
#~ "|quickstart_sklearn_link|_ in the Flower "
#~ "GitHub repository."
#~ msgstr ""

#~ msgid ""
#~ "Let's use `flwr new` to create a"
#~ " complete Flower+TensorFlow project. It "
#~ "will generate all the files needed "
#~ "to run, by default with the Flower"
#~ " Simulation Engine, a federation of "
#~ "10 nodes using `FedAvg "
#~ "<https://flower.ai/docs/framework/ref-"
#~ "api/flwr.server.strategy.FedAvg.html#flwr.server.strategy.FedAvg>`_."
#~ " The dataset will be partitioned "
#~ "using Flower Dataset's `IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
#~ msgstr ""

#~ msgid ""
#~ "With `TensorFlow`, we can use the "
#~ "built-in ``get_weights()`` and ``set_weights()``"
#~ " functions, which simplifies the "
#~ "implementation with `Flower`. The rest "
#~ "of the functionality in the ClientApp"
#~ " is directly inspired by the "
#~ "centralized case. The ``fit()`` method "
#~ "in the client trains the model "
#~ "using the local dataset. Similarly, the"
#~ " ``evaluate()`` method is used to "
#~ "evaluate the model received on a "
#~ "held-out validation set that the "
#~ "client might have:"
#~ msgstr ""

#~ msgid ""
#~ "Finally, we can construct a "
#~ "``ClientApp`` using the ``FlowerClient`` "
#~ "defined above by means of a "
#~ "``client_fn()`` callback. Note that the "
#~ "`context` enables you to get access "
#~ "to hyperparameters defined in your "
#~ "``pyproject.toml`` to configure the run. "
#~ "For example, in this tutorial we "
#~ "access the `local-epochs` setting to "
#~ "control the number of epochs a "
#~ "``ClientApp`` will perform when running "
#~ "the ``fit()`` method, in addition to "
#~ "`batch-size`. You could define "
#~ "additional hyperparameters in ``pyproject.toml`` "
#~ "and access them here."
#~ msgstr ""

#~ msgid ""
#~ "To construct a ``ServerApp`` we define"
#~ " a ``server_fn()`` callback with an "
#~ "identical signature to that of "
#~ "``client_fn()`` but the return type is"
#~ " `ServerAppComponents <https://flower.ai/docs/framework"
#~ "/ref-"
#~ "api/flwr.server.ServerAppComponents.html#serverappcomponents>`_ "
#~ "as opposed to a `Client "
#~ "<https://flower.ai/docs/framework/ref-"
#~ "api/flwr.client.Client.html#client>`_. In this "
#~ "example we use the `FedAvg`. To it"
#~ " we pass a randomly initialized model"
#~ " that will serve as the global "
#~ "model to federate."
#~ msgstr ""

#~ msgid ""
#~ "This example by default runs the "
#~ "Flower Simulation Engine, creating a "
#~ "federation of 10 nodes using `FedAvg "
#~ "<https://flower.ai/docs/framework/ref-"
#~ "api/flwr.server.strategy.FedAvg.html#flwr.server.strategy.FedAvg>`_"
#~ " as the aggregation strategy. The "
#~ "dataset will be partitioned using Flower"
#~ " Dataset's `IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_."
#~ " Let's run the project:"
#~ msgstr ""

#~ msgid ""
#~ "Check out this Federated Learning "
#~ "quickstart tutorial for using Flower "
#~ "with XGBoost to train classification "
#~ "models on trees."
#~ msgstr ""

#~ msgid "XGBoost"
#~ msgstr "XGBoost"

#~ msgid ""
#~ "EXtreme Gradient Boosting (**XGBoost**) is "
#~ "a robust and efficient implementation of"
#~ " gradient-boosted decision tree (**GBDT**),"
#~ " that maximises the computational "
#~ "boundaries for boosted tree methods. "
#~ "It's primarily designed to enhance both"
#~ " the performance and computational speed"
#~ " of machine learning models. In "
#~ "XGBoost, trees are constructed concurrently,"
#~ " unlike the sequential approach taken "
#~ "by GBDT."
#~ msgstr ""

#~ msgid ""
#~ "Often, for tabular data on medium-"
#~ "sized datasets with fewer than 10k "
#~ "training examples, XGBoost surpasses the "
#~ "results of deep learning techniques."
#~ msgstr ""

#~ msgid "Why Federated XGBoost?"
#~ msgstr "연합 학습이란 무엇입니까?"

#~ msgid ""
#~ "As the demand for data privacy and"
#~ " decentralized learning grows, there's an"
#~ " increasing requirement to implement "
#~ "federated XGBoost systems for specialised "
#~ "applications, like survival analysis and "
#~ "financial fraud detection."
#~ msgstr ""

#~ msgid ""
#~ "Federated learning ensures that raw data"
#~ " remains on the local device, making"
#~ " it an attractive approach for "
#~ "sensitive domains where data privacy is"
#~ " paramount. Given the robustness and "
#~ "efficiency of XGBoost, combining it with"
#~ " federated learning offers a promising "
#~ "solution for these specific challenges."
#~ msgstr ""

#~ msgid "Environment Setup"
#~ msgstr ""

#~ msgid ""
#~ "In this tutorial, we learn how to"
#~ " train a federated XGBoost model on"
#~ " the HIGGS dataset using Flower and"
#~ " the ``xgboost`` package to perform a"
#~ " binary classification task. We use a"
#~ " simple example (`full code xgboost-"
#~ "quickstart <https://github.com/adap/flower/tree/main/examples"
#~ "/xgboost-quickstart>`_) to demonstrate how "
#~ "federated XGBoost works, and then we "
#~ "dive into a more complex comprehensive"
#~ " example (`full code xgboost-comprehensive"
#~ " <https://github.com/adap/flower/tree/main/examples/xgboost-"
#~ "comprehensive>`_) to run various experiments."
#~ msgstr ""

#~ msgid ""
#~ "It is recommended to create a "
#~ "virtual environment and run everything "
#~ "within a :doc:`virtualenv <contributor-how-"
#~ "to-set-up-a-virtual-env>`."
#~ msgstr ""

#~ msgid ""
#~ "We first need to install Flower "
#~ "and Flower Datasets. You can do "
#~ "this by running :"
#~ msgstr ""

#~ msgid ""
#~ "Since we want to use ``xgboost`` "
#~ "package to build up XGBoost trees, "
#~ "let's go ahead and install ``xgboost``:"
#~ msgstr ""

#~ msgid ""
#~ "The ``local-epochs`` represents the "
#~ "number of iterations for local tree "
#~ "boost. We use CPU for the training"
#~ " in default. One can assign it "
#~ "to a GPU by setting ``tree_method`` "
#~ "to ``gpu_hist``. We use AUC as "
#~ "evaluation metric."
#~ msgstr ""

#~ msgid ""
#~ "This tutorial uses `Flower Datasets "
#~ "<https://flower.ai/docs/datasets/>`_ to easily "
#~ "download and partition the `HIGGS` "
#~ "dataset."
#~ msgstr ""

#~ msgid ""
#~ "In this example, we split the "
#~ "dataset into 20 partitions with uniform"
#~ " distribution (`IidPartitioner "
#~ "<https://flower.ai/docs/datasets/ref-"
#~ "api/flwr_datasets.partitioner.IidPartitioner.html#flwr_datasets.partitioner.IidPartitioner>`_)."
#~ " Then, we load the partition for "
#~ "the given client based on "
#~ "``partition_id``."
#~ msgstr ""

#~ msgid ""
#~ "Subsequently, we train/test split using "
#~ "the given partition (client's local "
#~ "data), and reformat data to DMatrix "
#~ "for the ``xgboost`` package."
#~ msgstr ""

#~ msgid ""
#~ "The functions of ``train_test_split`` and "
#~ "``transform_dataset_to_dmatrix`` are defined as "
#~ "below:"
#~ msgstr ""

#~ msgid ""
#~ "*Clients* are responsible for generating "
#~ "individual weight-updates for the model"
#~ " based on their local datasets. Let's"
#~ " first see how we define Flower "
#~ "client for XGBoost. We follow the "
#~ "general rule to define ``FlowerClient`` "
#~ "class inherited from ``fl.client.Client``."
#~ msgstr ""

#~ msgid ""
#~ "All required parameters defined above "
#~ "are passed to ``FlowerClient``'s constructor."
#~ msgstr ""

#~ msgid ""
#~ "Then, we override ``fit`` and "
#~ "``evaluate`` methods insides ``FlowerClient`` "
#~ "class as follows."
#~ msgstr ""

#~ msgid ""
#~ "In ``fit``, at the first round, we"
#~ " call ``xgb.train()`` to build up the"
#~ " first set of trees. From the "
#~ "second round, we load the global "
#~ "model sent from server to new "
#~ "build Booster object, and then update"
#~ " model weights on local training data"
#~ " with function ``_local_boost`` as follows:"
#~ msgstr ""

#~ msgid ""
#~ "In ``evaluate``, after loading the "
#~ "global model, we call ``bst.eval_set`` "
#~ "function to conduct evaluation on valid"
#~ " set. The AUC value will be "
#~ "returned."
#~ msgstr ""

#~ msgid ""
#~ "After the local training on clients, "
#~ "clients' model updates are sent to "
#~ "the *server*, which aggregates them to"
#~ " produce a better model. Finally, the"
#~ " *server* sends this improved model "
#~ "version back to each *client* to "
#~ "complete a federated round."
#~ msgstr ""

#~ msgid ""
#~ "In the file named ``server_app.py``, we"
#~ " define a strategy for XGBoost "
#~ "bagging aggregation:"
#~ msgstr ""

#~ msgid ""
#~ "An ``evaluate_metrics_aggregation`` function is "
#~ "defined to collect and wighted average"
#~ " the AUC values from clients. The "
#~ "``config_func`` function is to return "
#~ "the current FL round number to "
#~ "client's ``fit()`` and ``evaluate()`` methods."
#~ msgstr ""

#~ msgid "Tree-based Bagging Aggregation"
#~ msgstr ""

#~ msgid ""
#~ "You must be curious about how "
#~ "bagging aggregation works. Let's look "
#~ "into the details."
#~ msgstr ""

#~ msgid ""
#~ "In file ``flwr.server.strategy.fedxgb_bagging.py``, "
#~ "we define ``FedXgbBagging`` inherited from "
#~ "``flwr.server.strategy.FedAvg``. Then, we override"
#~ " the ``aggregate_fit``, ``aggregate_evaluate`` "
#~ "and ``evaluate`` methods as follows:"
#~ msgstr ""

#~ msgid ""
#~ "In ``aggregate_fit``, we sequentially "
#~ "aggregate the clients' XGBoost trees by"
#~ " calling ``aggregate()`` function:"
#~ msgstr ""

#~ msgid ""
#~ "In this function, we first fetch "
#~ "the number of trees and the number"
#~ " of parallel trees for the current"
#~ " and previous model by calling "
#~ "``_get_tree_nums``. Then, the fetched "
#~ "information will be aggregated. After "
#~ "that, the trees (containing model "
#~ "weights) are aggregated to generate a"
#~ " new tree model."
#~ msgstr ""

#~ msgid ""
#~ "After traversal of all clients' models,"
#~ " a new global model is generated, "
#~ "followed by serialisation, and sending "
#~ "the global model back to each "
#~ "client."
#~ msgstr ""

#~ msgid "Launch Federated XGBoost!"
#~ msgstr ""

#~ msgid ""
#~ "Congratulations! You've successfully built and"
#~ " run your first federated XGBoost "
#~ "system. The AUC values can be "
#~ "checked in ``History (metrics, distributed,"
#~ " evaluate)``. One can see that the"
#~ " average AUC increases over FL "
#~ "rounds."
#~ msgstr ""

#~ msgid ""
#~ "Check the full `source code "
#~ "<https://github.com/adap/flower/blob/main/examples/xgboost-"
#~ "quickstart>`_ for this example in "
#~ "``examples/xgboost-quickstart`` in the Flower"
#~ " GitHub repository."
#~ msgstr ""

#~ msgid "Comprehensive Federated XGBoost"
#~ msgstr ""

#~ msgid ""
#~ "Now that you know how federated "
#~ "XGBoost works with Flower, it's time "
#~ "to run some more comprehensive "
#~ "experiments by customising the experimental"
#~ " settings. In the xgboost-comprehensive "
#~ "example (`full code "
#~ "<https://github.com/adap/flower/tree/main/examples/xgboost-"
#~ "comprehensive>`_), we provide more options "
#~ "to define various experimental setups, "
#~ "including aggregation strategies, data "
#~ "partitioning and centralised / distributed "
#~ "evaluation. Let's take a look!"
#~ msgstr ""

#~ msgid "Cyclic Training"
#~ msgstr "중앙 집중식 훈련"

#~ msgid ""
#~ "In addition to bagging aggregation, we"
#~ " offer a cyclic training scheme, "
#~ "which performs FL in a client-"
#~ "by-client fashion. Instead of aggregating"
#~ " multiple clients, there is only one"
#~ " single client participating in the "
#~ "training per round in the cyclic "
#~ "training scenario. The trained local "
#~ "XGBoost trees will be passed to "
#~ "the next client as an initialised "
#~ "model for next round's boosting."
#~ msgstr ""

#~ msgid ""
#~ "To do this, we first customise a"
#~ " ``ClientManager`` in ``server_app.py``:"
#~ msgstr ""

#~ msgid ""
#~ "The customised ``ClientManager`` samples all"
#~ " available clients in each FL round"
#~ " based on the order of connection "
#~ "to the server. Then, we define a"
#~ " new strategy ``FedXgbCyclic`` in "
#~ "``flwr.server.strategy.fedxgb_cyclic.py``, in order "
#~ "to sequentially select only one client"
#~ " in given round and pass the "
#~ "received model to the next client."
#~ msgstr ""

#~ msgid ""
#~ "Unlike the original ``FedAvg``, we don't"
#~ " perform aggregation here. Instead, we "
#~ "just make a copy of the received"
#~ " client model as global model by "
#~ "overriding ``aggregate_fit``."
#~ msgstr ""

#~ msgid ""
#~ "Also, the customised ``configure_fit`` and "
#~ "``configure_evaluate`` methods ensure the "
#~ "clients to be sequentially selected "
#~ "given FL round:"
#~ msgstr ""

#~ msgid "Customised Data Partitioning"
#~ msgstr ""

#~ msgid ""
#~ "In ``task.py``, we use the "
#~ "``instantiate_fds`` function to instantiate "
#~ "Flower Datasets and the data partitioner"
#~ " based on the given ``partitioner_type``"
#~ " and ``num_partitions``. Currently, we "
#~ "provide four supported partitioner type "
#~ "to simulate the uniformity/non-uniformity "
#~ "in data quantity (uniform, linear, "
#~ "square, exponential)."
#~ msgstr ""

#~ msgid "Customised Centralised / Distributed Evaluation"
#~ msgstr "중앙 집중식 평가"

#~ msgid ""
#~ "To facilitate centralised evaluation, we "
#~ "define a function in ``server_app.py``:"
#~ msgstr ""

#~ msgid ""
#~ "This function returns an evaluation "
#~ "function, which instantiates a ``Booster`` "
#~ "object and loads the global model "
#~ "weights to it. The evaluation is "
#~ "conducted by calling ``eval_set()`` method,"
#~ " and the tested AUC value is "
#~ "reported."
#~ msgstr ""

#~ msgid ""
#~ "As for distributed evaluation on the "
#~ "clients, it's same as the quick-"
#~ "start example by overriding the "
#~ "``evaluate()`` method insides the "
#~ "``XgbClient`` class in ``client_app.py``."
#~ msgstr ""

#~ msgid "Arguments Explainer"
#~ msgstr "빌드 전달인자"

#~ msgid ""
#~ "We define all hyper-parameters under "
#~ "``[tool.flwr.app.config]`` entry in "
#~ "``pyproject.toml``:"
#~ msgstr ""

#~ msgid ""
#~ "On the server side, we allow user"
#~ " to specify training strategies / FL"
#~ " rounds / participating clients / "
#~ "clients for evaluation, and evaluation "
#~ "fashion. Note that with ``centralised-"
#~ "eval = true``, the sever will do"
#~ " centralised evaluation and all "
#~ "functionalities for client evaluation will "
#~ "be disabled."
#~ msgstr ""

#~ msgid ""
#~ "On the client side, we can define"
#~ " various options for client data "
#~ "partitioning. Besides, clients also have "
#~ "an option to conduct evaluation on "
#~ "centralised test set by setting "
#~ "``centralised-eval = true``, as well "
#~ "as an option to perform scaled "
#~ "learning rate based on the number "
#~ "of clients by setting ``scaled-lr "
#~ "= true``."
#~ msgstr ""

#~ msgid "Example Commands"
#~ msgstr "예시"

#~ msgid ""
#~ "To run bagging aggregation for 5 "
#~ "rounds evaluated on centralised test "
#~ "set:"
#~ msgstr ""

#~ msgid ""
#~ "To run cyclic training with linear "
#~ "partitioner type evaluated on centralised "
#~ "test set:"
#~ msgstr ""

#~ msgid ""
#~ "The full `code "
#~ "<https://github.com/adap/flower/blob/main/examples/xgboost-"
#~ "comprehensive/>`_ for this comprehensive "
#~ "example can be found in ``examples"
#~ "/xgboost-comprehensive`` in the Flower "
#~ "GitHub repository."
#~ msgstr ""

#~ msgid "Video Tutorial"
#~ msgstr "튜토리얼"

#~ msgid ""
#~ "The video shown below shows how to"
#~ " setup a XGBoost + Flower project "
#~ "using our previously recommended APIs. A"
#~ " new video tutorial will be released"
#~ " that shows the new APIs (as "
#~ "the content above does)"
#~ msgstr ""

#~ msgid ""
#~ "Aggregate custom evaluation results from "
#~ "federated clients in Flower using a "
#~ "strategy that applies weighted averaging "
#~ "for metrics like accuracy."
#~ msgstr ""

#~ msgid ""
#~ "The Flower server does not prescribe "
#~ "a way to aggregate evaluation results,"
#~ " but it enables the user to "
#~ "fully customize result aggregation."
#~ msgstr "Flower 서버는 평가 결과를 집계하는 방법을 규정하고 있지 않지만 사용자가 결과 집계를 완전히 사용자 지정할 수 있습니다."

#~ msgid "Aggregate Custom Evaluation Results"
#~ msgstr "사용자 지정 평가 결과 집계"

#~ msgid ""
#~ "The same ``Strategy``-customization approach "
#~ "can be used to aggregate custom "
#~ "evaluation results coming from individual "
#~ "clients. Clients can return custom "
#~ "metrics to the server by returning "
#~ "a dictionary:"
#~ msgstr ""
#~ "동일한 :code:`Strategy`-사용자 지정 방식을 사용하여 개별"
#~ " 클라이언트로부터 오는 사용자 지정 평가 결과를 집계할"
#~ " 수 있습니다. 클라이언트는 dictionary를 반환하여 사용자"
#~ " 지정 지표를 서버에 반환할 수 있습니다:"

#~ msgid ""
#~ "The server can then use a "
#~ "customized strategy to aggregate the "
#~ "metrics provided in these dictionaries:"
#~ msgstr "그런 다음 서버는 사용자 지정 전략을 사용하여 이러한 dictionaries에서 제공하는 메트릭을 집계할 수 있습니다:"

#~ msgid ""
#~ "Configure Flower clients by sending "
#~ "parameters from the server to control"
#~ " client-side hyperparameters using "
#~ "configuration dictionaries and strategies."
#~ msgstr ""

#~ msgid "Configuration values"
#~ msgstr "구성 값"

#~ msgid ""
#~ "``FitConfig`` and ``EvaluateConfig`` are "
#~ "dictionaries containing configuration values "
#~ "that the server sends to clients "
#~ "during federated learning rounds. These "
#~ "values must be of type ``Scalar``, "
#~ "which includes ``bool``, ``bytes``, ``float``,"
#~ " ``int``, or ``str`` (or equivalent "
#~ "types in different languages). Scalar is"
#~ " the value type directly supported by"
#~ " Flower for these configurations."
#~ msgstr ""

#~ msgid "For example, a ``FitConfig`` dictionary might look like this:"
#~ msgstr ""

#~ msgid ""
#~ "Flower serializes these configuration "
#~ "dictionaries (or *config dicts* for "
#~ "short) to their ProtoBuf representation, "
#~ "transports them to the client using "
#~ "gRPC, and then deserializes them back"
#~ " to Python dictionaries."
#~ msgstr ""
#~ "Flower는 이러한 구성 dictionaries(또는 줄여서 "
#~ "*config dict*)를 ProtoBuf 표현으로 직렬화하고, "
#~ "gRPC를 사용하여 클라이언트로 전송한 다음 다시 Python"
#~ " dictionaries로 역직렬화합니다."

#~ msgid ""
#~ "Currently, there is no support for "
#~ "directly sending collection types (e.g., "
#~ "``Set``, ``List``, ``Map``) as values in"
#~ " configuration dictionaries. To send "
#~ "collections, convert them to a supported"
#~ " type (e.g., JSON string) and decode"
#~ " on the client side."
#~ msgstr ""
#~ "현재 구성 사전에서 컬렉션 유형(예: ``Set``, "
#~ "``List``, ``Map``)을 값으로 직접 전송하는 기능은 "
#~ "지원되지 않습니다. 컬렉션을 지원되는 값 유형 중 "
#~ "하나로 변환한 다음 클라이언트 측에서 다시 변환하여 "
#~ "값으로 보내는 몇 가지 해결 방법이 있습니다."

#~ msgid "Example:"
#~ msgstr "예시"

#~ msgid "Configuration through Built-in Strategies"
#~ msgstr "기본 제공 전략을 통한 구성"

#~ msgid ""
#~ "Flower provides configuration options to "
#~ "control client behavior dynamically through"
#~ " ``FitConfig`` and ``EvaluateConfig``. These "
#~ "configurations allow server-side control "
#~ "over client-side parameters such as "
#~ "batch size, number of local epochs, "
#~ "learning rate, and evaluation settings, "
#~ "improving collaboration and experimentation."
#~ msgstr ""

#~ msgid "``FitConfig`` and ``EvaluateConfig``"
#~ msgstr "``eval_fn`` --> ``evaluate_fn``"

#~ msgid ""
#~ "``FitConfig`` and ``EvaluateConfig`` are "
#~ "dictionaries containing configuration values "
#~ "that the server sends to clients "
#~ "during federated learning rounds. These "
#~ "dictionaries enable the server to adjust"
#~ " client-side hyperparameters and monitor"
#~ " progress effectively."
#~ msgstr ""

#~ msgid "``FitConfig``"
#~ msgstr "``DISTRO``"

#~ msgid ""
#~ "``FitConfig`` specifies the hyperparameters "
#~ "for training rounds, such as the "
#~ "batch size, number of local epochs, "
#~ "and other parameters that influence "
#~ "training."
#~ msgstr ""

#~ msgid "For example, a ``fit_config`` callback might look like this:"
#~ msgstr ""

#~ msgid ""
#~ "You can then pass this ``fit_config``"
#~ " callback to a built-in strategy "
#~ "such as ``FedAvg``:"
#~ msgstr ""

#~ msgid ""
#~ "On the client side, the configuration"
#~ " is received in the ``fit`` method,"
#~ " where it can be read and used:"
#~ msgstr ""

#~ msgid "``EvaluateConfig``"
#~ msgstr ":code:`evaluate`"

#~ msgid ""
#~ "``EvaluateConfig`` specifies hyperparameters for "
#~ "the evaluation process, such as the "
#~ "batch size, evaluation frequency, or "
#~ "metrics to compute during evaluation."
#~ msgstr ""

#~ msgid "For example, an ``evaluate_config`` callback might look like this:"
#~ msgstr ""

#~ msgid ""
#~ "You can pass this ``evaluate_config`` "
#~ "callback to a built-in strategy "
#~ "like ``FedAvg``:"
#~ msgstr ""

#~ msgid ""
#~ "On the client side, the configuration"
#~ " is received in the ``evaluate`` "
#~ "method, where it can be used "
#~ "during the evaluation process:"
#~ msgstr ""

#~ msgid "Example: Sending Training Configurations"
#~ msgstr ""

#~ msgid ""
#~ "Imagine we want to send (a) the"
#~ " batch size, (b) the current global"
#~ " round, and (c) the number of "
#~ "local epochs. Our configuration function "
#~ "could look like this:"
#~ msgstr ""
#~ "간단한 예부터 시작하겠습니다. (a) 클라이언트가 사용해야 "
#~ "하는 배치 크기, (b) 현재 글로벌 연합 라운드,"
#~ " (c) 클라이언트 측에서 학습할 에포크 수를 전송하고"
#~ " 싶다고 가정해 보겠습니다. 구성 함수는 다음과 "
#~ "같습니다:"

#~ msgid ""
#~ "To use this function with a "
#~ "built-in strategy like ``FedAvg``, pass "
#~ "it to the ``FedAvg`` constructor "
#~ "(typically in your ``server_fn``):"
#~ msgstr ""

#~ msgid "Client-Side Configuration"
#~ msgstr "클라이언트 측 클리핑"

#~ msgid ""
#~ "On the client side, configurations are"
#~ " received as input to the ``fit`` "
#~ "and ``evaluate`` methods. For example:"
#~ msgstr ""

#~ msgid "Dynamic Configurations per Round"
#~ msgstr ""

#~ msgid ""
#~ "Configuration functions are called at "
#~ "the beginning of every round. This "
#~ "allows for dynamic adjustments based on"
#~ " progress. For example, you can "
#~ "increase the number of local epochs "
#~ "in later rounds:"
#~ msgstr ""

#~ msgid "Customizing Client Configurations"
#~ msgstr ""

#~ msgid ""
#~ "In some cases, it may be necessary"
#~ " to send different configurations to "
#~ "individual clients. To achieve this, you"
#~ " can create a custom strategy by "
#~ "extending a built-in one, such as"
#~ " ``FedAvg``:"
#~ msgstr ""

#~ msgid "Example: Client-Specific Configuration"
#~ msgstr ""

#~ msgid "Next, use this custom strategy as usual:"
#~ msgstr ""

#~ msgid "Summary of Enhancements"
#~ msgstr ""

#~ msgid ""
#~ "**Dynamic Configurations**: Enables per-round"
#~ " adjustments via functions."
#~ msgstr ""

#~ msgid "**Advanced Customization**: Supports client-specific strategies."
#~ msgstr ""

#~ msgid ""
#~ "**Client-Side Integration**: Configurations "
#~ "accessible in ``fit`` and ``evaluate``."
#~ msgstr ""

#~ msgid ""
#~ "By design, ClientApp_ objects are "
#~ "stateless. This means that the "
#~ "``ClientApp`` object is recreated each "
#~ "time a new ``Message`` is to be"
#~ " processed. This behaviour is identical "
#~ "with Flower's Simulation Engine and "
#~ "Deployment Engine. For the former, it"
#~ " allows us to simulate the running"
#~ " of a large number of nodes on"
#~ " a single machine or across multiple"
#~ " machines. For the latter, it enables"
#~ " each ``SuperNode`` to be part of "
#~ "multiple runs, each running a different"
#~ " ``ClientApp``."
#~ msgstr ""

#~ msgid ""
#~ "When a ``ClientApp`` is executed it "
#~ "receives a Context_. This context is "
#~ "unique for each ``ClientApp``, meaning "
#~ "that subsequent executions of the same"
#~ " ``ClientApp`` from the same node "
#~ "will receive the same ``Context`` "
#~ "object. In the ``Context``, the "
#~ "``.state`` attribute can be used to "
#~ "store information that you would like"
#~ " the ``ClientApp`` to have access to"
#~ " for the duration of the run. "
#~ "This could be anything from intermediate"
#~ " results such as the history of "
#~ "training losses (e.g. as a list of"
#~ " ``float`` values with a new entry"
#~ " appended each time the ``ClientApp`` "
#~ "is executed), certain parts of the "
#~ "model that should persist on the "
#~ "client side, or some other arbitrary "
#~ "Python objects. These items would need"
#~ " to be serialized before saving them"
#~ " into the context."
#~ msgstr ""

#~ msgid ""
#~ "This section will demonstrate how to "
#~ "save metrics such as accuracy/loss "
#~ "values to the Context_ so they can"
#~ " be used in subsequent executions of"
#~ " the ``ClientApp``. If your ``ClientApp``"
#~ " makes use of NumPyClient_ then "
#~ "entire object is also re-created "
#~ "for each call to methods like "
#~ "``fit()`` or ``evaluate()``."
#~ msgstr ""

#~ msgid ""
#~ "Let's begin with a simple setting "
#~ "in which ``ClientApp`` is defined as "
#~ "follows. The ``evaluate()`` method only "
#~ "generates a random number and prints "
#~ "it."
#~ msgstr ""

#~ msgid ""
#~ "Let's say we want to save that "
#~ "randomly generated integer and append it"
#~ " to a list that persists in the"
#~ " context. To do that, you'll need "
#~ "to do two key things:"
#~ msgstr ""

#~ msgid "Make the ``context.state`` reachable within your client class"
#~ msgstr ""

#~ msgid ""
#~ "Initialise the appropriate record type "
#~ "(in this example we use ConfigRecord_)"
#~ " and save/read your entry when "
#~ "required."
#~ msgstr ""

#~ msgid ""
#~ "If you run the app, you'll see "
#~ "an output similar to the one "
#~ "below. See how after each round "
#~ "the ``n_val`` entry in the context "
#~ "gets one additional integer ? Note "
#~ "that the order in which the "
#~ "``ClientApp`` logs these messages might "
#~ "differ slightly between rounds."
#~ msgstr ""

#~ msgid ""
#~ "Using ConfigRecord_ or MetricRecord_ to "
#~ "save \"simple\" components is fine "
#~ "(e.g., float, integer, boolean, string, "
#~ "bytes, and lists of these types. "
#~ "Note that MetricRecord_ only supports "
#~ "float, integer, and lists of these "
#~ "types) Flower has a specific type "
#~ "of record, a ArrayRecord_, for storing"
#~ " model parameters or more generally "
#~ "data arrays."
#~ msgstr ""

#~ msgid ""
#~ "Elements stored in a ``ArrayRecord`` are"
#~ " of type Array_, which is a "
#~ "data structure that holds ``bytes`` and"
#~ " metadata that can be used for "
#~ "deserialization. Let's see how to create"
#~ " an ``Array`` from a NumPy array "
#~ "and insert it into a ``ArrayRecord``."
#~ msgstr ""

#~ msgid ""
#~ "To extract the data in a "
#~ "``ArrayRecord``, you just need to "
#~ "deserialize the array if interest. For"
#~ " example, following the example above:"
#~ msgstr ""

#~ msgid ""
#~ "Let say now you want to apply "
#~ "the parameters stored in your context"
#~ " to a new instance of the model"
#~ " (as it happens each time a "
#~ "``ClientApp`` is executed). You will "
#~ "need to:"
#~ msgstr ""

#~ msgid ""
#~ "And that's it! Recall that even "
#~ "though this example shows how to "
#~ "store the entire ``state_dict`` in a "
#~ "``ArrayRecord``, you can just save part"
#~ " of it. The process would be "
#~ "identical, but you might need to "
#~ "adjust how it is loaded into an"
#~ " existing model using PyTorch APIs."
#~ msgstr ""

#~ msgid ""
#~ "A full introduction to federated "
#~ "learning with PyTorch and Flower can "
#~ "be found in :doc:`Quickstart PyTorch "
#~ "<tutorial-quickstart-pytorch>`. This how-to"
#~ " guide varies only a few details "
#~ "in ``task.py``. FedBN requires a model"
#~ " architecture (defined in class ``Net()``)"
#~ " that uses Batch Normalization layers:"
#~ msgstr ""

#~ msgid ""
#~ "To adopt FedBN, only the "
#~ "``get_parameters`` and ``set_parameters`` functions"
#~ " in ``task.py`` need to be revised."
#~ " FedBN only changes the client-side"
#~ " by excluding batch normalization "
#~ "parameters from being exchanged with the"
#~ " server."
#~ msgstr ""

#~ msgid "To test the new appraoch, run the project again:"
#~ msgstr ""

#~ msgid ""
#~ "The strategy abstraction enables "
#~ "implementation of fully custom strategies. "
#~ "A strategy is basically the federated"
#~ " learning algorithm that runs on the"
#~ " server. Strategies decide how to "
#~ "sample clients, how to configure clients"
#~ " for training, how to aggregate "
#~ "updates, and how to evaluate models. "
#~ "Flower provides a few built-in "
#~ "strategies which are based on the "
#~ "same API described below."
#~ msgstr ""
#~ "전략 추상화를 통해 완전한 맞춤형 전략을 구현할 수"
#~ " 있습니다. 전략은 기본적으로 서버에서 실행되는 연합 "
#~ "학습 알고리즘입니다. 전략은 클라이언트를 샘플링하는 방법, "
#~ "학습을 위해 클라이언트를 구성하는 방법, 업데이트를 집계하는"
#~ " 방법, 모델을 평가하는 방법을 결정합니다. Flower는 "
#~ "아래에 설명된 것과 동일한 API를 기반으로 하는 "
#~ "몇 가지 기본 제공 전략을 제공합니다."

#~ msgid ""
#~ "The strategy abstraction defines a few"
#~ " abstract methods that need to be "
#~ "implemented:"
#~ msgstr "전략 추상화에서는 구현해야 하는 몇 가지 추상적인 메서드를 정의합니다:"

#~ msgid ""
#~ "Creating a new strategy means "
#~ "implementing a new ``class`` (derived "
#~ "from the abstract base class "
#~ "``Strategy``) that implements for the "
#~ "previously shown abstract methods:"
#~ msgstr ""
#~ "새 전략을 생성한다는 것은 이전에 표시된 추상 "
#~ "메서드에 대해 구현하는 새로운 :code:`class`(추상 기본 "
#~ "클래스 :code:`Strategy`에서 파생됨)를 구현하는 것을 "
#~ "의미합니다:"

#~ msgid "The Flower server calls these methods in the following order:"
#~ msgstr "Flower 서버는 다음 순서로 이러한 메서드를 호출합니다:"

#~ msgid "The following sections describe each of those methods in more detail."
#~ msgstr "다음 섹션에서는 이러한 각 방법에 대해 자세히 설명합니다."

#~ msgid "The ``initialize_parameters`` method"
#~ msgstr ":code:`initialize_parameters` 메서드"

#~ msgid ""
#~ "``initialize_parameters`` is called only once,"
#~ " at the very beginning of an "
#~ "execution. It is responsible for "
#~ "providing the initial global model "
#~ "parameters in a serialized form (i.e.,"
#~ " as a ``Parameters`` object)."
#~ msgstr ""
#~ "code:`initialize_parameters`는 실행을 처음 시작할 때 "
#~ "한 번만 호출됩니다. 이 함수는 초기 전역 모델"
#~ " 파라미터를 직렬화된 형식(즉, :code:`Parameters` 객체)으로"
#~ " 제공하는 역할을 합니다."

#~ msgid ""
#~ "Built-in strategies return user-provided"
#~ " initial parameters. The following example"
#~ " shows how initial parameters can be"
#~ " passed to ``FedAvg``:"
#~ msgstr ""
#~ "기본 제공 전략은 사용자가 제공한 초기 매개 변수를"
#~ " 반환합니다. 다음 예는 초기 매개 변수를 "
#~ ":code:`FedAvg`에 전달하는 방법을 보여줍니다:"

#~ msgid ""
#~ "The Flower server will call "
#~ "``initialize_parameters``, which either returns "
#~ "the parameters that were passed to "
#~ "``initial_parameters``, or ``None``. If no "
#~ "parameters are returned from "
#~ "``initialize_parameters`` (i.e., ``None``), the "
#~ "server will randomly select one client"
#~ " and ask it to provide its "
#~ "parameters. This is a convenience "
#~ "feature and not recommended in practice,"
#~ " but it can be useful for "
#~ "prototyping. In practice, it is "
#~ "recommended to always use server-side"
#~ " parameter initialization."
#~ msgstr ""
#~ "Flower 서버는 :code:`initialize_parameters`를 호출하여 "
#~ ":code:`initial_parameters`에 전달된 파라미터를 반환하거나 "
#~ ":code:`None`을 반환합니다. :code:`initial_parameters`에서 "
#~ "반환되는 매개변수가 없는 경우(즉, :code:`None`) 서버는"
#~ " 무작위로 클라이언트 하나를 선택하여 해당 클라이언트에 "
#~ "매개변수를 제공하도록 요청합니다. 이는 편의 기능이며 실제로는"
#~ " 권장하지 않지만 프로토타이핑에는 유용할 수 있습니다. "
#~ "실제로는 항상 서버 측 매개변수 초기화를 사용하는 "
#~ "것이 좋습니다."

#~ msgid ""
#~ "Server-side parameter initialization is "
#~ "a powerful mechanism. It can be "
#~ "used, for example, to resume training"
#~ " from a previously saved checkpoint. "
#~ "It is also the fundamental capability"
#~ " needed to implement hybrid approaches, "
#~ "for example, to fine-tune a "
#~ "pre-trained model using federated learning."
#~ msgstr ""
#~ "서버 측 파라미터 초기화는 강력한 메커니즘입니다. 예를 "
#~ "들어 이전에 저장한 체크포인트에서 학습을 재개하는 데 "
#~ "사용할 수 있습니다. 또한 연합 학습을 사용하여 "
#~ "사전 학습된 모델을 미세 조정하는 등 하이브리드 "
#~ "접근 방식을 구현하는 데 필요한 기본 기능입니다."

#~ msgid ""
#~ "Use the ``client_manager`` to randomly "
#~ "sample all (or a subset of) "
#~ "available clients (each represented as a"
#~ " ``ClientProxy`` object)"
#~ msgstr ""
#~ ":code:`client_manager`를 사용하여 사용 가능한 모든 "
#~ "클라이언트(또는 그 하위 집합)를 무작위로 샘플링합니다(각각 "
#~ ":code:`ClientProxy` 개체로 표시됨)"

#~ msgid ""
#~ "Pair each ``ClientProxy`` with the same"
#~ " ``FitIns`` holding the current global "
#~ "model ``parameters`` and ``config`` dict"
#~ msgstr ""
#~ "각 :code:`ClientProxy`를 현재 글로벌 모델 "
#~ ":code:`parameters` 및 :code:`config` dict를 보유한"
#~ " 동일한 :code:`FitIns`와 쌍을 이룹니다"

#~ msgid ""
#~ "More sophisticated implementations can use "
#~ "``configure_fit`` to implement custom client"
#~ " selection logic. A client will only"
#~ " participate in a round if the "
#~ "corresponding ``ClientProxy`` is included in"
#~ " the list returned from ``configure_fit``."
#~ msgstr ""
#~ "보다 정교한 구현은 :code:`configure_fit`을 사용하여 "
#~ "사용자 지정 클라이언트 선택 로직을 구현할 수 "
#~ "있습니다. 클라이언트는 :code:`configure_fit`에서 반환된 목록에"
#~ " 해당 :code:`ClientProxy`가 포함된 경우에만 라운드에 "
#~ "참여합니다."

#~ msgid ""
#~ "The structure of this return value "
#~ "provides a lot of flexibility to "
#~ "the user. Since instructions are defined"
#~ " on a per-client basis, different "
#~ "instructions can be sent to each "
#~ "client. This enables custom strategies "
#~ "to train, for example, different models"
#~ " on different clients, or use "
#~ "different hyperparameters on different clients"
#~ " (via the ``config`` dict)."
#~ msgstr ""
#~ "이 반환 값의 구조는 사용자에게 많은 유연성을 "
#~ "제공합니다. instructions은 클라이언트별로 정의되므로 각 "
#~ "클라이언트에 서로 다른 명령어를 전송할 수 있습니다. "
#~ "이를 통해 예를 들어 클라이언트마다 다른 모델을 "
#~ "학습시키거나 클라이언트마다 다른 하이퍼파라미터를 사용하는 사용자 "
#~ "지정 전략을 사용할 수 있습니다(:code:`config` dict를"
#~ " 통해)."

#~ msgid ""
#~ "Of course, failures can happen, so "
#~ "there is no guarantee that the "
#~ "server will get results from all "
#~ "the clients it sent instructions to "
#~ "(via ``configure_fit``). ``aggregate_fit`` therefore"
#~ " receives a list of ``results``, but"
#~ " also a list of ``failures``."
#~ msgstr ""
#~ "물론 실패가 발생할 수 있으므로 서버가 명령을 보낸"
#~ " 모든 클라이언트로부터 결과를 얻을 수 있다는 보장은"
#~ " 없습니다(:code:`configure_fit`을 통해). 따라서 "
#~ ":code:`aggregate_fit`은 :code:`results` 목록뿐만 아니라 "
#~ ":code:`failures` 목록도 받습니다."

#~ msgid ""
#~ "``aggregate_fit`` returns an optional "
#~ "``Parameters`` object and a dictionary "
#~ "of aggregated metrics. The ``Parameters`` "
#~ "return value is optional because "
#~ "``aggregate_fit`` might decide that the "
#~ "results provided are not sufficient for"
#~ " aggregation (e.g., too many failures)."
#~ msgstr ""
#~ "code:`aggregate_fit`은 선택적 :code:`Parameters` 개체와 "
#~ "집계된 메트릭의 dictionary를 반환합니다. :code:`Parameters`"
#~ " 반환 값은 :code:`aggregate_fit`이 제공된 결과가 "
#~ "집계에 충분하지 않다고 판단할 수 있으므로(예: 실패 "
#~ "수가 너무 많음) 선택 사항입니다."

#~ msgid ""
#~ "The return value is a list of "
#~ "tuples, each representing the instructions "
#~ "that will be sent to a particular"
#~ " client. Strategy implementations usually "
#~ "perform the following steps in "
#~ "``configure_evaluate``:"
#~ msgstr ""
#~ "반환 값은 튜플 목록으로, 각 튜플은 특정 "
#~ "클라이언트로 전송될 명령어를 나타냅니다. 전략 구현은 "
#~ "일반적으로 :code:`configure_evaluate`에서 다음 단계를 "
#~ "수행합니다:"

#~ msgid ""
#~ "Pair each ``ClientProxy`` with the same"
#~ " ``EvaluateIns`` holding the current global"
#~ " model ``parameters`` and ``config`` dict"
#~ msgstr ""
#~ "각 :code:`ClientProxy`를 현재 글로벌 모델 "
#~ ":code:`parameters` 및 :code:`config` dict를 보유한"
#~ " 동일한 :code:`EvaluateIns`와 쌍을 이룹니다"

#~ msgid ""
#~ "More sophisticated implementations can use "
#~ "``configure_evaluate`` to implement custom "
#~ "client selection logic. A client will"
#~ " only participate in a round if "
#~ "the corresponding ``ClientProxy`` is included"
#~ " in the list returned from "
#~ "``configure_evaluate``."
#~ msgstr ""
#~ "보다 정교한 구현은 :code:`configure_evaluate`를 사용하여"
#~ " 사용자 지정 클라이언트 선택 로직을 구현할 수 "
#~ "있습니다. 클라이언트는 :code:`configure_evaluate`에서 반환된 "
#~ "목록에 해당 :code:`ClientProxy`가 포함된 경우에만 "
#~ "라운드에 참여합니다."

#~ msgid ""
#~ "The structure of this return value "
#~ "provides a lot of flexibility to "
#~ "the user. Since instructions are defined"
#~ " on a per-client basis, different "
#~ "instructions can be sent to each "
#~ "client. This enables custom strategies "
#~ "to evaluate, for example, different "
#~ "models on different clients, or use "
#~ "different hyperparameters on different clients"
#~ " (via the ``config`` dict)."
#~ msgstr ""
#~ "이 반환 값의 구조는 사용자에게 많은 유연성을 "
#~ "제공합니다. 명령어는 클라이언트별로 정의되므로 각 클라이언트에 "
#~ "서로 다른 명령어를 전송할 수 있습니다. 이를 통해"
#~ " 사용자 지정 전략을 통해 예를 들어 클라이언트마다"
#~ " 다른 모델을 평가하거나 클라이언트마다 다른 하이퍼파라미터를 "
#~ "사용할 수 있습니다(:code:`config` dict를 통해)."

#~ msgid ""
#~ "Of course, failures can happen, so "
#~ "there is no guarantee that the "
#~ "server will get results from all "
#~ "the clients it sent instructions to "
#~ "(via ``configure_evaluate``). ``aggregate_evaluate`` "
#~ "therefore receives a list of "
#~ "``results``, but also a list of "
#~ "``failures``."
#~ msgstr ""
#~ "물론 실패가 발생할 수 있으므로 서버가 명령을 보낸"
#~ " 모든 클라이언트로부터 결과를 얻을 수 있다는 보장은"
#~ " 없습니다(:code:`configure_evaluate`를 통해). 따라서 "
#~ ":code:`aggregate_evaluate`는 :code:`results` 목록뿐만 아니라"
#~ " :code:`failures` 목록도 받습니다."

#~ msgid ""
#~ "``aggregate_evaluate`` returns an optional "
#~ "``float`` (loss) and a dictionary of "
#~ "aggregated metrics. The ``float`` return "
#~ "value is optional because "
#~ "``aggregate_evaluate`` might decide that the"
#~ " results provided are not sufficient "
#~ "for aggregation (e.g., too many "
#~ "failures)."
#~ msgstr ""
#~ "code:`aggregate_evaluate`는 선택적 :code:`float`(손실)와 "
#~ "집계된 메트릭의 dictionary를 반환합니다. code:`float` "
#~ "반환 값은 :code:`aggregate_evaluate`가 제공된 결과가 "
#~ "집계에 충분하지 않다고 판단할 수 있으므로(예: 실패 "
#~ "수가 너무 많음) 선택 사항입니다."

#~ msgid ""
#~ "``evaluate`` is responsible for evaluating "
#~ "model parameters on the server-side. "
#~ "Having ``evaluate`` in addition to "
#~ "``configure_evaluate``/``aggregate_evaluate`` enables "
#~ "strategies to perform both servers-side"
#~ " and client-side (federated) evaluation."
#~ msgstr ""
#~ ":code:`evaluate`는 서버 측에서 모델 매개변수를 평가하는"
#~ " 역할을 담당합니다. "
#~ "code:`configure_evaluate`/:code:`aggregate_evaluate`와 함께 "
#~ ":code:`evaluate`를 사용하면 서버 측과 클라이언트 "
#~ "측(federated) 평가를 모두 수행할 수 있는 전략을"
#~ " 사용할 수 있습니다."

#~ msgid ""
#~ "The return value is again optional "
#~ "because the strategy might not need "
#~ "to implement server-side evaluation or"
#~ " because the user-defined ``evaluate`` "
#~ "method might not complete successfully "
#~ "(e.g., it might fail to load the"
#~ " server-side evaluation data)."
#~ msgstr ""
#~ "반환 값은 전략에서 서버 측 평가를 구현할 필요가"
#~ " 없거나 사용자 정의 :code:`evaluate` 메서드가 "
#~ "성공적으로 완료되지 않을 수 있기 때문에(예: 서버 "
#~ "측 평가 데이터를 로드하지 못할 수 있음) 다시"
#~ " 선택 사항으로 설정할 수 있습니다."

#~ msgid "Model Checkpointing"
#~ msgstr "모델 체크포인트"

#~ msgid ""
#~ "Model updates can be persisted on "
#~ "the server-side by customizing "
#~ "``Strategy`` methods. Implementing custom "
#~ "strategies is always an option, but "
#~ "for many cases it may be more "
#~ "convenient to simply customize an "
#~ "existing strategy. The following code "
#~ "example defines a new ``SaveModelStrategy``"
#~ " which customized the existing built-"
#~ "in ``FedAvg`` strategy. In particular, "
#~ "it customizes ``aggregate_fit`` by calling "
#~ "``aggregate_fit`` in the base class "
#~ "(``FedAvg``). It then continues to save"
#~ " returned (aggregated) weights before it"
#~ " returns those aggregated weights to "
#~ "the caller (i.e., the server):"
#~ msgstr ""
#~ ":code:`Strategy` 메소드를 사용자 지정하여 서버 측에서"
#~ " 모델 업데이트를 지속할 수 있습니다. 사용자 지정"
#~ " 전략을 구현하는 것은 항상 옵션이지만 대부분의 경우"
#~ " 기존 전략을 간단히 사용자 지정하는 것이 더 "
#~ "편리할 수 있습니다. 다음 코드 예시는 기존의 기본"
#~ " 제공 :code:`FedAvg` 전략을 사용자 지정한 새로운"
#~ " :code:`SaveModelStrategy`를 정의합니다. 특히, 기본 "
#~ "클래스(:code:`FedAvg`)에서 :code:`aggregate_fit`을 호출하여 "
#~ ":code:`aggregate_fit`을 사용자 지정합니다. 그런 다음 "
#~ "호출자(즉, 서버)에게 집계된 가중치를 반환하기 전에 "
#~ "반환된(집계된) 가중치를 계속 저장합니다:"

#~ msgid "Save and Load PyTorch Checkpoints"
#~ msgstr "파이토치 체크포인트 저장 및 로드"

#~ msgid ""
#~ "Similar to the previous example but "
#~ "with a few extra steps, we'll show"
#~ " how to store a PyTorch checkpoint"
#~ " we'll use the ``torch.save`` function. "
#~ "Firstly, ``aggregate_fit`` returns a "
#~ "``Parameters`` object that has to be "
#~ "transformed into a list of NumPy "
#~ "``ndarray``'s, then those are transformed "
#~ "into the PyTorch ``state_dict`` following "
#~ "the ``OrderedDict`` class structure."
#~ msgstr ""
#~ "이전 예제와 비슷하지만 몇 가지 단계가 추가되어 "
#~ "``torch.save`` 함수를 사용하여 파이토치 체크포인트를 저장하는"
#~ " 방법을 보여드리겠습니다. 먼저, ``aggregate_fit``은 "
#~ "``Parameters`` 객체를 반환하는데, 이 객체는 NumPy"
#~ " ``ndarray``의 목록으로 변환되어야 하며, "
#~ "``OrderedDict`` 클래스 구조에 따라 파이토치 "
#~ "``state_dict``로 변환됩니다."

#~ msgid ""
#~ "To load your progress, you simply "
#~ "append the following lines to your "
#~ "code. Note that this will iterate "
#~ "over all saved checkpoints and load "
#~ "the latest one:"
#~ msgstr ""
#~ "진행 상황을 로드하려면 코드에 다음 줄을 추가하기만 "
#~ "하면 됩니다. 이렇게 하면 저장된 모든 체크포인트를 "
#~ "반복하고 최신 체크포인트를 로드합니다:"

#~ msgid ""
#~ "Return/use this object of type "
#~ "``Parameters`` wherever necessary, such as "
#~ "in the ``initial_parameters`` when defining"
#~ " a ``Strategy``."
#~ msgstr "``전략``을 정의할 때 ``초기_파라미터``와 같이 필요한 경우 ``파라미터`` 유형의 이 객체를 반환/사용합니다."

#~ msgid ""
#~ "Alternatively, we can save and load "
#~ "the model updates during evaluation "
#~ "phase by overriding ``evaluate()`` or "
#~ "``aggregate_evaluate()`` method of the "
#~ "strategy (``FedAvg``). Checkout the details"
#~ " in `Advanced PyTorch Example "
#~ "<https://github.com/adap/flower/tree/main/examples/advanced-"
#~ "pytorch>`_ and `Advanced TensorFlow Example"
#~ " <https://github.com/adap/flower/tree/main/examples/advanced-"
#~ "tensorflow>`_."
#~ msgstr ""

#~ msgid ""
#~ "If you define functions to handle "
#~ "messages using decorators instead of "
#~ "``client_fn``, e.g., ``@app.train()``, you do"
#~ " not need to pass the ``client_fn``"
#~ " argument."
#~ msgstr ""

#~ msgid ""
#~ "To make the ``ServerApp`` use this "
#~ "strategy, pass a ``server_fn`` function "
#~ "to the ``ServerApp`` constructor. The "
#~ "``server_fn`` function should return a "
#~ "``ServerAppComponents`` object that contains "
#~ "the strategy instance and a "
#~ "``ServerConfig`` instance."
#~ msgstr ""

#~ msgid ""
#~ "Both ``Strategy`` and ``ServerConfig`` classes"
#~ " can be configured with parameters. "
#~ "The ``Context`` object passed to "
#~ "``server_fn`` contains the values specified"
#~ " in the ``[tool.flwr.app.config]`` table in"
#~ " your ``pyproject.toml`` (a snippet is "
#~ "shown below). To access these values,"
#~ " use ``context.run_config``."
#~ msgstr ""

#~ msgid ""
#~ "Existing strategies provide several ways "
#~ "to customize their behavior. Callback "
#~ "functions allow strategies to call "
#~ "user-provided code during execution. This"
#~ " approach enables you to modify the"
#~ " strategy's partial behavior without "
#~ "rewriting the whole class from zero."
#~ msgstr ""
#~ "기존 전략은 동작을 사용자 지정하는 여러 가지 "
#~ "방법을 제공합니다. 콜백 함수를 사용하면 전략이 실행 "
#~ "중에 사용자가 제공한 코드를 호출할 수 있습니다."

#~ msgid "Configuring client fit and client evaluate"
#~ msgstr "클라이언트 적합성 및 클라이언트 평가 구성"

#~ msgid ""
#~ "The server can pass new configuration"
#~ " values to the client each round "
#~ "by providing a function to "
#~ "``on_fit_config_fn``. The provided function "
#~ "will be called by the strategy and"
#~ " must return a dictionary of "
#~ "configuration key value pairs that will"
#~ " be sent to the client. It must"
#~ " return a dictionary of arbitrary "
#~ "configuration values ``client.fit`` and "
#~ "``client.evaluate`` functions during each "
#~ "round of federated learning."
#~ msgstr ""
#~ "서버는 매 라운드마다 새로운 설정 값을 클라이언트에 "
#~ "전달하기 위해 :code:`on_fit_config_fn`에 함수를 제공할 "
#~ "수 있습니다. 제공된 함수는 전략에 의해 호출되며 "
#~ "클라이언트에 전송될 구성 키 값 쌍의 dictionary를"
#~ " 반환해야 합니다. 연합 학습의 각 라운드 동안 "
#~ "임의의 구성 값 dictionary인 :code:`client.fit` "
#~ "및 :code:`client.evaluate` 함수를 반환해야 합니다."

#~ msgid ""
#~ "The ``on_fit_config_fn`` can be used to"
#~ " pass arbitrary configuration values from"
#~ " server to client and potentially "
#~ "change these values each round, for "
#~ "example, to adjust the learning rate."
#~ " The client will receive the "
#~ "dictionary returned by the "
#~ "``on_fit_config_fn`` in its own "
#~ "``client.fit()`` function. And while the "
#~ "values can be also passed directly "
#~ "via the context this function can "
#~ "be a place to implement finer "
#~ "control over the `fit` behaviour that"
#~ " may not be achieved by the "
#~ "context, which sets fixed values."
#~ msgstr ""
#~ ":code:`on_fit_config_fn`은 서버에서 클라이언트로 임의의 구성"
#~ " 값을 전달하고, 예를 들어 학습 속도를 조정하기 "
#~ "위해 매 라운드마다 이 값을 잠재적으로 변경하는 데"
#~ " 사용할 수 있습니다. 클라이언트는 자체 "
#~ ":code:`client.fit()` 함수에서 :code:`on_fit_config_fn`이 "
#~ "반환한 dictionary를 받습니다."

#~ msgid ""
#~ "Similar to ``on_fit_config_fn``, there is "
#~ "also ``on_evaluate_config_fn`` to customize "
#~ "the configuration sent to "
#~ "``client.evaluate()``"
#~ msgstr ""
#~ ":code:`on_fit_config_fn`과 유사하게, :code:`client.evaluate()`로"
#~ " 전송되는 구성을 사용자 지정하는 "
#~ ":code:`on_evaluate_config_fn`도 있습니다"

#~ msgid "Configuring server-side evaluation"
#~ msgstr "서버 측 평가 구성"

#~ msgid ""
#~ "Server-side evaluation can be enabled"
#~ " by passing an evaluation function to"
#~ " ``evaluate_fn``."
#~ msgstr "서버 측 평가는 :code:`evaluate_fn`에 평가 함수를 전달하여 활성화할 수 있습니다."

#~ msgid ""
#~ "Writing a fully custom strategy is "
#~ "a bit more involved, but it "
#~ "provides the most flexibility. Read the"
#~ " `Implementing Strategies <how-to-"
#~ "implement-strategies.html>`_ guide to learn "
#~ "more."
#~ msgstr ""
#~ "완전한 사용자 지정 전략을 작성하는 것은 조금 더"
#~ " 복잡하지만 유연성이 가장 뛰어납니다. 자세한 내용은 "
#~ "`Implementing Strategies <how-to-implement-"
#~ "strategies.html>`_ 가이드를 참조하세요."

#~ msgid ""
#~ "Number of nodes to keep before "
#~ "averaging (MultiKrum). Defaults to 0, in"
#~ " that case classical Krum is applied."
#~ msgstr ""

#~ msgid ""
#~ "`Charles Beauville`, `Chong Shen Ng`, "
#~ "`Daniel J. Beutel`, `Heng Pan`, "
#~ "`Javier`, `Patrick Foley`, `William Lindskog`,"
#~ " `William Lindskog-Munzing`, `Yan Gao` "
#~ "<!---TOKEN_v1.22.0-->"
#~ msgstr ""

#~ msgid ""
#~ "User authentication can be enabled if"
#~ " you're using the Flower Enterprise "
#~ "Edition (EE) Docker images. This is "
#~ "configured in the `global.userAuth` section"
#~ " of your `values.yml` file."
#~ msgstr ""

#~ msgid "`auth_type`: The authentication mechanism being used (e.g., oidc)."
#~ msgstr ""

#~ msgid "`validate_url`: The endpoint for validating user authentication."
#~ msgstr ""

#~ msgid ""
#~ "To use an existing secret that "
#~ "contains the user authentication "
#~ "configuration, set `existingSecret` to the "
#~ "name of the existing secret:"
#~ msgstr ""

#~ msgid ""
#~ "Note that the existing secret must "
#~ "contain the key `user-auth-config.yml`:"
#~ msgstr ""

#~ msgid ""
#~ "Configure SuperLink for user authentication"
#~ " and authorization. Private-by-default "
#~ "runs securely with OpenID Connect and"
#~ " OpenFGA."
#~ msgstr ""

#~ msgid ""
#~ "In this guide, you'll learn how to"
#~ " configure SuperLink with user-level "
#~ "authentication and authorization, and how "
#~ "to log in using the ``flwr`` CLI."
#~ " Once logged in, any users that "
#~ "are authorized on the SuperLink can "
#~ "run Flower CLI commands that interact"
#~ " with the SuperLink."
#~ msgstr ""

#~ msgid ""
#~ "With user authentication and authorization "
#~ "enabled, only users that have submitted"
#~ " the ``flwr run`` command can view"
#~ " and interact with their runs. This"
#~ " means that your runs are **private"
#~ " by default**, ensuring that only "
#~ "authorized users can access them."
#~ msgstr ""

#~ msgid ""
#~ "To enable user authentication and "
#~ "authorization, the SuperLink must be "
#~ "deployed with an `OpenID Connect (OIDC)"
#~ " <https://openid.net/developers/how-connect-works/>`_"
#~ " provider and an `OpenFGA "
#~ "<https://openfga.dev/>`_ server. The OIDC "
#~ "provider is used for user "
#~ "authentication, while OpenFGA is used "
#~ "for fine-grained access control. This"
#~ " means an authenticated user can only"
#~ " run ``flwr`` CLI commands on the "
#~ "SuperLink if they have been granted "
#~ "the necessary permissions by the "
#~ "SuperLink administrator. When enabled, both"
#~ " user authentication and authorization must"
#~ " be configured on the SuperLink."
#~ msgstr ""

#~ msgid ""
#~ "Save this file as ``user-auth-"
#~ "config.yaml``. Then pass it to the "
#~ "SuperLink via the ``--user-auth-config``"
#~ " flag when deploying the SuperLink:"
#~ msgstr ""

#~ msgid ""
#~ "To authorize a user, the SuperLink "
#~ "administrator must add the user's OIDC"
#~ " ``sub`` claim to the OpenFGA store"
#~ " with the appropriate relation."
#~ msgstr ""

#~ msgid ""
#~ "Once a SuperLink with user "
#~ "authentication and authorization is up "
#~ "and running, a user can interface "
#~ "with it after installing the ``flwr``"
#~ " PyPI package via the Flower CLI. "
#~ "Then, ensure that the ``enable-user-"
#~ "auth`` field is set to ``true`` in"
#~ " the federation section in the "
#~ "``pyproject.toml`` of the Flower app you"
#~ " want to run:"
#~ msgstr ""

#~ msgid ""
#~ "User authentication and authorization is "
#~ "only supported with TLS connections."
#~ msgstr ""

#~ msgid ""
#~ "With the above steps completed, you "
#~ "can now run ``flwr`` CLI commands "
#~ "against a SuperLink setup with user "
#~ "authentication and authorization. For example,"
#~ " as an authorized user, you can "
#~ "run the ``flwr run`` command to "
#~ "start a Flower app:"
#~ msgstr ""

#~ msgid ""
#~ "If the user does not have the "
#~ "necessary permissions to run the "
#~ "command, an error will be returned:"
#~ msgstr ""

#~ msgid ""
#~ "When user authentication is enabled, "
#~ "Flower uses an OIDC-compatible server"
#~ " to authenticate requests:"
#~ msgstr ""

#~ msgid "Path to the public key file."
#~ msgstr ""

#~ msgid ""
#~ "2. Verify that both files exist "
#~ "and contain valid elliptic curve keys."
#~ " - The private key file should "
#~ "be in a format compatible with "
#~ "elliptic curve cryptography. - The "
#~ "public key file should match the "
#~ "private key."
#~ msgstr ""

#~ msgid ""
#~ "Connecting a SuperNode to a SuperLink"
#~ " that has node authentication enabled "
#~ "requires passing two additional arguments "
#~ "(i.e. the public and private keys "
#~ "of the SuperNode) in addition to "
#~ "the TLS certificate."
#~ msgstr ""

#~ msgid ""
#~ "``--auth-supernode-public-key``: the "
#~ "public key of this SuperNode (which "
#~ "should be the same that was added"
#~ " to othe CSV used by the "
#~ "SuperLink)."
#~ msgstr ""

#~ msgid ""
#~ "Follow the same procedure to launch "
#~ "the second SuperNode by passing its "
#~ "corresponding key pair:"
#~ msgstr ""

#~ msgid "[301] SUPERNODE_NODE_AUTH_KEYS_REQUIRED"
#~ msgstr ""

#~ msgid ""
#~ "To run the SuperNode with "
#~ "authentication, file paths for both the"
#~ " private and public keys must be "
#~ "provided. Specifically, the following options"
#~ " must be specified:"
#~ msgstr ""

#~ msgid "``--auth-supernode-private-key``"
#~ msgstr ""

#~ msgid "``--auth-supernode-public-key``"
#~ msgstr ""

#~ msgid "Providing only one of these options is insufficient for authentication."
#~ msgstr ""

#~ msgid ""
#~ "1. Ensure that the paths to both"
#~ " the private key and public key "
#~ "files are specified in command-line "
#~ "arguments. For example:"
#~ msgstr ""

#~ msgid ""
#~ "Verify that the specified file paths "
#~ "are correct and that the files "
#~ "exist."
#~ msgstr ""

#~ msgid "[302] SUPERNODE_NODE_AUTH_KEYS_INVALID"
#~ msgstr ""

#~ msgid ""
#~ "The provided key files are invalid. "
#~ "Authentication requires a valid elliptic "
#~ "curve private and public key pair. "
#~ "This error occurs when either:"
#~ msgstr ""

#~ msgid ""
#~ "The **private key** file specified in"
#~ " ``--auth-supernode-private-key`` is "
#~ "invalid or unreadable."
#~ msgstr ""

#~ msgid ""
#~ "The **public key** file specified in "
#~ "``--auth-supernode-public-key`` is "
#~ "invalid or unreadable."
#~ msgstr ""

#~ msgid ""
#~ "Ensure that the file paths provided "
#~ "for the private and public key "
#~ "options are correct."
#~ msgstr ""

#~ msgid ""
#~ "2. Verify that both files exist "
#~ "and contain valid elliptic curve ssh "
#~ "keys. - The private key file "
#~ "should be in a format compatible "
#~ "with elliptic curve cryptography. - The"
#~ " public key file should match the "
#~ "private key."
#~ msgstr ""

#~ msgid ""
#~ "3. If the files are corrupted or"
#~ " not in the correct format, "
#~ "regenerate the elliptic curve ssh key"
#~ " pair and update the file paths "
#~ "accordingly. For example, in Linux/MacOS, "
#~ "**for rapid prototyping only** (not "
#~ "production; follow company procedures for "
#~ "key management):"
#~ msgstr ""

#~ msgid ""
#~ "**Automatic authentication**: In this mode,"
#~ " the SuperLink checks the timestamp-"
#~ "based signature in each request from "
#~ "SuperNodes to prevent impersonation and "
#~ "replay attacks."
#~ msgstr ""

#~ msgid ""
#~ "**CSV-based authentication**: This mode "
#~ "functions similarly to automatic "
#~ "authentication but requires the SuperLink "
#~ "to be provided with a list of "
#~ "authorized public keys, allowing only "
#~ "those SuperNodes to connect."
#~ msgstr ""

#~ msgid ""
#~ "The automatic authentication mode works "
#~ "out of the box and therefore "
#~ "requires no configuration. On the other"
#~ " hand, CSV-based authentication mode "
#~ "is more sophisticated and how it "
#~ "works and how it can be used "
#~ "is presented reminder of this guide. "
#~ "Flower's CSV-based node authentication "
#~ "leverages a signature-based mechanism to"
#~ " verify each node's identity and is"
#~ " only available when encrypted connections"
#~ " (SSL/TLS) are enabled:"
#~ msgstr ""

#~ msgid ""
#~ "This guide covers a preview feature "
#~ "that might change in future versions "
#~ "of Flower."
#~ msgstr "이 가이드에서는 향후 버전의 Flower에서 변경될 수 있는 미리보기 기능에 대해 설명합니다."

#~ msgid ""
#~ "``--auth-list-public-keys``: Specify the"
#~ " path to a CSV file storing the"
#~ " public keys of all SuperNodes that"
#~ " should be allowed to connect with"
#~ " the SuperLink. A valid CSV file "
#~ "storing known node public keys should"
#~ " list the keys in OpenSSH format, "
#~ "separated by commas. Refer to the "
#~ "code sample, which contains a CSV "
#~ "file with two known node public "
#~ "keys."
#~ msgstr ""
#~ "알려진 노드 공개키를 저장하는 유효한 CSV 파일은 "
#~ "쉼표로 구분하고 주석 없이 OpenSSH 형식으로 키를 "
#~ "나열해야 합니다. 예를 들어, 두 개의 알려진 노드"
#~ " 공개키가 포함된 CSV 파일이 포함된 코드 샘플을"
#~ " 참조하세요."

#~ msgid "Simulate the command without contacting any SuperNodes"
#~ msgstr ""

#~ msgid ":py:obj:`flwr.client <flwr.client>`\\"
#~ msgstr ":py:obj:`flwr.client <flwr.client>`\\"

#~ msgid "Flower client."
#~ msgstr "Flower 클라이언트."

#~ msgid ":py:obj:`flwr.common <flwr.common>`\\"
#~ msgstr ":py:obj:`flwr.common <flwr.common>`\\"

#~ msgid "Common components shared between server and client."
#~ msgstr "서버와 클라이언트 간에 공유되는 공통 구성 요소입니다."

#~ msgid ":py:obj:`flwr.server <flwr.server>`\\"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid "Flower server."
#~ msgstr "Flower 서버."

#~ msgid ":py:obj:`flwr.simulation <flwr.simulation>`\\"
#~ msgstr ":py:obj:`flwr.simulation <flwr.simulation>`\\"

#~ msgid "Flower simulation."
#~ msgstr "Flower 시뮬레이션."

#~ msgid "client"
#~ msgstr "클라이언트"

#~ msgid ""
#~ ":py:obj:`start_client <flwr.client.start_client>`\\ "
#~ "\\(\\*\\, server\\_address\\[\\, client\\_fn\\, "
#~ "...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`start_client <flwr.client.start_client>`\\ "
#~ "\\(\\*\\, server\\_address\\[\\, client\\_fn\\, "
#~ "...\\]\\)"

#~ msgid "Start a Flower client node which connects to a Flower server."
#~ msgstr "Flower 서버에 연결되는 Flower 클라이언트 노드를 시작합니다."

#~ msgid ""
#~ ":py:obj:`start_numpy_client <flwr.client.start_numpy_client>`\\"
#~ " \\(\\*\\, server\\_address\\, client\\)"
#~ msgstr ""
#~ ":py:obj:`start_numpy_client <flwr.client.start_numpy_client>`\\"
#~ " \\(\\*\\, server\\_address\\, client\\)"

#~ msgid "Start a Flower NumPyClient which connects to a gRPC server."
#~ msgstr "gRPC 서버에 연결되는 Flower NumPyClient를 시작합니다."

#~ msgid ":py:obj:`Client <flwr.client.Client>`\\ \\(\\)"
#~ msgstr ":py:obj:`Client <flwr.client.Client>`\\ \\(\\)"

#~ msgid "Abstract base class for Flower clients."
#~ msgstr "Flower 클라이언트를 위한 추상 베이스 클래스입니다."

#~ msgid ""
#~ ":py:obj:`ClientApp <flwr.client.ClientApp>`\\ "
#~ "\\(\\[client\\_fn\\, mods\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ClientApp <flwr.client.ClientApp>`\\ "
#~ "\\(\\[client\\_fn\\, mods\\]\\)"

#~ msgid ":py:obj:`NumPyClient <flwr.client.NumPyClient>`\\ \\(\\)"
#~ msgstr ":py:obj:`NumPyClient <flwr.client.NumPyClient>`\\ \\(\\)"

#~ msgid "Abstract base class for Flower clients using NumPy."
#~ msgstr "NumPy를 사용하는 Flower 클라이언트를 위한 추상 베이스 클래스입니다."

#~ msgid ":py:obj:`flwr.client.mod <flwr.client.mod>`\\"
#~ msgstr ":py:obj:`flwr.client.mod <flwr.client.mod>`\\"

#~ msgid ":py:obj:`evaluate <flwr.client.Client.evaluate>`\\ \\(ins\\)"
#~ msgstr ":py:obj:`evaluate <flwr.client.Client.evaluate>`\\ \\(ins\\)"

#~ msgid "Evaluate the provided parameters using the locally held dataset."
#~ msgstr "로컬로 보유한 데이터 세트를 사용하여 제공된 매개변수를 평가합니다."

#~ msgid ":py:obj:`fit <flwr.client.Client.fit>`\\ \\(ins\\)"
#~ msgstr ":py:obj:`fit <flwr.client.Client.fit>`\\ \\(ins\\)"

#~ msgid "Refine the provided parameters using the locally held dataset."
#~ msgstr "로컬로 보유한 데이터 세트를 사용하여 제공된 매개변수를 구체화합니다."

#~ msgid ""
#~ ":py:obj:`get_parameters <flwr.client.Client.get_parameters>`\\"
#~ " \\(ins\\)"
#~ msgstr ""
#~ ":py:obj:`get_parameters <flwr.client.Client.get_parameters>`\\"
#~ " \\(ins\\)"

#~ msgid "Return the current local model parameters."
#~ msgstr "현재 로컬 모델 파라미터를 반환합니다."

#~ msgid ""
#~ ":py:obj:`get_properties <flwr.client.Client.get_properties>`\\"
#~ " \\(ins\\)"
#~ msgstr ""
#~ ":py:obj:`get_properties <flwr.client.Client.get_properties>`\\"
#~ " \\(ins\\)"

#~ msgid "Return set of client's properties."
#~ msgstr "클라이언트의 속성 집합을 반환합니다."

#~ msgid ":py:obj:`to_client <flwr.client.Client.to_client>`\\ \\(\\)"
#~ msgstr ":py:obj:`to_client <flwr.client.Client.to_client>`\\ \\(\\)"

#~ msgid "Return client (itself)."
#~ msgstr "클라이언트(자체)를 반환합니다."

#~ msgid ""
#~ "The evaluation instructions containing "
#~ "(global) model parameters received from "
#~ "the server and a dictionary of "
#~ "configuration values used to customize "
#~ "the local evaluation process."
#~ msgstr ""
#~ "서버에서 받은 (전역) 모델 파라미터와 로컬 평가 "
#~ "프로세스를 사용자 지정하는 데 사용되는 구성 값 "
#~ "사전이 포함된 평가 지침입니다."

#~ msgid ""
#~ "The evaluation result containing the "
#~ "loss on the local dataset and "
#~ "other details such as the number "
#~ "of local data examples used for "
#~ "evaluation."
#~ msgstr "로컬 데이터 세트의 손실 및 평가에 사용된 로컬 데이터 예제 수와 같은 기타 세부 정보가 포함된 평가 결과입니다."

#~ msgid ""
#~ "The training instructions containing (global)"
#~ " model parameters received from the "
#~ "server and a dictionary of configuration"
#~ " values used to customize the local"
#~ " training process."
#~ msgstr ""
#~ "서버에서 받은 (전역) 모델 파라미터와 로컬 학습 "
#~ "프로세스를 사용자 지정하는 데 사용되는 구성 값 "
#~ "사전이 포함된 학습 지침입니다."

#~ msgid ""
#~ "The training result containing updated "
#~ "parameters and other details such as "
#~ "the number of local training examples"
#~ " used for training."
#~ msgstr "업데이트된 매개변수와 훈련에 사용된 로컬 훈련 예제 수와 같은 기타 세부 정보가 포함된 훈련 결과입니다."

#~ msgid ""
#~ "The get parameters instructions received "
#~ "from the server containing a dictionary"
#~ " of configuration values."
#~ msgstr "구성 값 dictionary이 포함된 서버에서 받은 매개변수 가져오기 명령어입니다."

#~ msgid "The current local model parameters."
#~ msgstr "현재 로컬 모델 파라미터입니다."

#~ msgid ""
#~ "The get properties instructions received "
#~ "from the server containing a dictionary"
#~ " of configuration values."
#~ msgstr "구성 값 dictionary이 포함된 서버로부터 받은 속성 가져오기 명령입니다."

#~ msgid "The current client properties."
#~ msgstr "현재 클라이언트 속성입니다."

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ "
#~ "\\(\\[action\\, mods\\]\\)"
#~ msgstr ":py:obj:`evaluate <flwr.client.ClientApp.evaluate>`\\ \\(\\)"

#~ msgid ":py:obj:`lifespan <flwr.client.ClientApp.lifespan>`\\ \\(\\)"
#~ msgstr ":py:obj:`Client <flwr.client.Client>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`query <flwr.client.ClientApp.query>`\\ "
#~ "\\(\\[action\\, mods\\]\\)"
#~ msgstr ":py:obj:`query <flwr.client.ClientApp.query>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`train <flwr.client.ClientApp.train>`\\ "
#~ "\\(\\[action\\, mods\\]\\)"
#~ msgstr ":py:obj:`train <flwr.client.ClientApp.train>`\\ \\(\\)"

#~ msgid "NumPyClient"
#~ msgstr "NumPyClient"

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.client.NumPyClient.evaluate>`\\ "
#~ "\\(parameters\\, config\\)"
#~ msgstr ""
#~ ":py:obj:`evaluate <flwr.client.NumPyClient.evaluate>`\\ "
#~ "\\(parameters\\, config\\)"

#~ msgid ""
#~ ":py:obj:`fit <flwr.client.NumPyClient.fit>`\\ "
#~ "\\(parameters\\, config\\)"
#~ msgstr ""
#~ ":py:obj:`fit <flwr.client.NumPyClient.fit>`\\ "
#~ "\\(parameters\\, config\\)"

#~ msgid "Train the provided parameters using the locally held dataset."
#~ msgstr "로컬로 보유한 데이터 세트를 사용하여 제공된 파라미터를 학습합니다."

#~ msgid ""
#~ ":py:obj:`get_parameters "
#~ "<flwr.client.NumPyClient.get_parameters>`\\ \\(config\\)"
#~ msgstr ""
#~ ":py:obj:`get_parameters "
#~ "<flwr.client.NumPyClient.get_parameters>`\\ \\(config\\)"

#~ msgid ""
#~ ":py:obj:`get_properties "
#~ "<flwr.client.NumPyClient.get_properties>`\\ \\(config\\)"
#~ msgstr ""
#~ ":py:obj:`get_properties "
#~ "<flwr.client.NumPyClient.get_properties>`\\ \\(config\\)"

#~ msgid "Return a client's set of properties."
#~ msgstr "클라이언트의 속성 집합을 반환합니다."

#~ msgid ":py:obj:`to_client <flwr.client.NumPyClient.to_client>`\\ \\(\\)"
#~ msgstr ":py:obj:`to_client <flwr.client.NumPyClient.to_client>`\\ \\(\\)"

#~ msgid "Convert to object to Client type and return it."
#~ msgstr "객체를 클라이언트 유형으로 변환하고 반환합니다."

#~ msgid "The current (global) model parameters."
#~ msgstr "현재(전역) 모델 매개변수입니다."

#~ msgid ""
#~ "Configuration parameters which allow the "
#~ "server to influence evaluation on the"
#~ " client. It can be used to "
#~ "communicate arbitrary values from the "
#~ "server to the client, for example, "
#~ "to influence the number of examples "
#~ "used for evaluation."
#~ msgstr ""
#~ "서버가 클라이언트의 평가에 영향을 줄 수 있는 구성"
#~ " 매개변수입니다. 예를 들어 평가에 사용되는 예제 수에"
#~ " 영향을 주기 위해 서버에서 클라이언트로 임의의 값을"
#~ " 전달하는 데 사용할 수 있습니다."

#~ msgid ""
#~ "* **loss** (*float*) -- The evaluation"
#~ " loss of the model on the local"
#~ " dataset. * **num_examples** (*int*) -- "
#~ "The number of examples used for "
#~ "evaluation. * **metrics** (*Dict[str, "
#~ "Scalar]*) -- A dictionary mapping "
#~ "arbitrary string keys to values of   "
#~ "type bool, bytes, float, int, or "
#~ "str. It can be used to   "
#~ "communicate arbitrary values back to the"
#~ " server."
#~ msgstr ""
#~ "* **loss** (*float*) - 로컬 데이터 세트에서"
#~ " 모델의 평가 손실입니다. * **num_examples** "
#~ "(*int*) -- 평가에 사용된 예제 수입니다. * "
#~ "**metrics** (*Dict[str, Scalar]*) -- 임의의 "
#~ "문자열 키를 부울, 바이트, float, int 또는 "
#~ "str 유형의 값에 매핑하는 dictionary입니다. 임의의 "
#~ "값을 서버에 다시 전달하는 데 사용할 수 있습니다."

#~ msgid ""
#~ "**loss** (*float*) -- The evaluation "
#~ "loss of the model on the local "
#~ "dataset."
#~ msgstr "**loss** (*float*) -- 로컬 데이터 세트에서 모델의 평가 손실입니다."

#~ msgid "**num_examples** (*int*) -- The number of examples used for evaluation."
#~ msgstr "**num_examples** (*int*) - 평가에 사용된 예제 수입니다."

#~ msgid ""
#~ "**metrics** (*Dict[str, Scalar]*) -- A "
#~ "dictionary mapping arbitrary string keys "
#~ "to values of type bool, bytes, "
#~ "float, int, or str. It can be "
#~ "used to communicate arbitrary values "
#~ "back to the server."
#~ msgstr ""
#~ "**metrics** (*Dict[str, Scalar]*) - 임의의 "
#~ "문자열 키를 bool, bytes, float, int 또는"
#~ " str 타입의 값에 매핑하는 dictionary입니다. 임의의"
#~ " 값을 서버에 다시 전달하는 데 사용할 수 "
#~ "있습니다."

#~ msgid ""
#~ "The previous return type format (int,"
#~ " float, float) and the extended "
#~ "format (int, float, float, Dict[str, "
#~ "Scalar]) have been deprecated and "
#~ "removed since Flower 0.19."
#~ msgstr ""
#~ "이전 반환 유형 형식(int, float, float)과 확장"
#~ " 형식(int, float, float, Dict[str, Scalar])은"
#~ " Flower 0.19부터 더 이상 사용되지 않으며 "
#~ "제거되었습니다."

#~ msgid ""
#~ "Configuration parameters which allow the "
#~ "server to influence training on the "
#~ "client. It can be used to "
#~ "communicate arbitrary values from the "
#~ "server to the client, for example, "
#~ "to set the number of (local) "
#~ "training epochs."
#~ msgstr ""
#~ "서버가 클라이언트의 훈련에 영향을 줄 수 있는 구성"
#~ " 매개변수입니다. 예를 들어 (로컬) 트레이닝 에포크 "
#~ "수를 설정하는 등 서버에서 클라이언트로 임의의 값을 "
#~ "전달하는 데 사용할 수 있습니다."

#~ msgid ""
#~ "* **parameters** (*NDArrays*) -- The "
#~ "locally updated model parameters. * "
#~ "**num_examples** (*int*) -- The number "
#~ "of examples used for training. * "
#~ "**metrics** (*Dict[str, Scalar]*) -- A "
#~ "dictionary mapping arbitrary string keys "
#~ "to values of type   bool, bytes, "
#~ "float, int, or str. It can be "
#~ "used to communicate   arbitrary values "
#~ "back to the server."
#~ msgstr ""
#~ "* **parameters** (*NDArrays*) - 로컬로 "
#~ "업데이트된 모델 파라미터입니다. * **num_examples** "
#~ "(*int*) -- 학습에 사용된 예제 수입니다. * "
#~ "**metrics** (*Dict[str, Scalar]*) - 임의의 "
#~ "문자열 키를 bool, bytes, float, int,또는 "
#~ "str 타입의 값에 매핑하는 dictionary입니다. 임의의 "
#~ "값을 서버에 다시 전달하는 데 사용할 수 있습니다."

#~ msgid "**parameters** (*NDArrays*) -- The locally updated model parameters."
#~ msgstr "**parameters** (*NDArrays*) - 로컬로 업데이트된 모델 파라미터입니다."

#~ msgid "**num_examples** (*int*) -- The number of examples used for training."
#~ msgstr "**num_examples** (*int*) - 트레이닝에 사용된 예제 수입니다."

#~ msgid ""
#~ "Configuration parameters requested by the "
#~ "server. This can be used to tell"
#~ " the client which parameters are "
#~ "needed along with some Scalar "
#~ "attributes."
#~ msgstr ""
#~ "서버에서 요청한 구성 매개변수입니다. 이는 일부 스칼라 "
#~ "속성과 함께 어떤 매개변수가 필요한지 클라이언트에게 알려주는"
#~ " 데 사용할 수 있습니다."

#~ msgid ""
#~ "**parameters** -- The local model "
#~ "parameters as a list of NumPy "
#~ "ndarrays."
#~ msgstr "**parameters** -- 로컬 모델 파라미터를 NumPy 배열 목록으로 표시합니다."

#~ msgid ""
#~ "Configuration parameters requested by the "
#~ "server. This can be used to tell"
#~ " the client which properties are "
#~ "needed along with some Scalar "
#~ "attributes."
#~ msgstr ""
#~ "서버에서 요청하는 구성 매개변수입니다. 이는 일부 스칼라"
#~ " 속성과 함께 어떤 속성이 필요한지 클라이언트에게 "
#~ "알려주는 데 사용할 수 있습니다."

#~ msgid ""
#~ "**properties** -- A dictionary mapping "
#~ "arbitrary string keys to values of "
#~ "type bool, bytes, float, int, or "
#~ "str. It can be used to communicate"
#~ " arbitrary property values back to "
#~ "the server."
#~ msgstr ""
#~ "**properties** -- 임의의 문자열 키를 bool, "
#~ "bytes, float, int 또는 str 타입의 값에"
#~ " 매핑하는 dictionary입니다. 임의의 속성 값을 서버에"
#~ " 다시 전달하는 데 사용할 수 있습니다."

#~ msgid ""
#~ ":py:obj:`adaptiveclipping_mod "
#~ "<flwr.client.mod.adaptiveclipping_mod>`\\ \\(msg\\, "
#~ "ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`adaptiveclipping_mod "
#~ "<flwr.client.mod.adaptiveclipping_mod>`\\ \\(msg\\, "
#~ "ctxt\\, call\\_next\\)"

#~ msgid ""
#~ ":py:obj:`arrays_size_mod <flwr.client.mod.arrays_size_mod>`\\"
#~ " \\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`parameters_size_mod "
#~ "<flwr.client.mod.parameters_size_mod>`\\ \\(msg\\, ctxt\\,"
#~ " call\\_next\\)"

#~ msgid ""
#~ ":py:obj:`fixedclipping_mod "
#~ "<flwr.client.mod.fixedclipping_mod>`\\ \\(msg\\, ctxt\\,"
#~ " call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`fixedclipping_mod "
#~ "<flwr.client.mod.fixedclipping_mod>`\\ \\(msg\\, ctxt\\,"
#~ " call\\_next\\)"

#~ msgid ":py:obj:`make_ffn <flwr.client.mod.make_ffn>`\\ \\(ffn\\, mods\\)"
#~ msgstr ":py:obj:`make_ffn <flwr.client.mod.make_ffn>`\\ \\(ffn\\, mods\\)"

#~ msgid "."
#~ msgstr "."

#~ msgid ""
#~ ":py:obj:`message_size_mod <flwr.client.mod.message_size_mod>`\\"
#~ " \\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`message_size_mod <flwr.client.mod.message_size_mod>`\\"
#~ " \\(msg\\, ctxt\\, call\\_next\\)"

#~ msgid ""
#~ ":py:obj:`secagg_mod <flwr.client.mod.secagg_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`secagg_mod <flwr.client.mod.secagg_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"

#~ msgid ""
#~ "Handle incoming message and return "
#~ "results, following the SecAgg protocol."
#~ msgstr "SecAgg 프로토콜에 따라 수신 메시지를 처리하고 결과를 반환합니다."

#~ msgid ""
#~ ":py:obj:`secaggplus_mod <flwr.client.mod.secaggplus_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"
#~ msgstr ""
#~ ":py:obj:`secaggplus_mod <flwr.client.mod.secaggplus_mod>`\\ "
#~ "\\(msg\\, ctxt\\, call\\_next\\)"

#~ msgid ""
#~ "Handle incoming message and return "
#~ "results, following the SecAgg+ protocol."
#~ msgstr "SecAgg+ 프로토콜에 따라 수신 메시지를 처리하고 결과를 반환합니다."

#~ msgid ""
#~ ":py:obj:`LocalDpMod <flwr.client.mod.LocalDpMod>`\\ "
#~ "\\(clipping\\_norm\\, sensitivity\\, ...\\)"
#~ msgstr ""
#~ ":py:obj:`LocalDpMod <flwr.client.mod.LocalDpMod>`\\ "
#~ "\\(clipping\\_norm\\, sensitivity\\, ...\\)"

#~ msgid ""
#~ "This mod needs to be used with "
#~ "the DifferentialPrivacyClientSideFixedClipping server-"
#~ "side strategy wrapper."
#~ msgstr ""
#~ "이 모드는 서버 측 전략 래퍼인 "
#~ "DifferentialPrivacyClientSideFixedClipping과 함께 사용해야 "
#~ "합니다."

#~ msgid "make\\_ffn"
#~ msgstr "make\\_ffn"

#~ msgid "secagg\\_mod"
#~ msgstr "secagg\\_mod"

#~ msgid "secaggplus\\_mod"
#~ msgstr "secaggplus\\_mod"

#~ msgid "start\\_client"
#~ msgstr "start\\_client"

#~ msgid ""
#~ "This function is deprecated since "
#~ "1.13.0. Use :code:`flower-supernode` command"
#~ " instead to start a SuperNode."
#~ msgstr ""

#~ msgid ""
#~ "The IPv4 or IPv6 address of the"
#~ " server. If the Flower server runs"
#~ " on the same machine on port "
#~ "8080, then `server_address` would be "
#~ "`\"[::]:8080\"`."
#~ msgstr ""
#~ "서버의 IPv4 또는 IPv6 주소입니다. Flower 서버가"
#~ " 포트 8080의 동일한 컴퓨터에서 실행되는 경우 "
#~ "`서버_주소`는 `\"[::]:8080\"`이 됩니다."

#~ msgid "A callable that instantiates a Client. (default: None)"
#~ msgstr "클라이언트를 인스턴스화하는 호출 가능 항목입니다. (기본값: None)"

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.client.Client` (default: None)"
#~ msgstr "추상 베이스 클래스 `flwr.client.Client`의 구현(기본값: None)"

#~ msgid ""
#~ "The maximum length of gRPC messages "
#~ "that can be exchanged with the "
#~ "Flower server. The default should be "
#~ "sufficient for most models. Users who"
#~ " train very large models might need"
#~ " to increase this value. Note that"
#~ " the Flower server needs to be "
#~ "started with the same value (see "
#~ "`flwr.server.start_server`), otherwise it will "
#~ "not know about the increased limit "
#~ "and block larger messages."
#~ msgstr ""
#~ "Flower 서버와 교환할 수 있는 gRPC 메시지의 "
#~ "최대 길이입니다. 기본값은 대부분의 모델에 충분합니다. 매우"
#~ " 큰 모델을 훈련하는 사용자는 이 값을 늘려야 "
#~ "할 수도 있습니다. Flower 서버는 동일한 값으로 "
#~ "시작해야 하며(`flwr.server.start_server` 참조), 그렇지 "
#~ "않으면 증가된 제한을 알지 못해 더 큰 메시지를"
#~ " 차단합니다."

#~ msgid ""
#~ "The PEM-encoded root certificates as "
#~ "a byte string or a path string."
#~ " If provided, a secure connection "
#~ "using the certificates will be "
#~ "established to an SSL-enabled Flower "
#~ "server."
#~ msgstr ""
#~ "바이트 문자열 또는 경로 문자열로 PEM 인코딩된 "
#~ "루트 인증서. 제공하면 인증서를 사용하여 SSL이 활성화된"
#~ " Flower 서버에 보안 연결이 설정됩니다."

#~ msgid ""
#~ "Starts an insecure gRPC connection when"
#~ " True. Enables HTTPS connection when "
#~ "False, using system certificates if "
#~ "`root_certificates` is None."
#~ msgstr ""
#~ "True일 경우 안전하지 않은 gRPC 연결을 시작합니다."
#~ " root_certificates`가 None인 경우 시스템 인증서를 "
#~ "사용하여 False일 때 HTTPS 연결을 활성화합니다."

#~ msgid ""
#~ "**[Deprecated]** This argument is no "
#~ "longer supported and will be removed "
#~ "in a future release."
#~ msgstr ""

#~ msgid ""
#~ "Tuple containing the elliptic curve "
#~ "private key and public key for "
#~ "authentication from the cryptography library."
#~ " Source: "
#~ "https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/ "
#~ "Used to establish an authenticated "
#~ "connection with the server."
#~ msgstr ""

#~ msgid ""
#~ "The maximum number of times the "
#~ "client will try to connect to the"
#~ " server before giving up in case "
#~ "of a connection error. If set to"
#~ " None, there is no limit to the"
#~ " number of tries."
#~ msgstr ""
#~ "연결 오류 발생 시 클라이언트가 서버 연결을 "
#~ "포기하기 전에 시도하는 최대 횟수입니다. None으로 설정하면"
#~ " 시도 횟수에 제한이 없습니다."

#~ msgid ""
#~ "The maximum duration before the client"
#~ " stops trying to connect to the "
#~ "server in case of connection error. "
#~ "If set to None, there is no "
#~ "limit to the total time."
#~ msgstr ""
#~ "연결 오류 발생 시 클라이언트가 서버에 대한 연결을"
#~ " 시도하지 않는 최대 기간입니다. None으로 설정하면 "
#~ "총 시간에는 제한이 없습니다."

#~ msgid "Starting a gRPC client with an insecure server connection::"
#~ msgstr "안전하지 않은 서버 연결로 gRPC 클라이언트 시작하기:"

#~ msgid "Starting a TLS-enabled gRPC client using system certificates::"
#~ msgstr "시스템 인증서를 사용하여 SSL 사용 gRPC 클라이언트를 시작합니다:"

#~ msgid "Starting a TLS-enabled gRPC client using provided certificates::"
#~ msgstr "제공된 인증서를 사용하여 SSL 지원 gRPC 클라이언트를 시작합니다:"

#~ msgid "start\\_numpy\\_client"
#~ msgstr "start\\_numpy\\_client"

#~ msgid ""
#~ "This function is deprecated since 1.7.0."
#~ " Use :code:`flwr.client.start_client` instead and"
#~ " first convert your :code:`NumPyClient` to"
#~ " type :code:`flwr.client.Client` by executing "
#~ "its :code:`to_client()` method."
#~ msgstr ""
#~ "이 함수는 1.7.0부터 더 이상 사용되지 않습니다. "
#~ "대신 :code:`flwr.client.start_client`를 사용하고 먼저 "
#~ ":code:`to_client()` 메서드를 실행하여 :code:`NumPyClient`를"
#~ " :code:`flwr.client.Client` 유형으로 변환합니다."

#~ msgid "An implementation of the abstract base class `flwr.client.NumPyClient`."
#~ msgstr "추상 베이스 클래스 `flwr.client.NumPyClient`의 구현입니다."

#~ msgid "common"
#~ msgstr "공통"

#~ msgid ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"
#~ msgstr ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`bytes_to_ndarray <flwr.common.bytes_to_ndarray>`\\ "
#~ "\\(tensor\\)"
#~ msgstr ""
#~ ":py:obj:`bytes_to_ndarray <flwr.common.bytes_to_ndarray>`\\ "
#~ "\\(tensor\\)"

#~ msgid "Deserialize NumPy ndarray from bytes."
#~ msgstr "바이트에서 NumPy를 역직렬화합니다."

#~ msgid ""
#~ ":py:obj:`configure <flwr.common.configure>`\\ "
#~ "\\(identifier\\[\\, filename\\, host\\]\\)"
#~ msgstr ""
#~ ":py:obj:`configure <flwr.common.configure>`\\ "
#~ "\\(identifier\\[\\, filename\\, host\\]\\)"

#~ msgid "Configure logging to file and/or remote log server."
#~ msgstr "파일 및/또는 원격 로그 서버에 로깅을 구성합니다."

#~ msgid ""
#~ ":py:obj:`event <flwr.common.event>`\\ "
#~ "\\(event\\_type\\[\\, event\\_details\\]\\)"
#~ msgstr ""
#~ ":py:obj:`event <flwr.common.event>`\\ "
#~ "\\(event\\_type\\[\\, event\\_details\\]\\)"

#~ msgid "Submit create_event to ThreadPoolExecutor to avoid blocking."
#~ msgstr "차단을 피하기 위해 create_event를 ThreadPoolExecutor에 제출합니다."

#~ msgid ""
#~ ":py:obj:`log <flwr.common.log>`\\ \\(level\\, msg\\,"
#~ " \\*args\\, \\*\\*kwargs\\)"
#~ msgstr ""
#~ ":py:obj:`log <flwr.common.log>`\\ \\(level\\, msg\\,"
#~ " \\*args\\, \\*\\*kwargs\\)"

#~ msgid "Log 'msg % args' with the integer severity 'level'."
#~ msgstr "정수 심각도 'level'과 함께 'msg % args'를 기록합니다."

#~ msgid ""
#~ ":py:obj:`ndarray_to_bytes <flwr.common.ndarray_to_bytes>`\\ "
#~ "\\(ndarray\\)"
#~ msgstr ""
#~ ":py:obj:`ndarray_to_bytes <flwr.common.ndarray_to_bytes>`\\ "
#~ "\\(ndarray\\)"

#~ msgid "Serialize NumPy ndarray to bytes."
#~ msgstr "NumPy와 배열을 바이트열로 직렬화합니다."

#~ msgid ""
#~ ":py:obj:`ndarrays_to_parameters "
#~ "<flwr.common.ndarrays_to_parameters>`\\ \\(ndarrays\\)"
#~ msgstr ""
#~ ":py:obj:`ndarrays_to_parameters "
#~ "<flwr.common.ndarrays_to_parameters>`\\ \\(ndarrays\\)"

#~ msgid "Convert NumPy ndarrays to parameters object."
#~ msgstr "NumPy 배열을 매개변수 객체로 변환합니다."

#~ msgid ":py:obj:`now <flwr.common.now>`\\ \\(\\)"
#~ msgstr ":py:obj:`now <flwr.common.now>`\\ \\(\\)"

#~ msgid "Construct a datetime from time.time() with time zone set to UTC."
#~ msgstr "표준 시간대를 UTC로 설정하여 time.time()에서 날짜 시간을 생성합니다."

#~ msgid ""
#~ ":py:obj:`parameters_to_ndarrays "
#~ "<flwr.common.parameters_to_ndarrays>`\\ \\(parameters\\)"
#~ msgstr ""
#~ ":py:obj:`parameters_to_ndarrays "
#~ "<flwr.common.parameters_to_ndarrays>`\\ \\(parameters\\)"

#~ msgid "Convert parameters object to NumPy ndarrays."
#~ msgstr "매개변수 객체를 NumPy 배열로 변환합니다."

#~ msgid ":py:obj:`Array <flwr.common.Array>`\\ \\(\\)"
#~ msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#~ msgid ":py:obj:`ArrayRecord <flwr.common.ArrayRecord>`\\ \\(\\)"
#~ msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#~ msgid ""
#~ ":py:obj:`ClientMessage <flwr.common.ClientMessage>`\\ "
#~ "\\(\\[get\\_properties\\_res\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ClientMessage <flwr.common.ClientMessage>`\\ "
#~ "\\(\\[get\\_properties\\_res\\, ...\\]\\)"

#~ msgid "ClientMessage is a container used to hold one result message."
#~ msgstr "ClientMessage는 하나의 결과 메시지를 저장하는 데 사용되는 컨테이너입니다."

#~ msgid ":py:obj:`Code <flwr.common.Code>`\\ \\(value\\)"
#~ msgstr ":py:obj:`Code <flwr.common.Code>`\\ \\(value\\)"

#~ msgid "Client status codes."
#~ msgstr "클라이언트 상태 코드."

#~ msgid ":py:obj:`Config <flwr.common.Config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#~ msgid ""
#~ "alias of :py:class:`dict`\\ [:py:class:`str`, "
#~ ":py:class:`bool` | :py:class:`bytes` | "
#~ ":py:class:`float` | :py:class:`int` | "
#~ ":py:class:`str`]"
#~ msgstr ""
#~ "Bases: :py:class:`~flwr.common.record.typeddict.TypedDict`\\ "
#~ "[:py:class:`str`, :py:class:`int` | "
#~ ":py:class:`float` | :py:class:`~typing.List`\\ "
#~ "[:py:class:`int`] | :py:class:`~typing.List`\\ "
#~ "[:py:class:`float`]]"

#~ msgid ""
#~ ":py:obj:`ConfigRecord <flwr.common.ConfigRecord>`\\ "
#~ "\\(\\[config\\_dict\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ConfigsRecord <flwr.common.ConfigsRecord>`\\ "
#~ "\\(\\[configs\\_dict\\, keep\\_input\\]\\)"

#~ msgid ""
#~ ":py:obj:`ConfigsRecord <flwr.common.ConfigsRecord>`\\ "
#~ "\\(\\[config\\_dict\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ConfigsRecord <flwr.common.ConfigsRecord>`\\ "
#~ "\\(\\[configs\\_dict\\, keep\\_input\\]\\)"

#~ msgid "Deprecated class ``ConfigsRecord``, use ``ConfigRecord`` instead."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Context <flwr.common.Context>`\\ \\(run\\_id\\,"
#~ " node\\_id\\, node\\_config\\, state\\, ...\\)"
#~ msgstr ":py:obj:`Context <flwr.common.Context>`\\ \\(state\\)"

#~ msgid ":py:obj:`DisconnectRes <flwr.common.DisconnectRes>`\\ \\(reason\\)"
#~ msgstr ":py:obj:`DisconnectRes <flwr.common.DisconnectRes>`\\ \\(reason\\)"

#~ msgid "DisconnectRes message from client to server."
#~ msgstr "클라이언트에서 서버로 연결 해제 메시지를 보냅니다."

#~ msgid ":py:obj:`Error <flwr.common.Error>`\\ \\(code\\[\\, reason\\]\\)"
#~ msgstr ":py:obj:`Error <flwr.common.Error>`\\ \\(code\\[\\, reason\\]\\)"

#~ msgid ""
#~ ":py:obj:`EvaluateIns <flwr.common.EvaluateIns>`\\ "
#~ "\\(parameters\\, config\\)"
#~ msgstr ""
#~ ":py:obj:`EvaluateIns <flwr.common.EvaluateIns>`\\ "
#~ "\\(parameters\\, config\\)"

#~ msgid "Evaluate instructions for a client."
#~ msgstr "클라이언트에 대한 지침을 평가합니다."

#~ msgid ""
#~ ":py:obj:`EvaluateRes <flwr.common.EvaluateRes>`\\ "
#~ "\\(status\\, loss\\, num\\_examples\\, metrics\\)"
#~ msgstr ""
#~ ":py:obj:`EvaluateRes <flwr.common.EvaluateRes>`\\ "
#~ "\\(status\\, loss\\, num\\_examples\\, metrics\\)"

#~ msgid "Evaluate response from a client."
#~ msgstr "클라이언트의 응답을 평가합니다."

#~ msgid ":py:obj:`EventType <flwr.common.EventType>`\\ \\(value\\)"
#~ msgstr ":py:obj:`EventType <flwr.common.EventType>`\\ \\(value\\)"

#~ msgid "Types of telemetry events."
#~ msgstr "원격 분석 이벤트의 유형."

#~ msgid ":py:obj:`FitIns <flwr.common.FitIns>`\\ \\(parameters\\, config\\)"
#~ msgstr ":py:obj:`FitIns <flwr.common.FitIns>`\\ \\(parameters\\, config\\)"

#~ msgid "Fit instructions for a client."
#~ msgstr "고객을 위한 맞춤 지침."

#~ msgid ""
#~ ":py:obj:`FitRes <flwr.common.FitRes>`\\ \\(status\\, "
#~ "parameters\\, num\\_examples\\, metrics\\)"
#~ msgstr ""
#~ ":py:obj:`FitRes <flwr.common.FitRes>`\\ \\(status\\, "
#~ "parameters\\, num\\_examples\\, metrics\\)"

#~ msgid "Fit response from a client."
#~ msgstr "클라이언트의 적합성 응답."

#~ msgid ""
#~ ":py:obj:`GetParametersIns <flwr.common.GetParametersIns>`\\ "
#~ "\\(config\\)"
#~ msgstr ""
#~ ":py:obj:`GetParametersIns <flwr.common.GetParametersIns>`\\ "
#~ "\\(config\\)"

#~ msgid "Parameters request for a client."
#~ msgstr "클라이언트에 대한 매개변수 요청입니다."

#~ msgid ""
#~ ":py:obj:`GetParametersRes <flwr.common.GetParametersRes>`\\ "
#~ "\\(status\\, parameters\\)"
#~ msgstr ""
#~ ":py:obj:`GetParametersRes <flwr.common.GetParametersRes>`\\ "
#~ "\\(status\\, parameters\\)"

#~ msgid "Response when asked to return parameters."
#~ msgstr "매개변수 반환 요청 시 응답합니다."

#~ msgid ""
#~ ":py:obj:`GetPropertiesIns <flwr.common.GetPropertiesIns>`\\ "
#~ "\\(config\\)"
#~ msgstr ""
#~ ":py:obj:`GetPropertiesIns <flwr.common.GetPropertiesIns>`\\ "
#~ "\\(config\\)"

#~ msgid "Properties request for a client."
#~ msgstr "클라이언트에 대한 속성 요청."

#~ msgid ""
#~ ":py:obj:`GetPropertiesRes <flwr.common.GetPropertiesRes>`\\ "
#~ "\\(status\\, properties\\)"
#~ msgstr ""
#~ ":py:obj:`GetPropertiesRes <flwr.common.GetPropertiesRes>`\\ "
#~ "\\(status\\, properties\\)"

#~ msgid "Properties response from a client."
#~ msgstr "클라이언트의 속성 응답을 확인합니다."

#~ msgid ":py:obj:`Message <flwr.common.Message>`\\ \\(\\)"
#~ msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#~ msgid ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"
#~ msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#~ msgid ":py:obj:`MessageTypeLegacy <flwr.common.MessageTypeLegacy>`\\ \\(\\)"
#~ msgstr ":py:obj:`MessageTypeLegacy <flwr.common.MessageTypeLegacy>`\\ \\(\\)"

#~ msgid "Legacy message type."
#~ msgstr "레거시 메시지 타입."

#~ msgid ""
#~ ":py:obj:`Metadata <flwr.common.Metadata>`\\ \\(run\\_id\\,"
#~ " message\\_id\\, src\\_node\\_id\\, ...\\)"
#~ msgstr ""
#~ ":py:obj:`Metadata <flwr.common.Metadata>`\\ \\(run\\_id\\,"
#~ " message\\_id\\, src\\_node\\_id\\, ...\\)"

#~ msgid ""
#~ ":py:obj:`MetricRecord <flwr.common.MetricRecord>`\\ "
#~ "\\(\\[metric\\_dict\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`MetricsRecord <flwr.common.MetricsRecord>`\\ "
#~ "\\(\\[metrics\\_dict\\, keep\\_input\\]\\)"

#~ msgid ":py:obj:`Metrics <flwr.common.Metrics>`\\"
#~ msgstr ":py:obj:`metrics <flwr.common.FitRes.metrics>`\\"

#~ msgid ""
#~ ":py:obj:`MetricsRecord <flwr.common.MetricsRecord>`\\ "
#~ "\\(\\[metric\\_dict\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`MetricsRecord <flwr.common.MetricsRecord>`\\ "
#~ "\\(\\[metrics\\_dict\\, keep\\_input\\]\\)"

#~ msgid "Deprecated class ``MetricsRecord``, use ``MetricRecord`` instead."
#~ msgstr ""

#~ msgid ":py:obj:`NDArray <flwr.common.NDArray>`\\"
#~ msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#~ msgid ""
#~ "alias of :py:class:`~numpy.ndarray`\\ "
#~ "[:py:obj:`~typing.Any`, :py:class:`~numpy.dtype`\\ "
#~ "[:py:obj:`~typing.Any`]]"
#~ msgstr ""
#~ "alias of :py:class:`~numpy.ndarray`\\ "
#~ "[:py:obj:`~typing.Any`, :py:class:`~numpy.dtype`\\ "
#~ "[:py:obj:`~typing.Any`]]"

#~ msgid ":py:obj:`NDArrays <flwr.common.NDArrays>`\\"
#~ msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#~ msgid ""
#~ "alias of :py:class:`list`\\ "
#~ "[:py:class:`~numpy.ndarray`\\ [:py:obj:`~typing.Any`, "
#~ ":py:class:`~numpy.dtype`\\ [:py:obj:`~typing.Any`]]]"
#~ msgstr ""
#~ "alias of :py:class:`~numpy.ndarray`\\ "
#~ "[:py:obj:`~typing.Any`, :py:class:`~numpy.dtype`\\ "
#~ "[:py:obj:`~typing.Any`]]"

#~ msgid ""
#~ ":py:obj:`Parameters <flwr.common.Parameters>`\\ "
#~ "\\(tensors\\, tensor\\_type\\)"
#~ msgstr ""
#~ ":py:obj:`Parameters <flwr.common.Parameters>`\\ "
#~ "\\(tensors\\, tensor\\_type\\)"

#~ msgid "Model parameters."
#~ msgstr "모델 매개변수."

#~ msgid ""
#~ ":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
#~ "\\(\\*args\\, \\*\\*kwargs\\)"
#~ msgstr ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordSet.parameters_records>`\\"

#~ msgid "Deprecated class ``ParametersRecord``, use ``ArrayRecord`` instead."
#~ msgstr ""

#~ msgid ":py:obj:`Properties <flwr.common.Properties>`\\"
#~ msgstr ":py:obj:`properties <flwr.common.GetPropertiesRes.properties>`\\"

#~ msgid ":py:obj:`ReconnectIns <flwr.common.ReconnectIns>`\\ \\(seconds\\)"
#~ msgstr ":py:obj:`ReconnectIns <flwr.common.ReconnectIns>`\\ \\(seconds\\)"

#~ msgid "ReconnectIns message from server to client."
#~ msgstr "서버에서 클라이언트로 메시지를 다시 연결합니다."

#~ msgid ""
#~ ":py:obj:`RecordDict <flwr.common.RecordDict>`\\ "
#~ "\\(\\[records\\, parameters\\_records\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`RecordSet <flwr.common.RecordSet>`\\ "
#~ "\\(\\[parameters\\_records\\, ...\\]\\)"

#~ msgid ""
#~ ":py:obj:`RecordSet <flwr.common.RecordSet>`\\ "
#~ "\\(\\[records\\, parameters\\_records\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`RecordSet <flwr.common.RecordSet>`\\ "
#~ "\\(\\[parameters\\_records\\, ...\\]\\)"

#~ msgid "Deprecated class ``RecordSet``, use ``RecordDict`` instead."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
#~ "\\(\\[get\\_properties\\_ins\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
#~ "\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#~ msgid "ServerMessage is a container used to hold one instruction message."
#~ msgstr "ServerMessage는 하나의 instruction 메시지를 저장하는 데 사용되는 컨테이너입니다."

#~ msgid ":py:obj:`Status <flwr.common.Status>`\\ \\(code\\, message\\)"
#~ msgstr ":py:obj:`Status <flwr.common.Status>`\\ \\(code\\, message\\)"

#~ msgid "Client status."
#~ msgstr "클라이언트 상태."

#~ msgid ":py:obj:`deflate <flwr.common.Array.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#~ msgid ""
#~ ":py:obj:`from_numpy_ndarray "
#~ "<flwr.common.Array.from_numpy_ndarray>`\\ \\(ndarray\\)"
#~ msgstr ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`from_torch_tensor "
#~ "<flwr.common.Array.from_torch_tensor>`\\ \\(tensor\\)"
#~ msgstr ""
#~ ":py:obj:`ndarray_to_bytes <flwr.common.ndarray_to_bytes>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.Array.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`numpy <flwr.common.Array.numpy>`\\ \\(\\)"
#~ msgstr ":py:obj:`numpy <flwr.common.Array.numpy>`\\ \\(\\)"

#~ msgid ":py:obj:`slice_array <flwr.common.Array.slice_array>`\\ \\(\\)"
#~ msgstr ":py:obj:`NDArray <flwr.common.NDArray>`\\"

#~ msgid ":py:obj:`children <flwr.common.Array.children>`\\"
#~ msgstr ":py:obj:`shape <flwr.common.Array.shape>`\\"

#~ msgid ":py:obj:`is_dirty <flwr.common.Array.is_dirty>`\\"
#~ msgstr ":py:obj:`stype <flwr.common.Array.stype>`\\"

#~ msgid ":py:obj:`object_id <flwr.common.Array.object_id>`\\"
#~ msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#~ msgid ":py:obj:`dtype <flwr.common.Array.dtype>`\\"
#~ msgstr ":py:obj:`dtype <flwr.common.Array.dtype>`\\"

#~ msgid ":py:obj:`shape <flwr.common.Array.shape>`\\"
#~ msgstr ":py:obj:`shape <flwr.common.Array.shape>`\\"

#~ msgid ":py:obj:`stype <flwr.common.Array.stype>`\\"
#~ msgstr ":py:obj:`stype <flwr.common.Array.stype>`\\"

#~ msgid ":py:obj:`data <flwr.common.Array.data>`\\"
#~ msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#~ msgid ":py:obj:`clear <flwr.common.ArrayRecord.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.ArrayRecord.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`count_bytes <flwr.common.ArrayRecord.count_bytes>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`count_bytes "
#~ "<flwr.common.ParametersRecord.count_bytes>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.ArrayRecord.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#~ msgid ""
#~ ":py:obj:`from_array_dict "
#~ "<flwr.common.ArrayRecord.from_array_dict>`\\ \\(array\\_dict\\,"
#~ " \\*\\[\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
#~ "\\(\\[array\\_dict\\, keep\\_input\\]\\)"

#~ msgid ""
#~ ":py:obj:`from_numpy_ndarrays "
#~ "<flwr.common.ArrayRecord.from_numpy_ndarrays>`\\ \\(ndarrays\\,"
#~ " \\*\\[\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`from_torch_state_dict "
#~ "<flwr.common.ArrayRecord.from_torch_state_dict>`\\ "
#~ "\\(state\\_dict\\, \\*\\[\\, ...\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ParametersRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`get <flwr.common.ArrayRecord.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.ArrayRecord.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.ArrayRecord.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.ArrayRecord.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.ArrayRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.ArrayRecord.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.ArrayRecord.setdefault>`\\ "
#~ "\\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`to_numpy_ndarrays "
#~ "<flwr.common.ArrayRecord.to_numpy_ndarrays>`\\ \\(\\*\\[\\, "
#~ "keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`to_torch_state_dict "
#~ "<flwr.common.ArrayRecord.to_torch_state_dict>`\\ \\(\\*\\[\\,"
#~ " keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
#~ "\\(\\[array\\_dict\\, keep\\_input\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.ArrayRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.ArrayRecord.values>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`children <flwr.common.ArrayRecord.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`is_dirty <flwr.common.ArrayRecord.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`object_id <flwr.common.ArrayRecord.object_id>`\\"
#~ msgstr ":py:obj:`data <flwr.common.Array.data>`\\"

#~ msgid "ClientMessage"
#~ msgstr "클라이언트 메시지"

#~ msgid ":py:obj:`evaluate_res <flwr.common.ClientMessage.evaluate_res>`\\"
#~ msgstr ":py:obj:`evaluate_res <flwr.common.ClientMessage.evaluate_res>`\\"

#~ msgid ":py:obj:`fit_res <flwr.common.ClientMessage.fit_res>`\\"
#~ msgstr ":py:obj:`fit_res <flwr.common.ClientMessage.fit_res>`\\"

#~ msgid ""
#~ ":py:obj:`get_parameters_res "
#~ "<flwr.common.ClientMessage.get_parameters_res>`\\"
#~ msgstr ""
#~ ":py:obj:`get_parameters_res "
#~ "<flwr.common.ClientMessage.get_parameters_res>`\\"

#~ msgid ""
#~ ":py:obj:`get_properties_res "
#~ "<flwr.common.ClientMessage.get_properties_res>`\\"
#~ msgstr ""
#~ ":py:obj:`get_properties_res "
#~ "<flwr.common.ClientMessage.get_properties_res>`\\"

#~ msgid "Code"
#~ msgstr "코드"

#~ msgid "Bases: :py:class:`~enum.Enum`"
#~ msgstr "Bases: :py:class:`~enum.Enum`"

#~ msgid ":py:obj:`OK <flwr.common.Code.OK>`\\"
#~ msgstr ":py:obj:`OK <flwr.common.Code.OK>`\\"

#~ msgid ""
#~ ":py:obj:`GET_PROPERTIES_NOT_IMPLEMENTED "
#~ "<flwr.common.Code.GET_PROPERTIES_NOT_IMPLEMENTED>`\\"
#~ msgstr ""
#~ ":py:obj:`GET_PROPERTIES_NOT_IMPLEMENTED "
#~ "<flwr.common.Code.GET_PROPERTIES_NOT_IMPLEMENTED>`\\"

#~ msgid ""
#~ ":py:obj:`GET_PARAMETERS_NOT_IMPLEMENTED "
#~ "<flwr.common.Code.GET_PARAMETERS_NOT_IMPLEMENTED>`\\"
#~ msgstr ""
#~ ":py:obj:`GET_PARAMETERS_NOT_IMPLEMENTED "
#~ "<flwr.common.Code.GET_PARAMETERS_NOT_IMPLEMENTED>`\\"

#~ msgid ":py:obj:`FIT_NOT_IMPLEMENTED <flwr.common.Code.FIT_NOT_IMPLEMENTED>`\\"
#~ msgstr ":py:obj:`FIT_NOT_IMPLEMENTED <flwr.common.Code.FIT_NOT_IMPLEMENTED>`\\"

#~ msgid ""
#~ ":py:obj:`EVALUATE_NOT_IMPLEMENTED "
#~ "<flwr.common.Code.EVALUATE_NOT_IMPLEMENTED>`\\"
#~ msgstr ""
#~ ":py:obj:`EVALUATE_NOT_IMPLEMENTED "
#~ "<flwr.common.Code.EVALUATE_NOT_IMPLEMENTED>`\\"

#~ msgid "Config"
#~ msgstr "구성"

#~ msgid ":py:obj:`clear <flwr.common.ConfigRecord.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.ConfigRecord.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`count_bytes <flwr.common.ConfigRecord.count_bytes>`\\ \\(\\)"
#~ msgstr ":py:obj:`count_bytes <flwr.common.ConfigsRecord.count_bytes>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.ConfigRecord.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`get <flwr.common.ConfigRecord.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.ConfigRecord.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.ConfigRecord.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.ConfigRecord.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.ConfigRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.ConfigsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.ConfigRecord.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.ConfigRecord.setdefault>`\\ "
#~ "\\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.ConfigRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.ConfigsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.ConfigRecord.values>`\\ \\(\\)"
#~ msgstr ":py:obj:`values <flwr.common.ConfigsRecord.values>`\\ \\(\\)"

#~ msgid ":py:obj:`children <flwr.common.ConfigRecord.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`is_dirty <flwr.common.ConfigRecord.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`object_id <flwr.common.ConfigRecord.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#~ msgid "ConfigsRecord"
#~ msgstr "컨피그 레코드"

#~ msgid "Bases: :py:class:`~flwr.common.record.configrecord.ConfigRecord`"
#~ msgstr ""

#~ msgid ""
#~ "This class exists solely for backward"
#~ " compatibility with legacy code that "
#~ "previously used ``ConfigsRecord``. It has "
#~ "been renamed to ``ConfigRecord``."
#~ msgstr ""

#~ msgid ""
#~ "``ConfigsRecord`` is deprecated and will "
#~ "be removed in a future release. "
#~ "Use ``ConfigRecord`` instead."
#~ msgstr ""

#~ msgid "Legacy (deprecated) usage::"
#~ msgstr ""

#~ msgid "Updated usage::"
#~ msgstr ""

#~ msgid ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.ConfigsRecord.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`count_bytes <flwr.common.ConfigsRecord.count_bytes>`\\ \\(\\)"
#~ msgstr ":py:obj:`count_bytes <flwr.common.ConfigsRecord.count_bytes>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.ConfigsRecord.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.ConfigsRecord.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.ConfigsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.ConfigsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.ConfigsRecord.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ConfigsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.ConfigsRecord.setdefault>`\\"
#~ " \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ConfigsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.ConfigsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.ConfigsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.ConfigsRecord.values>`\\ \\(\\)"
#~ msgstr ":py:obj:`values <flwr.common.ConfigsRecord.values>`\\ \\(\\)"

#~ msgid ":py:obj:`children <flwr.common.ConfigsRecord.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`is_dirty <flwr.common.ConfigsRecord.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.ConfigsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`object_id <flwr.common.ConfigsRecord.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.ConfigsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`run_id <flwr.common.Context.run_id>`\\"
#~ msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#~ msgid ":py:obj:`node_id <flwr.common.Context.node_id>`\\"
#~ msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#~ msgid ":py:obj:`node_config <flwr.common.Context.node_config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#~ msgid ":py:obj:`state <flwr.common.Context.state>`\\"
#~ msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#~ msgid ":py:obj:`run_config <flwr.common.Context.run_config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#~ msgid "DisconnectRes"
#~ msgstr "연결 해제"

#~ msgid ":py:obj:`reason <flwr.common.DisconnectRes.reason>`\\"
#~ msgstr ":py:obj:`reason <flwr.common.DisconnectRes.reason>`\\"

#~ msgid ":py:obj:`code <flwr.common.Error.code>`\\"
#~ msgstr ":py:obj:`code <flwr.common.Error.code>`\\"

#~ msgid ":py:obj:`reason <flwr.common.Error.reason>`\\"
#~ msgstr ":py:obj:`reason <flwr.common.Error.reason>`\\"

#~ msgid "EvaluateIns"
#~ msgstr "평가"

#~ msgid ":py:obj:`parameters <flwr.common.EvaluateIns.parameters>`\\"
#~ msgstr ":py:obj:`parameters <flwr.common.EvaluateIns.parameters>`\\"

#~ msgid ":py:obj:`config <flwr.common.EvaluateIns.config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.EvaluateIns.config>`\\"

#~ msgid "EvaluateRes"
#~ msgstr "EvaluateRes"

#~ msgid ":py:obj:`status <flwr.common.EvaluateRes.status>`\\"
#~ msgstr ":py:obj:`status <flwr.common.EvaluateRes.status>`\\"

#~ msgid ":py:obj:`loss <flwr.common.EvaluateRes.loss>`\\"
#~ msgstr ":py:obj:`loss <flwr.common.EvaluateRes.loss>`\\"

#~ msgid ":py:obj:`num_examples <flwr.common.EvaluateRes.num_examples>`\\"
#~ msgstr ":py:obj:`num_examples <flwr.common.EvaluateRes.num_examples>`\\"

#~ msgid ":py:obj:`metrics <flwr.common.EvaluateRes.metrics>`\\"
#~ msgstr ":py:obj:`metrics <flwr.common.EvaluateRes.metrics>`\\"

#~ msgid "EventType"
#~ msgstr "이벤트 타입"

#~ msgid "Bases: :py:class:`str`, :py:class:`~enum.Enum`"
#~ msgstr "Bases: :py:class:`str`, :py:class:`~enum.Enum`"

#~ msgid ""
#~ ":py:obj:`encode <flwr.common.EventType.encode>`\\ "
#~ "\\(\\[encoding\\, errors\\]\\)"
#~ msgstr ""
#~ ":py:obj:`encode <flwr.common.EventType.encode>`\\ "
#~ "\\(\\[encoding\\, errors\\]\\)"

#~ msgid "Encode the string using the codec registered for encoding."
#~ msgstr "인코딩용으로 등록된 코덱을 사용하여 문자열을 인코딩합니다."

#~ msgid ""
#~ ":py:obj:`replace <flwr.common.EventType.replace>`\\ "
#~ "\\(old\\, new\\[\\, count\\]\\)"
#~ msgstr ""
#~ ":py:obj:`replace <flwr.common.EventType.replace>`\\ "
#~ "\\(old\\, new\\[\\, count\\]\\)"

#~ msgid "Return a copy with all occurrences of substring old replaced by new."
#~ msgstr "이전 하위 문자열이 모두 새 하위 문자열로 바뀐 사본을 반환합니다."

#~ msgid ""
#~ ":py:obj:`split <flwr.common.EventType.split>`\\ "
#~ "\\(\\[sep\\, maxsplit\\]\\)"
#~ msgstr ""
#~ ":py:obj:`split <flwr.common.EventType.split>`\\ "
#~ "\\(\\[sep\\, maxsplit\\]\\)"

#~ msgid ""
#~ "Return a list of the substrings in"
#~ " the string, using sep as the "
#~ "separator string."
#~ msgstr "sep를 구분 문자열로 사용하여 문자열의 하위 문자열 목록을 반환합니다."

#~ msgid ""
#~ ":py:obj:`rsplit <flwr.common.EventType.rsplit>`\\ "
#~ "\\(\\[sep\\, maxsplit\\]\\)"
#~ msgstr ""
#~ ":py:obj:`rsplit <flwr.common.EventType.rsplit>`\\ "
#~ "\\(\\[sep\\, maxsplit\\]\\)"

#~ msgid ":py:obj:`join <flwr.common.EventType.join>`\\ \\(iterable\\, \\/\\)"
#~ msgstr ":py:obj:`join <flwr.common.EventType.join>`\\ \\(iterable\\, \\/\\)"

#~ msgid "Concatenate any number of strings."
#~ msgstr "원하는 수의 문자열을 연결합니다."

#~ msgid ":py:obj:`capitalize <flwr.common.EventType.capitalize>`\\ \\(\\)"
#~ msgstr ":py:obj:`capitalize <flwr.common.EventType.capitalize>`\\ \\(\\)"

#~ msgid "Return a capitalized version of the string."
#~ msgstr "대문자로 된 문자열을 반환합니다."

#~ msgid ":py:obj:`casefold <flwr.common.EventType.casefold>`\\ \\(\\)"
#~ msgstr ":py:obj:`casefold <flwr.common.EventType.casefold>`\\ \\(\\)"

#~ msgid "Return a version of the string suitable for caseless comparisons."
#~ msgstr "대소문자 구분 없는 비교에 적합한 문자열을 반환합니다."

#~ msgid ":py:obj:`title <flwr.common.EventType.title>`\\ \\(\\)"
#~ msgstr ":py:obj:`title <flwr.common.EventType.title>`\\ \\(\\)"

#~ msgid "Return a version of the string where each word is titlecased."
#~ msgstr "각 단어의 제목이 대소문자로 구분된 문자열을 반환합니다."

#~ msgid ""
#~ ":py:obj:`center <flwr.common.EventType.center>`\\ "
#~ "\\(width\\[\\, fillchar\\]\\)"
#~ msgstr ""
#~ ":py:obj:`center <flwr.common.EventType.center>`\\ "
#~ "\\(width\\[\\, fillchar\\]\\)"

#~ msgid "Return a centered string of length width."
#~ msgstr "길이 너비의 가운데 문자열을 반환합니다."

#~ msgid ""
#~ ":py:obj:`count <flwr.common.EventType.count>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`count <flwr.common.EventType.count>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"

#~ msgid ""
#~ "Return the number of non-overlapping "
#~ "occurrences of substring sub in string"
#~ " S[start:end]."
#~ msgstr "문자열 S[start:end]에서 하위 문자열 sub이 겹치지 않는 횟수를 반환합니다."

#~ msgid ""
#~ ":py:obj:`expandtabs <flwr.common.EventType.expandtabs>`\\ "
#~ "\\(\\[tabsize\\]\\)"
#~ msgstr ""
#~ ":py:obj:`expandtabs <flwr.common.EventType.expandtabs>`\\ "
#~ "\\(\\[tabsize\\]\\)"

#~ msgid "Return a copy where all tab characters are expanded using spaces."
#~ msgstr "모든 탭 문자가 공백을 사용하여 확장된 사본을 반환합니다."

#~ msgid ""
#~ ":py:obj:`find <flwr.common.EventType.find>`\\ \\(sub\\[\\,"
#~ " start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`find <flwr.common.EventType.find>`\\ \\(sub\\[\\,"
#~ " start\\[\\, end\\]\\]\\)"

#~ msgid ""
#~ "Return the lowest index in S where"
#~ " substring sub is found, such that"
#~ " sub is contained within S[start:end]."
#~ msgstr "하위 문자열 sub이 발견되는 S에서 하위가 S[start:end] 내에 포함되는 가장 낮은 인덱스를 반환합니다."

#~ msgid ""
#~ ":py:obj:`partition <flwr.common.EventType.partition>`\\ "
#~ "\\(sep\\, \\/\\)"
#~ msgstr ""
#~ ":py:obj:`partition <flwr.common.EventType.partition>`\\ "
#~ "\\(sep\\, \\/\\)"

#~ msgid "Partition the string into three parts using the given separator."
#~ msgstr "지정된 구분 기호를 사용하여 문자열을 세 부분으로 분할합니다."

#~ msgid ""
#~ ":py:obj:`index <flwr.common.EventType.index>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`index <flwr.common.EventType.index>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"

#~ msgid ""
#~ ":py:obj:`ljust <flwr.common.EventType.ljust>`\\ "
#~ "\\(width\\[\\, fillchar\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ljust <flwr.common.EventType.ljust>`\\ "
#~ "\\(width\\[\\, fillchar\\]\\)"

#~ msgid "Return a left-justified string of length width."
#~ msgstr "왼쪽으로 정렬된 길이의 문자열을 반환합니다."

#~ msgid ":py:obj:`lower <flwr.common.EventType.lower>`\\ \\(\\)"
#~ msgstr ":py:obj:`lower <flwr.common.EventType.lower>`\\ \\(\\)"

#~ msgid "Return a copy of the string converted to lowercase."
#~ msgstr "소문자로 변환된 문자열 사본을 반환합니다."

#~ msgid ":py:obj:`lstrip <flwr.common.EventType.lstrip>`\\ \\(\\[chars\\]\\)"
#~ msgstr ":py:obj:`lstrip <flwr.common.EventType.lstrip>`\\ \\(\\[chars\\]\\)"

#~ msgid "Return a copy of the string with leading whitespace removed."
#~ msgstr "선행 공백이 제거된 문자열의 복사본을 반환합니다."

#~ msgid ""
#~ ":py:obj:`rfind <flwr.common.EventType.rfind>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`rfind <flwr.common.EventType.rfind>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"

#~ msgid ""
#~ "Return the highest index in S "
#~ "where substring sub is found, such "
#~ "that sub is contained within "
#~ "S[start:end]."
#~ msgstr "부분 문자열 sub이 발견되는 곳에서 sub이 S[start:end] 내에 포함되도록 S에서 가장 높은 인덱스를 반환합니다."

#~ msgid ""
#~ ":py:obj:`rindex <flwr.common.EventType.rindex>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`rindex <flwr.common.EventType.rindex>`\\ "
#~ "\\(sub\\[\\, start\\[\\, end\\]\\]\\)"

#~ msgid ""
#~ ":py:obj:`rjust <flwr.common.EventType.rjust>`\\ "
#~ "\\(width\\[\\, fillchar\\]\\)"
#~ msgstr ""
#~ ":py:obj:`rjust <flwr.common.EventType.rjust>`\\ "
#~ "\\(width\\[\\, fillchar\\]\\)"

#~ msgid "Return a right-justified string of length width."
#~ msgstr "길이 너비의 오른쪽 정렬된 문자열을 반환합니다."

#~ msgid ":py:obj:`rstrip <flwr.common.EventType.rstrip>`\\ \\(\\[chars\\]\\)"
#~ msgstr ":py:obj:`rstrip <flwr.common.EventType.rstrip>`\\ \\(\\[chars\\]\\)"

#~ msgid "Return a copy of the string with trailing whitespace removed."
#~ msgstr "후행 공백이 제거된 문자열의 복사본을 반환합니다."

#~ msgid ""
#~ ":py:obj:`rpartition <flwr.common.EventType.rpartition>`\\ "
#~ "\\(sep\\, \\/\\)"
#~ msgstr ""
#~ ":py:obj:`rpartition <flwr.common.EventType.rpartition>`\\ "
#~ "\\(sep\\, \\/\\)"

#~ msgid ""
#~ ":py:obj:`splitlines <flwr.common.EventType.splitlines>`\\ "
#~ "\\(\\[keepends\\]\\)"
#~ msgstr ""
#~ ":py:obj:`splitlines <flwr.common.EventType.splitlines>`\\ "
#~ "\\(\\[keepends\\]\\)"

#~ msgid "Return a list of the lines in the string, breaking at line boundaries."
#~ msgstr "문자열의 줄 목록을 줄 경계에서 구분하여 반환합니다."

#~ msgid ":py:obj:`strip <flwr.common.EventType.strip>`\\ \\(\\[chars\\]\\)"
#~ msgstr ":py:obj:`strip <flwr.common.EventType.strip>`\\ \\(\\[chars\\]\\)"

#~ msgid ""
#~ "Return a copy of the string with"
#~ " leading and trailing whitespace removed."
#~ msgstr "선행 및 후행 공백이 제거된 문자열 사본을 반환합니다."

#~ msgid ":py:obj:`swapcase <flwr.common.EventType.swapcase>`\\ \\(\\)"
#~ msgstr ":py:obj:`swapcase <flwr.common.EventType.swapcase>`\\ \\(\\)"

#~ msgid ""
#~ "Convert uppercase characters to lowercase "
#~ "and lowercase characters to uppercase."
#~ msgstr "대문자를 소문자로, 소문자를 대문자로 변환합니다."

#~ msgid ""
#~ ":py:obj:`translate <flwr.common.EventType.translate>`\\ "
#~ "\\(table\\, \\/\\)"
#~ msgstr ""
#~ ":py:obj:`translate <flwr.common.EventType.translate>`\\ "
#~ "\\(table\\, \\/\\)"

#~ msgid "Replace each character in the string using the given translation table."
#~ msgstr "주어진 번역 테이블을 사용하여 문자열의 각 문자를 바꿉니다."

#~ msgid ":py:obj:`upper <flwr.common.EventType.upper>`\\ \\(\\)"
#~ msgstr ":py:obj:`upper <flwr.common.EventType.upper>`\\ \\(\\)"

#~ msgid "Return a copy of the string converted to uppercase."
#~ msgstr "Return a copy of the string converted to uppercase."

#~ msgid ""
#~ ":py:obj:`startswith <flwr.common.EventType.startswith>`\\ "
#~ "\\(prefix\\[\\, start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`startswith <flwr.common.EventType.startswith>`\\ "
#~ "\\(prefix\\[\\, start\\[\\, end\\]\\]\\)"

#~ msgid "Return True if S starts with the specified prefix, False otherwise."
#~ msgstr "S가 지정된 접두사로 시작하면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ""
#~ ":py:obj:`endswith <flwr.common.EventType.endswith>`\\ "
#~ "\\(suffix\\[\\, start\\[\\, end\\]\\]\\)"
#~ msgstr ""
#~ ":py:obj:`endswith <flwr.common.EventType.endswith>`\\ "
#~ "\\(suffix\\[\\, start\\[\\, end\\]\\]\\)"

#~ msgid "Return True if S ends with the specified suffix, False otherwise."
#~ msgstr "S가 지정된 접미사로 끝나면 True를 반환하고 그렇지 않으면 False을 반환합니다."

#~ msgid ""
#~ ":py:obj:`removeprefix <flwr.common.EventType.removeprefix>`\\"
#~ " \\(prefix\\, \\/\\)"
#~ msgstr ""
#~ ":py:obj:`removeprefix <flwr.common.EventType.removeprefix>`\\"
#~ " \\(prefix\\, \\/\\)"

#~ msgid "Return a str with the given prefix string removed if present."
#~ msgstr "주어진 접두사 문자열이 있는 경우 제거된 문자열을 반환합니다."

#~ msgid ""
#~ ":py:obj:`removesuffix <flwr.common.EventType.removesuffix>`\\"
#~ " \\(suffix\\, \\/\\)"
#~ msgstr ""
#~ ":py:obj:`removesuffix <flwr.common.EventType.removesuffix>`\\"
#~ " \\(suffix\\, \\/\\)"

#~ msgid "Return a str with the given suffix string removed if present."
#~ msgstr "주어진 접미사 문자열이 있는 경우 제거된 문자열을 반환합니다."

#~ msgid ":py:obj:`isascii <flwr.common.EventType.isascii>`\\ \\(\\)"
#~ msgstr ":py:obj:`isascii <flwr.common.EventType.isascii>`\\ \\(\\)"

#~ msgid "Return True if all characters in the string are ASCII, False otherwise."
#~ msgstr "문자열의 모든 문자가 ASCII인 경우 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`islower <flwr.common.EventType.islower>`\\ \\(\\)"
#~ msgstr ":py:obj:`islower <flwr.common.EventType.islower>`\\ \\(\\)"

#~ msgid "Return True if the string is a lowercase string, False otherwise."
#~ msgstr "문자열이 소문자 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isupper <flwr.common.EventType.isupper>`\\ \\(\\)"
#~ msgstr ":py:obj:`isupper <flwr.common.EventType.isupper>`\\ \\(\\)"

#~ msgid "Return True if the string is an uppercase string, False otherwise."
#~ msgstr "문자열이 대문자 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`istitle <flwr.common.EventType.istitle>`\\ \\(\\)"
#~ msgstr ":py:obj:`istitle <flwr.common.EventType.istitle>`\\ \\(\\)"

#~ msgid "Return True if the string is a title-cased string, False otherwise."
#~ msgstr "문자열이 제목 대/소문자가 구분된 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isspace <flwr.common.EventType.isspace>`\\ \\(\\)"
#~ msgstr ":py:obj:`isspace <flwr.common.EventType.isspace>`\\ \\(\\)"

#~ msgid "Return True if the string is a whitespace string, False otherwise."
#~ msgstr "문자열이 공백 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isdecimal <flwr.common.EventType.isdecimal>`\\ \\(\\)"
#~ msgstr ":py:obj:`isdecimal <flwr.common.EventType.isdecimal>`\\ \\(\\)"

#~ msgid "Return True if the string is a decimal string, False otherwise."
#~ msgstr "문자열이 10진수 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isdigit <flwr.common.EventType.isdigit>`\\ \\(\\)"
#~ msgstr ":py:obj:`isdigit <flwr.common.EventType.isdigit>`\\ \\(\\)"

#~ msgid "Return True if the string is a digit string, False otherwise."
#~ msgstr "문자열이 숫자 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isnumeric <flwr.common.EventType.isnumeric>`\\ \\(\\)"
#~ msgstr ":py:obj:`isnumeric <flwr.common.EventType.isnumeric>`\\ \\(\\)"

#~ msgid "Return True if the string is a numeric string, False otherwise."
#~ msgstr "문자열이 숫자 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isalpha <flwr.common.EventType.isalpha>`\\ \\(\\)"
#~ msgstr ":py:obj:`isalpha <flwr.common.EventType.isalpha>`\\ \\(\\)"

#~ msgid "Return True if the string is an alphabetic string, False otherwise."
#~ msgstr "문자열이 알파벳 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isalnum <flwr.common.EventType.isalnum>`\\ \\(\\)"
#~ msgstr ":py:obj:`isalnum <flwr.common.EventType.isalnum>`\\ \\(\\)"

#~ msgid "Return True if the string is an alpha-numeric string, False otherwise."
#~ msgstr "문자열이 영-숫자 문자열이면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isidentifier <flwr.common.EventType.isidentifier>`\\ \\(\\)"
#~ msgstr ":py:obj:`isidentifier <flwr.common.EventType.isidentifier>`\\ \\(\\)"

#~ msgid ""
#~ "Return True if the string is a "
#~ "valid Python identifier, False otherwise."
#~ msgstr "문자열이 유효한 파이썬 식별자인 경우 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`isprintable <flwr.common.EventType.isprintable>`\\ \\(\\)"
#~ msgstr ":py:obj:`isprintable <flwr.common.EventType.isprintable>`\\ \\(\\)"

#~ msgid "Return True if the string is printable, False otherwise."
#~ msgstr "문자열을 인쇄할 수 있으면 True를 반환하고, 그렇지 않으면 False를 반환합니다."

#~ msgid ":py:obj:`zfill <flwr.common.EventType.zfill>`\\ \\(width\\, \\/\\)"
#~ msgstr ":py:obj:`zfill <flwr.common.EventType.zfill>`\\ \\(width\\, \\/\\)"

#~ msgid ""
#~ "Pad a numeric string with zeros on"
#~ " the left, to fill a field of"
#~ " the given width."
#~ msgstr "숫자 문자열을 왼쪽에 0으로 채워서 지정된 너비의 필드를 채웁니다."

#~ msgid ""
#~ ":py:obj:`format <flwr.common.EventType.format>`\\ "
#~ "\\(\\*args\\, \\*\\*kwargs\\)"
#~ msgstr ""
#~ ":py:obj:`format <flwr.common.EventType.format>`\\ "
#~ "\\(\\*args\\, \\*\\*kwargs\\)"

#~ msgid ""
#~ "Return a formatted version of S, "
#~ "using substitutions from args and "
#~ "kwargs."
#~ msgstr "args와 kwarg의 치환을 사용하여 형식이 지정된 S를 반환합니다."

#~ msgid ":py:obj:`format_map <flwr.common.EventType.format_map>`\\ \\(mapping\\)"
#~ msgstr ":py:obj:`format_map <flwr.common.EventType.format_map>`\\ \\(mapping\\)"

#~ msgid "Return a formatted version of S, using substitutions from mapping."
#~ msgstr "매핑의 치환을 사용하여 형식이 지정된 S를 반환합니다."

#~ msgid ":py:obj:`maketrans <flwr.common.EventType.maketrans>`\\"
#~ msgstr ":py:obj:`maketrans <flwr.common.EventType.maketrans>`\\"

#~ msgid "Return a translation table usable for str.translate()."
#~ msgstr "str.translate()에 사용할 수 있는 번역 테이블을 반환합니다."

#~ msgid ":py:obj:`PING <flwr.common.EventType.PING>`\\"
#~ msgstr ":py:obj:`PING <flwr.common.EventType.PING>`\\"

#~ msgid ""
#~ ":py:obj:`START_CLIENT_ENTER "
#~ "<flwr.common.EventType.START_CLIENT_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_CLIENT_ENTER "
#~ "<flwr.common.EventType.START_CLIENT_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`START_CLIENT_LEAVE "
#~ "<flwr.common.EventType.START_CLIENT_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_CLIENT_LEAVE "
#~ "<flwr.common.EventType.START_CLIENT_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`START_SERVER_ENTER "
#~ "<flwr.common.EventType.START_SERVER_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SERVER_ENTER "
#~ "<flwr.common.EventType.START_SERVER_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`START_SERVER_LEAVE "
#~ "<flwr.common.EventType.START_SERVER_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SERVER_LEAVE "
#~ "<flwr.common.EventType.START_SERVER_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`START_SIMULATION_ENTER "
#~ "<flwr.common.EventType.START_SIMULATION_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_ENTER "
#~ "<flwr.common.EventType.START_SIMULATION_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`START_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.START_SIMULATION_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.START_SIMULATION_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`FLWR_SIMULATION_RUN_ENTER "
#~ "<flwr.common.EventType.FLWR_SIMULATION_RUN_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_ENTER "
#~ "<flwr.common.EventType.START_SIMULATION_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`FLWR_SIMULATION_RUN_LEAVE "
#~ "<flwr.common.EventType.FLWR_SIMULATION_RUN_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.START_SIMULATION_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`FLWR_SERVERAPP_RUN_ENTER "
#~ "<flwr.common.EventType.FLWR_SERVERAPP_RUN_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SERVER_APP_ENTER "
#~ "<flwr.common.EventType.RUN_SERVER_APP_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`FLWR_SERVERAPP_RUN_LEAVE "
#~ "<flwr.common.EventType.FLWR_SERVERAPP_RUN_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SERVER_APP_LEAVE "
#~ "<flwr.common.EventType.RUN_SERVER_APP_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`CLI_FLOWER_SIMULATION_ENTER "
#~ "<flwr.common.EventType.CLI_FLOWER_SIMULATION_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_ENTER "
#~ "<flwr.common.EventType.START_SIMULATION_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`CLI_FLOWER_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.CLI_FLOWER_SIMULATION_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.START_SIMULATION_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`PYTHON_API_RUN_SIMULATION_ENTER "
#~ "<flwr.common.EventType.PYTHON_API_RUN_SIMULATION_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_ENTER "
#~ "<flwr.common.EventType.START_SIMULATION_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`PYTHON_API_RUN_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.PYTHON_API_RUN_SIMULATION_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`START_SIMULATION_LEAVE "
#~ "<flwr.common.EventType.START_SIMULATION_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_SUPERLINK_ENTER "
#~ "<flwr.common.EventType.RUN_SUPERLINK_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SUPERLINK_ENTER "
#~ "<flwr.common.EventType.RUN_SUPERLINK_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_SUPERLINK_LEAVE "
#~ "<flwr.common.EventType.RUN_SUPERLINK_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SUPERLINK_LEAVE "
#~ "<flwr.common.EventType.RUN_SUPERLINK_LEAVE>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_SUPERNODE_ENTER "
#~ "<flwr.common.EventType.RUN_SUPERNODE_ENTER>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SUPERNODE_ENTER "
#~ "<flwr.common.EventType.RUN_SUPERNODE_ENTER>`\\"

#~ msgid ""
#~ ":py:obj:`RUN_SUPERNODE_LEAVE "
#~ "<flwr.common.EventType.RUN_SUPERNODE_LEAVE>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_SUPERNODE_LEAVE "
#~ "<flwr.common.EventType.RUN_SUPERNODE_LEAVE>`\\"

#~ msgid ""
#~ "More specifically, make the first "
#~ "character have upper case and the "
#~ "rest lower case."
#~ msgstr "보다 구체적으로, 첫 번째 문자는 대문자로, 나머지는 소문자로 만듭니다."

#~ msgid ""
#~ "Padding is done using the specified "
#~ "fill character (default is a space)."
#~ msgstr "패딩은 지정된 채우기 문자를 사용하여 수행됩니다(기본값은 공백)."

#~ msgid ""
#~ "Return the number of non-overlapping "
#~ "occurrences of substring sub in string"
#~ " S[start:end].  Optional arguments start "
#~ "and end are interpreted as in "
#~ "slice notation."
#~ msgstr ""
#~ "문자열 S[start:end]에서 부분 문자열 sub의 겹치지 "
#~ "않는 횟수를 반환합니다.  선택적 인자 start와 end는"
#~ " 슬라이스 표기법과 같이 해석됩니다."

#~ msgid "encoding"
#~ msgstr "인코딩"

#~ msgid "The encoding in which to encode the string."
#~ msgstr "문자열을 인코딩합니다."

#~ msgid "errors"
#~ msgstr "오류"

#~ msgid ""
#~ "The error handling scheme to use "
#~ "for encoding errors. The default is "
#~ "'strict' meaning that encoding errors "
#~ "raise a UnicodeEncodeError.  Other possible"
#~ " values are 'ignore', 'replace' and "
#~ "'xmlcharrefreplace' as well as any other"
#~ " name registered with codecs.register_error "
#~ "that can handle UnicodeEncodeErrors."
#~ msgstr ""
#~ "인코딩 오류에 사용할 오류 처리 방식입니다. 기본값은 "
#~ "'strict'로, 인코딩 오류가 발생하면 UnicodeEncodeError를"
#~ " 발생시킵니다.  다른 가능한 값으로는 'ignore', "
#~ "'replace', 'xmlcharrefreplace', 그리고 "
#~ "UnicodeEncodeError를 처리할 수 있는 "
#~ "codecs.register_error에 등록된 다른 이름도 사용할 수"
#~ " 있습니다."

#~ msgid ""
#~ "Return True if S ends with the "
#~ "specified suffix, False otherwise. With "
#~ "optional start, test S beginning at "
#~ "that position. With optional end, stop"
#~ " comparing S at that position. suffix"
#~ " can also be a tuple of strings"
#~ " to try."
#~ msgstr ""
#~ "S가 지정된 접미사로 끝나면 True를 반환하고, 그렇지"
#~ " 않으면 False를 반환합니다. 시작 옵션을 사용하면 "
#~ "해당 위치부터 S를 테스트합니다. end 옵션을 사용하면"
#~ " 해당 위치에서 S 비교를 중지합니다. 접미사는 시도할"
#~ " 문자열의 튜플일 수도 있습니다."

#~ msgid "If tabsize is not given, a tab size of 8 characters is assumed."
#~ msgstr "탭 크기를 지정하지 않으면 크기가 8로 지정됩니다."

#~ msgid ""
#~ "Return the lowest index in S where"
#~ " substring sub is found, such that"
#~ " sub is contained within S[start:end].  "
#~ "Optional arguments start and end are "
#~ "interpreted as in slice notation."
#~ msgstr ""
#~ "부분 문자열 sub가 발견되는 곳의 가장 낮은 "
#~ "인덱스를 반환하며, sub는 S[start:end] 내에 포함되어야"
#~ " 합니다.  선택적 인자 start와 end는 슬라이스 "
#~ "표기법과 같이 해석됩니다."

#~ msgid "Return -1 on failure."
#~ msgstr "실패 시 -1을 반환합니다."

#~ msgid ""
#~ "Return a formatted version of S, "
#~ "using substitutions from args and "
#~ "kwargs. The substitutions are identified "
#~ "by braces ('{' and '}')."
#~ msgstr "args와 kwargs의 치환을 사용하여 형식이 지정된 S를 반환합니다. 치환은 중괄호('{' 및 '}')로 식별됩니다."

#~ msgid ""
#~ "Return a formatted version of S, "
#~ "using substitutions from mapping. The "
#~ "substitutions are identified by braces "
#~ "('{' and '}')."
#~ msgstr "매핑의 치환을 사용하여 형식이 지정된 S를 반환합니다. 치환은 중괄호('{' 및 '}')로 식별됩니다."

#~ msgid "Raises ValueError when the substring is not found."
#~ msgstr "부분 문자열을 찾을 수 없을 때 ValueError를 발생시킵니다."

#~ msgid ""
#~ "A string is alpha-numeric if all"
#~ " characters in the string are "
#~ "alpha-numeric and there is at least"
#~ " one character in the string."
#~ msgstr "문자열의 모든 문자가 영숫자이고 문자열에 하나 이상의 문자가 있는 경우 문자열은 영-숫자입니다."

#~ msgid ""
#~ "A string is alphabetic if all "
#~ "characters in the string are alphabetic"
#~ " and there is at least one "
#~ "character in the string."
#~ msgstr "문자열의 모든 문자가 알파벳이고 문자열에 하나 이상의 문자가 있는 경우 문자열은 알파벳입니다."

#~ msgid ""
#~ "ASCII characters have code points in "
#~ "the range U+0000-U+007F. Empty string is"
#~ " ASCII too."
#~ msgstr "ASCII 문자는 U+0000-U+007F 범위의 코드 포인트가 있습니다. 빈 문자열도 ASCII입니다."

#~ msgid ""
#~ "A string is a decimal string if"
#~ " all characters in the string are "
#~ "decimal and there is at least one"
#~ " character in the string."
#~ msgstr "문자열의 모든 문자가 10진수이고 문자열에 하나 이상의 문자가 있는 경우 문자열은 10진수 문자열입니다."

#~ msgid ""
#~ "A string is a digit string if "
#~ "all characters in the string are "
#~ "digits and there is at least one"
#~ " character in the string."
#~ msgstr "문자열의 모든 문자가 숫자이고 문자열에 하나 이상의 문자가 있는 경우 문자열은 숫자 문자열입니다."

#~ msgid ""
#~ "Call keyword.iskeyword(s) to test whether "
#~ "string s is a reserved identifier, "
#~ "such as \"def\" or \"class\"."
#~ msgstr ""
#~ "keyword.iskeyword(s)를 호출하여 문자열 s가 \"def\" "
#~ "또는 \"class\"와 같은 예약 식별자인지 테스트합니다."

#~ msgid ""
#~ "A string is lowercase if all cased"
#~ " characters in the string are "
#~ "lowercase and there is at least "
#~ "one cased character in the string."
#~ msgstr "문자열이 모두 소문자이고 문자열에 문자가 하나 이상 있는 경우 문자열은 소문자입니다."

#~ msgid ""
#~ "A string is numeric if all "
#~ "characters in the string are numeric "
#~ "and there is at least one "
#~ "character in the string."
#~ msgstr "문자열의 모든 문자가 숫자이고 문자열에 하나 이상의 문자가 있는 경우 문자열은 숫자입니다."

#~ msgid ""
#~ "A string is printable if all of"
#~ " its characters are considered printable"
#~ " in repr() or if it is empty."
#~ msgstr "문자열은 repr()에서 모든 문자가 인쇄 가능한 것으로 간주되거나 비어 있는 경우 인쇄할 수 있습니다."

#~ msgid ""
#~ "A string is whitespace if all "
#~ "characters in the string are whitespace"
#~ " and there is at least one "
#~ "character in the string."
#~ msgstr "문자열의 모든 문자가 공백이고 문자열에 하나 이상의 문자가 있는 경우 문자열은 공백입니다."

#~ msgid ""
#~ "In a title-cased string, upper- "
#~ "and title-case characters may only "
#~ "follow uncased characters and lowercase "
#~ "characters only cased ones."
#~ msgstr "제목 대/소문자 문자열에서 대문자와 제목 대문자는 대소문자만, 소문자는 대문자만 뒤에 올 수 있습니다."

#~ msgid ""
#~ "A string is uppercase if all cased"
#~ " characters in the string are "
#~ "uppercase and there is at least "
#~ "one cased character in the string."
#~ msgstr "문자열의 모든 문자가 대문자이고 문자열에 문자가 하나 이상 있는 경우 문자열은 대문자입니다."

#~ msgid ""
#~ "The string whose method is called "
#~ "is inserted in between each given "
#~ "string. The result is returned as "
#~ "a new string."
#~ msgstr "메서드가 호출되는 문자열은 주어진 각 문자열 사이에 삽입됩니다. 결과는 새 문자열로 반환됩니다."

#~ msgid "Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'"
#~ msgstr "Example: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'"

#~ msgid "If chars is given and not None, remove characters in chars instead."
#~ msgstr "None이 아닌 문자가 지정되면 대신 문자열에서 문자를 제거합니다."

#~ msgid ""
#~ "If there is only one argument, it"
#~ " must be a dictionary mapping Unicode"
#~ " ordinals (integers) or characters to "
#~ "Unicode ordinals, strings or None. "
#~ "Character keys will be then converted"
#~ " to ordinals. If there are two "
#~ "arguments, they must be strings of "
#~ "equal length, and in the resulting "
#~ "dictionary, each character in x will "
#~ "be mapped to the character at the"
#~ " same position in y. If there "
#~ "is a third argument, it must be"
#~ " a string, whose characters will be"
#~ " mapped to None in the result."
#~ msgstr ""
#~ "argument이 하나만 있는 경우, 유니코드 서수(정수) "
#~ "또는 문자를 유니코드 서수, 문자열 또는 None에 "
#~ "매핑하는 dictionary이어야 합니다. 그러면 문자 키가 "
#~ "서수로 변환됩니다. 인수가 두 개이면 길이가 같은 "
#~ "문자열이어야 하며, 결과 dictionary에서 x의 각 "
#~ "문자는 y의 같은 위치에 있는 문자에 매핑됩니다. "
#~ "세 번째 인수가 있으면 문자열이어야 하며, 그 "
#~ "문자는 결과에서 None에 매핑됩니다."

#~ msgid ""
#~ "This will search for the separator "
#~ "in the string.  If the separator "
#~ "is found, returns a 3-tuple containing"
#~ " the part before the separator, the"
#~ " separator itself, and the part after"
#~ " it."
#~ msgstr ""
#~ "문자열에서 구분 기호를 검색합니다.  구분 기호가 발견되면"
#~ " 구분 기호 앞 부분, 구분 기호 자체, 구분"
#~ " 기호 뒤 부분을 포함하는 3-tuple을 반환합니다."

#~ msgid ""
#~ "If the separator is not found, "
#~ "returns a 3-tuple containing the "
#~ "original string and two empty strings."
#~ msgstr "구분 기호를 찾을 수 없으면 원래 문자열과 빈 문자열 2개를 포함하는 3-튜플을 반환합니다."

#~ msgid ""
#~ "If the string starts with the "
#~ "prefix string, return string[len(prefix):]. "
#~ "Otherwise, return a copy of the "
#~ "original string."
#~ msgstr ""
#~ "문자열이 접두사 문자열로 시작하면 문자열[len(prefix):]을 "
#~ "반환합니다. 그렇지 않으면 원본 문자열의 복사본을 반환합니다."

#~ msgid ""
#~ "If the string ends with the suffix"
#~ " string and that suffix is not "
#~ "empty, return string[:-len(suffix)]. Otherwise, "
#~ "return a copy of the original "
#~ "string."
#~ msgstr ""
#~ "문자열이 접미사 문자열로 끝나고 해당 접미사가 비어 "
#~ "있지 않으면 문자열[:-len(suffix)]을 반환합니다. 그렇지 "
#~ "않으면 원본 문자열의 복사본을 반환합니다."

#~ msgid "count"
#~ msgstr "카운트"

#~ msgid ""
#~ "Maximum number of occurrences to "
#~ "replace. -1 (the default value) means"
#~ " replace all occurrences."
#~ msgstr "대체할 최대 발생 횟수입니다. -1(기본값)은 모든 항목을 교체한다는 의미입니다."

#~ msgid ""
#~ "If the optional argument count is "
#~ "given, only the first count occurrences"
#~ " are replaced."
#~ msgstr "선택적 argument 개수를 지정하면 첫 번째 개수만 바뀝니다."

#~ msgid ""
#~ "Return the highest index in S "
#~ "where substring sub is found, such "
#~ "that sub is contained within "
#~ "S[start:end].  Optional arguments start and"
#~ " end are interpreted as in slice "
#~ "notation."
#~ msgstr ""
#~ "부분 문자열 sub가 발견되는 곳의 가장 높은 "
#~ "인덱스를 반환하며, sub는 S[start:end] 내에 포함되어야"
#~ " 합니다.  선택적 인자 start와 end는 슬라이스 "
#~ "표기법과 같이 해석됩니다."

#~ msgid ""
#~ "This will search for the separator "
#~ "in the string, starting at the "
#~ "end. If the separator is found, "
#~ "returns a 3-tuple containing the part"
#~ " before the separator, the separator "
#~ "itself, and the part after it."
#~ msgstr ""
#~ "그러면 문자열에서 끝 부분부터 시작하여 구분 기호를 "
#~ "검색합니다. 구분 기호가 발견되면 구분 기호 앞 "
#~ "부분, 구분 기호 자체, 구분 기호 뒤 부분을"
#~ " 포함하는 3-tuple을 반환합니다."

#~ msgid ""
#~ "If the separator is not found, "
#~ "returns a 3-tuple containing two empty"
#~ " strings and the original string."
#~ msgstr "구분 기호를 찾을 수 없는 경우 빈 문자열 2개와 원래 문자열을 포함하는 3-tuple을 반환합니다."

#~ msgid "sep"
#~ msgstr "sep"

#~ msgid "The separator used to split the string."
#~ msgstr "문자열을 분할하는 데 사용되는 구분 기호입니다."

#~ msgid ""
#~ "When set to None (the default "
#~ "value), will split on any whitespace "
#~ "character (including \\\\n \\\\r \\\\t "
#~ "\\\\f and spaces) and will discard "
#~ "empty strings from the result."
#~ msgstr ""
#~ "None(기본값)으로 설정하면 모든 공백 문자(\\\\n \\\\r"
#~ " \\\\t \\\\f 및 공백 포함)를 분할하고 "
#~ "결과에서 빈 문자열을 삭제합니다."

#~ msgid "maxsplit"
#~ msgstr "maxsplit"

#~ msgid ""
#~ "Maximum number of splits (starting from"
#~ " the left). -1 (the default value)"
#~ " means no limit."
#~ msgstr "최대 분할 횟수(왼쪽부터 시작). -1(기본값)은 제한이 없음을 의미합니다."

#~ msgid "Splitting starts at the end of the string and works to the front."
#~ msgstr "분할은 문자열 끝에서 시작하여 앞쪽으로 진행됩니다."

#~ msgid ""
#~ "Note, str.split() is mainly useful for"
#~ " data that has been intentionally "
#~ "delimited.  With natural text that "
#~ "includes punctuation, consider using the "
#~ "regular expression module."
#~ msgstr ""
#~ "참고로 str.split()은 주로 의도적으로 구분된 데이터에 "
#~ "유용합니다.  구두점이 포함된 자연 텍스트의 경우 정규식"
#~ " 모듈을 사용하는 것이 좋습니다."

#~ msgid ""
#~ "Line breaks are not included in "
#~ "the resulting list unless keepends is"
#~ " given and true."
#~ msgstr "줄 바꿈은 keepends가 주어지고 참이 아니면 결과 목록에 포함되지 않습니다."

#~ msgid ""
#~ "Return True if S starts with the"
#~ " specified prefix, False otherwise. With"
#~ " optional start, test S beginning at"
#~ " that position. With optional end, "
#~ "stop comparing S at that position. "
#~ "prefix can also be a tuple of "
#~ "strings to try."
#~ msgstr ""
#~ "S가 지정된 접두사로 시작하면 True를 반환하고, 그렇지"
#~ " 않으면 False를 반환합니다. 시작 옵션을 사용하면 "
#~ "해당 위치에서 시작되는 S를 테스트합니다. 선택적 end를"
#~ " 사용하면 해당 위치에서 S 비교를 중지합니다. 접두사는"
#~ " 시도할 문자열의 튜플일 수도 있습니다."

#~ msgid ""
#~ "More specifically, words start with "
#~ "uppercased characters and all remaining "
#~ "cased characters have lower case."
#~ msgstr "보다 구체적으로, 단어는 대문자로 시작하고 나머지 모든 대소문자는 소문자로 표기합니다."

#~ msgid "table"
#~ msgstr "table"

#~ msgid ""
#~ "Translation table, which must be a "
#~ "mapping of Unicode ordinals to Unicode"
#~ " ordinals, strings, or None."
#~ msgstr "유니코드 서수를 유니코드 서수, 문자열 또는 없음으로 매핑하는 번역 테이블이어야 합니다."

#~ msgid ""
#~ "The table must implement lookup/indexing "
#~ "via __getitem__, for instance a "
#~ "dictionary or list.  If this operation"
#~ " raises LookupError, the character is "
#~ "left untouched.  Characters mapped to "
#~ "None are deleted."
#~ msgstr ""
#~ "테이블은 사전이나 목록과 같이 __getitem__을 통해 "
#~ "조회/색인을 구현해야 합니다.  이 작업에서 LookupError가"
#~ " 발생하면 문자는 그대로 유지됩니다.  없음으로 매핑된 "
#~ "문자는 삭제됩니다."

#~ msgid "The string is never truncated."
#~ msgstr "문자열은 잘리지 않습니다."

#~ msgid "FitIns"
#~ msgstr "FitIns"

#~ msgid ":py:obj:`parameters <flwr.common.FitIns.parameters>`\\"
#~ msgstr ":py:obj:`parameters <flwr.common.FitIns.parameters>`\\"

#~ msgid ":py:obj:`config <flwr.common.FitIns.config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#~ msgid "FitRes"
#~ msgstr "FitRes"

#~ msgid ":py:obj:`status <flwr.common.FitRes.status>`\\"
#~ msgstr ":py:obj:`status <flwr.common.FitRes.status>`\\"

#~ msgid ":py:obj:`parameters <flwr.common.FitRes.parameters>`\\"
#~ msgstr ":py:obj:`parameters <flwr.common.FitRes.parameters>`\\"

#~ msgid ":py:obj:`num_examples <flwr.common.FitRes.num_examples>`\\"
#~ msgstr ":py:obj:`num_examples <flwr.common.FitRes.num_examples>`\\"

#~ msgid ":py:obj:`metrics <flwr.common.FitRes.metrics>`\\"
#~ msgstr ":py:obj:`metrics <flwr.common.FitRes.metrics>`\\"

#~ msgid "GetParametersIns"
#~ msgstr "GetParametersIns"

#~ msgid ":py:obj:`config <flwr.common.GetParametersIns.config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.GetParametersIns.config>`\\"

#~ msgid "GetParametersRes"
#~ msgstr "GetParametersRes"

#~ msgid ":py:obj:`status <flwr.common.GetParametersRes.status>`\\"
#~ msgstr ":py:obj:`status <flwr.common.GetParametersRes.status>`\\"

#~ msgid ":py:obj:`parameters <flwr.common.GetParametersRes.parameters>`\\"
#~ msgstr ":py:obj:`parameters <flwr.common.GetParametersRes.parameters>`\\"

#~ msgid "GetPropertiesIns"
#~ msgstr "GetPropertiesIns"

#~ msgid ":py:obj:`config <flwr.common.GetPropertiesIns.config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.GetPropertiesIns.config>`\\"

#~ msgid "GetPropertiesRes"
#~ msgstr "GetPropertiesRes"

#~ msgid ":py:obj:`status <flwr.common.GetPropertiesRes.status>`\\"
#~ msgstr ":py:obj:`status <flwr.common.GetPropertiesRes.status>`\\"

#~ msgid ":py:obj:`properties <flwr.common.GetPropertiesRes.properties>`\\"
#~ msgstr ":py:obj:`properties <flwr.common.GetPropertiesRes.properties>`\\"

#~ msgid ""
#~ ":py:obj:`create_error_reply "
#~ "<flwr.common.Message.create_error_reply>`\\ \\(error\\[\\, "
#~ "ttl\\]\\)"
#~ msgstr ""
#~ ":py:obj:`create_error_reply "
#~ "<flwr.common.Message.create_error_reply>`\\ \\(error\\[\\, "
#~ "ttl\\]\\)"

#~ msgid ""
#~ ":py:obj:`create_reply <flwr.common.Message.create_reply>`\\ "
#~ "\\(content\\[\\, ttl\\]\\)"
#~ msgstr ""
#~ ":py:obj:`create_reply <flwr.common.Message.create_reply>`\\ "
#~ "\\(content\\[\\, ttl\\]\\)"

#~ msgid ":py:obj:`deflate <flwr.common.Message.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`has_content <flwr.common.Message.has_content>`\\ \\(\\)"
#~ msgstr ":py:obj:`has_content <flwr.common.Message.has_content>`\\ \\(\\)"

#~ msgid ":py:obj:`has_error <flwr.common.Message.has_error>`\\ \\(\\)"
#~ msgstr ":py:obj:`has_error <flwr.common.Message.has_error>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.Message.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`children <flwr.common.Message.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`content <flwr.common.Message.content>`\\"
#~ msgstr ":py:obj:`content <flwr.common.Message.content>`\\"

#~ msgid ":py:obj:`error <flwr.common.Message.error>`\\"
#~ msgstr ":py:obj:`error <flwr.common.Message.error>`\\"

#~ msgid ":py:obj:`is_dirty <flwr.common.Message.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`metadata <flwr.common.Message.metadata>`\\"
#~ msgstr ":py:obj:`metadata <flwr.common.Message.metadata>`\\"

#~ msgid ":py:obj:`object_id <flwr.common.Message.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`EVALUATE <flwr.common.MessageType.EVALUATE>`\\"
#~ msgstr ":py:obj:`EVALUATE <flwr.common.MessageType.EVALUATE>`\\"

#~ msgid ":py:obj:`QUERY <flwr.common.MessageType.QUERY>`\\"
#~ msgstr ":py:obj:`QUERY <flwr.common.MessageType.QUERY>`\\"

#~ msgid ":py:obj:`SYSTEM <flwr.common.MessageType.SYSTEM>`\\"
#~ msgstr ":py:obj:`TRAIN <flwr.common.MessageType.TRAIN>`\\"

#~ msgid ":py:obj:`TRAIN <flwr.common.MessageType.TRAIN>`\\"
#~ msgstr ":py:obj:`TRAIN <flwr.common.MessageType.TRAIN>`\\"

#~ msgid "MessageTypeLegacy"
#~ msgstr "MessageTypeLegacy"

#~ msgid ""
#~ ":py:obj:`GET_PARAMETERS "
#~ "<flwr.common.MessageTypeLegacy.GET_PARAMETERS>`\\"
#~ msgstr ""
#~ ":py:obj:`GET_PARAMETERS "
#~ "<flwr.common.MessageTypeLegacy.GET_PARAMETERS>`\\"

#~ msgid ""
#~ ":py:obj:`GET_PROPERTIES "
#~ "<flwr.common.MessageTypeLegacy.GET_PROPERTIES>`\\"
#~ msgstr ""
#~ ":py:obj:`GET_PROPERTIES "
#~ "<flwr.common.MessageTypeLegacy.GET_PROPERTIES>`\\"

#~ msgid ":py:obj:`created_at <flwr.common.Metadata.created_at>`\\"
#~ msgstr ":py:obj:`created_at <flwr.common.Metadata.created_at>`\\"

#~ msgid ":py:obj:`delivered_at <flwr.common.Metadata.delivered_at>`\\"
#~ msgstr ":py:obj:`created_at <flwr.common.Metadata.created_at>`\\"

#~ msgid ":py:obj:`dst_node_id <flwr.common.Metadata.dst_node_id>`\\"
#~ msgstr ":py:obj:`dst_node_id <flwr.common.Metadata.dst_node_id>`\\"

#~ msgid ":py:obj:`group_id <flwr.common.Metadata.group_id>`\\"
#~ msgstr ":py:obj:`group_id <flwr.common.Metadata.group_id>`\\"

#~ msgid ":py:obj:`message_id <flwr.common.Metadata.message_id>`\\"
#~ msgstr ":py:obj:`message_id <flwr.common.Metadata.message_id>`\\"

#~ msgid ":py:obj:`message_type <flwr.common.Metadata.message_type>`\\"
#~ msgstr ":py:obj:`message_type <flwr.common.Metadata.message_type>`\\"

#~ msgid ""
#~ ":py:obj:`reply_to_message_id "
#~ "<flwr.common.Metadata.reply_to_message_id>`\\"
#~ msgstr ":py:obj:`reply_to_message <flwr.common.Metadata.reply_to_message>`\\"

#~ msgid ":py:obj:`run_id <flwr.common.Metadata.run_id>`\\"
#~ msgstr ":py:obj:`run_id <flwr.common.Metadata.run_id>`\\"

#~ msgid ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"
#~ msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#~ msgid ":py:obj:`ttl <flwr.common.Metadata.ttl>`\\"
#~ msgstr ":py:obj:`ttl <flwr.common.Metadata.ttl>`\\"

#~ msgid ":py:obj:`clear <flwr.common.MetricRecord.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.MetricRecord.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`count_bytes <flwr.common.MetricRecord.count_bytes>`\\ \\(\\)"
#~ msgstr ":py:obj:`count_bytes <flwr.common.MetricsRecord.count_bytes>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.MetricRecord.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`get <flwr.common.MetricRecord.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.MetricRecord.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.MetricRecord.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.MetricRecord.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.MetricRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.MetricRecord.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.MetricRecord.setdefault>`\\ "
#~ "\\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.MetricRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.MetricRecord.values>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`children <flwr.common.MetricRecord.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`is_dirty <flwr.common.MetricRecord.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`object_id <flwr.common.MetricRecord.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid "Metrics"
#~ msgstr "MetricsRecord"

#~ msgid "MetricsRecord"
#~ msgstr "MetricsRecord"

#~ msgid "Bases: :py:class:`~flwr.common.record.metricrecord.MetricRecord`"
#~ msgstr ""

#~ msgid ""
#~ "This class exists solely for backward"
#~ " compatibility with legacy code that "
#~ "previously used ``MetricsRecord``. It has "
#~ "been renamed to ``MetricRecord``."
#~ msgstr ""

#~ msgid ""
#~ "``MetricsRecord`` is deprecated and will "
#~ "be removed in a future release. "
#~ "Use ``MetricRecord`` instead."
#~ msgstr ""

#~ msgid ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.MetricsRecord.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`count_bytes <flwr.common.MetricsRecord.count_bytes>`\\ \\(\\)"
#~ msgstr ":py:obj:`count_bytes <flwr.common.MetricsRecord.count_bytes>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.MetricsRecord.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.MetricsRecord.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.MetricsRecord.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.MetricsRecord.setdefault>`\\"
#~ " \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.MetricsRecord.values>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`children <flwr.common.MetricsRecord.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`is_dirty <flwr.common.MetricsRecord.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`object_id <flwr.common.MetricsRecord.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid "NDArray"
#~ msgstr "NDArray"

#~ msgid "NDArrays"
#~ msgstr "NDArray"

#~ msgid ":py:obj:`tensors <flwr.common.Parameters.tensors>`\\"
#~ msgstr ":py:obj:`tensors <flwr.common.Parameters.tensors>`\\"

#~ msgid ":py:obj:`tensor_type <flwr.common.Parameters.tensor_type>`\\"
#~ msgstr ":py:obj:`tensor_type <flwr.common.Parameters.tensor_type>`\\"

#~ msgid "ParametersRecord"
#~ msgstr "ParametersRecord"

#~ msgid "Bases: :py:class:`~flwr.common.record.arrayrecord.ArrayRecord`"
#~ msgstr ""

#~ msgid ""
#~ "This class exists solely for backward"
#~ " compatibility with legacy code that "
#~ "previously used ``ParametersRecord``. It has"
#~ " been renamed to ``ArrayRecord``."
#~ msgstr ""

#~ msgid ""
#~ "``ParametersRecord`` is deprecated and will"
#~ " be removed in a future release. "
#~ "Use ``ArrayRecord`` instead."
#~ msgstr ""

#~ msgid ":py:obj:`clear <flwr.common.ParametersRecord.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.ParametersRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.ParametersRecord.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.ParametersRecord.keys>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`count_bytes "
#~ "<flwr.common.ParametersRecord.count_bytes>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`count_bytes "
#~ "<flwr.common.ParametersRecord.count_bytes>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.ParametersRecord.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`from_array_dict "
#~ "<flwr.common.ParametersRecord.from_array_dict>`\\ "
#~ "\\(array\\_dict\\, \\*\\[\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
#~ "\\(\\[array\\_dict\\, keep\\_input\\]\\)"

#~ msgid ""
#~ ":py:obj:`from_numpy_ndarrays "
#~ "<flwr.common.ParametersRecord.from_numpy_ndarrays>`\\ "
#~ "\\(ndarrays\\, \\*\\[\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`from_torch_state_dict "
#~ "<flwr.common.ParametersRecord.from_torch_state_dict>`\\ "
#~ "\\(state\\_dict\\, \\*\\[\\, ...\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ParametersRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`get <flwr.common.ParametersRecord.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ParametersRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.ParametersRecord.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.ParametersRecord.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ParametersRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.ParametersRecord.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.ParametersRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.ParametersRecord.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.ParametersRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.ParametersRecord.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.ParametersRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.ParametersRecord.setdefault>`\\"
#~ " \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.ParametersRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`to_numpy_ndarrays "
#~ "<flwr.common.ParametersRecord.to_numpy_ndarrays>`\\ \\(\\*\\[\\,"
#~ " keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`array_from_numpy <flwr.common.array_from_numpy>`\\ "
#~ "\\(ndarray\\)"

#~ msgid ""
#~ ":py:obj:`to_torch_state_dict "
#~ "<flwr.common.ParametersRecord.to_torch_state_dict>`\\ "
#~ "\\(\\*\\[\\, keep\\_input\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ParametersRecord <flwr.common.ParametersRecord>`\\ "
#~ "\\(\\[array\\_dict\\, keep\\_input\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.ParametersRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.ParametersRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.ParametersRecord.values>`\\ \\(\\)"
#~ msgstr ":py:obj:`values <flwr.common.ParametersRecord.values>`\\ \\(\\)"

#~ msgid ":py:obj:`children <flwr.common.ParametersRecord.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.ParametersRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`is_dirty <flwr.common.ParametersRecord.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.ParametersRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`object_id <flwr.common.ParametersRecord.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid "Properties"
#~ msgstr "GetPropertiesRes"

#~ msgid "ReconnectIns"
#~ msgstr "ReconnectIns"

#~ msgid ":py:obj:`seconds <flwr.common.ReconnectIns.seconds>`\\"
#~ msgstr ":py:obj:`seconds <flwr.common.ReconnectIns.seconds>`\\"

#~ msgid ":py:obj:`clear <flwr.common.RecordDict.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.RecordDict.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.RecordDict.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`get <flwr.common.RecordDict.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.RecordDict.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.RecordDict.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.RecordDict.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.RecordDict.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.RecordDict.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.RecordDict.setdefault>`\\ "
#~ "\\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.RecordDict.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.RecordDict.values>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`array_records <flwr.common.RecordDict.array_records>`\\"
#~ msgstr ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordSet.parameters_records>`\\"

#~ msgid ":py:obj:`children <flwr.common.RecordDict.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`config_records <flwr.common.RecordDict.config_records>`\\"
#~ msgstr ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"

#~ msgid ":py:obj:`configs_records <flwr.common.RecordDict.configs_records>`\\"
#~ msgstr ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"

#~ msgid ":py:obj:`is_dirty <flwr.common.RecordDict.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`metric_records <flwr.common.RecordDict.metric_records>`\\"
#~ msgstr ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"

#~ msgid ":py:obj:`metrics_records <flwr.common.RecordDict.metrics_records>`\\"
#~ msgstr ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"

#~ msgid ":py:obj:`object_id <flwr.common.RecordDict.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordDict.parameters_records>`\\"
#~ msgstr ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordSet.parameters_records>`\\"

#~ msgid "RecordSet"
#~ msgstr "RecordSet"

#~ msgid "Bases: :py:class:`~flwr.common.record.recorddict.RecordDict`"
#~ msgstr ""

#~ msgid ""
#~ "This class exists solely for backward"
#~ " compatibility with legacy code that "
#~ "previously used ``RecordSet``. It has "
#~ "been renamed to ``RecordDict`` and will"
#~ " be removed in a future release."
#~ msgstr ""

#~ msgid ""
#~ "``RecordSet`` is deprecated and will be"
#~ " removed in a future release. Use "
#~ "``RecordDict`` instead."
#~ msgstr ""

#~ msgid ":py:obj:`clear <flwr.common.RecordSet.clear>`\\ \\(\\)"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`copy <flwr.common.RecordSet.copy>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`deflate <flwr.common.RecordSet.deflate>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`get <flwr.common.RecordSet.get>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`inflate <flwr.common.RecordSet.inflate>`\\ "
#~ "\\(object\\_content\\[\\, children\\]\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`items <flwr.common.RecordSet.items>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ":py:obj:`keys <flwr.common.RecordSet.keys>`\\ \\(\\)"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ":py:obj:`pop <flwr.common.RecordSet.pop>`\\ \\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`pop <flwr.common.MetricsRecord.pop>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ":py:obj:`popitem <flwr.common.RecordSet.popitem>`\\ \\(\\)"
#~ msgstr ":py:obj:`items <flwr.common.MetricsRecord.items>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`setdefault <flwr.common.RecordSet.setdefault>`\\ "
#~ "\\(k\\[\\,d\\]\\)"
#~ msgstr ":py:obj:`get <flwr.common.MetricsRecord.get>`\\ \\(k\\[\\,d\\]\\)"

#~ msgid ""
#~ ":py:obj:`update <flwr.common.RecordSet.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`values <flwr.common.RecordSet.values>`\\ \\(\\)"
#~ msgstr ""
#~ ":py:obj:`update <flwr.common.MetricsRecord.update>`\\ "
#~ "\\(\\[E\\, \\]\\*\\*F\\)"

#~ msgid ":py:obj:`array_records <flwr.common.RecordSet.array_records>`\\"
#~ msgstr ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordSet.parameters_records>`\\"

#~ msgid ":py:obj:`children <flwr.common.RecordSet.children>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`config_records <flwr.common.RecordSet.config_records>`\\"
#~ msgstr ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"

#~ msgid ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"
#~ msgstr ":py:obj:`configs_records <flwr.common.RecordSet.configs_records>`\\"

#~ msgid ":py:obj:`is_dirty <flwr.common.RecordSet.is_dirty>`\\"
#~ msgstr ":py:obj:`clear <flwr.common.MetricsRecord.clear>`\\ \\(\\)"

#~ msgid ":py:obj:`metric_records <flwr.common.RecordSet.metric_records>`\\"
#~ msgstr ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"

#~ msgid ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"
#~ msgstr ":py:obj:`metrics_records <flwr.common.RecordSet.metrics_records>`\\"

#~ msgid ":py:obj:`object_id <flwr.common.RecordSet.object_id>`\\"
#~ msgstr ":py:obj:`keys <flwr.common.MetricsRecord.keys>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordSet.parameters_records>`\\"
#~ msgstr ""
#~ ":py:obj:`parameters_records "
#~ "<flwr.common.RecordSet.parameters_records>`\\"

#~ msgid "ServerMessage"
#~ msgstr "ServerMessage"

#~ msgid ":py:obj:`evaluate_ins <flwr.common.ServerMessage.evaluate_ins>`\\"
#~ msgstr ":py:obj:`evaluate_ins <flwr.common.ServerMessage.evaluate_ins>`\\"

#~ msgid ":py:obj:`fit_ins <flwr.common.ServerMessage.fit_ins>`\\"
#~ msgstr ":py:obj:`fit_ins <flwr.common.ServerMessage.fit_ins>`\\"

#~ msgid ""
#~ ":py:obj:`get_parameters_ins "
#~ "<flwr.common.ServerMessage.get_parameters_ins>`\\"
#~ msgstr ""
#~ ":py:obj:`get_parameters_ins "
#~ "<flwr.common.ServerMessage.get_parameters_ins>`\\"

#~ msgid ""
#~ ":py:obj:`get_properties_ins "
#~ "<flwr.common.ServerMessage.get_properties_ins>`\\"
#~ msgstr ""
#~ ":py:obj:`get_properties_ins "
#~ "<flwr.common.ServerMessage.get_properties_ins>`\\"

#~ msgid "Status"
#~ msgstr "Status"

#~ msgid ":py:obj:`code <flwr.common.Status.code>`\\"
#~ msgstr ":py:obj:`code <flwr.common.Status.code>`\\"

#~ msgid ":py:obj:`message <flwr.common.Status.message>`\\"
#~ msgstr ":py:obj:`message <flwr.common.Status.message>`\\"

#~ msgid "array\\_from\\_numpy"
#~ msgstr "array\\_from\\_numpy"

#~ msgid "bytes\\_to\\_ndarray"
#~ msgstr "bytes\\_to\\_ndarray"

#~ msgid "configure"
#~ msgstr "구성"

#~ msgid "event"
#~ msgstr "이벤트"

#~ msgid "log"
#~ msgstr "로그"

#~ msgid ""
#~ "To pass exception information, use the"
#~ " keyword argument exc_info with a "
#~ "true value, e.g."
#~ msgstr "예외 정보를 전달하려면 키워드 argument exc_info를 참 값과 함께 사용합니다."

#~ msgid "logger.log(level, \"We have a %s\", \"mysterious problem\", exc_info=1)"
#~ msgstr ""

#~ msgid "ndarray\\_to\\_bytes"
#~ msgstr ""

#~ msgid "ndarrays\\_to\\_parameters"
#~ msgstr ""

#~ msgid "now"
#~ msgstr ""

#~ msgid "parameters\\_to\\_ndarrays"
#~ msgstr ""

#~ msgid "server"
#~ msgstr "서버"

#~ msgid ""
#~ ":py:obj:`start_server <flwr.server.start_server>`\\ "
#~ "\\(\\*\\[\\, server\\_address\\, server\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Start a Flower server using the gRPC transport layer."
#~ msgstr "gRPC transport layer를 사용하여 Flower 서버를 실행하세요."

#~ msgid ":py:obj:`ClientManager <flwr.server.ClientManager>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Abstract base class for managing Flower clients."
#~ msgstr "Flower 클라이언트를 관리하기 위한 Abstract base class."

#~ msgid ":py:obj:`Driver <flwr.server.Driver>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Deprecated abstract base class ``Driver``, use ``Grid`` instead."
#~ msgstr ""

#~ msgid ":py:obj:`Grid <flwr.server.Grid>`\\ \\(\\)"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ":py:obj:`History <flwr.server.History>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "History class for training and/or evaluation metrics collection."
#~ msgstr "메트릭 콜렉션을 훈련 및 평가하기 위한 History class."

#~ msgid ""
#~ ":py:obj:`LegacyContext <flwr.server.LegacyContext>`\\ "
#~ "\\(context\\[\\, config\\, strategy\\, ...\\]\\)"
#~ msgstr ":py:obj:`Context <flwr.common.Context>`\\ \\(state\\)"

#~ msgid "Legacy Context."
#~ msgstr "레거시 콘텍스트."

#~ msgid ""
#~ ":py:obj:`Server <flwr.server.Server>`\\ \\(\\*\\, "
#~ "client\\_manager\\[\\, strategy\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ServerApp <flwr.server.ServerApp>`\\ "
#~ "\\(\\[server\\, config\\, strategy\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ServerAppComponents "
#~ "<flwr.server.ServerAppComponents>`\\ \\(\\[server\\, "
#~ "config\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`ServerMessage <flwr.common.ServerMessage>`\\ "
#~ "\\(\\[get\\_properties\\_ins\\, ...\\]\\)"

#~ msgid "Components to construct a ServerApp."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ServerConfig <flwr.server.ServerConfig>`\\ "
#~ "\\(\\[num\\_rounds\\, round\\_timeout\\]\\)"
#~ msgstr ""

#~ msgid "Flower server config."
#~ msgstr "Flower 서버 설정."

#~ msgid ""
#~ ":py:obj:`SimpleClientManager "
#~ "<flwr.server.SimpleClientManager>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Provides a pool of available clients."
#~ msgstr "사용 가능한 클라이언트 그룹 제공."

#~ msgid "Contains the strategy abstraction and different implementations."
#~ msgstr ""

#~ msgid "Workflows."
#~ msgstr ""

#~ msgid "ClientManager"
#~ msgstr ""

#~ msgid ":py:obj:`all <flwr.server.ClientManager.all>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Return all available clients."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_available "
#~ "<flwr.server.ClientManager.num_available>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Return the number of available clients."
#~ msgstr ""

#~ msgid ":py:obj:`register <flwr.server.ClientManager.register>`\\ \\(client\\)"
#~ msgstr ""

#~ msgid "Register Flower ClientProxy instance."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`sample <flwr.server.ClientManager.sample>`\\ "
#~ "\\(num\\_clients\\[\\, min\\_num\\_clients\\, "
#~ "criterion\\]\\)"
#~ msgstr ""

#~ msgid "Sample a number of Flower ClientProxy instances."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`unregister <flwr.server.ClientManager.unregister>`\\"
#~ " \\(client\\)"
#~ msgstr ""

#~ msgid "Unregister Flower ClientProxy instance."
#~ msgstr "Flower ClientProxy 인스턴스 등록 해제."

#~ msgid ""
#~ ":py:obj:`wait_for <flwr.server.ClientManager.wait_for>`\\ "
#~ "\\(num\\_clients\\, timeout\\)"
#~ msgstr ""

#~ msgid "Wait until at least `num_clients` are available."
#~ msgstr "적어도 1개의 `num_clients` 가 사용 가능해질 때까지 기다리세요."

#~ msgid "**num_available** -- The number of currently available clients."
#~ msgstr ""

#~ msgid "The ClientProxy of the Client to register."
#~ msgstr "클라이언트 모델의 민감도입니다."

#~ msgid ""
#~ "**success** -- Indicating if registration "
#~ "was successful. False if ClientProxy is"
#~ " already registered or can not be "
#~ "registered for any reason."
#~ msgstr ""

#~ msgid "This method is idempotent."
#~ msgstr ""

#~ msgid "The ClientProxy of the Client to unregister."
#~ msgstr "클라이언트 모델의 민감도입니다."

#~ msgid "Driver"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.server.grid.grid.Grid`"
#~ msgstr ""

#~ msgid ""
#~ "This class is provided solely for "
#~ "backward compatibility with legacy code "
#~ "that previously relied on the ``Driver``"
#~ " class. It has been deprecated in "
#~ "favor of the updated abstract base "
#~ "class ``Grid``, which now encompasses "
#~ "all communication-related functionality and"
#~ " improvements between the ServerApp and "
#~ "the SuperLink."
#~ msgstr ""

#~ msgid ""
#~ "``Driver`` is deprecated and will be "
#~ "removed in a future release. Use "
#~ "``Grid`` in the signature of your "
#~ "ServerApp."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`create_message <flwr.server.Driver.create_message>`\\"
#~ " \\(content\\, message\\_type\\, ...\\[\\, "
#~ "ttl\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`get_node_ids <flwr.server.Driver.get_node_ids>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`pull_messages <flwr.server.Driver.pull_messages>`\\ "
#~ "\\(message\\_ids\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`push_messages <flwr.server.Driver.push_messages>`\\ "
#~ "\\(messages\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`send_and_receive "
#~ "<flwr.server.Driver.send_and_receive>`\\ \\(messages\\, "
#~ "\\*\\[\\, timeout\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`set_run <flwr.server.Driver.set_run>`\\ \\(run\\_id\\)"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ":py:obj:`run <flwr.server.Driver.run>`\\"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ""
#~ ":py:obj:`create_message <flwr.server.Grid.create_message>`\\ "
#~ "\\(content\\, message\\_type\\, ...\\[\\, ttl\\]\\)"
#~ msgstr ""
#~ ":py:obj:`create_reply <flwr.common.Message.create_reply>`\\ "
#~ "\\(content\\[\\, ttl\\]\\)"

#~ msgid ":py:obj:`get_node_ids <flwr.server.Grid.get_node_ids>`\\ \\(\\)"
#~ msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#~ msgid ""
#~ ":py:obj:`pull_messages <flwr.server.Grid.pull_messages>`\\ "
#~ "\\(message\\_ids\\)"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ""
#~ ":py:obj:`push_messages <flwr.server.Grid.push_messages>`\\ "
#~ "\\(messages\\)"
#~ msgstr ":py:obj:`MessageType <flwr.common.MessageType>`\\ \\(\\)"

#~ msgid ""
#~ ":py:obj:`send_and_receive <flwr.server.Grid.send_and_receive>`\\"
#~ " \\(messages\\, \\*\\[\\, timeout\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`set_run <flwr.server.Grid.set_run>`\\ \\(run\\_id\\)"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ":py:obj:`run <flwr.server.Grid.run>`\\"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid "History"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_loss_centralized "
#~ "<flwr.server.History.add_loss_centralized>`\\ "
#~ "\\(server\\_round\\, loss\\)"
#~ msgstr ""

#~ msgid "Add one loss entry (from centralized evaluation)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_loss_distributed "
#~ "<flwr.server.History.add_loss_distributed>`\\ "
#~ "\\(server\\_round\\, loss\\)"
#~ msgstr ""

#~ msgid "Add one loss entry (from distributed evaluation)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_metrics_centralized "
#~ "<flwr.server.History.add_metrics_centralized>`\\ "
#~ "\\(server\\_round\\, metrics\\)"
#~ msgstr ""

#~ msgid "Add metrics entries (from centralized evaluation)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_metrics_distributed "
#~ "<flwr.server.History.add_metrics_distributed>`\\ "
#~ "\\(server\\_round\\, metrics\\)"
#~ msgstr ""

#~ msgid "Add metrics entries (from distributed evaluation)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_metrics_distributed_fit "
#~ "<flwr.server.History.add_metrics_distributed_fit>`\\ "
#~ "\\(server\\_round\\, ...\\)"
#~ msgstr ""

#~ msgid "Add metrics entries (from distributed fit)."
#~ msgstr ""

#~ msgid "LegacyContext"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.common.context.Context`"
#~ msgstr ""

#~ msgid ":py:obj:`config <flwr.server.LegacyContext.config>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`strategy <flwr.server.LegacyContext.strategy>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`client_manager <flwr.server.LegacyContext.client_manager>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`history <flwr.server.LegacyContext.history>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`run_id <flwr.server.LegacyContext.run_id>`\\"
#~ msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#~ msgid ":py:obj:`node_id <flwr.server.LegacyContext.node_id>`\\"
#~ msgstr ":py:obj:`src_node_id <flwr.common.Metadata.src_node_id>`\\"

#~ msgid ":py:obj:`node_config <flwr.server.LegacyContext.node_config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.EvaluateIns.config>`\\"

#~ msgid ":py:obj:`state <flwr.server.LegacyContext.state>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`run_config <flwr.server.LegacyContext.run_config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#~ msgid "Server"
#~ msgstr ""

#~ msgid ":py:obj:`client_manager <flwr.server.Server.client_manager>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Return ClientManager."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`disconnect_all_clients "
#~ "<flwr.server.Server.disconnect_all_clients>`\\ \\(timeout\\)"
#~ msgstr ""

#~ msgid "Send shutdown signal to all clients."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate_round <flwr.server.Server.evaluate_round>`\\"
#~ " \\(server\\_round\\, timeout\\)"
#~ msgstr ""

#~ msgid "Validate current global model on a number of clients."
#~ msgstr ""

#~ msgid ":py:obj:`fit <flwr.server.Server.fit>`\\ \\(num\\_rounds\\, timeout\\)"
#~ msgstr ""

#~ msgid "Run federated averaging for a number of rounds."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`fit_round <flwr.server.Server.fit_round>`\\ "
#~ "\\(server\\_round\\, timeout\\)"
#~ msgstr ""

#~ msgid "Perform a single round of federated averaging."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`set_max_workers <flwr.server.Server.set_max_workers>`\\"
#~ " \\(max\\_workers\\)"
#~ msgstr ""

#~ msgid "Set the max_workers used by ThreadPoolExecutor."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`set_strategy <flwr.server.Server.set_strategy>`\\ "
#~ "\\(strategy\\)"
#~ msgstr ""

#~ msgid "Replace server strategy."
#~ msgstr ""

#~ msgid ":py:obj:`lifespan <flwr.server.ServerApp.lifespan>`\\ \\(\\)"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ":py:obj:`main <flwr.server.ServerApp.main>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "ServerAppComponents"
#~ msgstr ""

#~ msgid ""
#~ "A server implementation, either "
#~ "`flwr.server.Server` or a subclass thereof."
#~ " If no instance is provided, one "
#~ "will be created internally."
#~ msgstr ""

#~ msgid ""
#~ "Currently supported values are `num_rounds`"
#~ " (int, default: 1) and `round_timeout` "
#~ "in seconds (float, default: None)."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.server.strategy.Strategy`. If no "
#~ "strategy is provided, then "
#~ "`flwr.server.strategy.FedAvg` will be used."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the class "
#~ "`flwr.server.ClientManager`. If no implementation"
#~ " is provided, then "
#~ "`flwr.server.SimpleClientManager` will be used."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`client_manager "
#~ "<flwr.server.ServerAppComponents.client_manager>`\\"
#~ msgstr ""
#~ ":py:obj:`RUN_CLIENT_APP_ENTER "
#~ "<flwr.common.EventType.RUN_CLIENT_APP_ENTER>`\\"

#~ msgid ":py:obj:`config <flwr.server.ServerAppComponents.config>`\\"
#~ msgstr ":py:obj:`config <flwr.common.FitIns.config>`\\"

#~ msgid ":py:obj:`server <flwr.server.ServerAppComponents.server>`\\"
#~ msgstr ":py:obj:`flwr.server <flwr.server>`\\"

#~ msgid ":py:obj:`strategy <flwr.server.ServerAppComponents.strategy>`\\"
#~ msgstr ":py:obj:`state <flwr.common.Context.state>`\\"

#~ msgid "ServerConfig"
#~ msgstr ""

#~ msgid ""
#~ "All attributes have default values which"
#~ " allows users to configure just the"
#~ " ones they care about."
#~ msgstr ""

#~ msgid ":py:obj:`num_rounds <flwr.server.ServerConfig.num_rounds>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`round_timeout <flwr.server.ServerConfig.round_timeout>`\\"
#~ msgstr ""

#~ msgid "SimpleClientManager"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.server.client_manager.ClientManager`"
#~ msgstr ""

#~ msgid ":py:obj:`all <flwr.server.SimpleClientManager.all>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_available "
#~ "<flwr.server.SimpleClientManager.num_available>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`register <flwr.server.SimpleClientManager.register>`\\"
#~ " \\(client\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`sample <flwr.server.SimpleClientManager.sample>`\\ "
#~ "\\(num\\_clients\\[\\, min\\_num\\_clients\\, "
#~ "criterion\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`unregister "
#~ "<flwr.server.SimpleClientManager.unregister>`\\ \\(client\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`wait_for <flwr.server.SimpleClientManager.wait_for>`\\"
#~ " \\(num\\_clients\\[\\, timeout\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Blocks until the requested number of "
#~ "clients is available or until a "
#~ "timeout is reached. Current timeout "
#~ "default: 1 day."
#~ msgstr ""

#~ msgid "The number of clients to wait for."
#~ msgstr ""

#~ msgid "The time in seconds to wait for, defaults to 86400 (24h)."
#~ msgstr ""

#~ msgid "**success**"
#~ msgstr ""

#~ msgid "start\\_server"
#~ msgstr ""

#~ msgid ""
#~ "This function is deprecated since "
#~ "1.13.0. Use the :code:`flower-superlink` "
#~ "command instead to start a SuperLink."
#~ msgstr ""

#~ msgid "The IPv4 or IPv6 address of the server. Defaults to `\"[::]:8080\"`."
#~ msgstr ""

#~ msgid ""
#~ "A server implementation, either "
#~ "`flwr.server.Server` or a subclass thereof."
#~ " If no instance is provided, then "
#~ "`start_server` will create one."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.server.strategy.Strategy`. If no "
#~ "strategy is provided, then `start_server` "
#~ "will use `flwr.server.strategy.FedAvg`."
#~ msgstr ""

#~ msgid ""
#~ "An implementation of the abstract base"
#~ " class `flwr.server.ClientManager`. If no "
#~ "implementation is provided, then "
#~ "`start_server` will use "
#~ "`flwr.server.client_manager.SimpleClientManager`."
#~ msgstr ""

#~ msgid ""
#~ "The maximum length of gRPC messages "
#~ "that can be exchanged with the "
#~ "Flower clients. The default should be"
#~ " sufficient for most models. Users "
#~ "who train very large models might "
#~ "need to increase this value. Note "
#~ "that the Flower clients need to be"
#~ " started with the same value (see "
#~ "`flwr.client.start_client`), otherwise clients will"
#~ " not know about the increased limit"
#~ " and block larger messages."
#~ msgstr ""

#~ msgid ""
#~ "Tuple containing root certificate, server "
#~ "certificate, and private key to start"
#~ " a secure SSL-enabled server. The "
#~ "tuple is expected to have three "
#~ "bytes elements in the following order:"
#~ "      * CA certificate.     * server "
#~ "certificate.     * server private key."
#~ msgstr ""

#~ msgid ""
#~ "Tuple containing root certificate, server "
#~ "certificate, and private key to start"
#~ " a secure SSL-enabled server. The "
#~ "tuple is expected to have three "
#~ "bytes elements in the following order:"
#~ msgstr ""

#~ msgid "CA certificate."
#~ msgstr ""

#~ msgid "server certificate."
#~ msgstr ""

#~ msgid "server private key."
#~ msgstr ""

#~ msgid "**hist** -- Object containing training and evaluation metrics."
#~ msgstr ""

#~ msgid "Starting an insecure server::"
#~ msgstr "안전하지 않은 서버 연결로 gRPC 클라이언트 시작하기:"

#~ msgid "Starting a TLS-enabled server::"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Bulyan <flwr.server.strategy.Bulyan>`\\ \\(\\*\\,"
#~ " fraction\\_fit\\, fraction\\_evaluate\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DPFedAvgAdaptive "
#~ "<flwr.server.strategy.DPFedAvgAdaptive>`\\ \\(strategy\\, "
#~ "num\\_sampled\\_clients\\)"
#~ msgstr ""

#~ msgid "Wrapper for configuring a Strategy for DP with Adaptive Clipping."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DPFedAvgFixed <flwr.server.strategy.DPFedAvgFixed>`\\"
#~ " \\(strategy\\, num\\_sampled\\_clients\\, ...\\)"
#~ msgstr ""

#~ msgid "Wrapper for configuring a Strategy for DP with Fixed Clipping."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DifferentialPrivacyClientSideAdaptiveClipping "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping>`\\"
#~ " \\(...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DifferentialPrivacyClientSideFixedClipping "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping>`\\"
#~ " \\(...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DifferentialPrivacyServerSideAdaptiveClipping "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping>`\\"
#~ " \\(...\\)"
#~ msgstr ""

#~ msgid "Strategy wrapper for central DP with server-side adaptive clipping."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DifferentialPrivacyServerSideFixedClipping "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping>`\\"
#~ " \\(...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FaultTolerantFedAvg "
#~ "<flwr.server.strategy.FaultTolerantFedAvg>`\\ \\(\\*\\[\\, "
#~ "fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Configurable fault-tolerant FedAvg strategy implementation."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedAdagrad <flwr.server.strategy.FedAdagrad>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedAdam <flwr.server.strategy.FedAdam>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedAvg <flwr.server.strategy.FedAvg>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, fraction\\_evaluate\\, "
#~ "...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedAvgAndroid <flwr.server.strategy.FedAvgAndroid>`\\"
#~ " \\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedAvgM <flwr.server.strategy.FedAvgM>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedMedian <flwr.server.strategy.FedMedian>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Configurable FedMedian strategy implementation."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedOpt <flwr.server.strategy.FedOpt>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, fraction\\_evaluate\\, "
#~ "...\\]\\)"
#~ msgstr ""

#~ msgid "Federated Optim strategy."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedProx <flwr.server.strategy.FedProx>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedTrimmedAvg <flwr.server.strategy.FedTrimmedAvg>`\\"
#~ " \\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedXgbBagging <flwr.server.strategy.FedXgbBagging>`\\"
#~ " \\(\\[evaluate\\_function\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedXgbCyclic <flwr.server.strategy.FedXgbCyclic>`\\ "
#~ "\\(\\*\\*kwargs\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedXgbNnAvg <flwr.server.strategy.FedXgbNnAvg>`\\ "
#~ "\\(\\*args\\, \\*\\*kwargs\\)"
#~ msgstr ""

#~ msgid "Configurable FedXgbNnAvg strategy implementation."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FedYogi <flwr.server.strategy.FedYogi>`\\ "
#~ "\\(\\*\\[\\, fraction\\_fit\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Krum <flwr.server.strategy.Krum>`\\ \\(\\*\\[\\,"
#~ " fraction\\_fit\\, fraction\\_evaluate\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`QFedAvg <flwr.server.strategy.QFedAvg>`\\ "
#~ "\\(\\*\\[\\, q\\_param\\, qffl\\_learning\\_rate\\, "
#~ "...\\]\\)"
#~ msgstr ""

#~ msgid "Configurable QFedAvg strategy implementation."
#~ msgstr ""

#~ msgid ":py:obj:`Strategy <flwr.server.strategy.Strategy>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.server.strategy.fedavg.FedAvg`"
#~ msgstr ""

#~ msgid "Fraction of clients used during training. Defaults to 1.0."
#~ msgstr ""

#~ msgid "Fraction of clients used during validation. Defaults to 1.0."
#~ msgstr ""

#~ msgid "Minimum number of clients used during training. Defaults to 2."
#~ msgstr ""

#~ msgid "Minimum number of clients used during validation. Defaults to 2."
#~ msgstr ""

#~ msgid "Minimum number of total clients in the system. Defaults to 2."
#~ msgstr ""

#~ msgid "Number of malicious clients in the system. Defaults to 0."
#~ msgstr ""

#~ msgid "Optional function used for validation. Defaults to None."
#~ msgstr ""

#~ msgid "Function used to configure training. Defaults to None."
#~ msgstr ""

#~ msgid "Function used to configure validation. Defaults to None."
#~ msgstr ""

#~ msgid "Whether or not accept rounds containing failures. Defaults to True."
#~ msgstr ""

#~ msgid "Initial global model parameters."
#~ msgstr ""

#~ msgid ""
#~ "Byzantine resilient aggregation rule that "
#~ "is used as the first step of "
#~ "the Bulyan (e.g., Krum)"
#~ msgstr ""

#~ msgid "arguments to the first_aggregation rule"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.Bulyan.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid "Aggregate evaluation losses using weighted average."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.Bulyan.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate fit results using Bulyan."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.Bulyan.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.Bulyan.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.Bulyan.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid "Evaluate model parameters using an evaluation function."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.Bulyan.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid "Initialize global model parameters."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.Bulyan.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "Use a fraction of available clients for evaluation."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.Bulyan.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "Return the sample size and the required number of available clients."
#~ msgstr ""

#~ msgid "DPFedAvgAdaptive"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.server.strategy.dpfedavg_fixed.DPFedAvgFixed`"
#~ msgstr ""

#~ msgid "This class is deprecated and will be removed in a future release."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.DPFedAvgAdaptive.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid "Aggregate evaluation losses using the given strategy."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.DPFedAvgAdaptive.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate training results as in DPFedAvgFixed and update clip norms."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.DPFedAvgAdaptive.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid "Configure the next round of evaluation using the specified strategy."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.DPFedAvgAdaptive.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.DPFedAvgAdaptive.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ "Evaluate model parameters using an "
#~ "evaluation function from the strategy."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.DPFedAvgAdaptive.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid "Initialize global model parameters using given strategy."
#~ msgstr ""

#~ msgid "The client manager which holds all currently connected clients."
#~ msgstr ""

#~ msgid ""
#~ "**evaluate_configuration** -- A list of "
#~ "tuples. Each tuple in the list "
#~ "identifies a `ClientProxy` and the "
#~ "`EvaluateIns` for this particular "
#~ "`ClientProxy`. If a particular `ClientProxy`"
#~ " is not included in this list, "
#~ "it means that this `ClientProxy` will"
#~ " not participate in the next round"
#~ " of federated evaluation."
#~ msgstr ""

#~ msgid "DPFedAvgFixed"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.server.strategy.strategy.Strategy`"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.DPFedAvgFixed.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.DPFedAvgFixed.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate training results using unweighted aggregation."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.DPFedAvgFixed.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.DPFedAvgFixed.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ "Configure the next round of training "
#~ "incorporating Differential Privacy (DP)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.DPFedAvgFixed.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.DPFedAvgFixed.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ "Configuration of the next training round"
#~ " includes information related to DP, "
#~ "such as clip norm and noise "
#~ "stddev."
#~ msgstr ""

#~ msgid ""
#~ "**fit_configuration** -- A list of "
#~ "tuples. Each tuple in the list "
#~ "identifies a `ClientProxy` and the "
#~ "`FitIns` for this particular `ClientProxy`."
#~ " If a particular `ClientProxy` is not"
#~ " included in this list, it means "
#~ "that this `ClientProxy` will not "
#~ "participate in the next round of "
#~ "federated learning."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping.aggregate_evaluate>`\\"
#~ " \\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping.aggregate_fit>`\\"
#~ " \\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate training results and update clip norms."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping.configure_evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping.configure_fit>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideAdaptiveClipping.initialize_parameters>`\\"
#~ " \\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping.aggregate_evaluate>`\\"
#~ " \\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping.aggregate_fit>`\\"
#~ " \\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Add noise to the aggregated parameters."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping.configure_evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping.configure_fit>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.DifferentialPrivacyClientSideFixedClipping.initialize_parameters>`\\"
#~ " \\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ "The standard deviation of the noise "
#~ "added to the count of updates "
#~ "below the estimate. Andrew et al. "
#~ "recommends to set to `expected_num_records/20`"
#~ msgstr ""

#~ msgid ""
#~ "Wrap the strategy with the "
#~ "DifferentialPrivacyServerSideAdaptiveClipping wrapper::"
#~ msgstr "이 모드는 서버 측 전략 래퍼인 차분 프라이버시 클라이언트 측 적응형 클리핑과 함께 사용해야 합니다."

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping.aggregate_evaluate>`\\"
#~ " \\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping.aggregate_fit>`\\"
#~ " \\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping.configure_evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping.configure_fit>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideAdaptiveClipping.initialize_parameters>`\\"
#~ " \\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ "Wrap the strategy with the "
#~ "DifferentialPrivacyServerSideFixedClipping wrapper::"
#~ msgstr ""
#~ "이 모드는 서버 측 전략 래퍼인 "
#~ "DifferentialPrivacyClientSideFixedClipping과 함께 사용해야 "
#~ "합니다."

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping.aggregate_evaluate>`\\"
#~ " \\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping.aggregate_fit>`\\"
#~ " \\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Compute the updates, clip, and pass them for aggregation."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping.configure_evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping.configure_fit>`\\"
#~ " \\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.DifferentialPrivacyServerSideFixedClipping.initialize_parameters>`\\"
#~ " \\(client\\_manager\\)"
#~ msgstr ""

#~ msgid "Afterward, add noise to the aggregated parameters."
#~ msgstr ""

#~ msgid "FaultTolerantFedAvg"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate fit results using weighted average."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.initialize_parameters>`\\"
#~ " \\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.num_evaluation_clients>`\\"
#~ " \\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FaultTolerantFedAvg.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "Bases: :py:class:`~flwr.server.strategy.fedopt.FedOpt`"
#~ msgstr ""

#~ msgid "Metrics aggregation function, optional."
#~ msgstr ""

#~ msgid "Controls the algorithm's degree of adaptability. Defaults to 1e-9."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedAdagrad.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedAdagrad.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedAdagrad.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedAdagrad.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedAdagrad.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedAdagrad.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedAdagrad.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedAdagrad.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedAdam.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedAdam.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedAdam.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedAdam.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedAdam.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedAdam.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedAdam.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedAdam.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ "Fraction of clients used during "
#~ "training. In case `min_fit_clients` is "
#~ "larger than `fraction_fit * "
#~ "available_clients`, `min_fit_clients` will still "
#~ "be sampled. Defaults to 1.0."
#~ msgstr ""

#~ msgid ""
#~ "Fraction of clients used during "
#~ "validation. In case `min_evaluate_clients` is"
#~ " larger than `fraction_evaluate * "
#~ "available_clients`, `min_evaluate_clients` will "
#~ "still be sampled. Defaults to 1.0."
#~ msgstr ""

#~ msgid "Enable (True) or disable (False) in-place aggregation of model updates."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedAvg.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedAvg.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedAvg.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedAvg.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedAvg.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedAvg.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedAvg.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedAvg.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "FedAvgAndroid"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedAvgAndroid.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedAvgAndroid.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`bytes_to_ndarray "
#~ "<flwr.server.strategy.FedAvgAndroid.bytes_to_ndarray>`\\ "
#~ "\\(tensor\\)"
#~ msgstr ""

#~ msgid "Deserialize NumPy array from bytes."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedAvgAndroid.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedAvgAndroid.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.FedAvgAndroid.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedAvgAndroid.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ndarray_to_bytes "
#~ "<flwr.server.strategy.FedAvgAndroid.ndarray_to_bytes>`\\ "
#~ "\\(ndarray\\)"
#~ msgstr ""

#~ msgid "Serialize NumPy array to bytes."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ndarrays_to_parameters "
#~ "<flwr.server.strategy.FedAvgAndroid.ndarrays_to_parameters>`\\ "
#~ "\\(ndarrays\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedAvgAndroid.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedAvgAndroid.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`parameters_to_ndarrays "
#~ "<flwr.server.strategy.FedAvgAndroid.parameters_to_ndarrays>`\\ "
#~ "\\(parameters\\)"
#~ msgstr ""

#~ msgid "Convert parameters object to NumPy weights."
#~ msgstr ""

#~ msgid ""
#~ "Server-side learning rate used in "
#~ "server-side optimization. Defaults to 1.0."
#~ msgstr ""

#~ msgid "Server-side momentum factor used for FedAvgM. Defaults to 0.0."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedAvgM.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedAvgM.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedAvgM.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedAvgM.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedAvgM.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedAvgM.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedAvgM.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedAvgM.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedMedian.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedMedian.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate fit results using median."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedMedian.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedMedian.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedMedian.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedMedian.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedMedian.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedMedian.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "FedOpt"
#~ msgstr ""

#~ msgid "Momentum parameter. Defaults to 0.0."
#~ msgstr ""

#~ msgid "Second moment parameter. Defaults to 0.0."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedOpt.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedOpt.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedOpt.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedOpt.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedOpt.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedOpt.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedOpt.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedOpt.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ "The strategy in itself will not be"
#~ " different than FedAvg, the client "
#~ "needs to be adjusted. A proximal "
#~ "term needs to be added to the "
#~ "loss function during the training:"
#~ msgstr ""

#~ msgid ""
#~ "\\\\frac{\\\\mu}{2} || w - w^t ||^2\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "Where $w^t$ are the global parameters"
#~ " and $w$ are the local weights "
#~ "the function will be optimized with."
#~ msgstr ""

#~ msgid ""
#~ "With `global_params` being a copy of "
#~ "the parameters before the training takes"
#~ " place."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedProx.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedProx.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedProx.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedProx.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedProx.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedProx.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedProx.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedProx.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "Sends the proximal factor mu to the clients"
#~ msgstr ""

#~ msgid "Fraction to cut off of both tails of the distribution. Defaults to 0.2."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedTrimmedAvg.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedTrimmedAvg.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate fit results using trimmed average."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedTrimmedAvg.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedTrimmedAvg.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.FedTrimmedAvg.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedTrimmedAvg.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedTrimmedAvg.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedTrimmedAvg.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedXgbBagging.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid "Aggregate evaluation metrics using average."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedXgbBagging.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate fit results using bagging."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedXgbBagging.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedXgbBagging.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.FedXgbBagging.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedXgbBagging.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedXgbBagging.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedXgbBagging.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedXgbCyclic.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedXgbCyclic.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedXgbCyclic.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedXgbCyclic.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate "
#~ "<flwr.server.strategy.FedXgbCyclic.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedXgbCyclic.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedXgbCyclic.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedXgbCyclic.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid "FedXgbNnAvg"
#~ msgstr ""

#~ msgid ""
#~ "This strategy is deprecated, but a "
#~ "copy of it is available in Flower"
#~ " Baselines: "
#~ "https://github.com/adap/flower/tree/main/baselines/hfedxgboost."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedXgbNnAvg.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedXgbNnAvg.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedXgbNnAvg.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedXgbNnAvg.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedXgbNnAvg.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedXgbNnAvg.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedXgbNnAvg.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedXgbNnAvg.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.FedYogi.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.FedYogi.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.FedYogi.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.FedYogi.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.FedYogi.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.FedYogi.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.FedYogi.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.FedYogi.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ "Number of clients to keep before "
#~ "averaging (MultiKrum). Defaults to 0, in"
#~ " that case classical Krum is applied."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.Krum.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.Krum.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate fit results using Krum."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.Krum.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.Krum.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.Krum.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.Krum.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.Krum.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.Krum.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.QFedAvg.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.QFedAvg.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.QFedAvg.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.QFedAvg.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.QFedAvg.evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.QFedAvg.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_evaluation_clients "
#~ "<flwr.server.strategy.QFedAvg.num_evaluation_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`num_fit_clients "
#~ "<flwr.server.strategy.QFedAvg.num_fit_clients>`\\ "
#~ "\\(num\\_available\\_clients\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_evaluate "
#~ "<flwr.server.strategy.Strategy.aggregate_evaluate>`\\ "
#~ "\\(server\\_round\\, results\\, ...\\)"
#~ msgstr ""

#~ msgid "Aggregate evaluation results."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`aggregate_fit "
#~ "<flwr.server.strategy.Strategy.aggregate_fit>`\\ "
#~ "\\(server\\_round\\, results\\, failures\\)"
#~ msgstr ""

#~ msgid "Aggregate training results."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_evaluate "
#~ "<flwr.server.strategy.Strategy.configure_evaluate>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`configure_fit "
#~ "<flwr.server.strategy.Strategy.configure_fit>`\\ "
#~ "\\(server\\_round\\, parameters\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`evaluate <flwr.server.strategy.Strategy.evaluate>`\\"
#~ " \\(server\\_round\\, parameters\\)"
#~ msgstr ""

#~ msgid "Evaluate the current model parameters."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`initialize_parameters "
#~ "<flwr.server.strategy.Strategy.initialize_parameters>`\\ "
#~ "\\(client\\_manager\\)"
#~ msgstr ""

#~ msgid "Initialize the (global) model parameters."
#~ msgstr ""

#~ msgid ""
#~ "Successful updates from the previously "
#~ "selected and configured clients. Each "
#~ "pair of `(ClientProxy, FitRes` constitutes "
#~ "a successful update from one of "
#~ "the previously selected clients. Not "
#~ "that not all previously selected clients"
#~ " are necessarily included in this "
#~ "list: a client might drop out and"
#~ " not submit a result. For each "
#~ "client that did not submit an "
#~ "update, there should be an `Exception`"
#~ " in `failures`."
#~ msgstr ""

#~ msgid ""
#~ "Exceptions that occurred while the "
#~ "server was waiting for client updates."
#~ msgstr ""

#~ msgid ""
#~ "**aggregation_result** -- The aggregated "
#~ "evaluation result. Aggregation typically uses"
#~ " some variant of a weighted average."
#~ msgstr ""

#~ msgid ""
#~ "Successful updates from the previously "
#~ "selected and configured clients. Each "
#~ "pair of `(ClientProxy, FitRes)` constitutes"
#~ " a successful update from one of "
#~ "the previously selected clients. Not "
#~ "that not all previously selected clients"
#~ " are necessarily included in this "
#~ "list: a client might drop out and"
#~ " not submit a result. For each "
#~ "client that did not submit an "
#~ "update, there should be an `Exception`"
#~ " in `failures`."
#~ msgstr ""

#~ msgid ""
#~ "**parameters** -- If parameters are "
#~ "returned, then the server will treat "
#~ "these as the new global model "
#~ "parameters (i.e., it will replace the"
#~ " previous parameters with the ones "
#~ "returned from this method). If `None`"
#~ " is returned (e.g., because there "
#~ "were only failures and no viable "
#~ "results) then the server will no "
#~ "update the previous model parameters, "
#~ "the updates received in this round "
#~ "are discarded, and the global model "
#~ "parameters remain the same."
#~ msgstr ""

#~ msgid ""
#~ "This function can be used to "
#~ "perform centralized (i.e., server-side) "
#~ "evaluation of model parameters."
#~ msgstr ""

#~ msgid ""
#~ "**evaluation_result** -- The evaluation "
#~ "result, usually a Tuple containing loss"
#~ " and a dictionary containing task-"
#~ "specific metrics (e.g., accuracy)."
#~ msgstr ""

#~ msgid ""
#~ "**parameters** -- If parameters are "
#~ "returned, then the server will treat "
#~ "these as the initial global model "
#~ "parameters."
#~ msgstr ""

#~ msgid "workflow"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`DefaultWorkflow "
#~ "<flwr.server.workflow.DefaultWorkflow>`\\ "
#~ "\\(\\[fit\\_workflow\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Default workflow in Flower."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`SecAggPlusWorkflow "
#~ "<flwr.server.workflow.SecAggPlusWorkflow>`\\ \\(num\\_shares\\,"
#~ " ...\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "The workflow for the SecAgg+ protocol."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`SecAggWorkflow <flwr.server.workflow.SecAggWorkflow>`\\"
#~ " \\(reconstruction\\_threshold\\, \\*\\)"
#~ msgstr ""

#~ msgid "The workflow for the SecAgg protocol."
#~ msgstr ""

#~ msgid "DefaultWorkflow"
#~ msgstr ""

#~ msgid "SecAggPlusWorkflow"
#~ msgstr ""

#~ msgid ""
#~ "The SecAgg+ protocol ensures the secure"
#~ " summation of integer vectors owned "
#~ "by multiple parties, without accessing "
#~ "any individual integer vector. This "
#~ "workflow allows the server to compute"
#~ " the weighted average of model "
#~ "parameters across all clients, ensuring "
#~ "individual contributions remain private. This"
#~ " is achieved by clients sending both,"
#~ " a weighting factor and a weighted"
#~ " version of the locally updated "
#~ "parameters, both of which are masked "
#~ "for privacy. Specifically, each client "
#~ "uploads \"[w, w * params]\" with "
#~ "masks, where weighting factor 'w' is "
#~ "the number of examples ('num_examples') "
#~ "and 'params' represents the model "
#~ "parameters ('parameters') from the client's"
#~ " `FitRes`. The server then aggregates "
#~ "these contributions to compute the "
#~ "weighted average of model parameters."
#~ msgstr ""

#~ msgid "The protocol involves four main stages:"
#~ msgstr ""

#~ msgid ""
#~ "'setup': Send SecAgg+ configuration to "
#~ "clients and collect their public keys."
#~ msgstr ""

#~ msgid ""
#~ "'share keys': Broadcast public keys "
#~ "among clients and collect encrypted "
#~ "secret key shares."
#~ msgstr ""

#~ msgid ""
#~ "'collect masked vectors': Forward encrypted"
#~ " secret key shares to target clients"
#~ " and collect masked model parameters."
#~ msgstr ""

#~ msgid ""
#~ "'unmask': Collect secret key shares to"
#~ " decrypt and aggregate the model "
#~ "parameters."
#~ msgstr ""

#~ msgid ""
#~ "Only the aggregated model parameters are"
#~ " exposed and passed to "
#~ "`Strategy.aggregate_fit`, ensuring individual data"
#~ " privacy."
#~ msgstr ""

#~ msgid ""
#~ "The number of shares into which "
#~ "each client's private key is split "
#~ "under the SecAgg+ protocol. If specified"
#~ " as a float, it represents the "
#~ "proportion of all selected clients, and"
#~ " the number of shares will be "
#~ "set dynamically in the run time. A"
#~ " private key can be reconstructed "
#~ "from these shares, allowing for the "
#~ "secure aggregation of model updates. "
#~ "Each client sends one share to "
#~ "each of its neighbors while retaining"
#~ " one."
#~ msgstr ""

#~ msgid ""
#~ "The minimum number of shares required"
#~ " to reconstruct a client's private "
#~ "key, or, if specified as a float,"
#~ " it represents the proportion of the"
#~ " total number of shares needed for"
#~ " reconstruction. This threshold ensures "
#~ "privacy by allowing for the recovery "
#~ "of contributions from dropped clients "
#~ "during aggregation, without compromising "
#~ "individual client data."
#~ msgstr ""

#~ msgid ""
#~ "The maximum value of the weight "
#~ "that can be assigned to any single"
#~ " client's update during the weighted "
#~ "average calculation on the server side,"
#~ " e.g., in the FedAvg algorithm."
#~ msgstr ""

#~ msgid ""
#~ "The range within which model parameters"
#~ " are clipped before quantization. This "
#~ "parameter ensures each model parameter "
#~ "is bounded within [-clipping_range, "
#~ "clipping_range], facilitating quantization."
#~ msgstr ""

#~ msgid ""
#~ "The size of the range into which"
#~ " floating-point model parameters are "
#~ "quantized, mapping each parameter to an"
#~ " integer in [0, quantization_range-1]. This"
#~ " facilitates cryptographic operations on "
#~ "the model updates."
#~ msgstr ""

#~ msgid ""
#~ "The range of values from which "
#~ "random mask entries are uniformly "
#~ "sampled ([0, modulus_range-1]). `modulus_range` "
#~ "must be less than 4294967296. Please "
#~ "use 2**n values for `modulus_range` to"
#~ " prevent overflow issues."
#~ msgstr ""

#~ msgid ""
#~ "The timeout duration in seconds. If "
#~ "specified, the workflow will wait for"
#~ " replies for this duration each time."
#~ " If `None`, there is no time "
#~ "limit and the workflow will wait "
#~ "until replies for all messages are "
#~ "received."
#~ msgstr ""

#~ msgid ""
#~ "Generally, higher `num_shares` means more "
#~ "robust to dropouts while increasing the"
#~ " computational costs; higher "
#~ "`reconstruction_threshold` means better privacy "
#~ "guarantees but less tolerance to "
#~ "dropouts."
#~ msgstr ""

#~ msgid ""
#~ "Too large `max_weight` may compromise "
#~ "the precision of the quantization."
#~ msgstr ""

#~ msgid "`modulus_range` must be 2**n and larger than `quantization_range`."
#~ msgstr ""

#~ msgid ""
#~ "When `num_shares` is a float, it "
#~ "is interpreted as the proportion of "
#~ "all selected clients, and hence the "
#~ "number of shares will be determined "
#~ "in the runtime. This allows for "
#~ "dynamic adjustment based on the total"
#~ " number of participating clients."
#~ msgstr ""

#~ msgid ""
#~ "Similarly, when `reconstruction_threshold` is "
#~ "a float, it is interpreted as the"
#~ " proportion of the number of shares"
#~ " needed for the reconstruction of a"
#~ " private key. This feature enables "
#~ "flexibility in setting the security "
#~ "threshold relative to the number of "
#~ "distributed shares."
#~ msgstr ""

#~ msgid ""
#~ "`num_shares`, `reconstruction_threshold`, and the"
#~ " quantization parameters (`clipping_range`, "
#~ "`quantization_range`, `modulus_range`) play critical"
#~ " roles in balancing privacy, robustness,"
#~ " and efficiency within the SecAgg+ "
#~ "protocol."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`collect_masked_vectors_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.collect_masked_vectors_stage>`\\"
#~ " \\(grid\\, context\\, ...\\)"
#~ msgstr ""

#~ msgid "Execute the 'collect masked vectors' stage."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`setup_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.setup_stage>`\\ "
#~ "\\(grid\\, context\\, state\\)"
#~ msgstr ""

#~ msgid "Execute the 'setup' stage."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`share_keys_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.share_keys_stage>`\\ "
#~ "\\(grid\\, context\\, state\\)"
#~ msgstr ""

#~ msgid "Execute the 'share keys' stage."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`unmask_stage "
#~ "<flwr.server.workflow.SecAggPlusWorkflow.unmask_stage>`\\ "
#~ "\\(grid\\, context\\, state\\)"
#~ msgstr ""

#~ msgid "Execute the 'unmask' stage."
#~ msgstr ""

#~ msgid "SecAggWorkflow"
#~ msgstr ""

#~ msgid ""
#~ "Bases: "
#~ ":py:class:`~flwr.server.workflow.secure_aggregation.secaggplus_workflow.SecAggPlusWorkflow`"
#~ msgstr ""

#~ msgid ""
#~ "The SecAgg protocol ensures the secure"
#~ " summation of integer vectors owned "
#~ "by multiple parties, without accessing "
#~ "any individual integer vector. This "
#~ "workflow allows the server to compute"
#~ " the weighted average of model "
#~ "parameters across all clients, ensuring "
#~ "individual contributions remain private. This"
#~ " is achieved by clients sending both,"
#~ " a weighting factor and a weighted"
#~ " version of the locally updated "
#~ "parameters, both of which are masked "
#~ "for privacy. Specifically, each client "
#~ "uploads \"[w, w * params]\" with "
#~ "masks, where weighting factor 'w' is "
#~ "the number of examples ('num_examples') "
#~ "and 'params' represents the model "
#~ "parameters ('parameters') from the client's"
#~ " `FitRes`. The server then aggregates "
#~ "these contributions to compute the "
#~ "weighted average of model parameters."
#~ msgstr ""

#~ msgid ""
#~ "'setup': Send SecAgg configuration to "
#~ "clients and collect their public keys."
#~ msgstr ""

#~ msgid ""
#~ "Each client's private key is split "
#~ "into N shares under the SecAgg "
#~ "protocol, where N is the number of"
#~ " selected clients."
#~ msgstr ""

#~ msgid ""
#~ "Generally, higher `reconstruction_threshold` means"
#~ " better privacy guarantees but less "
#~ "tolerance to dropouts."
#~ msgstr ""

#~ msgid ""
#~ "When `reconstruction_threshold` is a float,"
#~ " it is interpreted as the proportion"
#~ " of the number of all selected "
#~ "clients needed for the reconstruction of"
#~ " a private key. This feature enables"
#~ " flexibility in setting the security "
#~ "threshold relative to the number of "
#~ "selected clients."
#~ msgstr ""

#~ msgid ""
#~ "`reconstruction_threshold`, and the quantization "
#~ "parameters (`clipping_range`, `quantization_range`, "
#~ "`modulus_range`) play critical roles in "
#~ "balancing privacy, robustness, and efficiency"
#~ " within the SecAgg protocol."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`collect_masked_vectors_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.collect_masked_vectors_stage>`\\"
#~ " \\(grid\\, context\\, ...\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`setup_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.setup_stage>`\\ \\(grid\\,"
#~ " context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`share_keys_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.share_keys_stage>`\\ "
#~ "\\(grid\\, context\\, state\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`unmask_stage "
#~ "<flwr.server.workflow.SecAggWorkflow.unmask_stage>`\\ \\(grid\\,"
#~ " context\\, state\\)"
#~ msgstr ""

#~ msgid "simulation"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`run_simulation <flwr.simulation.run_simulation>`\\ "
#~ "\\(server\\_app\\, client\\_app\\, ...\\)"
#~ msgstr ""

#~ msgid "Run a Flower App using the Simulation Engine."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`run_simulation_process "
#~ "<flwr.simulation.run_simulation_process>`\\ \\(...\\[\\, "
#~ "flwr\\_dir\\_\\, ...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`start_client <flwr.client.start_client>`\\ "
#~ "\\(\\*\\, server\\_address\\[\\, client\\_fn\\, "
#~ "...\\]\\)"

#~ msgid "Run Flower Simulation process."
#~ msgstr "Flower 시뮬레이션."

#~ msgid ""
#~ ":py:obj:`start_simulation <flwr.simulation.start_simulation>`\\"
#~ " \\(\\*args\\, \\*\\*kwargs\\)"
#~ msgstr ""
#~ ":py:obj:`start_client <flwr.client.start_client>`\\ "
#~ "\\(\\*\\, server\\_address\\[\\, client\\_fn\\, "
#~ "...\\]\\)"

#~ msgid ""
#~ ":py:obj:`SimulationIoConnection "
#~ "<flwr.simulation.SimulationIoConnection>`\\ \\(\\[...\\]\\)"
#~ msgstr ""
#~ ":py:obj:`start_client <flwr.client.start_client>`\\ "
#~ "\\(\\*\\, server\\_address\\[\\, client\\_fn\\, "
#~ "...\\]\\)"

#~ msgid "`SimulationIoConnection` provides an interface to the SimulationIo API."
#~ msgstr ""

#~ msgid "SimulationIoConnection"
#~ msgstr "CLI 시뮬레이션"

#~ msgid ""
#~ "The address (URL, IPv6, IPv4) of "
#~ "the SuperLink SimulationIo API service."
#~ msgstr ""

#~ msgid ""
#~ "The PEM-encoded root certificates as "
#~ "a byte string. If provided, a "
#~ "secure connection using the certificates "
#~ "will be established to an SSL-"
#~ "enabled Flower server."
#~ msgstr ""
#~ "바이트 문자열 또는 경로 문자열로 PEM 인코딩된 "
#~ "루트 인증서. 제공하면 인증서를 사용하여 SSL이 활성화된"
#~ " Flower 서버에 보안 연결이 설정됩니다."

#~ msgid "run\\_simulation"
#~ msgstr ""

#~ msgid ""
#~ "The `ServerApp` to be executed. It "
#~ "will send messages to different "
#~ "`ClientApp` instances running on different "
#~ "(virtual) SuperNodes."
#~ msgstr ""

#~ msgid ""
#~ "The `ClientApp` to be executed by "
#~ "each of the SuperNodes. It will "
#~ "receive messages sent by the "
#~ "`ServerApp`."
#~ msgstr ""

#~ msgid ""
#~ "Number of nodes that run a "
#~ "ClientApp. They can be sampled by "
#~ "a Grid in the ServerApp and "
#~ "receive a Message describing what the"
#~ " ClientApp should perform."
#~ msgstr ""

#~ msgid "A simulation backend that runs `ClientApp` objects."
#~ msgstr ""

#~ msgid ""
#~ "'A dictionary to configure a backend."
#~ " Separate dictionaries to configure "
#~ "different elements of backend. Supported "
#~ "top-level keys are `init_args` for "
#~ "values parsed to initialisation of "
#~ "backend, `client_resources` to define the "
#~ "resources for clients, and `actor` to"
#~ " define the actor parameters. Values "
#~ "supported in <value> are those included"
#~ " by `flwr.common.typing.ConfigRecordValues`."
#~ msgstr ""

#~ msgid ""
#~ "A boolean to indicate whether to "
#~ "enable GPU growth on the main "
#~ "thread. This is desirable if you "
#~ "make use of a TensorFlow model on"
#~ " your `ServerApp` while having your "
#~ "`ClientApp` running on the same GPU. "
#~ "Without enabling this, you might "
#~ "encounter an out-of-memory error "
#~ "because TensorFlow, by default, allocates "
#~ "all GPU memory. Read more about "
#~ "how `tf.config.experimental.set_memory_growth()` works "
#~ "in the TensorFlow documentation: "
#~ "https://www.tensorflow.org/api/stable."
#~ msgstr ""

#~ msgid ""
#~ "When disabled, only INFO, WARNING and"
#~ " ERROR log messages will be shown."
#~ " If enabled, DEBUG-level logs will"
#~ " be displayed."
#~ msgstr ""

#~ msgid "run\\_simulation\\_process"
#~ msgstr "시뮬레이션 실행"

#~ msgid "start\\_simulation"
#~ msgstr ""

#~ msgid ""
#~ "**FAB:** Name of the FAB associated "
#~ "with the run (``{FAB_ID} (v{FAB_VERSION})``)."
#~ msgstr ""

#~ msgid "**Created At:** Timestamp when the run was created."
#~ msgstr "메시지가 생성된 때의 Unix timestamp입니다."

#~ msgid "**Finished At:** Timestamp when the run finished."
#~ msgstr ""

#~ msgid "[304] SUPERNODE_TRUST_ENTITY_REQUIRED"
#~ msgstr ""

#~ msgid ""
#~ "This error occurs when entity "
#~ "verification is enabled using the "
#~ "``--enable-entities-verification`` flag, but "
#~ "no trusted entities have been provided."
#~ " The SuperNode should be restarted "
#~ "with a valid list of trusted "
#~ "entities."
#~ msgstr ""

#~ msgid "To fix this issue, you can either:"
#~ msgstr ""

#~ msgid ""
#~ "Provide a trusted entities list with "
#~ "``--trust-entities`` when launching the "
#~ "SuperNode. Supply a YAML file (for "
#~ "example, ``--trust-entities ./pks.yaml``) "
#~ "containing the trusted entities’ public "
#~ "key IDs and their corresponding public"
#~ " keys."
#~ msgstr ""

#~ msgid ""
#~ "The public keys must be in "
#~ "**OpenSSH format**, and currently only "
#~ "the **ssh-ed25519** key type is "
#~ "supported."
#~ msgstr ""

#~ msgid ""
#~ "Disable entity verification. Remove the "
#~ "``--enable-entities-verification`` flag when "
#~ "starting the SuperNode to run without"
#~ " entity verification."
#~ msgstr ""

#~ msgid ""
#~ "For production-oriented use cases, "
#~ ":ref:`enable TLS<TLS>` for secure data "
#~ "transmission."
#~ msgstr ""

#~ msgid ""
#~ "A typed dictionary (``str`` to "
#~ ":class:`Array`) that can store named "
#~ "arrays, including model parameters, gradients,"
#~ " embeddings or non-parameter arrays. "
#~ "Internally, this behaves similarly to an"
#~ " ``OrderedDict[str, Array]``. An ``ArrayRecord``"
#~ " can be viewed as an equivalent "
#~ "to PyTorch's ``state_dict``, but it "
#~ "holds arrays in a serialized form."
#~ msgstr ""

#~ msgid ""
#~ "Flower app name. For remote apps, "
#~ "use the format '@user/app==1.0.0'. Version "
#~ "is optional (defaults to latest)."
#~ msgstr ""

