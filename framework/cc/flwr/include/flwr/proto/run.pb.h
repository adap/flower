// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flwr/proto/run.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flwr_2fproto_2frun_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flwr_2fproto_2frun_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "flwr/proto/fab.pb.h"
#include "flwr/proto/node.pb.h"
#include "flwr/proto/recorddict.pb.h"
#include "flwr/proto/transport.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flwr_2fproto_2frun_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flwr_2fproto_2frun_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flwr_2fproto_2frun_2eproto;
namespace flwr {
namespace proto {
class CreateRunRequest;
struct CreateRunRequestDefaultTypeInternal;
extern CreateRunRequestDefaultTypeInternal _CreateRunRequest_default_instance_;
class CreateRunRequest_OverrideConfigEntry_DoNotUse;
struct CreateRunRequest_OverrideConfigEntry_DoNotUseDefaultTypeInternal;
extern CreateRunRequest_OverrideConfigEntry_DoNotUseDefaultTypeInternal _CreateRunRequest_OverrideConfigEntry_DoNotUse_default_instance_;
class CreateRunResponse;
struct CreateRunResponseDefaultTypeInternal;
extern CreateRunResponseDefaultTypeInternal _CreateRunResponse_default_instance_;
class GetFederationOptionsRequest;
struct GetFederationOptionsRequestDefaultTypeInternal;
extern GetFederationOptionsRequestDefaultTypeInternal _GetFederationOptionsRequest_default_instance_;
class GetFederationOptionsResponse;
struct GetFederationOptionsResponseDefaultTypeInternal;
extern GetFederationOptionsResponseDefaultTypeInternal _GetFederationOptionsResponse_default_instance_;
class GetRunRequest;
struct GetRunRequestDefaultTypeInternal;
extern GetRunRequestDefaultTypeInternal _GetRunRequest_default_instance_;
class GetRunResponse;
struct GetRunResponseDefaultTypeInternal;
extern GetRunResponseDefaultTypeInternal _GetRunResponse_default_instance_;
class GetRunStatusRequest;
struct GetRunStatusRequestDefaultTypeInternal;
extern GetRunStatusRequestDefaultTypeInternal _GetRunStatusRequest_default_instance_;
class GetRunStatusResponse;
struct GetRunStatusResponseDefaultTypeInternal;
extern GetRunStatusResponseDefaultTypeInternal _GetRunStatusResponse_default_instance_;
class GetRunStatusResponse_RunStatusDictEntry_DoNotUse;
struct GetRunStatusResponse_RunStatusDictEntry_DoNotUseDefaultTypeInternal;
extern GetRunStatusResponse_RunStatusDictEntry_DoNotUseDefaultTypeInternal _GetRunStatusResponse_RunStatusDictEntry_DoNotUse_default_instance_;
class Run;
struct RunDefaultTypeInternal;
extern RunDefaultTypeInternal _Run_default_instance_;
class RunStatus;
struct RunStatusDefaultTypeInternal;
extern RunStatusDefaultTypeInternal _RunStatus_default_instance_;
class Run_OverrideConfigEntry_DoNotUse;
struct Run_OverrideConfigEntry_DoNotUseDefaultTypeInternal;
extern Run_OverrideConfigEntry_DoNotUseDefaultTypeInternal _Run_OverrideConfigEntry_DoNotUse_default_instance_;
class UpdateRunStatusRequest;
struct UpdateRunStatusRequestDefaultTypeInternal;
extern UpdateRunStatusRequestDefaultTypeInternal _UpdateRunStatusRequest_default_instance_;
class UpdateRunStatusResponse;
struct UpdateRunStatusResponseDefaultTypeInternal;
extern UpdateRunStatusResponseDefaultTypeInternal _UpdateRunStatusResponse_default_instance_;
}  // namespace proto
}  // namespace flwr
PROTOBUF_NAMESPACE_OPEN
template<> ::flwr::proto::CreateRunRequest* Arena::CreateMaybeMessage<::flwr::proto::CreateRunRequest>(Arena*);
template<> ::flwr::proto::CreateRunRequest_OverrideConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::flwr::proto::CreateRunRequest_OverrideConfigEntry_DoNotUse>(Arena*);
template<> ::flwr::proto::CreateRunResponse* Arena::CreateMaybeMessage<::flwr::proto::CreateRunResponse>(Arena*);
template<> ::flwr::proto::GetFederationOptionsRequest* Arena::CreateMaybeMessage<::flwr::proto::GetFederationOptionsRequest>(Arena*);
template<> ::flwr::proto::GetFederationOptionsResponse* Arena::CreateMaybeMessage<::flwr::proto::GetFederationOptionsResponse>(Arena*);
template<> ::flwr::proto::GetRunRequest* Arena::CreateMaybeMessage<::flwr::proto::GetRunRequest>(Arena*);
template<> ::flwr::proto::GetRunResponse* Arena::CreateMaybeMessage<::flwr::proto::GetRunResponse>(Arena*);
template<> ::flwr::proto::GetRunStatusRequest* Arena::CreateMaybeMessage<::flwr::proto::GetRunStatusRequest>(Arena*);
template<> ::flwr::proto::GetRunStatusResponse* Arena::CreateMaybeMessage<::flwr::proto::GetRunStatusResponse>(Arena*);
template<> ::flwr::proto::GetRunStatusResponse_RunStatusDictEntry_DoNotUse* Arena::CreateMaybeMessage<::flwr::proto::GetRunStatusResponse_RunStatusDictEntry_DoNotUse>(Arena*);
template<> ::flwr::proto::Run* Arena::CreateMaybeMessage<::flwr::proto::Run>(Arena*);
template<> ::flwr::proto::RunStatus* Arena::CreateMaybeMessage<::flwr::proto::RunStatus>(Arena*);
template<> ::flwr::proto::Run_OverrideConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::flwr::proto::Run_OverrideConfigEntry_DoNotUse>(Arena*);
template<> ::flwr::proto::UpdateRunStatusRequest* Arena::CreateMaybeMessage<::flwr::proto::UpdateRunStatusRequest>(Arena*);
template<> ::flwr::proto::UpdateRunStatusResponse* Arena::CreateMaybeMessage<::flwr::proto::UpdateRunStatusResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flwr {
namespace proto {

// ===================================================================

class Run_OverrideConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Run_OverrideConfigEntry_DoNotUse, 
    std::string, ::flwr::proto::Scalar,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Run_OverrideConfigEntry_DoNotUse, 
    std::string, ::flwr::proto::Scalar,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Run_OverrideConfigEntry_DoNotUse();
  explicit constexpr Run_OverrideConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Run_OverrideConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Run_OverrideConfigEntry_DoNotUse& other);
  static const Run_OverrideConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Run_OverrideConfigEntry_DoNotUse*>(&_Run_OverrideConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flwr.proto.Run.OverrideConfigEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Run final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.Run) */ {
 public:
  inline Run() : Run(nullptr) {}
  ~Run() override;
  explicit constexpr Run(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Run(const Run& from);
  Run(Run&& from) noexcept
    : Run() {
    *this = ::std::move(from);
  }

  inline Run& operator=(const Run& from) {
    CopyFrom(from);
    return *this;
  }
  inline Run& operator=(Run&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Run& default_instance() {
    return *internal_default_instance();
  }
  static inline const Run* internal_default_instance() {
    return reinterpret_cast<const Run*>(
               &_Run_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Run& a, Run& b) {
    a.Swap(&b);
  }
  inline void Swap(Run* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Run* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Run* New() const final {
    return new Run();
  }

  Run* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Run>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Run& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Run& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Run* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.Run";
  }
  protected:
  explicit Run(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOverrideConfigFieldNumber = 4,
    kFabIdFieldNumber = 2,
    kFabVersionFieldNumber = 3,
    kFabHashFieldNumber = 5,
    kPendingAtFieldNumber = 6,
    kStartingAtFieldNumber = 7,
    kRunningAtFieldNumber = 8,
    kFinishedAtFieldNumber = 9,
    kStatusFieldNumber = 10,
    kRunIdFieldNumber = 1,
  };
  // map<string, .flwr.proto.Scalar> override_config = 4;
  int override_config_size() const;
  private:
  int _internal_override_config_size() const;
  public:
  void clear_override_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
      _internal_override_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
      _internal_mutable_override_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
      override_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
      mutable_override_config();

  // string fab_id = 2;
  void clear_fab_id();
  const std::string& fab_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fab_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fab_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_fab_id();
  void set_allocated_fab_id(std::string* fab_id);
  private:
  const std::string& _internal_fab_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fab_id(const std::string& value);
  std::string* _internal_mutable_fab_id();
  public:

  // string fab_version = 3;
  void clear_fab_version();
  const std::string& fab_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fab_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fab_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_fab_version();
  void set_allocated_fab_version(std::string* fab_version);
  private:
  const std::string& _internal_fab_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fab_version(const std::string& value);
  std::string* _internal_mutable_fab_version();
  public:

  // string fab_hash = 5;
  void clear_fab_hash();
  const std::string& fab_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fab_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fab_hash();
  PROTOBUF_MUST_USE_RESULT std::string* release_fab_hash();
  void set_allocated_fab_hash(std::string* fab_hash);
  private:
  const std::string& _internal_fab_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fab_hash(const std::string& value);
  std::string* _internal_mutable_fab_hash();
  public:

  // string pending_at = 6;
  void clear_pending_at();
  const std::string& pending_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pending_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pending_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_pending_at();
  void set_allocated_pending_at(std::string* pending_at);
  private:
  const std::string& _internal_pending_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pending_at(const std::string& value);
  std::string* _internal_mutable_pending_at();
  public:

  // string starting_at = 7;
  void clear_starting_at();
  const std::string& starting_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_starting_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_starting_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_starting_at();
  void set_allocated_starting_at(std::string* starting_at);
  private:
  const std::string& _internal_starting_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_starting_at(const std::string& value);
  std::string* _internal_mutable_starting_at();
  public:

  // string running_at = 8;
  void clear_running_at();
  const std::string& running_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_running_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_running_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_running_at();
  void set_allocated_running_at(std::string* running_at);
  private:
  const std::string& _internal_running_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_running_at(const std::string& value);
  std::string* _internal_mutable_running_at();
  public:

  // string finished_at = 9;
  void clear_finished_at();
  const std::string& finished_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_finished_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_finished_at();
  PROTOBUF_MUST_USE_RESULT std::string* release_finished_at();
  void set_allocated_finished_at(std::string* finished_at);
  private:
  const std::string& _internal_finished_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_finished_at(const std::string& value);
  std::string* _internal_mutable_finished_at();
  public:

  // .flwr.proto.RunStatus status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::flwr::proto::RunStatus& status() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::RunStatus* release_status();
  ::flwr::proto::RunStatus* mutable_status();
  void set_allocated_status(::flwr::proto::RunStatus* status);
  private:
  const ::flwr::proto::RunStatus& _internal_status() const;
  ::flwr::proto::RunStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::flwr::proto::RunStatus* status);
  ::flwr::proto::RunStatus* unsafe_arena_release_status();

  // uint64 run_id = 1;
  void clear_run_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id() const;
  void set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_run_id() const;
  void _internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flwr.proto.Run)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Run_OverrideConfigEntry_DoNotUse,
      std::string, ::flwr::proto::Scalar,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> override_config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fab_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fab_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fab_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pending_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr starting_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr running_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finished_at_;
  ::flwr::proto::RunStatus* status_;
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class RunStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.RunStatus) */ {
 public:
  inline RunStatus() : RunStatus(nullptr) {}
  ~RunStatus() override;
  explicit constexpr RunStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunStatus(const RunStatus& from);
  RunStatus(RunStatus&& from) noexcept
    : RunStatus() {
    *this = ::std::move(from);
  }

  inline RunStatus& operator=(const RunStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunStatus& operator=(RunStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunStatus* internal_default_instance() {
    return reinterpret_cast<const RunStatus*>(
               &_RunStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RunStatus& a, RunStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RunStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunStatus* New() const final {
    return new RunStatus();
  }

  RunStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.RunStatus";
  }
  protected:
  explicit RunStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSubStatusFieldNumber = 2,
    kDetailsFieldNumber = 3,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string sub_status = 2;
  void clear_sub_status();
  const std::string& sub_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sub_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sub_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_sub_status();
  void set_allocated_sub_status(std::string* sub_status);
  private:
  const std::string& _internal_sub_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_status(const std::string& value);
  std::string* _internal_mutable_sub_status();
  public:

  // string details = 3;
  void clear_details();
  const std::string& details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_details();
  PROTOBUF_MUST_USE_RESULT std::string* release_details();
  void set_allocated_details(std::string* details);
  private:
  const std::string& _internal_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_details(const std::string& value);
  std::string* _internal_mutable_details();
  public:

  // @@protoc_insertion_point(class_scope:flwr.proto.RunStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr details_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class CreateRunRequest_OverrideConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRunRequest_OverrideConfigEntry_DoNotUse, 
    std::string, ::flwr::proto::Scalar,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateRunRequest_OverrideConfigEntry_DoNotUse, 
    std::string, ::flwr::proto::Scalar,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  CreateRunRequest_OverrideConfigEntry_DoNotUse();
  explicit constexpr CreateRunRequest_OverrideConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CreateRunRequest_OverrideConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateRunRequest_OverrideConfigEntry_DoNotUse& other);
  static const CreateRunRequest_OverrideConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateRunRequest_OverrideConfigEntry_DoNotUse*>(&_CreateRunRequest_OverrideConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flwr.proto.CreateRunRequest.OverrideConfigEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CreateRunRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.CreateRunRequest) */ {
 public:
  inline CreateRunRequest() : CreateRunRequest(nullptr) {}
  ~CreateRunRequest() override;
  explicit constexpr CreateRunRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRunRequest(const CreateRunRequest& from);
  CreateRunRequest(CreateRunRequest&& from) noexcept
    : CreateRunRequest() {
    *this = ::std::move(from);
  }

  inline CreateRunRequest& operator=(const CreateRunRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRunRequest& operator=(CreateRunRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRunRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRunRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRunRequest*>(
               &_CreateRunRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateRunRequest& a, CreateRunRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRunRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRunRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRunRequest* New() const final {
    return new CreateRunRequest();
  }

  CreateRunRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRunRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRunRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRunRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRunRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.CreateRunRequest";
  }
  protected:
  explicit CreateRunRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOverrideConfigFieldNumber = 3,
    kFabIdFieldNumber = 1,
    kFabVersionFieldNumber = 2,
    kFabFieldNumber = 4,
  };
  // map<string, .flwr.proto.Scalar> override_config = 3;
  int override_config_size() const;
  private:
  int _internal_override_config_size() const;
  public:
  void clear_override_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
      _internal_override_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
      _internal_mutable_override_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
      override_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
      mutable_override_config();

  // string fab_id = 1;
  void clear_fab_id();
  const std::string& fab_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fab_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fab_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_fab_id();
  void set_allocated_fab_id(std::string* fab_id);
  private:
  const std::string& _internal_fab_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fab_id(const std::string& value);
  std::string* _internal_mutable_fab_id();
  public:

  // string fab_version = 2;
  void clear_fab_version();
  const std::string& fab_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fab_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fab_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_fab_version();
  void set_allocated_fab_version(std::string* fab_version);
  private:
  const std::string& _internal_fab_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fab_version(const std::string& value);
  std::string* _internal_mutable_fab_version();
  public:

  // .flwr.proto.Fab fab = 4;
  bool has_fab() const;
  private:
  bool _internal_has_fab() const;
  public:
  void clear_fab();
  const ::flwr::proto::Fab& fab() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::Fab* release_fab();
  ::flwr::proto::Fab* mutable_fab();
  void set_allocated_fab(::flwr::proto::Fab* fab);
  private:
  const ::flwr::proto::Fab& _internal_fab() const;
  ::flwr::proto::Fab* _internal_mutable_fab();
  public:
  void unsafe_arena_set_allocated_fab(
      ::flwr::proto::Fab* fab);
  ::flwr::proto::Fab* unsafe_arena_release_fab();

  // @@protoc_insertion_point(class_scope:flwr.proto.CreateRunRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateRunRequest_OverrideConfigEntry_DoNotUse,
      std::string, ::flwr::proto::Scalar,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> override_config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fab_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fab_version_;
  ::flwr::proto::Fab* fab_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class CreateRunResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.CreateRunResponse) */ {
 public:
  inline CreateRunResponse() : CreateRunResponse(nullptr) {}
  ~CreateRunResponse() override;
  explicit constexpr CreateRunResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRunResponse(const CreateRunResponse& from);
  CreateRunResponse(CreateRunResponse&& from) noexcept
    : CreateRunResponse() {
    *this = ::std::move(from);
  }

  inline CreateRunResponse& operator=(const CreateRunResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRunResponse& operator=(CreateRunResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRunResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRunResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRunResponse*>(
               &_CreateRunResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CreateRunResponse& a, CreateRunResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRunResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRunResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRunResponse* New() const final {
    return new CreateRunResponse();
  }

  CreateRunResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRunResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRunResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateRunResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRunResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.CreateRunResponse";
  }
  protected:
  explicit CreateRunResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunIdFieldNumber = 1,
  };
  // uint64 run_id = 1;
  void clear_run_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id() const;
  void set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_run_id() const;
  void _internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flwr.proto.CreateRunResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class GetRunRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.GetRunRequest) */ {
 public:
  inline GetRunRequest() : GetRunRequest(nullptr) {}
  ~GetRunRequest() override;
  explicit constexpr GetRunRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRunRequest(const GetRunRequest& from);
  GetRunRequest(GetRunRequest&& from) noexcept
    : GetRunRequest() {
    *this = ::std::move(from);
  }

  inline GetRunRequest& operator=(const GetRunRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRunRequest& operator=(GetRunRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRunRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRunRequest* internal_default_instance() {
    return reinterpret_cast<const GetRunRequest*>(
               &_GetRunRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetRunRequest& a, GetRunRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRunRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRunRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRunRequest* New() const final {
    return new GetRunRequest();
  }

  GetRunRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRunRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRunRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRunRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRunRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.GetRunRequest";
  }
  protected:
  explicit GetRunRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kRunIdFieldNumber = 2,
  };
  // .flwr.proto.Node node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::flwr::proto::Node& node() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::Node* release_node();
  ::flwr::proto::Node* mutable_node();
  void set_allocated_node(::flwr::proto::Node* node);
  private:
  const ::flwr::proto::Node& _internal_node() const;
  ::flwr::proto::Node* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::flwr::proto::Node* node);
  ::flwr::proto::Node* unsafe_arena_release_node();

  // uint64 run_id = 2;
  void clear_run_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id() const;
  void set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_run_id() const;
  void _internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flwr.proto.GetRunRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flwr::proto::Node* node_;
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class GetRunResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.GetRunResponse) */ {
 public:
  inline GetRunResponse() : GetRunResponse(nullptr) {}
  ~GetRunResponse() override;
  explicit constexpr GetRunResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRunResponse(const GetRunResponse& from);
  GetRunResponse(GetRunResponse&& from) noexcept
    : GetRunResponse() {
    *this = ::std::move(from);
  }

  inline GetRunResponse& operator=(const GetRunResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRunResponse& operator=(GetRunResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRunResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRunResponse* internal_default_instance() {
    return reinterpret_cast<const GetRunResponse*>(
               &_GetRunResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetRunResponse& a, GetRunResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRunResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRunResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRunResponse* New() const final {
    return new GetRunResponse();
  }

  GetRunResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRunResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRunResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRunResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRunResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.GetRunResponse";
  }
  protected:
  explicit GetRunResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunFieldNumber = 1,
  };
  // .flwr.proto.Run run = 1;
  bool has_run() const;
  private:
  bool _internal_has_run() const;
  public:
  void clear_run();
  const ::flwr::proto::Run& run() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::Run* release_run();
  ::flwr::proto::Run* mutable_run();
  void set_allocated_run(::flwr::proto::Run* run);
  private:
  const ::flwr::proto::Run& _internal_run() const;
  ::flwr::proto::Run* _internal_mutable_run();
  public:
  void unsafe_arena_set_allocated_run(
      ::flwr::proto::Run* run);
  ::flwr::proto::Run* unsafe_arena_release_run();

  // @@protoc_insertion_point(class_scope:flwr.proto.GetRunResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flwr::proto::Run* run_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class UpdateRunStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.UpdateRunStatusRequest) */ {
 public:
  inline UpdateRunStatusRequest() : UpdateRunStatusRequest(nullptr) {}
  ~UpdateRunStatusRequest() override;
  explicit constexpr UpdateRunStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRunStatusRequest(const UpdateRunStatusRequest& from);
  UpdateRunStatusRequest(UpdateRunStatusRequest&& from) noexcept
    : UpdateRunStatusRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRunStatusRequest& operator=(const UpdateRunStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRunStatusRequest& operator=(UpdateRunStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRunStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRunStatusRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRunStatusRequest*>(
               &_UpdateRunStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UpdateRunStatusRequest& a, UpdateRunStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRunStatusRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRunStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateRunStatusRequest* New() const final {
    return new UpdateRunStatusRequest();
  }

  UpdateRunStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRunStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRunStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateRunStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRunStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.UpdateRunStatusRequest";
  }
  protected:
  explicit UpdateRunStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunStatusFieldNumber = 2,
    kRunIdFieldNumber = 1,
  };
  // .flwr.proto.RunStatus run_status = 2;
  bool has_run_status() const;
  private:
  bool _internal_has_run_status() const;
  public:
  void clear_run_status();
  const ::flwr::proto::RunStatus& run_status() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::RunStatus* release_run_status();
  ::flwr::proto::RunStatus* mutable_run_status();
  void set_allocated_run_status(::flwr::proto::RunStatus* run_status);
  private:
  const ::flwr::proto::RunStatus& _internal_run_status() const;
  ::flwr::proto::RunStatus* _internal_mutable_run_status();
  public:
  void unsafe_arena_set_allocated_run_status(
      ::flwr::proto::RunStatus* run_status);
  ::flwr::proto::RunStatus* unsafe_arena_release_run_status();

  // uint64 run_id = 1;
  void clear_run_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id() const;
  void set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_run_id() const;
  void _internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flwr.proto.UpdateRunStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flwr::proto::RunStatus* run_status_;
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class UpdateRunStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flwr.proto.UpdateRunStatusResponse) */ {
 public:
  inline UpdateRunStatusResponse() : UpdateRunStatusResponse(nullptr) {}
  explicit constexpr UpdateRunStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRunStatusResponse(const UpdateRunStatusResponse& from);
  UpdateRunStatusResponse(UpdateRunStatusResponse&& from) noexcept
    : UpdateRunStatusResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRunStatusResponse& operator=(const UpdateRunStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRunStatusResponse& operator=(UpdateRunStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRunStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRunStatusResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRunStatusResponse*>(
               &_UpdateRunStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateRunStatusResponse& a, UpdateRunStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRunStatusResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRunStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateRunStatusResponse* New() const final {
    return new UpdateRunStatusResponse();
  }

  UpdateRunStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRunStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRunStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRunStatusResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.UpdateRunStatusResponse";
  }
  protected:
  explicit UpdateRunStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flwr.proto.UpdateRunStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class GetRunStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.GetRunStatusRequest) */ {
 public:
  inline GetRunStatusRequest() : GetRunStatusRequest(nullptr) {}
  ~GetRunStatusRequest() override;
  explicit constexpr GetRunStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRunStatusRequest(const GetRunStatusRequest& from);
  GetRunStatusRequest(GetRunStatusRequest&& from) noexcept
    : GetRunStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetRunStatusRequest& operator=(const GetRunStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRunStatusRequest& operator=(GetRunStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRunStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRunStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetRunStatusRequest*>(
               &_GetRunStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetRunStatusRequest& a, GetRunStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRunStatusRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRunStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRunStatusRequest* New() const final {
    return new GetRunStatusRequest();
  }

  GetRunStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRunStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRunStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRunStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRunStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.GetRunStatusRequest";
  }
  protected:
  explicit GetRunStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunIdsFieldNumber = 2,
    kNodeFieldNumber = 1,
  };
  // repeated uint64 run_ids = 2;
  int run_ids_size() const;
  private:
  int _internal_run_ids_size() const;
  public:
  void clear_run_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_run_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_run_ids() const;
  void _internal_add_run_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_run_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 run_ids(int index) const;
  void set_run_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_run_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      run_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_run_ids();

  // .flwr.proto.Node node = 1;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::flwr::proto::Node& node() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::Node* release_node();
  ::flwr::proto::Node* mutable_node();
  void set_allocated_node(::flwr::proto::Node* node);
  private:
  const ::flwr::proto::Node& _internal_node() const;
  ::flwr::proto::Node* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::flwr::proto::Node* node);
  ::flwr::proto::Node* unsafe_arena_release_node();

  // @@protoc_insertion_point(class_scope:flwr.proto.GetRunStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > run_ids_;
  mutable std::atomic<int> _run_ids_cached_byte_size_;
  ::flwr::proto::Node* node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class GetRunStatusResponse_RunStatusDictEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetRunStatusResponse_RunStatusDictEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetRunStatusResponse_RunStatusDictEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetRunStatusResponse_RunStatusDictEntry_DoNotUse();
  explicit constexpr GetRunStatusResponse_RunStatusDictEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetRunStatusResponse_RunStatusDictEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetRunStatusResponse_RunStatusDictEntry_DoNotUse& other);
  static const GetRunStatusResponse_RunStatusDictEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetRunStatusResponse_RunStatusDictEntry_DoNotUse*>(&_GetRunStatusResponse_RunStatusDictEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetRunStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.GetRunStatusResponse) */ {
 public:
  inline GetRunStatusResponse() : GetRunStatusResponse(nullptr) {}
  ~GetRunStatusResponse() override;
  explicit constexpr GetRunStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRunStatusResponse(const GetRunStatusResponse& from);
  GetRunStatusResponse(GetRunStatusResponse&& from) noexcept
    : GetRunStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetRunStatusResponse& operator=(const GetRunStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRunStatusResponse& operator=(GetRunStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRunStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRunStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetRunStatusResponse*>(
               &_GetRunStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetRunStatusResponse& a, GetRunStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRunStatusResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRunStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRunStatusResponse* New() const final {
    return new GetRunStatusResponse();
  }

  GetRunStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRunStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRunStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRunStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRunStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.GetRunStatusResponse";
  }
  protected:
  explicit GetRunStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRunStatusDictFieldNumber = 1,
  };
  // map<uint64, .flwr.proto.RunStatus> run_status_dict = 1;
  int run_status_dict_size() const;
  private:
  int _internal_run_status_dict_size() const;
  public:
  void clear_run_status_dict();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >&
      _internal_run_status_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >*
      _internal_mutable_run_status_dict();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >&
      run_status_dict() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >*
      mutable_run_status_dict();

  // @@protoc_insertion_point(class_scope:flwr.proto.GetRunStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetRunStatusResponse_RunStatusDictEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> run_status_dict_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class GetFederationOptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.GetFederationOptionsRequest) */ {
 public:
  inline GetFederationOptionsRequest() : GetFederationOptionsRequest(nullptr) {}
  ~GetFederationOptionsRequest() override;
  explicit constexpr GetFederationOptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFederationOptionsRequest(const GetFederationOptionsRequest& from);
  GetFederationOptionsRequest(GetFederationOptionsRequest&& from) noexcept
    : GetFederationOptionsRequest() {
    *this = ::std::move(from);
  }

  inline GetFederationOptionsRequest& operator=(const GetFederationOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFederationOptionsRequest& operator=(GetFederationOptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFederationOptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFederationOptionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetFederationOptionsRequest*>(
               &_GetFederationOptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetFederationOptionsRequest& a, GetFederationOptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFederationOptionsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFederationOptionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFederationOptionsRequest* New() const final {
    return new GetFederationOptionsRequest();
  }

  GetFederationOptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFederationOptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFederationOptionsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFederationOptionsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFederationOptionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.GetFederationOptionsRequest";
  }
  protected:
  explicit GetFederationOptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunIdFieldNumber = 1,
  };
  // uint64 run_id = 1;
  void clear_run_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id() const;
  void set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_run_id() const;
  void _internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flwr.proto.GetFederationOptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 run_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// -------------------------------------------------------------------

class GetFederationOptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flwr.proto.GetFederationOptionsResponse) */ {
 public:
  inline GetFederationOptionsResponse() : GetFederationOptionsResponse(nullptr) {}
  ~GetFederationOptionsResponse() override;
  explicit constexpr GetFederationOptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetFederationOptionsResponse(const GetFederationOptionsResponse& from);
  GetFederationOptionsResponse(GetFederationOptionsResponse&& from) noexcept
    : GetFederationOptionsResponse() {
    *this = ::std::move(from);
  }

  inline GetFederationOptionsResponse& operator=(const GetFederationOptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetFederationOptionsResponse& operator=(GetFederationOptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetFederationOptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetFederationOptionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetFederationOptionsResponse*>(
               &_GetFederationOptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetFederationOptionsResponse& a, GetFederationOptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetFederationOptionsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetFederationOptionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetFederationOptionsResponse* New() const final {
    return new GetFederationOptionsResponse();
  }

  GetFederationOptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetFederationOptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetFederationOptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetFederationOptionsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetFederationOptionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flwr.proto.GetFederationOptionsResponse";
  }
  protected:
  explicit GetFederationOptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFederationOptionsFieldNumber = 1,
  };
  // .flwr.proto.ConfigRecord federation_options = 1;
  bool has_federation_options() const;
  private:
  bool _internal_has_federation_options() const;
  public:
  void clear_federation_options();
  const ::flwr::proto::ConfigRecord& federation_options() const;
  PROTOBUF_MUST_USE_RESULT ::flwr::proto::ConfigRecord* release_federation_options();
  ::flwr::proto::ConfigRecord* mutable_federation_options();
  void set_allocated_federation_options(::flwr::proto::ConfigRecord* federation_options);
  private:
  const ::flwr::proto::ConfigRecord& _internal_federation_options() const;
  ::flwr::proto::ConfigRecord* _internal_mutable_federation_options();
  public:
  void unsafe_arena_set_allocated_federation_options(
      ::flwr::proto::ConfigRecord* federation_options);
  ::flwr::proto::ConfigRecord* unsafe_arena_release_federation_options();

  // @@protoc_insertion_point(class_scope:flwr.proto.GetFederationOptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flwr::proto::ConfigRecord* federation_options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flwr_2fproto_2frun_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Run

// uint64 run_id = 1;
inline void Run::clear_run_id() {
  run_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Run::_internal_run_id() const {
  return run_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Run::run_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.run_id)
  return _internal_run_id();
}
inline void Run::_internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  run_id_ = value;
}
inline void Run::set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:flwr.proto.Run.run_id)
}

// string fab_id = 2;
inline void Run::clear_fab_id() {
  fab_id_.ClearToEmpty();
}
inline const std::string& Run::fab_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.fab_id)
  return _internal_fab_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_fab_id(ArgT0&& arg0, ArgT... args) {
 
 fab_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.fab_id)
}
inline std::string* Run::mutable_fab_id() {
  std::string* _s = _internal_mutable_fab_id();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.fab_id)
  return _s;
}
inline const std::string& Run::_internal_fab_id() const {
  return fab_id_.Get();
}
inline void Run::_internal_set_fab_id(const std::string& value) {
  
  fab_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_fab_id() {
  
  return fab_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_fab_id() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.fab_id)
  return fab_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_fab_id(std::string* fab_id) {
  if (fab_id != nullptr) {
    
  } else {
    
  }
  fab_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fab_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.fab_id)
}

// string fab_version = 3;
inline void Run::clear_fab_version() {
  fab_version_.ClearToEmpty();
}
inline const std::string& Run::fab_version() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.fab_version)
  return _internal_fab_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_fab_version(ArgT0&& arg0, ArgT... args) {
 
 fab_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.fab_version)
}
inline std::string* Run::mutable_fab_version() {
  std::string* _s = _internal_mutable_fab_version();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.fab_version)
  return _s;
}
inline const std::string& Run::_internal_fab_version() const {
  return fab_version_.Get();
}
inline void Run::_internal_set_fab_version(const std::string& value) {
  
  fab_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_fab_version() {
  
  return fab_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_fab_version() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.fab_version)
  return fab_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_fab_version(std::string* fab_version) {
  if (fab_version != nullptr) {
    
  } else {
    
  }
  fab_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fab_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.fab_version)
}

// map<string, .flwr.proto.Scalar> override_config = 4;
inline int Run::_internal_override_config_size() const {
  return override_config_.size();
}
inline int Run::override_config_size() const {
  return _internal_override_config_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
Run::_internal_override_config() const {
  return override_config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
Run::override_config() const {
  // @@protoc_insertion_point(field_map:flwr.proto.Run.override_config)
  return _internal_override_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
Run::_internal_mutable_override_config() {
  return override_config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
Run::mutable_override_config() {
  // @@protoc_insertion_point(field_mutable_map:flwr.proto.Run.override_config)
  return _internal_mutable_override_config();
}

// string fab_hash = 5;
inline void Run::clear_fab_hash() {
  fab_hash_.ClearToEmpty();
}
inline const std::string& Run::fab_hash() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.fab_hash)
  return _internal_fab_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_fab_hash(ArgT0&& arg0, ArgT... args) {
 
 fab_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.fab_hash)
}
inline std::string* Run::mutable_fab_hash() {
  std::string* _s = _internal_mutable_fab_hash();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.fab_hash)
  return _s;
}
inline const std::string& Run::_internal_fab_hash() const {
  return fab_hash_.Get();
}
inline void Run::_internal_set_fab_hash(const std::string& value) {
  
  fab_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_fab_hash() {
  
  return fab_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_fab_hash() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.fab_hash)
  return fab_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_fab_hash(std::string* fab_hash) {
  if (fab_hash != nullptr) {
    
  } else {
    
  }
  fab_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fab_hash,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.fab_hash)
}

// string pending_at = 6;
inline void Run::clear_pending_at() {
  pending_at_.ClearToEmpty();
}
inline const std::string& Run::pending_at() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.pending_at)
  return _internal_pending_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_pending_at(ArgT0&& arg0, ArgT... args) {
 
 pending_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.pending_at)
}
inline std::string* Run::mutable_pending_at() {
  std::string* _s = _internal_mutable_pending_at();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.pending_at)
  return _s;
}
inline const std::string& Run::_internal_pending_at() const {
  return pending_at_.Get();
}
inline void Run::_internal_set_pending_at(const std::string& value) {
  
  pending_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_pending_at() {
  
  return pending_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_pending_at() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.pending_at)
  return pending_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_pending_at(std::string* pending_at) {
  if (pending_at != nullptr) {
    
  } else {
    
  }
  pending_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pending_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.pending_at)
}

// string starting_at = 7;
inline void Run::clear_starting_at() {
  starting_at_.ClearToEmpty();
}
inline const std::string& Run::starting_at() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.starting_at)
  return _internal_starting_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_starting_at(ArgT0&& arg0, ArgT... args) {
 
 starting_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.starting_at)
}
inline std::string* Run::mutable_starting_at() {
  std::string* _s = _internal_mutable_starting_at();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.starting_at)
  return _s;
}
inline const std::string& Run::_internal_starting_at() const {
  return starting_at_.Get();
}
inline void Run::_internal_set_starting_at(const std::string& value) {
  
  starting_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_starting_at() {
  
  return starting_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_starting_at() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.starting_at)
  return starting_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_starting_at(std::string* starting_at) {
  if (starting_at != nullptr) {
    
  } else {
    
  }
  starting_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), starting_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.starting_at)
}

// string running_at = 8;
inline void Run::clear_running_at() {
  running_at_.ClearToEmpty();
}
inline const std::string& Run::running_at() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.running_at)
  return _internal_running_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_running_at(ArgT0&& arg0, ArgT... args) {
 
 running_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.running_at)
}
inline std::string* Run::mutable_running_at() {
  std::string* _s = _internal_mutable_running_at();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.running_at)
  return _s;
}
inline const std::string& Run::_internal_running_at() const {
  return running_at_.Get();
}
inline void Run::_internal_set_running_at(const std::string& value) {
  
  running_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_running_at() {
  
  return running_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_running_at() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.running_at)
  return running_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_running_at(std::string* running_at) {
  if (running_at != nullptr) {
    
  } else {
    
  }
  running_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), running_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.running_at)
}

// string finished_at = 9;
inline void Run::clear_finished_at() {
  finished_at_.ClearToEmpty();
}
inline const std::string& Run::finished_at() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.finished_at)
  return _internal_finished_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Run::set_finished_at(ArgT0&& arg0, ArgT... args) {
 
 finished_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.Run.finished_at)
}
inline std::string* Run::mutable_finished_at() {
  std::string* _s = _internal_mutable_finished_at();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.finished_at)
  return _s;
}
inline const std::string& Run::_internal_finished_at() const {
  return finished_at_.Get();
}
inline void Run::_internal_set_finished_at(const std::string& value) {
  
  finished_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Run::_internal_mutable_finished_at() {
  
  return finished_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Run::release_finished_at() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.finished_at)
  return finished_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Run::set_allocated_finished_at(std::string* finished_at) {
  if (finished_at != nullptr) {
    
  } else {
    
  }
  finished_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), finished_at,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.finished_at)
}

// .flwr.proto.RunStatus status = 10;
inline bool Run::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Run::has_status() const {
  return _internal_has_status();
}
inline void Run::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::flwr::proto::RunStatus& Run::_internal_status() const {
  const ::flwr::proto::RunStatus* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::RunStatus&>(
      ::flwr::proto::_RunStatus_default_instance_);
}
inline const ::flwr::proto::RunStatus& Run::status() const {
  // @@protoc_insertion_point(field_get:flwr.proto.Run.status)
  return _internal_status();
}
inline void Run::unsafe_arena_set_allocated_status(
    ::flwr::proto::RunStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.Run.status)
}
inline ::flwr::proto::RunStatus* Run::release_status() {
  
  ::flwr::proto::RunStatus* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::RunStatus* Run::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:flwr.proto.Run.status)
  
  ::flwr::proto::RunStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::flwr::proto::RunStatus* Run::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::RunStatus>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::flwr::proto::RunStatus* Run::mutable_status() {
  ::flwr::proto::RunStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:flwr.proto.Run.status)
  return _msg;
}
inline void Run::set_allocated_status(::flwr::proto::RunStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flwr::proto::RunStatus>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.Run.status)
}

// -------------------------------------------------------------------

// RunStatus

// string status = 1;
inline void RunStatus::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& RunStatus::status() const {
  // @@protoc_insertion_point(field_get:flwr.proto.RunStatus.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunStatus::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.RunStatus.status)
}
inline std::string* RunStatus::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:flwr.proto.RunStatus.status)
  return _s;
}
inline const std::string& RunStatus::_internal_status() const {
  return status_.Get();
}
inline void RunStatus::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RunStatus::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RunStatus::release_status() {
  // @@protoc_insertion_point(field_release:flwr.proto.RunStatus.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RunStatus::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.RunStatus.status)
}

// string sub_status = 2;
inline void RunStatus::clear_sub_status() {
  sub_status_.ClearToEmpty();
}
inline const std::string& RunStatus::sub_status() const {
  // @@protoc_insertion_point(field_get:flwr.proto.RunStatus.sub_status)
  return _internal_sub_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunStatus::set_sub_status(ArgT0&& arg0, ArgT... args) {
 
 sub_status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.RunStatus.sub_status)
}
inline std::string* RunStatus::mutable_sub_status() {
  std::string* _s = _internal_mutable_sub_status();
  // @@protoc_insertion_point(field_mutable:flwr.proto.RunStatus.sub_status)
  return _s;
}
inline const std::string& RunStatus::_internal_sub_status() const {
  return sub_status_.Get();
}
inline void RunStatus::_internal_set_sub_status(const std::string& value) {
  
  sub_status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RunStatus::_internal_mutable_sub_status() {
  
  return sub_status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RunStatus::release_sub_status() {
  // @@protoc_insertion_point(field_release:flwr.proto.RunStatus.sub_status)
  return sub_status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RunStatus::set_allocated_sub_status(std::string* sub_status) {
  if (sub_status != nullptr) {
    
  } else {
    
  }
  sub_status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.RunStatus.sub_status)
}

// string details = 3;
inline void RunStatus::clear_details() {
  details_.ClearToEmpty();
}
inline const std::string& RunStatus::details() const {
  // @@protoc_insertion_point(field_get:flwr.proto.RunStatus.details)
  return _internal_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunStatus::set_details(ArgT0&& arg0, ArgT... args) {
 
 details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.RunStatus.details)
}
inline std::string* RunStatus::mutable_details() {
  std::string* _s = _internal_mutable_details();
  // @@protoc_insertion_point(field_mutable:flwr.proto.RunStatus.details)
  return _s;
}
inline const std::string& RunStatus::_internal_details() const {
  return details_.Get();
}
inline void RunStatus::_internal_set_details(const std::string& value) {
  
  details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RunStatus::_internal_mutable_details() {
  
  return details_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RunStatus::release_details() {
  // @@protoc_insertion_point(field_release:flwr.proto.RunStatus.details)
  return details_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RunStatus::set_allocated_details(std::string* details) {
  if (details != nullptr) {
    
  } else {
    
  }
  details_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), details,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.RunStatus.details)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateRunRequest

// string fab_id = 1;
inline void CreateRunRequest::clear_fab_id() {
  fab_id_.ClearToEmpty();
}
inline const std::string& CreateRunRequest::fab_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.CreateRunRequest.fab_id)
  return _internal_fab_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRunRequest::set_fab_id(ArgT0&& arg0, ArgT... args) {
 
 fab_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.CreateRunRequest.fab_id)
}
inline std::string* CreateRunRequest::mutable_fab_id() {
  std::string* _s = _internal_mutable_fab_id();
  // @@protoc_insertion_point(field_mutable:flwr.proto.CreateRunRequest.fab_id)
  return _s;
}
inline const std::string& CreateRunRequest::_internal_fab_id() const {
  return fab_id_.Get();
}
inline void CreateRunRequest::_internal_set_fab_id(const std::string& value) {
  
  fab_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRunRequest::_internal_mutable_fab_id() {
  
  return fab_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRunRequest::release_fab_id() {
  // @@protoc_insertion_point(field_release:flwr.proto.CreateRunRequest.fab_id)
  return fab_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRunRequest::set_allocated_fab_id(std::string* fab_id) {
  if (fab_id != nullptr) {
    
  } else {
    
  }
  fab_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fab_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.CreateRunRequest.fab_id)
}

// string fab_version = 2;
inline void CreateRunRequest::clear_fab_version() {
  fab_version_.ClearToEmpty();
}
inline const std::string& CreateRunRequest::fab_version() const {
  // @@protoc_insertion_point(field_get:flwr.proto.CreateRunRequest.fab_version)
  return _internal_fab_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRunRequest::set_fab_version(ArgT0&& arg0, ArgT... args) {
 
 fab_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flwr.proto.CreateRunRequest.fab_version)
}
inline std::string* CreateRunRequest::mutable_fab_version() {
  std::string* _s = _internal_mutable_fab_version();
  // @@protoc_insertion_point(field_mutable:flwr.proto.CreateRunRequest.fab_version)
  return _s;
}
inline const std::string& CreateRunRequest::_internal_fab_version() const {
  return fab_version_.Get();
}
inline void CreateRunRequest::_internal_set_fab_version(const std::string& value) {
  
  fab_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateRunRequest::_internal_mutable_fab_version() {
  
  return fab_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateRunRequest::release_fab_version() {
  // @@protoc_insertion_point(field_release:flwr.proto.CreateRunRequest.fab_version)
  return fab_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateRunRequest::set_allocated_fab_version(std::string* fab_version) {
  if (fab_version != nullptr) {
    
  } else {
    
  }
  fab_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fab_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.CreateRunRequest.fab_version)
}

// map<string, .flwr.proto.Scalar> override_config = 3;
inline int CreateRunRequest::_internal_override_config_size() const {
  return override_config_.size();
}
inline int CreateRunRequest::override_config_size() const {
  return _internal_override_config_size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
CreateRunRequest::_internal_override_config() const {
  return override_config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >&
CreateRunRequest::override_config() const {
  // @@protoc_insertion_point(field_map:flwr.proto.CreateRunRequest.override_config)
  return _internal_override_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
CreateRunRequest::_internal_mutable_override_config() {
  return override_config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::flwr::proto::Scalar >*
CreateRunRequest::mutable_override_config() {
  // @@protoc_insertion_point(field_mutable_map:flwr.proto.CreateRunRequest.override_config)
  return _internal_mutable_override_config();
}

// .flwr.proto.Fab fab = 4;
inline bool CreateRunRequest::_internal_has_fab() const {
  return this != internal_default_instance() && fab_ != nullptr;
}
inline bool CreateRunRequest::has_fab() const {
  return _internal_has_fab();
}
inline const ::flwr::proto::Fab& CreateRunRequest::_internal_fab() const {
  const ::flwr::proto::Fab* p = fab_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::Fab&>(
      ::flwr::proto::_Fab_default_instance_);
}
inline const ::flwr::proto::Fab& CreateRunRequest::fab() const {
  // @@protoc_insertion_point(field_get:flwr.proto.CreateRunRequest.fab)
  return _internal_fab();
}
inline void CreateRunRequest::unsafe_arena_set_allocated_fab(
    ::flwr::proto::Fab* fab) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fab_);
  }
  fab_ = fab;
  if (fab) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.CreateRunRequest.fab)
}
inline ::flwr::proto::Fab* CreateRunRequest::release_fab() {
  
  ::flwr::proto::Fab* temp = fab_;
  fab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::Fab* CreateRunRequest::unsafe_arena_release_fab() {
  // @@protoc_insertion_point(field_release:flwr.proto.CreateRunRequest.fab)
  
  ::flwr::proto::Fab* temp = fab_;
  fab_ = nullptr;
  return temp;
}
inline ::flwr::proto::Fab* CreateRunRequest::_internal_mutable_fab() {
  
  if (fab_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::Fab>(GetArenaForAllocation());
    fab_ = p;
  }
  return fab_;
}
inline ::flwr::proto::Fab* CreateRunRequest::mutable_fab() {
  ::flwr::proto::Fab* _msg = _internal_mutable_fab();
  // @@protoc_insertion_point(field_mutable:flwr.proto.CreateRunRequest.fab)
  return _msg;
}
inline void CreateRunRequest::set_allocated_fab(::flwr::proto::Fab* fab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fab_);
  }
  if (fab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fab));
    if (message_arena != submessage_arena) {
      fab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fab, submessage_arena);
    }
    
  } else {
    
  }
  fab_ = fab;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.CreateRunRequest.fab)
}

// -------------------------------------------------------------------

// CreateRunResponse

// uint64 run_id = 1;
inline void CreateRunResponse::clear_run_id() {
  run_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateRunResponse::_internal_run_id() const {
  return run_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CreateRunResponse::run_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.CreateRunResponse.run_id)
  return _internal_run_id();
}
inline void CreateRunResponse::_internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  run_id_ = value;
}
inline void CreateRunResponse::set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:flwr.proto.CreateRunResponse.run_id)
}

// -------------------------------------------------------------------

// GetRunRequest

// .flwr.proto.Node node = 1;
inline bool GetRunRequest::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool GetRunRequest::has_node() const {
  return _internal_has_node();
}
inline const ::flwr::proto::Node& GetRunRequest::_internal_node() const {
  const ::flwr::proto::Node* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::Node&>(
      ::flwr::proto::_Node_default_instance_);
}
inline const ::flwr::proto::Node& GetRunRequest::node() const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetRunRequest.node)
  return _internal_node();
}
inline void GetRunRequest::unsafe_arena_set_allocated_node(
    ::flwr::proto::Node* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.GetRunRequest.node)
}
inline ::flwr::proto::Node* GetRunRequest::release_node() {
  
  ::flwr::proto::Node* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::Node* GetRunRequest::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:flwr.proto.GetRunRequest.node)
  
  ::flwr::proto::Node* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::flwr::proto::Node* GetRunRequest::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::Node>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::flwr::proto::Node* GetRunRequest::mutable_node() {
  ::flwr::proto::Node* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:flwr.proto.GetRunRequest.node)
  return _msg;
}
inline void GetRunRequest::set_allocated_node(::flwr::proto::Node* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node));
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.GetRunRequest.node)
}

// uint64 run_id = 2;
inline void GetRunRequest::clear_run_id() {
  run_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetRunRequest::_internal_run_id() const {
  return run_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetRunRequest::run_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetRunRequest.run_id)
  return _internal_run_id();
}
inline void GetRunRequest::_internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  run_id_ = value;
}
inline void GetRunRequest::set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:flwr.proto.GetRunRequest.run_id)
}

// -------------------------------------------------------------------

// GetRunResponse

// .flwr.proto.Run run = 1;
inline bool GetRunResponse::_internal_has_run() const {
  return this != internal_default_instance() && run_ != nullptr;
}
inline bool GetRunResponse::has_run() const {
  return _internal_has_run();
}
inline void GetRunResponse::clear_run() {
  if (GetArenaForAllocation() == nullptr && run_ != nullptr) {
    delete run_;
  }
  run_ = nullptr;
}
inline const ::flwr::proto::Run& GetRunResponse::_internal_run() const {
  const ::flwr::proto::Run* p = run_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::Run&>(
      ::flwr::proto::_Run_default_instance_);
}
inline const ::flwr::proto::Run& GetRunResponse::run() const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetRunResponse.run)
  return _internal_run();
}
inline void GetRunResponse::unsafe_arena_set_allocated_run(
    ::flwr::proto::Run* run) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(run_);
  }
  run_ = run;
  if (run) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.GetRunResponse.run)
}
inline ::flwr::proto::Run* GetRunResponse::release_run() {
  
  ::flwr::proto::Run* temp = run_;
  run_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::Run* GetRunResponse::unsafe_arena_release_run() {
  // @@protoc_insertion_point(field_release:flwr.proto.GetRunResponse.run)
  
  ::flwr::proto::Run* temp = run_;
  run_ = nullptr;
  return temp;
}
inline ::flwr::proto::Run* GetRunResponse::_internal_mutable_run() {
  
  if (run_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::Run>(GetArenaForAllocation());
    run_ = p;
  }
  return run_;
}
inline ::flwr::proto::Run* GetRunResponse::mutable_run() {
  ::flwr::proto::Run* _msg = _internal_mutable_run();
  // @@protoc_insertion_point(field_mutable:flwr.proto.GetRunResponse.run)
  return _msg;
}
inline void GetRunResponse::set_allocated_run(::flwr::proto::Run* run) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete run_;
  }
  if (run) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flwr::proto::Run>::GetOwningArena(run);
    if (message_arena != submessage_arena) {
      run = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, run, submessage_arena);
    }
    
  } else {
    
  }
  run_ = run;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.GetRunResponse.run)
}

// -------------------------------------------------------------------

// UpdateRunStatusRequest

// uint64 run_id = 1;
inline void UpdateRunStatusRequest::clear_run_id() {
  run_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UpdateRunStatusRequest::_internal_run_id() const {
  return run_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UpdateRunStatusRequest::run_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.UpdateRunStatusRequest.run_id)
  return _internal_run_id();
}
inline void UpdateRunStatusRequest::_internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  run_id_ = value;
}
inline void UpdateRunStatusRequest::set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:flwr.proto.UpdateRunStatusRequest.run_id)
}

// .flwr.proto.RunStatus run_status = 2;
inline bool UpdateRunStatusRequest::_internal_has_run_status() const {
  return this != internal_default_instance() && run_status_ != nullptr;
}
inline bool UpdateRunStatusRequest::has_run_status() const {
  return _internal_has_run_status();
}
inline void UpdateRunStatusRequest::clear_run_status() {
  if (GetArenaForAllocation() == nullptr && run_status_ != nullptr) {
    delete run_status_;
  }
  run_status_ = nullptr;
}
inline const ::flwr::proto::RunStatus& UpdateRunStatusRequest::_internal_run_status() const {
  const ::flwr::proto::RunStatus* p = run_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::RunStatus&>(
      ::flwr::proto::_RunStatus_default_instance_);
}
inline const ::flwr::proto::RunStatus& UpdateRunStatusRequest::run_status() const {
  // @@protoc_insertion_point(field_get:flwr.proto.UpdateRunStatusRequest.run_status)
  return _internal_run_status();
}
inline void UpdateRunStatusRequest::unsafe_arena_set_allocated_run_status(
    ::flwr::proto::RunStatus* run_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(run_status_);
  }
  run_status_ = run_status;
  if (run_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.UpdateRunStatusRequest.run_status)
}
inline ::flwr::proto::RunStatus* UpdateRunStatusRequest::release_run_status() {
  
  ::flwr::proto::RunStatus* temp = run_status_;
  run_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::RunStatus* UpdateRunStatusRequest::unsafe_arena_release_run_status() {
  // @@protoc_insertion_point(field_release:flwr.proto.UpdateRunStatusRequest.run_status)
  
  ::flwr::proto::RunStatus* temp = run_status_;
  run_status_ = nullptr;
  return temp;
}
inline ::flwr::proto::RunStatus* UpdateRunStatusRequest::_internal_mutable_run_status() {
  
  if (run_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::RunStatus>(GetArenaForAllocation());
    run_status_ = p;
  }
  return run_status_;
}
inline ::flwr::proto::RunStatus* UpdateRunStatusRequest::mutable_run_status() {
  ::flwr::proto::RunStatus* _msg = _internal_mutable_run_status();
  // @@protoc_insertion_point(field_mutable:flwr.proto.UpdateRunStatusRequest.run_status)
  return _msg;
}
inline void UpdateRunStatusRequest::set_allocated_run_status(::flwr::proto::RunStatus* run_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete run_status_;
  }
  if (run_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flwr::proto::RunStatus>::GetOwningArena(run_status);
    if (message_arena != submessage_arena) {
      run_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, run_status, submessage_arena);
    }
    
  } else {
    
  }
  run_status_ = run_status;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.UpdateRunStatusRequest.run_status)
}

// -------------------------------------------------------------------

// UpdateRunStatusResponse

// -------------------------------------------------------------------

// GetRunStatusRequest

// .flwr.proto.Node node = 1;
inline bool GetRunStatusRequest::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool GetRunStatusRequest::has_node() const {
  return _internal_has_node();
}
inline const ::flwr::proto::Node& GetRunStatusRequest::_internal_node() const {
  const ::flwr::proto::Node* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::Node&>(
      ::flwr::proto::_Node_default_instance_);
}
inline const ::flwr::proto::Node& GetRunStatusRequest::node() const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetRunStatusRequest.node)
  return _internal_node();
}
inline void GetRunStatusRequest::unsafe_arena_set_allocated_node(
    ::flwr::proto::Node* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.GetRunStatusRequest.node)
}
inline ::flwr::proto::Node* GetRunStatusRequest::release_node() {
  
  ::flwr::proto::Node* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::Node* GetRunStatusRequest::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:flwr.proto.GetRunStatusRequest.node)
  
  ::flwr::proto::Node* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::flwr::proto::Node* GetRunStatusRequest::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::Node>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::flwr::proto::Node* GetRunStatusRequest::mutable_node() {
  ::flwr::proto::Node* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:flwr.proto.GetRunStatusRequest.node)
  return _msg;
}
inline void GetRunStatusRequest::set_allocated_node(::flwr::proto::Node* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node));
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.GetRunStatusRequest.node)
}

// repeated uint64 run_ids = 2;
inline int GetRunStatusRequest::_internal_run_ids_size() const {
  return run_ids_.size();
}
inline int GetRunStatusRequest::run_ids_size() const {
  return _internal_run_ids_size();
}
inline void GetRunStatusRequest::clear_run_ids() {
  run_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetRunStatusRequest::_internal_run_ids(int index) const {
  return run_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetRunStatusRequest::run_ids(int index) const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetRunStatusRequest.run_ids)
  return _internal_run_ids(index);
}
inline void GetRunStatusRequest::set_run_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  run_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:flwr.proto.GetRunStatusRequest.run_ids)
}
inline void GetRunStatusRequest::_internal_add_run_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  run_ids_.Add(value);
}
inline void GetRunStatusRequest::add_run_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_run_ids(value);
  // @@protoc_insertion_point(field_add:flwr.proto.GetRunStatusRequest.run_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
GetRunStatusRequest::_internal_run_ids() const {
  return run_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
GetRunStatusRequest::run_ids() const {
  // @@protoc_insertion_point(field_list:flwr.proto.GetRunStatusRequest.run_ids)
  return _internal_run_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
GetRunStatusRequest::_internal_mutable_run_ids() {
  return &run_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
GetRunStatusRequest::mutable_run_ids() {
  // @@protoc_insertion_point(field_mutable_list:flwr.proto.GetRunStatusRequest.run_ids)
  return _internal_mutable_run_ids();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetRunStatusResponse

// map<uint64, .flwr.proto.RunStatus> run_status_dict = 1;
inline int GetRunStatusResponse::_internal_run_status_dict_size() const {
  return run_status_dict_.size();
}
inline int GetRunStatusResponse::run_status_dict_size() const {
  return _internal_run_status_dict_size();
}
inline void GetRunStatusResponse::clear_run_status_dict() {
  run_status_dict_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >&
GetRunStatusResponse::_internal_run_status_dict() const {
  return run_status_dict_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >&
GetRunStatusResponse::run_status_dict() const {
  // @@protoc_insertion_point(field_map:flwr.proto.GetRunStatusResponse.run_status_dict)
  return _internal_run_status_dict();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >*
GetRunStatusResponse::_internal_mutable_run_status_dict() {
  return run_status_dict_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::flwr::proto::RunStatus >*
GetRunStatusResponse::mutable_run_status_dict() {
  // @@protoc_insertion_point(field_mutable_map:flwr.proto.GetRunStatusResponse.run_status_dict)
  return _internal_mutable_run_status_dict();
}

// -------------------------------------------------------------------

// GetFederationOptionsRequest

// uint64 run_id = 1;
inline void GetFederationOptionsRequest::clear_run_id() {
  run_id_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFederationOptionsRequest::_internal_run_id() const {
  return run_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetFederationOptionsRequest::run_id() const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetFederationOptionsRequest.run_id)
  return _internal_run_id();
}
inline void GetFederationOptionsRequest::_internal_set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  run_id_ = value;
}
inline void GetFederationOptionsRequest::set_run_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_run_id(value);
  // @@protoc_insertion_point(field_set:flwr.proto.GetFederationOptionsRequest.run_id)
}

// -------------------------------------------------------------------

// GetFederationOptionsResponse

// .flwr.proto.ConfigRecord federation_options = 1;
inline bool GetFederationOptionsResponse::_internal_has_federation_options() const {
  return this != internal_default_instance() && federation_options_ != nullptr;
}
inline bool GetFederationOptionsResponse::has_federation_options() const {
  return _internal_has_federation_options();
}
inline const ::flwr::proto::ConfigRecord& GetFederationOptionsResponse::_internal_federation_options() const {
  const ::flwr::proto::ConfigRecord* p = federation_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::flwr::proto::ConfigRecord&>(
      ::flwr::proto::_ConfigRecord_default_instance_);
}
inline const ::flwr::proto::ConfigRecord& GetFederationOptionsResponse::federation_options() const {
  // @@protoc_insertion_point(field_get:flwr.proto.GetFederationOptionsResponse.federation_options)
  return _internal_federation_options();
}
inline void GetFederationOptionsResponse::unsafe_arena_set_allocated_federation_options(
    ::flwr::proto::ConfigRecord* federation_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(federation_options_);
  }
  federation_options_ = federation_options;
  if (federation_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flwr.proto.GetFederationOptionsResponse.federation_options)
}
inline ::flwr::proto::ConfigRecord* GetFederationOptionsResponse::release_federation_options() {
  
  ::flwr::proto::ConfigRecord* temp = federation_options_;
  federation_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flwr::proto::ConfigRecord* GetFederationOptionsResponse::unsafe_arena_release_federation_options() {
  // @@protoc_insertion_point(field_release:flwr.proto.GetFederationOptionsResponse.federation_options)
  
  ::flwr::proto::ConfigRecord* temp = federation_options_;
  federation_options_ = nullptr;
  return temp;
}
inline ::flwr::proto::ConfigRecord* GetFederationOptionsResponse::_internal_mutable_federation_options() {
  
  if (federation_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::flwr::proto::ConfigRecord>(GetArenaForAllocation());
    federation_options_ = p;
  }
  return federation_options_;
}
inline ::flwr::proto::ConfigRecord* GetFederationOptionsResponse::mutable_federation_options() {
  ::flwr::proto::ConfigRecord* _msg = _internal_mutable_federation_options();
  // @@protoc_insertion_point(field_mutable:flwr.proto.GetFederationOptionsResponse.federation_options)
  return _msg;
}
inline void GetFederationOptionsResponse::set_allocated_federation_options(::flwr::proto::ConfigRecord* federation_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(federation_options_);
  }
  if (federation_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(federation_options));
    if (message_arena != submessage_arena) {
      federation_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, federation_options, submessage_arena);
    }
    
  } else {
    
  }
  federation_options_ = federation_options;
  // @@protoc_insertion_point(field_set_allocated:flwr.proto.GetFederationOptionsResponse.federation_options)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace flwr

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flwr_2fproto_2frun_2eproto
